(function(/*! Brunch !*/) {
  'use strict';

  var globals = typeof window !== 'undefined' ? window : global;
  if (typeof globals.require === 'function') return;

  var modules = {};
  var cache = {};

  var has = function(object, name) {
    return ({}).hasOwnProperty.call(object, name);
  };

  var expand = function(root, name) {
    var results = [], parts, part;
    if (/^\.\.?(\/|$)/.test(name)) {
      parts = [root, name].join('/').split('/');
    } else {
      parts = name.split('/');
    }
    for (var i = 0, length = parts.length; i < length; i++) {
      part = parts[i];
      if (part === '..') {
        results.pop();
      } else if (part !== '.' && part !== '') {
        results.push(part);
      }
    }
    return results.join('/');
  };

  var dirname = function(path) {
    return path.split('/').slice(0, -1).join('/');
  };

  var localRequire = function(path) {
    return function(name) {
      var dir = dirname(path);
      var absolute = expand(dir, name);
      return globals.require(absolute);
    };
  };

  var initModule = function(name, definition) {
    var module = {id: name, exports: {}};
    definition(module.exports, localRequire(name), module);
    var exports = cache[name] = module.exports;
    return exports;
  };

  var require = function(name) {
    var path = expand(name, '.');

    if (has(cache, path)) return cache[path];
    if (has(modules, path)) return initModule(path, modules[path]);

    var dirIndex = expand(path, './index');
    if (has(cache, dirIndex)) return cache[dirIndex];
    if (has(modules, dirIndex)) return initModule(dirIndex, modules[dirIndex]);

    throw new Error('Cannot find module "' + name + '"');
  };

  var define = function(bundle, fn) {
    if (typeof bundle === 'object') {
      for (var key in bundle) {
        if (has(bundle, key)) {
          modules[key] = bundle[key];
        }
      }
    } else {
      modules[bundle] = fn;
    }
  };

  globals.require = require;
  globals.require.define = define;
  globals.require.register = define;
  globals.require.brunch = true;
})();

window.require.register("app", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // Application bootstrapper

  module.exports = Em.Application.create({
    name: 'Ambari Web',
    rootElement: '#wrapper',

    store: DS.Store.create({
      revision: 4,
      adapter: DS.FixtureAdapter.create({
        simulateRemoteResponse: false
      })
    }),
    isAdmin: false,
    /**
     * return url prefix with number value of version of HDP stack
     */
    stackVersionURL:function(){
      var stackVersion = this.get('currentStackVersion') || this.get('defaultStackVersion');
      if(stackVersion.indexOf('HDPLocal') !== -1){
        return '/stacks/HDPLocal/version/' + stackVersion.replace(/HDPLocal-/g, '');
      }
      return '/stacks/HDP/version/' + stackVersion.replace(/HDP-/g, '');
    }.property('currentStackVersion'),
    
    /**
     * return url prefix with number value of version of HDP stack
     */
    stack2VersionURL:function(){
      var stackVersion = this.get('currentStackVersion') || this.get('defaultStackVersion');
      if(stackVersion.indexOf('HDPLocal') !== -1){
        return '/stacks2/HDPLocal/versions/' + stackVersion.replace(/HDPLocal-/g, '');
      }
      return '/stacks2/HDP/versions/' + stackVersion.replace(/HDP-/g, '');
    }.property('currentStackVersion'),
    clusterName: null,
    currentStackVersion: '',
    currentStackVersionNumber: function(){
      return this.get('currentStackVersion').replace(/HDP(Local)?-/, '');
    }.property('currentStackVersion')
  });

  /**
   * Ambari overrides the default date transformer.
   * This is done because of the non-standard data
   * sent. For example Nagios sends date as "12345678".
   * The problem is that it is a String and is represented
   * only in seconds whereas Javascript's Date needs
   * milliseconds representation.
   */
  DS.attr.transforms.date = {
    from: function (serialized) {
      var type = typeof serialized;
      if (type === "string") {
        serialized = parseInt(serialized);
        type = typeof serialized;
      }
      if (type === "number") {
        // The number could be seconds or milliseconds.
        // If seconds, then multiplying with 1000 should still
        // keep it below the current time.
        if (serialized * 1000 < new Date().getTime()) {
          serialized = serialized * 1000;
        }
        return new Date(serialized);
      } else if (serialized === null || serialized === undefined) {
        // if the value is not present in the data,
        // return undefined, not null.
        return serialized;
      } else {
        return null;
      }
    },
    to: function (deserialized) {
      if (deserialized instanceof Date) {
        return deserialized.getTime();
      } else if (deserialized === undefined) {
        return undefined;
      } else {
        return null;
      }
    }
  }

  DS.attr.transforms.object = {
    from: function(serialized) {
      return Ember.none(serialized) ? null : Object(serialized);
    },

    to: function(deserialized) {
      return Ember.none(deserialized) ? null : Object(deserialized);
    }
  };


  
});
window.require.register("classes/job_class", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');
  var date = require('utils/date');
  var misc = require('utils/misc');

  App.Job2 = Ember.Object.extend({

    id: "", //string
    jobName: "", //string
    workflowEntityName: "", //string
    maps: 0, //number
    reduces: 0, //number
    status: "", //string
    input: 0, //number
    output: 0, //number
    elapsed_time: 0, //number

    duration: function() {
      return date.timingFormat(parseInt(this.get('elapsed_time')));
    }.property('elapsed_time'),

    inputFormatted: function () {
      return misc.formatBandwidth(this.get('input'));
    }.property('input'),

    outputFormatted: function () {
      return misc.formatBandwidth(this.get('output'));
    }.property('output')

  });
  
});
window.require.register("classes/run_class", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');
  var date = require('utils/date');
  var misc = require('utils/misc');

  App.Run2 = Ember.Object.extend({
    id: null, //string
    appName: null, //string
    userName: null, //string
    numJobsTotal: 0, //number
    numJobsCompleted: 0, //number
    startTime: 0, //number
    elapsedTime: 0, //number
    workflowContext: null, //string
    input: 0, //number
    output: 0, //number

    /**
     * Will set to true when we load all jobs related to this run
     */
    loadAllJobs : false,

    /**
     * runId  short part
     */
    idFormatted: function() {
      return this.get('id').substr(0, 20);
    }.property('id'),

    /**
     * Run duration
     */
    duration: function() {
      return date.timingFormat(this.get('elapsedTime'));
    }.property('elapsedTime'),

    /**
     * Status of running jobs
     */
    isRunning: function () {
      return !this.get('numJobsTotal') == this.get('numJobsCompleted');
    }.property('numJobsTotal', 'numJobsCompleted'),

    /**
     * Sum of input bandwidth for all jobs with appropriate measure
     */
    inputFormatted: function () {
      return misc.formatBandwidth(this.get('input'));
    }.property('input'),

    /**
     *  Sum of output bandwidth for all jobs with appropriate measure
     */
    outputFormatted: function () {
      return misc.formatBandwidth(this.get('output'));
    }.property('output'),

    lastUpdateTime: function() {
      return this.get('startTime') + this.get('elapsedTime');
    }.property('elapsedTime', 'startTime'),

    lastUpdateTimeFormatted: function() {
      return date.dateFormat(this.get('lastUpdateTime'));
    }.property('lastUpdateTime'),

    lastUpdateTimeFormattedShort: function(){
      return date.dateFormatShort(this.get('lastUpdateTime'));
    }.property('lastUpdateTime'),

    /**
     * Type value based on first part of id
     */
    type: function() {
      if (this.get('id').indexOf('pig_') === 0) {
        return 'Pig';
      }
      if (this.get('id').indexOf('hive_') === 0) {
        return 'Hive';
      }
      if (this.get('id').indexOf('mr_') === 0) {
        return 'MapReduce';
      }
      return 'Undefined';
    }.property('id')
  });
});
window.require.register("config", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.testMode = (location.port == '3333'); // test mode is automatically enabled if running on brunch server
  App.testModeDelayForActions = 10000;
  App.skipBootstrap = false;
  App.alwaysGoToInstaller = false;
  App.testEnableSecurity = true; // By default enable security is tested; turning it false tests disable security
  App.apiPrefix = '/api/v1';
  App.defaultStackVersion = 'HDP-1.3.2';
  App.defaultLocalStackVersion = 'HDPLocal-1.3.2';
  App.defaultJavaHome = '/usr/jdk/jdk1.6.0_31';
  App.timeout = 180000; // default AJAX timeout
  App.maxRetries = 3; // max number of retries for certain AJAX calls
  App.bgOperationsUpdateInterval = 6000;
  App.componentsUpdateInterval = 6000;
  App.contentUpdateInterval = 15000;
  App.maxRunsForAppBrowser = 500;
  App.pageReloadTime=3600000;
  App.singleNodeInstall = false;
  App.singleNodeAlias = document.location.hostname;

  // experimental features are automatically enabled if running on brunch server
  App.enableExperimental = false;

  App.supports = {
    addServices: false,
    hostOverrides: false,
    mirroring: false,
    secureCluster: true,
    secureClusterProceedPopup: false,
    reassignMaster: false,
    stackUpgrade: false,
    capacitySchedulerUi: false,
    startStopAllServices: true,
    hiveOozieExtraDatabases: true,
    multipleHBaseMasters: false,
    addMasters: false,
    customizeSmokeTestUser: true,
    hue: false,
    ldapGroupMapping: false,
    localRepositories: false
  };

  if (App.enableExperimental) {
    for (var support in App.supports) {
      App.supports[support] = true;
    }
  }

  // this is to make sure that IE does not cache data when making AJAX calls to the server
  $.ajaxSetup({
    cache: false
  });

  /**
   * Test Mode values
   */
  App.test_hostname = 'hostname';
  
});
window.require.register("controllers", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  // load all controllers here

  require('controllers/application');
  require('controllers/login_controller');
  require('controllers/wizard');
  require('controllers/installer');
  require('controllers/global/background_operations_controller');
  require('controllers/main');
  require('controllers/main/admin');
  require('controllers/main/admin/cluster');
  require('controllers/main/admin/stack_upgrade_controller');
  require('controllers/main/admin/user');
  require('controllers/main/admin/misc_controller');
  require('controllers/main/admin/user/edit');
  require('controllers/main/admin/user/create');
  require('controllers/main/admin/advanced');
  require('utils/polling');
  require('controllers/main/admin/security');
  require('controllers/main/admin/security/disable');
  require('controllers/main/admin/security/add/addSecurity_controller');
  require('controllers/main/admin/security/add/step1');
  require('controllers/main/admin/security/add/step2');
  require('controllers/main/admin/security/add/step3');
  require('controllers/main/admin/security/add/step4');
  require('controllers/main/admin/authentication');
  require('controllers/main/service');
  require('controllers/main/service/item');
  require('controllers/main/service/info/summary');
  require('controllers/main/service/info/configs');
  require('controllers/main/service/info/audit');
  require('controllers/main/service/add_controller');
  require('controllers/main/service/reassign_controller');
  require('controllers/main/host');
  require('controllers/main/host/details');
  require('controllers/main/host/configs_service');
  require('controllers/main/host/add_controller');
  require('controllers/main/charts');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_processrun');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_diskspaceused');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_cpuWaitIO');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_memoryused');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_bytesread');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_byteswritten');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_gctime');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_memHeapUsed');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_mapreduce');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_mapreduce_gctime');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_mapreduce_mapsRunning');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_mapreduce_reducesRunning');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_mapreduce_memHeapUsed');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_hbase');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_hbase_readrequest');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_hbase_writerequest');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_hbase_compactionqueue');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_hbase_regions');
  require('controllers/main/charts/heatmap_metrics/heatmap_metric_hbase_memstoresize');
  require('controllers/main/charts/heatmap');
  require('controllers/main/apps_controller');
  require('controllers/main/apps/item_controller');
  require('controllers/main/mirroring_controller');
  require('controllers/main/mirroring/dataset_controller');
  require('controllers/main/mirroring/datasets_controller');
  require('controllers/main/mirroring/jobs_controller');
  require('controllers/main/mirroring/targetClusterController');
  require('controllers/main/mirroring/testConnection_controller');
  require('controllers/main/mirroring/testConnectionResults_controller');
  require('controllers/wizard/slave_component_groups_controller');
  require('controllers/wizard/step0_controller');
  require('controllers/wizard/step1_controller');
  require('controllers/wizard/step2_controller');
  require('controllers/wizard/step3_controller');
  require('controllers/wizard/step4_controller');
  require('controllers/wizard/step5_controller');
  require('controllers/wizard/step6_controller');
  require('controllers/wizard/step7_controller');
  require('controllers/wizard/step8_controller');
  require('controllers/wizard/step9_controller');
  require('controllers/wizard/step10_controller');
  require('controllers/wizard/step11_controller');
  require('controllers/wizard/step12_controller');
  require('controllers/wizard/step13_controller');
  require('controllers/wizard/step14_controller');
  require('controllers/wizard/stack_upgrade/step1_controller');
  require('controllers/wizard/stack_upgrade/step2_controller');
  require('controllers/wizard/stack_upgrade/step3_controller');
  require('controllers/global/cluster_controller');
  require('controllers/global/update_controller');
  
});
window.require.register("controllers/application", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.ApplicationController = Em.Controller.extend({

    name: 'applicationController',

    clusterName: function () {
      return (App.router.get('clusterController.clusterName') || 'My Cluster');
    }.property('App.router.clusterController.clusterName'),

    clusterDisplayName: function () {
      var name = this.get('clusterName');
      var displayName = name.length > 13 ? name.substr(0, 10) + "..." : name;
      return displayName;
    }.property('clusterName'),

    isClusterDataLoaded: function() {
      return App.router.get('clusterController.isLoaded') && App.router.get('loggedIn');
    }.property('App.router.clusterController.isLoaded','App.router.loggedIn'),

    init: function(){
      this._super();
    }
  });
});
window.require.register("controllers/global/background_operations_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.BackgroundOperationsController = Em.Controller.extend({
    name: 'backgroundOperationsController',

    /**
     * Whether we need to refresh background operations or not
     */
    isWorking : false,

    allOperationsCount : 0,

    /**
     * For host component popup
     */
    services:[],
    serviceTimestamp: null,

    /**
     * Start polling, when <code>isWorking</code> become true
     */
    startPolling: function(){
      if(this.get('isWorking')){
        this.requestMostRecent();
        App.updater.run(this, 'requestMostRecent', 'isWorking', App.bgOperationsUpdateInterval);
      }
    }.observes('isWorking'),

    /**
     * Get all requests from server
     * @param callback
     */
    requestMostRecent: function(callback){
      App.ajax.send({
        name: 'background_operations.get_most_recent',
        'sender': this,
        'success': 'callBackForMostRecent',
        'callback': callback
      });
    },

    /**
     * Prepare recived from server requests for host component popup
     * @param data
     */
    callBackForMostRecent: function(data){
      this.get("services").clear();
      var runningServices = 0;
      var self = this;
      data.items = data.items.sort(function(a,b){return b.Requests.id - a.Requests.id});
      data.items.forEach(function(request){
        var hostsMap = {};
        var isRunningTasks = false;
        request.tasks.forEach(function (task) {
          if (!isRunningTasks && (['QUEUED', 'IN_PROGRESS', 'PENDING'].contains(task.Tasks.status))) {
            isRunningTasks = true;
          }
          if (hostsMap[task.Tasks.host_name]) {
            hostsMap[task.Tasks.host_name].logTasks.push(task);
          } else {
            hostsMap[task.Tasks.host_name] = {
              name: task.Tasks.host_name,
              publicName: task.Tasks.host_name,
              logTasks: [task]
            };
          }
        }, this);
        var hosts = [];
        for(var hostName in hostsMap){
          hosts.push(hostsMap[hostName]);
        }
        var rq = Em.Object.create({
          id: request.Requests.id,
          name: request.Requests.request_context || 'Request name not specified',
          displayName: request.Requests.request_context || 'Request name not specified',
          progress: 10,
          status: "",
          isRunning: isRunningTasks,
          hosts: hosts
        });
        runningServices += ~~isRunningTasks;
        self.get("services").push(rq);
      });
      self.set("allOperationsCount",runningServices);
      self.set('serviceTimestamp', new Date().getTime());
    },

    popupView: null,

    /**
     * Onclick handler for background operations number located right to logo
     * @return PopupObject For testing purposes
     */
    showPopup: function(){
      App.updater.immediateRun('requestMostRecent');
      if(this.get('popupView')){
        this.set('popupView.isOpen', true);
        $(this.get('popupView.element')).appendTo('#wrapper');
      } else {
        this.set('popupView', App.HostPopup.initPopup("", this, true));
      }
    }

  });
  
});
window.require.register("controllers/global/cluster_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.ClusterController = Em.Controller.extend({
    name:'clusterController',
    cluster:null,
    isLoaded:false,
    clusterDataLoadedPercent: 'width:0', // 0 to 1
    /**
     * Whether we need to update statuses automatically or not
     */
    isWorking: false,
    updateLoadStatus:function (item) {
      var loadList = this.get('dataLoadList');
      var loaded = true;
      var numLoaded = 0;
      var loadListLength = 0;
      loadList.set(item, true);
      for (var i in loadList) {
        if (loadList.hasOwnProperty(i)) {
          loadListLength++;
          if(!loadList[i] && loaded){
            loaded = false;
          }
        }
        // calculate the number of true
        if (loadList.hasOwnProperty(i) && loadList[i]){
          numLoaded++;
        }
      }
      this.set('isLoaded', loaded);
      this.set('clusterDataLoadedPercent', 'width:' + (Math.floor(numLoaded / loadListLength * 100)).toString() + '%');
    },

    dataLoadList:Em.Object.create({
      'hosts':false,
      'services':false,
      'cluster':false,
      'clusterStatus':false,
      'racks':false,
      'alerts':false,
      'users':false,
      'datasets':false,
      'targetclusters':false
    }),

    /**
     * load cluster name
     */
    loadClusterName:function (reload) {
      if (this.get('clusterName') && !reload) {
        return;
      }

      App.ajax.send({
        name: 'cluster.load_cluster_name',
        sender: this,
        success: 'loadClusterNameSuccessCallback',
        error: 'loadClusterNameErrorCallback'
      });

      if(!App.get('currentStackVersion')){
        App.set('currentStackVersion', App.defaultStackVersion);
      }
    },

    loadClusterNameSuccessCallback: function (data) {
      this.set('cluster', data.items[0]);
      App.set('clusterName', data.items[0].Clusters.cluster_name);
      App.set('currentStackVersion', data.items[0].Clusters.version);
    },

    loadClusterNameErrorCallback: function (request, ajaxOptions, error) {
      console.log('failed on loading cluster name');
      this.set('isLoaded', true);
    },

    getUrl:function (testUrl, url) {
      return (App.testMode) ? testUrl : App.apiPrefix + '/clusters/' + this.get('clusterName') + url;
    },

    /**
     * Provides the URL to use for Ganglia server. This URL
     * is helpful in populating links in UI.
     *
     * If null is returned, it means GANGLIA service is not installed.
     */
    gangliaUrl: function () {
      if (App.testMode) {
        return 'http://gangliaserver/ganglia/?t=yes';
      } else {
        // We want live data here
        var svcs = App.Service.find();
        var gangliaSvc = svcs.findProperty("serviceName", "GANGLIA");
        if (gangliaSvc) {
          var svcComponents = gangliaSvc.get('hostComponents');
          if (svcComponents) {
            var gangliaSvcComponent = svcComponents.findProperty("componentName", "GANGLIA_SERVER");
            if (gangliaSvcComponent) {
              var hostName = gangliaSvcComponent.get('host.hostName');
              if (hostName) {
                var host = App.Host.find(hostName);
                if (host) {
                  hostName = host.get('publicHostName');
                }
                return "http://" + (App.singleNodeInstall ? App.singleNodeAlias : hostName) + "/ganglia";
              }
            }
          }
        }
        return null;
      }
    }.property('App.router.updateController.isUpdated', 'dataLoadList.hosts'),

    /**
     * Provides the URL to use for NAGIOS server. This URL
     * is helpful in getting alerts data from server and also
     * in populating links in UI.
     *
     * If null is returned, it means NAGIOS service is not installed.
     */
    nagiosUrl:function () {
      if (App.testMode) {
        return 'http://nagiosserver/nagios';
      } else {
        // We want live data here
        var svcs = App.Service.find();
        var nagiosSvc = svcs.findProperty("serviceName", "NAGIOS");
        if (nagiosSvc) {
          var svcComponents = nagiosSvc.get('hostComponents');
          if (svcComponents) {
            var nagiosSvcComponent = svcComponents.findProperty("componentName", "NAGIOS_SERVER");
            if (nagiosSvcComponent) {
              var hostName = nagiosSvcComponent.get('host.hostName');
              if (hostName) {
                var host = App.Host.find(hostName);
                if (host) {
                  hostName = host.get('publicHostName');
                }
                return "http://" + (App.singleNodeInstall ? App.singleNodeAlias : hostName) + "/nagios";
              }
            }
          }
        }
        return null;
      }
    }.property('App.router.updateController.isUpdated', 'dataLoadList.services', 'dataLoadList.hosts'),

    isNagiosInstalled:function () {
      return !!App.Service.find().findProperty('serviceName', 'NAGIOS');
    }.property('App.router.updateController.isUpdated', 'dataLoadList.services'),

    /**
     * Sorted list of alerts.
     * Changes whenever alerts are loaded.
     */
    alerts:[],
    updateAlerts: function(){
      var alerts = App.Alert.find();
      var alertsArray = alerts.toArray();
      var sortedArray = alertsArray.sort(function (left, right) {
        var statusDiff = right.get('status') - left.get('status');
        if (statusDiff == 0) { // same error severity - sort by time
          var rightTime = right.get('date');
          var leftTime = left.get('date');
          rightTime = rightTime ? rightTime.getTime() : 0;
          leftTime = leftTime ? leftTime.getTime() : 0;
          statusDiff = rightTime - leftTime;
        }
        return statusDiff;
      });
      this.set('alerts', sortedArray);
    },

    /**
     * Load alerts from server
     * @param callback Slave function, should be called to fire delayed update.
     * Look at <code>App.updater.run</code> for more information.
     * Also used to set <code>dataLoadList.alerts</code> status during app loading
     */
    loadAlerts:function (callback) {
      if (this.get('isNagiosInstalled')) {
        var dataUrl = this.getUrl('/data/alerts/alerts.json', '/host_components?fields=HostRoles/nagios_alerts&HostRoles/component_name=NAGIOS_SERVER');
        var self = this;
        var ajaxOptions = {
          dataType:"json",
          complete:function () {
            self.updateAlerts();
            callback();
          },
          error: function(jqXHR, testStatus, error) {
            console.log('Nagios $.ajax() response:', error);
          }
        };
        App.HttpClient.get(dataUrl, App.alertsMapper, ajaxOptions);
      } else {
        console.log("No Nagios URL provided.");
        callback();
      }
    },

    /**
     * Determination of Nagios presence is known only after App.Service is
     * loaded from server. When that is done, no one tells alerts to load,
     * due to which alerts are not loaded & shown till the next polling cycle.
     * This method immediately loads alerts once Nagios presence is known.
     */
    isNagiosInstalledListener: function () {
      var self = this;
      self.loadAlerts(function () {
        self.updateLoadStatus('alerts');
      });
    }.observes('isNagiosInstalled'),

    /**
     * Send request to server to load components updated statuses
     * @param callback Slave function, should be called to fire delayed update.
     * Look at <code>App.updater.run</code> for more information
     * @return {Boolean} Whether we have errors
     */
    loadUpdatedStatus: function(callback){

      if(!this.get('clusterName')){
        callback();
        return false;
      }

      var servicesUrl = this.getUrl('/data/dashboard/services.json', '/services?fields=ServiceInfo,components/host_components/HostRoles/desired_state,components/host_components/HostRoles/state');

      App.HttpClient.get(servicesUrl, App.statusMapper, {
        complete: callback
      });
      return true;
    },

    /**
     * Run <code>loadUpdatedStatus</code> with delay
     * @param delay
     */
    loadUpdatedStatusDelayed: function(delay){
      setTimeout(function(){
        App.updater.immediateRun('loadUpdatedStatus');
      }, delay);
    },

    /**
     * Start polling, when <code>isWorking</code> become true
     */
    startPolling: function(){
      if(!this.get('isWorking')){
        return false;
      }
      App.updater.run(this, 'loadUpdatedStatus', 'isWorking', App.componentsUpdateInterval); //update will not run it immediately
      App.updater.run(this, 'loadAlerts', 'isWorking'); //update will not run it immediately
      return true;
    }.observes('isWorking'),
    /**
     *
     *  load all data and update load status
     */
    loadClusterData:function () {
      var self = this;
      if (!this.get('clusterName')) {
        return;
      }

      if(this.get('isLoaded')) { // do not load data repeatedly
        return;
      }

      var clusterUrl = this.getUrl('/data/clusters/cluster.json', '?fields=Clusters');
      var hostsUrl = this.getUrl('/data/hosts/hosts.json', '/hosts?fields=Hosts/host_name,Hosts/public_host_name,Hosts/disk_info,Hosts/cpu_count,Hosts/total_mem,Hosts/host_status,Hosts/last_heartbeat_time,Hosts/os_arch,Hosts/os_type,Hosts/ip,host_components,metrics/disk,metrics/load/load_one');
      var usersUrl = App.testMode ? '/data/users/users.json' : App.apiPrefix + '/users/?fields=*';
      var racksUrl = "/data/racks/racks.json";
      var dataSetUrl = "/data/mirroring/all_datasets.json";
      var targetClusterUrl = "/data/mirroring/target_clusters.json";

      App.HttpClient.get(targetClusterUrl, App.targetClusterMapper, {
        complete: function (jqXHR, textStatus) {
          self.updateLoadStatus('targetclusters');
        }
      }, function (jqXHR, textStatus) {
        self.updateLoadStatus('targetclusters');
      });


      App.HttpClient.get(dataSetUrl, App.dataSetMapper, {
        complete: function (jqXHR, textStatus) {
          self.updateLoadStatus('datasets');
        }
      }, function (jqXHR, textStatus) {
        self.updateLoadStatus('datasets');
      });

      App.HttpClient.get(racksUrl, App.racksMapper, {
        complete:function (jqXHR, textStatus) {
          self.updateLoadStatus('racks');
        }
      }, function (jqXHR, textStatus) {
        self.updateLoadStatus('racks');
      });

      App.HttpClient.get(clusterUrl, App.clusterMapper, {
        complete:function (jqXHR, textStatus) {
          self.updateLoadStatus('cluster');
        }
      }, function (jqXHR, textStatus) {
          self.updateLoadStatus('cluster');
      });

      if (App.testMode) {
        self.updateLoadStatus('clusterStatus');
      } else {
        App.clusterStatus.updateFromServer(true).complete(function() {
          self.updateLoadStatus('clusterStatus');
        });
      }
      
      App.HttpClient.get(hostsUrl, App.hostsMapper, {
        complete:function (jqXHR, textStatus) {
          self.updateLoadStatus('hosts');
        }
      }, function (jqXHR, textStatus) {
          self.updateLoadStatus('hosts');
      });

      App.HttpClient.get(usersUrl, App.usersMapper, {
        complete:function (jqXHR, textStatus) {
          self.updateLoadStatus('users');
        }
      }, function (jqXHR, textStatus) {
          self.updateLoadStatus('users');
      });

      App.router.get('updateController').updateServiceMetric(function(){
          self.updateLoadStatus('services');
      }, true);

      this.loadAlerts(function(){
          self.updateLoadStatus('alerts');
      });

    },

    clusterName:function () {
      return (this.get('cluster')) ? this.get('cluster').Clusters.cluster_name : null;
    }.property('cluster'),
    
    updateClusterData: function () {
      var clusterUrl = this.getUrl('/data/clusters/cluster.json', '?fields=Clusters');
      App.HttpClient.get(clusterUrl, App.clusterMapper, {
        complete:function(){}
      });
    }
  });
  
});
window.require.register("controllers/global/update_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.UpdateController = Em.Controller.extend({
    name:'updateController',
    isUpdated:false,
    cluster:null,
    isWorking: false,
    timeIntervalId: null,
    clusterName:function () {
      return App.router.get('clusterController.clusterName');
    }.property('App.router.clusterController.clusterName'),

    getUrl:function (testUrl, url) {
      return (App.testMode) ? testUrl : App.apiPrefix + '/clusters/' + this.get('clusterName') + url;
    },

    /**
     * Start polling, when <code>isWorking</code> become true
     */
    updateAll:function(){
      if(this.get('isWorking')) {
        App.updater.run(this, 'updateHost', 'isWorking');
        App.updater.run(this, 'updateServiceMetric', 'isWorking');
        App.updater.run(this, 'graphsUpdate', 'isWorking');
      }
    }.observes('isWorking'),

    updateHost:function(callback) {
      var self = this;
        var hostsUrl = this.getUrl('/data/hosts/hosts.json', '/hosts?fields=Hosts/host_name,Hosts/public_host_name,Hosts/disk_info,Hosts/cpu_count,Hosts/total_mem,Hosts/host_status,Hosts/last_heartbeat_time,Hosts/os_arch,Hosts/os_type,Hosts/ip,host_components,metrics/disk,metrics/load/load_one');
        App.HttpClient.get(hostsUrl, App.hostsMapper, {
          complete: callback
        });
    },
    graphs: [],
    graphsUpdate: function (callback) {
        var existedGraphs = [];
        this.get('graphs').forEach(function (_graph) {
          var view = Em.View.views[_graph.id];
          if (view) {
            existedGraphs.push(_graph);
            //console.log('updated graph', _graph.name);
            view.loadData();
            //if graph opened as modal popup update it to
            if($(".modal-graph-line .modal-body #" + _graph.popupId + "-container-popup").length) {
              view.loadData();
            }
          }
        });
      callback();
      this.set('graphs', existedGraphs);
    },

    /**
     * Updates the services information. 
     *
     * @param callback
     * @param isInitialLoad  If true, only basic information is loaded.
     */
    updateServiceMetric: function (callback, isInitialLoad) {
      var self = this;
      self.set('isUpdated', false);
      
      var conditionalFields = [];
      if (App.Service.find().findProperty('serviceName', 'FLUME')) {
        conditionalFields.push("components/host_components/metrics/flume/flume");
      }
      var conditionalFieldsString = conditionalFields.length > 0 ? ',' + conditionalFields.join(',') : '';
      var methodStartTs = new Date().getTime();
      var servicesUrl = isInitialLoad ? 
        //this.getUrl('/data/dashboard/services.json', '/services?fields=components/ServiceComponentInfo,components/host_components,components/host_components/HostRoles') :
        this.getUrl('/data/dashboard/services.json', '/services?fields=components/ServiceComponentInfo,components/host_components,components/host_components/HostRoles,components/host_components/metrics/jvm/memHeapUsedM,components/host_components/metrics/jvm/memHeapCommittedM,components/host_components/metrics/mapred/jobtracker/trackers_decommissioned,components/host_components/metrics/cpu/cpu_wio,components/host_components/metrics/rpc/RpcQueueTime_avg_time'+conditionalFieldsString):
        this.getUrl('/data/dashboard/services.json', '/services?fields=components/ServiceComponentInfo,components/host_components,components/host_components/HostRoles,components/host_components/metrics/jvm/memHeapUsedM,components/host_components/metrics/jvm/memHeapCommittedM,components/host_components/metrics/mapred/jobtracker/trackers_decommissioned,components/host_components/metrics/cpu/cpu_wio,components/host_components/metrics/rpc/RpcQueueTime_avg_time'+conditionalFieldsString);
      var callback = callback || function (jqXHR, textStatus) {
        self.set('isUpdated', true);
      };
      App.HttpClient.get(servicesUrl, App.servicesMapper, {
        complete: function(){
          console.log("UpdateServiceMetric() Finished in:"+ (new Date().getTime()-methodStartTs) + " ms");
          callback();
        }
      });
    }

  });
  
});
window.require.register("controllers/installer", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.InstallerController = App.WizardController.extend({

    name: 'installerController',

    totalSteps: 11,

    content: Em.Object.create({
      cluster: null,
      installOptions: null,
      hosts: null,
      services: null,
      slaveComponentHosts: null,
      masterComponentHosts: null,
      serviceConfigProperties: null,
      advancedServiceConfig: null,
      slaveGroupProperties: null,
      controllerName: 'installerController'
    }),

    init: function () {
      this._super();
      this.get('isStepDisabled').setEach('value', true);
      this.get('isStepDisabled').pushObject(Ember.Object.create({
        step: 0,
        value: false
      }));
    },

    getCluster: function(){
      return jQuery.extend({}, this.get('clusterStatusTemplate'));
    },

    getInstallOptions: function(){
      return jQuery.extend({}, this.get('installOptionsTemplate'));
    },

    getHosts: function(){
      return [];
    },

    /**
     * Remove host from model. Used at <code>Confirm hosts(step2)</code> step
     * @param hosts Array of hosts, which we want to delete
     */
    removeHosts: function (hosts) {
      //todo Replace this code with real logic
      App.db.removeHosts(hosts);
    },

    /**
     * Load confirmed hosts.
     * Will be used at <code>Assign Masters(step5)</code> step
     */
    loadConfirmedHosts: function () {
      this.set('content.hosts', App.db.getHosts() || []);
    },

    /**
     * Load services data. Will be used at <code>Select services(step4)</code> step
     */
    loadServices: function () {
      var servicesInfo = App.db.getService();
      servicesInfo.forEach(function (item, index) {
        servicesInfo[index] = Em.Object.create(item);
        servicesInfo[index].isInstalled = false;
      });
      this.set('content.services', servicesInfo);
      console.log('installerController.loadServices: loaded data ', JSON.stringify(servicesInfo));
      console.log("The type odf serviceInfo: " + typeof servicesInfo);
      console.log('selected services ', servicesInfo.filterProperty('isSelected', true).mapProperty('serviceName'));
    },

    stacks: [],

    /**
     * Load stacks data from server or take exist data from local db
     */
    loadStacks: function () {
      var stacks = App.db.getStacks();
      if (stacks && stacks.length) {
        var convertedStacks = [];
        stacks.forEach(function (stack) {
          convertedStacks.pushObject(Ember.Object.create(stack));
        });
        App.set('currentStackVersion', convertedStacks.findProperty('isSelected').get('name'));
        this.set('content.stacks', convertedStacks);
      } else {
        App.ajax.send({
          name: 'wizard.stacks',
          sender: this,
          success: 'loadStacksSuccessCallback',
          error: 'loadStacksErrorCallback'
        });
      }
    },

    /**
     * Send queries to load versions for each stack
     */
    loadStacksSuccessCallback: function (data) {
      var stacks = data.items;
      var result;
      this.get('stacks').clear();
      stacks.forEach(function (stack) {
        App.ajax.send({
          name: 'wizard.stacks_versions',
          sender: this,
          data: {
            stackName: stack.Stacks.stack_name
          },
          success: 'loadStacksVersionsSuccessCallback',
          error: 'loadStacksVersionsErrorCallback'
        });
      }, this);
      result = this.get('stacks');
      if (!result.length) {
        console.log('Error: therea are no active stacks');
      } else {
        var defaultStackVersion = result.findProperty('name', App.defaultStackVersion);
        if (defaultStackVersion) {
          defaultStackVersion.set('isSelected', true)
        } else {
          result.objectAt(0).set('isSelected', true);
        }
      }
      App.db.setStacks(result);
      this.set('content.stacks', result);
    },

    /**
     * onError callback for loading stacks data
     */
    loadStacksErrorCallback: function () {
      console.log('Error in loading stacks');
    },

    /**
     * Parse loaded data and create array of stacks objects
     */
    loadStacksVersionsSuccessCallback: function (data) {
      var result = [];
      var stackVersions = data.items.filterProperty('Versions.active');
      stackVersions.sort(function (a, b) {
        if (a.Versions.stack_version > b.Versions.stack_version) {
          return -1;
        }
        if (a.Versions.stack_version < b.Versions.stack_version) {
          return 1;
        }
        return 0;
      });
      stackVersions.forEach(function (version) {
        /*
         * operatingSystems:[
         *  {
         *    osType: 'centos5',
         *    baseUrl: 'http://...',
         *    originalBaseUrl: 'http://...',
         *    defaultBaseUrl: 'http://...',
         *    mirrorsList: '';
         *  },
         *  {
         *    osType: 'centos6',
         *    baseUrl: 'http://...',
         *    originalBaseUrl: 'http://...',
         *    defaultBaseUrl: 'http://...',
         *    mirrorsList: '';
         *  },
         * ]
         */
        var oses = [];
        if (version.operatingSystems) {
          version.operatingSystems.forEach(function (os) {
            if (os.repositories) {
              os.repositories.forEach(function (repo) {
                if(repo.Repositories.repo_name == version.Versions.stack_name){
                  oses.push({
                    osType: os.OperatingSystems.os_type,
                    baseUrl: repo.Repositories.base_url,
                    originalBaseUrl: repo.Repositories.base_url,
                    defaultBaseUrl: repo.Repositories.default_base_url ? 
                        repo.Repositories.default_base_url : repo.Repositories.base_url,
                    mirrorsList: repo.Repositories.mirrors_list
                  });
                }
              });
            }
          });
        }
        result.push(
            Ember.Object.create({
              name: version.Versions.stack_name + "-" + version.Versions.stack_version,
              isSelected: false,
              operatingSystems: oses
            })
        );
      }, this);
      this.get('stacks').pushObjects(result);
    },

    /**
     * onError callback for loading stacks data
     */
    loadStacksVersionsErrorCallback: function () {
      console.log('Error in loading stacks');
    },

    /**
     * Save data to model
     * @param stepController App.WizardStep4Controller
     */
    saveServices: function (stepController) {
      var serviceNames = [];
      App.db.setService(stepController.get('content'));
      stepController.filterProperty('isSelected', true).forEach(function (item) {
        serviceNames.push(item.serviceName);
      });
      this.set('content.selectedServiceNames', serviceNames);
      App.db.setSelectedServiceNames(serviceNames);
      console.log('installerController.saveServices: saved data ', serviceNames);
    },

    /**
     * Save Master Component Hosts data to Main Controller
     * @param stepController App.WizardStep5Controller
     */
    saveMasterComponentHosts: function (stepController) {
      var obj = stepController.get('selectedServicesMasters');

      var masterComponentHosts = [];
      obj.forEach(function (_component) {
        masterComponentHosts.push({
          display_name: _component.get('display_name'),
          component: _component.get('component_name'),
          hostName: _component.get('selectedHost'),
          serviceId: _component.get('serviceId'),
          isInstalled: false
        });
      });

      console.log("installerController.saveMasterComponentHosts: saved hosts ", masterComponentHosts);
      App.db.setMasterComponentHosts(masterComponentHosts);
      this.set('content.masterComponentHosts', masterComponentHosts);
    },

    /**
     * Load master component hosts data for using in required step controllers
     */
    loadMasterComponentHosts: function () {
      var masterComponentHosts = App.db.getMasterComponentHosts() || [];
      this.set("content.masterComponentHosts", masterComponentHosts);
      console.log("InstallerController.loadMasterComponentHosts: loaded hosts ", masterComponentHosts);
    },

    /**
     * Load master component hosts data for using in required step controllers
     */
    loadSlaveComponentHosts: function () {
      var slaveComponentHosts = App.db.getSlaveComponentHosts() || null;
      this.set("content.slaveComponentHosts", slaveComponentHosts);
      console.log("InstallerController.loadSlaveComponentHosts: loaded hosts ", slaveComponentHosts);
    },

    /**
     * Load serviceConfigProperties to model
     */
    loadServiceConfigProperties: function () {
      var serviceConfigProperties = App.db.getServiceConfigProperties();
      this.set('content.serviceConfigProperties', serviceConfigProperties);
      console.log("InstallerController.loadServiceConfigProperties: loaded config ", serviceConfigProperties);

      this.set('content.advancedServiceConfig', App.db.getAdvancedServiceConfig());
    },

    /**
     * Load information about hosts with clients components
     */
    loadClients: function () {
      var clients = App.db.getClientsForSelectedServices();
      this.set('content.clients', clients);
      console.log("InstallerController.loadClients: loaded list ", clients);
    },

    /**
     * Generate clients list for selected services and save it to model
     * @param stepController step4WizardController
     */
    saveClients: function (stepController) {
      var clients = [];
      var serviceComponents = require('data/service_components');

      stepController.get('content').filterProperty('isSelected', true).forEach(function (_service) {
        var client = serviceComponents.filterProperty('service_name', _service.serviceName).findProperty('isClient', true);
        if (client) {
          clients.pushObject({
            component_name: client.component_name,
            display_name: client.display_name,
            isInstalled: false
          });
        }
      }, this);

      App.db.setClientsForSelectedServices(clients);
      this.set('content.clients', clients);
      console.log("InstallerController.saveClients: saved list ", clients);
    },

    /**
     * Save stacks data to local db
     * @param stepController step1WizardController
     */
    saveStacks: function (stepController) {
      var stacks = stepController.get('content.stacks');
      if (stacks.length) {
        App.set('currentStackVersion', stacks.findProperty('isSelected').get('name'));
      } else {
        App.set('currentStackVersion', App.defaultStackVersion);
      }
      App.db.setStacks(stacks);
      this.set('content.stacks', stacks);
    },

    /**
     * Load data for all steps until <code>current step</code>
     */
    loadAllPriorSteps: function () {
      var step = this.get('currentStep');
      switch (step) {
        case '10':
        case '9':
        case '8':
        case '7':
          this.loadServiceConfigProperties();
        case '6':
          this.loadSlaveComponentHosts();
          this.loadClients();
        case '5':
          this.loadMasterComponentHosts();
          this.loadConfirmedHosts();
        case '4':
          this.loadServices();
        case '3':
          this.loadConfirmedHosts();
        case '2':
          this.load('installOptions');
        case '1':
          this.loadStacks();
        case '0':
          this.load('cluster');
      }
    },
    /**
     * Clear all temporary data
     */
    finish: function () {
      this.setCurrentStep('0');
      this.clearStorageData();
    },

    setStepsEnable: function () {
      for (var i = 0; i <= this.totalSteps; i++) {
        var step = this.get('isStepDisabled').findProperty('step', i);
        if (i <= this.get('currentStep')) {
          step.set('value', false);
        } else {
          step.set('value', true);
        }
      }
    }.observes('currentStep'),

    setLowerStepsDisable: function (stepNo) {
      for (var i = 0; i < stepNo; i++) {
        var step = this.get('isStepDisabled').findProperty('step', i);
        step.set('value', true);
      }
    }

  });

  
});
window.require.register("controllers/login_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.LoginController = Em.Object.extend({

    name: 'loginController',

    loginName: '',
    password: '',

    errorMessage: '',

    submit: function (e) {
      this.set('errorMessage', '');

      var self = this;

      App.get('router').login();
    },

    postLogin: function (isAuthenticated) {
      if (!isAuthenticated) {
        console.log('Failed to login as: ' + this.get('loginName'));
        this.set('errorMessage', Em.I18n.t('login.error'));
      }
    }

  });
});
window.require.register("controllers/main", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  require('models/background_operation');

  App.MainController = Em.Controller.extend({
    name: 'mainController',

    updateTitle: function(){
      var name = App.router.get('clusterController.clusterName');
      if (name) {
        name = name.length > 13 ? name.substr(0, 10) + "..." : name;
      } else {
        name = Em.I18n.t('common.loading');
      }
      $('title').text('大数据平台 - ' + name);
    }.observes('App.router.clusterController.clusterName'),

    isClusterDataLoaded: function(){
      return App.router.get('clusterController.isLoaded');
    }.property('App.router.clusterController.isLoaded'),

    clusterDataLoadedPercent: function(){
      return App.router.get('clusterController.clusterDataLoadedPercent');
    }.property('App.router.clusterController.clusterDataLoadedPercent'),
    /**
     * run all processes and cluster's data loading
     */
    initialize: function(){
      this.initAdmin();
      App.router.get('clusterController').loadClusterData();
      this.startPolling();
    },
    initAdmin: function(){
      if(App.db && App.db.getUser() && App.db.getUser().admin) {
        App.set('isAdmin', true);
        console.log('Administrator logged in');
      }
    },

    dataLoading: function () {
      var self = this;
      var dfd = $.Deferred();
      if (App.router.get('clusterController.isLoaded')) {
        dfd.resolve();
      } else {
        var interval = setInterval(function () {
          if (self.get('isClusterDataLoaded')) {
            dfd.resolve();
            clearInterval(interval);
          }
        }, 50);
      }
      return dfd.promise();
    },

    startPolling: function(){
      App.router.get('updateController').set('isWorking', true);
      App.router.get('backgroundOperationsController').set('isWorking', true);
      App.router.get('clusterController').set('isWorking', true);
    },
    stopPolling: function(){
      App.router.get('updateController').set('isWorking', false);
      App.router.get('backgroundOperationsController').set('isWorking', false);
      App.router.get('clusterController').set('isWorking', false);
    },

    reloadTimeOut: null,

    pageReload: function () {

      clearTimeout(this.get("reloadTimeOut"));

      this.set('reloadTimeOut',
          setTimeout(function () {
            location.reload()
          }, App.pageReloadTime)
      );
    }.observes("App.router.location.lastSetURL")

  })
});
window.require.register("controllers/main/admin", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminController = Em.Controller.extend({
    name: 'mainAdminController',
    category: 'user'
  });
});
window.require.register("controllers/main/admin/advanced", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminAdvancedController = Em.Controller.extend({
    name:'mainAdminAdvancedController',
    uninstall: function(event){
      var params = event.context;
      App.ModalPopup.show({
        uninstallParams: params,
        header: Em.I18n.t('admin.advanced.popup.header'),
        bodyClass: App.MainAdminAdvancedPasswordView.reopen({}), // layout: Em.Handlebars.compile()
        onPrimary: function(){
          var form = this.getForm();
          if(form) {
            if(form.isValid()) {
              console.warn("TODO: request for cluster uninstall");
            }
          }
          this.onClose();
        },
        onSecondary: function(){
          this.onClose();
        },

        getForm: function(){
          var form = false;
          $.each(this.get('_childViews'), function(){
            if(this.get('path') == "bodyClass") {
              return form = this.get('_childViews')[0];
            }
          });

          return form;
        }
      })
    }
  })
});
window.require.register("controllers/main/admin/authentication", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminAuthenticationController = Em.Controller.extend({
    name:'mainAdminAuthenticationController',
    /**
     * save user form after editing
     * @param event
     */
    save:function (event) {
      var form = event.context;
      if (form.isValid()) {
        form.save();
        App.ModalPopup.show({
          header:Em.I18n.t('admin.authentication.form.testConfiguration'),
          body:form.get('resultText'),
          secondary:false,
          onPrimary:function () {
            this.hide();
          }
        });
      }
    },
    content:App.Authentication.find(1)
  })
});
window.require.register("controllers/main/admin/cluster", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var stringUtils = require('utils/string_utils');

  App.MainAdminClusterController = Em.Controller.extend({
    name:'mainAdminClusterController',
    services: [],
    upgradeVersion: '',
    /**
     * get the newest version of HDP from server
     */
    updateUpgradeVersion: function(){
      if(App.router.get('clusterController.isLoaded')){
        App.ajax.send({
          name: 'cluster.update_upgrade_version',
          sender: this,
          success: 'updateUpgradeVersionSuccessCallback',
          error: 'updateUpgradeVersionErrorCallback'
        });
      }
    }.observes('App.router.clusterController.isLoaded', 'App.currentStackVersion'),

    updateUpgradeVersionSuccessCallback: function(data) {
      var upgradeVersion = this.get('upgradeVersion') || App.defaultStackVersion;
      var currentStack = {};
      var upgradeStack = {};
      var currentVersion = App.get('currentStackVersionNumber');
      var minUpgradeVersion = currentVersion;
      upgradeVersion = upgradeVersion.replace(/HDP-/, '');
      data.items.mapProperty('Versions.stack_version').forEach(function(version){
        upgradeVersion = (stringUtils.compareVersions(upgradeVersion, version) === -1) ? version : upgradeVersion;
      });
      currentStack = data.items.findProperty('Versions.stack_version', currentVersion);
      upgradeStack = data.items.findProperty('Versions.stack_version', upgradeVersion);
      minUpgradeVersion = upgradeStack.Versions.min_upgrade_version;
      if(minUpgradeVersion && (stringUtils.compareVersions(minUpgradeVersion, currentVersion) === 1)){
        upgradeVersion = currentVersion;
        upgradeStack = currentStack;
      }
      upgradeVersion = 'HDP-' + upgradeVersion;
      this.set('upgradeVersion', upgradeVersion);
      if(currentStack && upgradeStack) {
        this.parseServicesInfo(currentStack, upgradeStack);
      }
      else {
        console.log('HDP stack doesn\'t have services with defaultStackVersion');
      }
    },

    updateUpgradeVersionErrorCallback: function(request, ajaxOptions, error) {
      console.log('Error message is: ' + request.responseText);
      console.log('HDP stack doesn\'t have services with defaultStackVersion');
    },

    /**
     * parse services info(versions, description) by version
     */
    parseServicesInfo: function (currentStack, upgradeStack) {
      var result = [];
      var installedServices = App.Service.find().mapProperty('serviceName');
      var displayOrderConfig = require('data/services');
      if(currentStack.stackServices.length && upgradeStack.stackServices.length){
        // loop through all the service components
        for (var i = 0; i < displayOrderConfig.length; i++) {
          var entry = currentStack.stackServices.
            findProperty("StackServices.service_name", displayOrderConfig[i].serviceName);
          if (entry) {
            entry = entry.StackServices;
            if (installedServices.contains(entry.service_name)) {
              var myService = Em.Object.create({
                serviceName: entry.service_name,
                displayName: displayOrderConfig[i].displayName,
                isDisabled: displayOrderConfig[i].isDisabled,
                isSelected: true,
                isInstalled: false,
                isHidden: displayOrderConfig[i].isHidden,
                description: entry.comments,
                version: entry.service_version,
                newVersion: ''
              });
              // it's possible that there is no corresponding service in the new stack
              var matchedService = upgradeStack.stackServices.findProperty("StackServices.service_name", displayOrderConfig[i].serviceName);
              if (matchedService) {
                myService.newVersion = matchedService.StackServices.service_version;
              }
              //From 1.3.0 for Hive we display only "Hive" (but it install HCat and WebHCat as well)
              if (this.get('upgradeVersion').replace(/HDP-/, '') >= '1.3.0' && displayOrderConfig[i].serviceName == 'HIVE') {
                myService.set('displayName', 'Hive');
              }
              result.push(myService);
            }
          }
          else {
            console.warn('Service not found - ', displayOrderConfig[i].serviceName);
          }
        }
      }
      this.set('services', result);
    }
  });
});
window.require.register("controllers/main/admin/misc_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  require('controllers/main/service/info/configs');

  App.MainAdminMiscController = App.MainServiceInfoConfigsController.extend({
    name:'mainAdminMiscController',
    users: null,
    content: {
      serviceName: 'MISC'
    },
    loadUsers: function() {
      this.set('selectedService', this.get('content.serviceName'));
      this.loadServiceConfig();
    },
    loadServiceConfig: function() {
      App.ajax.send({
        name: 'config.tags',
        sender: this,
        data: {
          serviceName: this.get('content.serviceName'),
          serviceConfigsDef: this.get('serviceConfigs').findProperty('serviceName', this.get('content.serviceName'))
        },
        success: 'loadServiceTagSuccess'
      });
    },
    loadServiceTagSuccess: function(data, opt, params) {
      var installedServices = App.Service.find().mapProperty("serviceName");
      var serviceConfigsDef = params.serviceConfigsDef;
      var serviceName = this.get('content.serviceName');
      var loadedClusterSiteToTagMap = {};

      for ( var site in data.Clusters.desired_configs) {
        if (serviceConfigsDef.sites.indexOf(site) > -1) {
          loadedClusterSiteToTagMap[site] = data.Clusters.desired_configs[site]['tag'];
        }
      }
      this.setServiceConfigTags(loadedClusterSiteToTagMap);
      var configGroups = App.config.loadConfigsByTags(this.get('serviceConfigTags'));
      var configSet = App.config.mergePreDefinedWithLoaded(configGroups, [], this.get('serviceConfigTags'), serviceName);

      var misc_configs = configSet.globalConfigs.filterProperty('serviceName', this.get('selectedService')).filterProperty('category', 'Users and Groups').filterProperty('isVisible', true);

      misc_configs = App.config.miscConfigVisibleProperty(misc_configs, installedServices);

      var sortOrder = this.get('configs').filterProperty('serviceName', this.get('selectedService')).filterProperty('category', 'Users and Groups').filterProperty('isVisible', true).mapProperty('name');

      var sorted = [];

      if(sortOrder) {
        sortOrder.forEach(function(name) {
          sorted.push(misc_configs.findProperty('name', name));
        });
        this.set('users', sorted);
      }
      else {
        this.set('users', misc_configs);
      }
      this.set('dataIsLoaded', true);
    }
  });
  
});
window.require.register("controllers/main/admin/security", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  App.MainAdminSecurityController = Em.Controller.extend({
    name: 'mainAdminSecurityController',
    isSubmitDisabled: false,
    securityEnabled: false,
    dataIsLoaded: false,
    serviceUsers: [],
    tag: null,
    getAddSecurityWizardStatus: function () {
      return App.db.getSecurityWizardStatus();
    },
    setAddSecurityWizardStatus: function (status) {
      App.db.setSecurityWizardStatus(status);
    },

    setDisableSecurityStatus: function (status) {
      App.db.setDisableSecurityStatus(status);
    },
    getDisableSecurityStatus: function (status) {
      return App.db.getDisableSecurityStatus();
    },

    notifySecurityOff: false,
    notifySecurityAdd: false,

    notifySecurityOffPopup: function () {
      var self = this;
      if (!this.get('isSubmitDisabled')) {
        App.ModalPopup.show({
          header: Em.I18n.t('popup.confirmation.commonHeader'),
          primary: Em.I18n.t('ok'),
          onPrimary: function () {
            App.db.setSecurityDeployStages(undefined);
            self.setDisableSecurityStatus("RUNNING");
            App.router.transitionTo('disableSecurity');
            this.hide();
          },
          bodyClass: Ember.View.extend({
            isMapReduceInstalled: App.Service.find().mapProperty('serviceName').contains('MAPREDUCE'),
            template: Ember.Handlebars.compile([
              '<div class="alert">',
              '{{t admin.security.disable.popup.body}}',
              '{{#if view.isMapReduceInstalled}}',
              '<br>',
              '{{t admin.security.disable.popup.body.warning}}',
              '{{/if}}',
              '</div>'
            ].join('\n'))
          })
        })
      }
    },

    getUpdatedSecurityStatus: function () {
      this.setSecurityStatus();
      return this.get('securityEnabled');
    },

    setSecurityStatus: function () {
      if (App.testMode) {
        this.set('securityEnabled', !App.testEnableSecurity);
        this.set('dataIsLoaded', true);
      } else {
        //get Security Status From Server
        App.ajax.send({
          name: 'admin.security_status',
          sender: this,
          success: 'getSecurityStatusFromServerSuccessCallback',
          error: 'errorCallback'
        });
      }
    },

    errorCallback: function () {
      this.set('dataIsLoaded', true);
      this.showSecurityErrorPopup();
    },

    getSecurityStatusFromServerSuccessCallback: function (data) {
      var configs = data.Clusters.desired_configs;
      if ('global' in configs) {
        this.set('tag', configs['global'].tag);
        this.getServiceConfigsFromServer();
      }
      else {
        this.showSecurityErrorPopup();
      }
    },

    getServiceConfigsFromServer: function () {
      App.ajax.send({
        name: 'admin.service_config',
        sender: this,
        data: {
          siteName: 'global',
          tagName: this.get('tag')
        },
        success: 'getServiceConfigsFromServerSuccessCallback',
        error: 'errorCallback'
      });
    },

    getServiceConfigsFromServerSuccessCallback: function (data) {
      console.log("TRACE: In success function for the GET getServiceConfigsFromServer call");
      var configs = data.items.findProperty('tag', this.get('tag')).properties;
      if (configs && (configs['security_enabled'] === 'true' || configs['security_enabled'] === true)) {
        this.set('securityEnabled', true);
      }
      else {
        this.set('securityEnabled', false);
      }
      this.loadUsers(configs);
      this.set('dataIsLoaded', true);
    },

    loadUsers: function (configs) {
      var serviceUsers = this.get('serviceUsers');
      serviceUsers.pushObject({
        id: 'puppet var',
        name: 'hdfs_user',
        value: configs['hdfs_user'] ? configs['hdfs_user'] : 'hdfs'
      });
      serviceUsers.pushObject({
        id: 'puppet var',
        name: 'mapred_user',
        value: configs['mapred_user'] ? configs['mapred_user'] : 'mapred'
      });
      serviceUsers.pushObject({
        id: 'puppet var',
        name: 'hbase_user',
        value: configs['hbase_user'] ? configs['hbase_user'] : 'hbase'
      });
      serviceUsers.pushObject({
        id: 'puppet var',
        name: 'hive_user',
        value: configs['hive_user'] ? configs['hive_user'] : 'hive'
      });
      serviceUsers.pushObject({
        id: 'puppet var',
        name: 'proxyuser_group',
        value: configs['proxyuser_group'] ? configs['proxyuser_group'] : 'users'
      });
      serviceUsers.pushObject({
        id: 'puppet var',
        name: 'smokeuser',
        value: configs['smokeuser'] ? configs['smokeuser'] : 'ambari-qa'
      });
      serviceUsers.pushObject({
        id: 'puppet var',
        name: 'zk_user',
        value: configs['zk_user'] ? configs['zk_user'] : 'zookeeper'
      });
      serviceUsers.pushObject({
        id: 'puppet var',
        name: 'oozie_user',
        value: configs['oozie_user'] ? configs['oozie_user'] : 'oozie'
      });
      serviceUsers.pushObject({
        id: 'puppet var',
        name: 'nagios_user',
        value: configs['nagios_user'] ? configs['nagios_user'] : 'nagios'
      });
      serviceUsers.pushObject({
        id: 'puppet var',
        name: 'user_group',
        value: configs['user_group'] ? configs['user_group'] : 'hadoop'
      });
    },

    showSecurityErrorPopup: function () {
      App.ModalPopup.show({
        header: Em.I18n.t('common.error'),
        secondary: false,
        onPrimary: function () {
          this.hide();
        },
        bodyClass: Ember.View.extend({
          template: Ember.Handlebars.compile('<p>{{t admin.security.status.error}}</p>')
        })
      });
    }
  });


  
});
window.require.register("controllers/main/admin/security/add/addSecurity_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  App.AddSecurityController = App.WizardController.extend({

    name: 'addSecurityController',
    securityEnabled: false,

    totalSteps: 4,

    content: Em.Object.create({
      services: [],
      serviceConfigProperties: null,
      controllerName: 'addSecurityController'
    }),

    /**
     * Loads all prior steps on refresh
     */
    loadAllPriorSteps: function () {
      var step = this.get('currentStep');
      switch (step) {
        case '4':
        case '3':
        case '2':
          this.loadServiceConfigs();
        case '1':
          this.loadServices();
      }
    },

    clearServices: function () {
      if (this.get('content.services')) {
        this.get('content.services').clear();
      }
    },

    /**
     * Loads all installed services
     */
    loadServices: function () {
      this.clearServices();
      var secureServices = require('data/secure_configs');
      var installedServices = App.Service.find().mapProperty('serviceName');
      //General (only non service tab) tab is always displayed
      this.get('content.services').push(secureServices.findProperty('serviceName', 'GENERAL'));
      installedServices.forEach(function (_service) {
        var secureService = secureServices.findProperty('serviceName', _service);
        if (secureService) {
          this.get('content.services').push(secureService);
        }
      }, this);

    },

    saveServiceConfigProperties: function (stepController) {
      var serviceConfigProperties = [];
      stepController.get('stepConfigs').forEach(function (_content) {
        _content.get('configs').forEach(function (_configProperties) {
          var displayType = _configProperties.get('displayType');
          if (displayType === 'directories' || displayType === 'directory') {
            var value = _configProperties.get('value').trim().split(/\s+/g).join(',');
            _configProperties.set('value', value);
          }
          var overrides = _configProperties.get('overrides');
          var overridesArray = [];
          if(overrides!=null){
            overrides.forEach(function(override){
              var overrideEntry = {
                value: override.get('value'),
                hosts: []
              };
              override.get('selectedHostOptions').forEach(function(host){
                overrideEntry.hosts.push(host);
              });
              overridesArray.push(overrideEntry);
            });
          }
          overridesArray = (overridesArray.length) ? overridesArray : null;
          var configProperty = {
            id: _configProperties.get('id'),
            name: _configProperties.get('name'),
            value: _configProperties.get('value'),
            defaultValue: _configProperties.get('defaultValue'),
            serviceName: _configProperties.get('serviceName'),
            domain:  _configProperties.get('domain'),
            filename: _configProperties.get('filename'),
            unit: _configProperties.get('unit'),
            components: _configProperties.get('components'),
            component: _configProperties.get('component'),
            overrides: overridesArray
          };
          serviceConfigProperties.push(configProperty);
        }, this);
      }, this);
      App.db.setSecureConfigProperties(serviceConfigProperties);
      this.set('content.serviceConfigProperties', serviceConfigProperties);
    },

    /**
     * Loads all service config properties
     */

    loadServiceConfigs: function () {
      var serviceConfigProperties = App.db.getSecureConfigProperties();
      this.set('content.serviceConfigProperties', serviceConfigProperties);
    }
  });

  
});
window.require.register("controllers/main/admin/security/add/step1", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  App.MainAdminSecurityAddStep1Controller = Em.Controller.extend({

    name: 'mainAdminSecurityAddStep1Controller'
  });
});
window.require.register("controllers/main/admin/security/add/step2", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var stringUtils = require('utils/string_utils');

  App.MainAdminSecurityAddStep2Controller = Em.Controller.extend({

    name: 'mainAdminSecurityAddStep2Controller',
    stepConfigs: [],
    installedServices: [],
    selectedService: null,
    securityUsers: [],

    isSubmitDisabled: function () {
      return !this.stepConfigs.filterProperty('showConfig', true).everyProperty('errorCount', 0);
    }.property('stepConfigs.@each.errorCount'),

    clearStep: function () {
      this.get('stepConfigs').clear();
      this.get('securityUsers').clear();
    },


    /**
     *  Function is called whenever the step is loaded
     */
    loadStep: function () {
      console.log("TRACE: Loading addSecurity step2: Configure Services");
      this.clearStep();
      this.loadUsers();
      this.addUserPrincipals(this.get('content.services'));
      this.addMasterHostToGlobals(this.get('content.services'));
      this.addSlaveHostToGlobals(this.get('content.services'));
      this.renderServiceConfigs(this.get('content.services'));
      var storedServices = this.get('content.serviceConfigProperties');
      if (storedServices) {
        var configs = new Ember.Set();

        // for all services`
        this.get('stepConfigs').forEach(function (_content) {
          //for all components
          _content.get('configs').forEach(function (_config) {

            var componentVal = storedServices.findProperty('name', _config.get('name'));
            //if we have config for specified component
            if (componentVal) {
              //set it
              _config.set('value', componentVal.value);
            }

          }, this);
        }, this);

      }
      //
      this.set('installedServices', App.Service.find().mapProperty('serviceName'));
      console.log("The services are: " + this.get('installedServices'));
      //
    },

    /**
     * Render configs for active services
     * @param serviceConfigs
     */
    renderServiceConfigs: function (serviceConfigs) {
      serviceConfigs.forEach(function (_serviceConfig) {

        var serviceConfig = App.ServiceConfig.create({
          filename: _serviceConfig.filename,
          serviceName: _serviceConfig.serviceName,
          displayName: _serviceConfig.displayName,
          configCategories: _serviceConfig.configCategories,
          showConfig: true,
          configs: []
        });

        this.loadComponentConfigs(_serviceConfig, serviceConfig);

        console.log('pushing ' + serviceConfig.serviceName, serviceConfig);

        this.get('stepConfigs').pushObject(serviceConfig);
      }, this);
      this.set('selectedService', this.get('stepConfigs').filterProperty('showConfig', true).objectAt(0));
    },

    /**
     * Load child components to service config object
     * @param _componentConfig
     * @param componentConfig
     */
    loadComponentConfigs: function (_componentConfig, componentConfig) {
      _componentConfig.configs.forEach(function (_serviceConfigProperty) {
        var serviceConfigProperty = App.ServiceConfigProperty.create(_serviceConfigProperty);
        componentConfig.configs.pushObject(serviceConfigProperty);
        serviceConfigProperty.set('isEditable', serviceConfigProperty.get('isReconfigurable'));
        serviceConfigProperty.validate();
      }, this);
    },

    /**
     * fill config with hosts of component
     * @param service
     * @param configName
     * @param componentName
     */
    setHostsToConfig: function(service, configName, componentName){
      if(service){
        var hosts = service.configs.findProperty('name', configName);
        if(hosts){
          hosts.defaultValue = App.Service.find(service.serviceName)
            .get('hostComponents')
            .filterProperty('componentName', componentName)
            .mapProperty('host.hostName');
        }
      }
    },

    loadUsers: function() {
      var securityUsers = App.router.get('mainAdminSecurityController').get('serviceUsers');
      if (!securityUsers || securityUsers.length < 1) { // Page could be refreshed in middle
        if (App.testMode) {
          securityUsers.pushObject({id: 'puppet var', name: 'hdfs_user', value: 'hdfs'});
          securityUsers.pushObject({id: 'puppet var', name: 'mapred_user', value: 'mapred'});
          securityUsers.pushObject({id: 'puppet var', name: 'hbase_user', value: 'hbase'});
          securityUsers.pushObject({id: 'puppet var', name: 'hive_user', value: 'hive'});
          securityUsers.pushObject({id: 'puppet var', name: 'smokeuser', value: 'ambari-qa'});
        } else {
          App.router.get('mainAdminSecurityController').setSecurityStatus();
          securityUsers = App.router.get('mainAdminSecurityController').get('serviceUsers');
        }
      }
      this.set('securityUsers',securityUsers);
    },

    addUserPrincipals: function(serviceConfigs) {
      var securityUsers = this.get('securityUsers');
      var smokeUser = securityUsers.findProperty('name', 'smokeuser');
      var hdfsUser = securityUsers.findProperty('name', 'hdfs_user');
      var hbaseUser = securityUsers.findProperty('name', 'hbase_user');
      var generalService = serviceConfigs.findProperty('serviceName', 'GENERAL');
      var smokeUserPrincipal = generalService.configs.findProperty('name', 'smokeuser_principal_name');
      var hdfsUserPrincipal = generalService.configs.findProperty('name', 'hdfs_principal_name');
      var hbaseUserPrincipal = generalService.configs.findProperty('name', 'hbase_principal_name');
      var hbaseUserKeytab = generalService.configs.findProperty('name', 'hbase_user_keytab');
      var hbaseService = serviceConfigs.findProperty('serviceName', 'HBASE');
      if(smokeUser && smokeUserPrincipal) {
        smokeUserPrincipal.defaultValue = smokeUser.value;
      }
      if(hdfsUser && hdfsUserPrincipal) {
        hdfsUserPrincipal.defaultValue = hdfsUser.value;
      }
      if(hbaseService && hbaseUser && hbaseUserPrincipal) {
        hbaseUserPrincipal.defaultValue = hbaseUser.value;
        hbaseUserPrincipal.isVisible = true;
        hbaseUserKeytab.isVisible = true;
      }
    },

    addSlaveHostToGlobals: function(serviceConfigs){
      var hdfsService = serviceConfigs.findProperty('serviceName', 'HDFS');
      var mapReduceService = serviceConfigs.findProperty('serviceName', 'MAPREDUCE');
      var hbaseService = serviceConfigs.findProperty('serviceName', 'HBASE');
      this.setHostsToConfig(hdfsService, 'datanode_hosts', 'DATANODE');
      this.setHostsToConfig(mapReduceService, 'tasktracker_hosts', 'TASKTRACKER');
      this.setHostsToConfig(hbaseService, 'regionserver_hosts', 'HBASE_REGIONSERVER');
    },

    addMasterHostToGlobals: function (serviceConfigs) {
      var oozieService = serviceConfigs.findProperty('serviceName', 'OOZIE');
      var hiveService = serviceConfigs.findProperty('serviceName', 'HIVE');
      var webHcatService = serviceConfigs.findProperty('serviceName', 'WEBHCAT');
      var nagiosService = serviceConfigs.findProperty('serviceName', 'NAGIOS');
      var hbaseService = serviceConfigs.findProperty('serviceName', 'HBASE');
      var zooKeeperService = serviceConfigs.findProperty('serviceName', 'ZOOKEEPER');
      var hdfsService = serviceConfigs.findProperty('serviceName', 'HDFS');
      var mapReduceService = serviceConfigs.findProperty('serviceName', 'MAPREDUCE');
      if (oozieService) {
        var oozieServerHost = oozieService.configs.findProperty('name', 'oozie_servername');
        var oozieServerPrincipal = oozieService.configs.findProperty('name', 'oozie_principal_name');
        var oozieSpnegoPrincipal =  oozieService.configs.findProperty('name', 'oozie_http_principal_name');
        if (oozieServerHost && oozieServerPrincipal && oozieSpnegoPrincipal) {
          oozieServerHost.defaultValue = App.Service.find('OOZIE').get('hostComponents').findProperty('componentName', 'OOZIE_SERVER').get('host.hostName');
          oozieServerPrincipal.defaultValue = 'oozie/' + oozieServerHost.defaultValue.toLowerCase();
          oozieSpnegoPrincipal.defaultValue = 'HTTP/' + oozieServerHost.defaultValue.toLowerCase();
        }
      }
      if (hiveService) {
        var hiveServerHost = hiveService.configs.findProperty('name', 'hive_metastore');
        if (hiveServerHost) {
          hiveServerHost.defaultValue = App.Service.find('HIVE').get('hostComponents').findProperty('componentName', 'HIVE_SERVER').get('host.hostName');
        }
      }
      if(webHcatService) {
        var webHcatHost = webHcatService.configs.findProperty('name', 'webhcatserver_host');
        var webHcatSpnegoPrincipal = webHcatService.configs.findProperty('name', 'webHCat_http_principal_name');
        if (webHcatHost && webHcatSpnegoPrincipal) {
          webHcatHost.defaultValue = App.Service.find('WEBHCAT').get('hostComponents').findProperty('componentName', 'WEBHCAT_SERVER').get('host.hostName');
          webHcatSpnegoPrincipal.defaultValue = 'HTTP/' + webHcatHost.defaultValue.toLowerCase();

        }
      }

      if(nagiosService) {
        var nagiosServerHost = nagiosService.configs.findProperty('name', 'nagios_server');
        var nagiosServerPrincipal = nagiosService.configs.findProperty('name', 'nagios_principal_name');
        if (nagiosServerHost && nagiosServerPrincipal) {
          nagiosServerHost.defaultValue = App.Service.find('NAGIOS').get('hostComponents').findProperty('componentName', 'NAGIOS_SERVER').get('host.hostName');
          nagiosServerPrincipal.defaultValue = 'nagios/' + nagiosServerHost.defaultValue.toLowerCase();
        }
      }
      if(hdfsService){
        var namenodeHost = hdfsService.configs.findProperty('name', 'namenode_host');
        var sNamenodeHost = hdfsService.configs.findProperty('name', 'snamenode_host');
        if (namenodeHost && sNamenodeHost) {
          namenodeHost.defaultValue = App.Service.find('HDFS').get('hostComponents').findProperty('componentName', 'NAMENODE').get('host.hostName');
          sNamenodeHost.defaultValue = App.Service.find('HDFS').get('hostComponents').findProperty('componentName', 'SECONDARY_NAMENODE').get('host.hostName');
        }
      }
      if(mapReduceService){
        var jobTrackerHost = mapReduceService.configs.findProperty('name', 'jobtracker_host');
        if (jobTrackerHost) {
          jobTrackerHost.defaultValue = App.Service.find('MAPREDUCE').get('hostComponents').findProperty('componentName', 'JOBTRACKER').get('host.hostName');
        }
      }
      this.setHostsToConfig(hbaseService, 'hbasemaster_host', 'HBASE_MASTER');
      this.setHostsToConfig(zooKeeperService, 'zookeeperserver_hosts', 'ZOOKEEPER_SERVER');
    },

    /**
     *  submit and move to step3
     */

    submit: function () {
      if (!this.get('isSubmitDisabled')) {
        App.router.send('next');
      }
    }

  });
});
window.require.register("controllers/main/admin/security/add/step3", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var stringUtils = require('utils/string_utils');

  App.MainAdminSecurityAddStep3Controller = Em.Controller.extend({
    name: 'mainAdminSecurityAddStep3Controller',
    hostComponents: [],
    doDownloadCsv: function () {
      if ($.browser.msie && $.browser.version < 10) {
        this.openInfoInNewTab();
      } else {
        var blob = new Blob([stringUtils.arrayToCSV(this.get('hostComponents'))], {type: "text/csv;charset=utf-8;"});
        saveAs(blob, "host-principal-keytab-list.csv");
      }
    },
    openInfoInNewTab: function () {
      var newWindow = window.open('');
      var newDocument = newWindow.document;
      newDocument.write(stringUtils.arrayToCSV(this.get('hostComponents')));
      newWindow.focus();
    },
    loadStep: function(){
      var configs = this.get('content.serviceConfigProperties');
      var hosts = App.Host.find();
      var result = [];
      var componentsToDisplay = ['NAMENODE', 'SECONDARY_NAMENODE', 'DATANODE', 'JOBTRACKER', 'ZOOKEEPER_SERVER', 'HIVE_SERVER', 'TASKTRACKER',
        'OOZIE_SERVER', 'NAGIOS_SERVER', 'HBASE_MASTER', 'HBASE_REGIONSERVER'];
      var securityUsers = [];
      if (!securityUsers || securityUsers.length < 1) { // Page could be refreshed in middle
        if (App.testMode) {
          securityUsers.pushObject({id: 'puppet var', name: 'hdfs_user', value: 'hdfs'});
          securityUsers.pushObject({id: 'puppet var', name: 'mapred_user', value: 'mapred'});
          securityUsers.pushObject({id: 'puppet var', name: 'hbase_user', value: 'hbase'});
          securityUsers.pushObject({id: 'puppet var', name: 'hive_user', value: 'hive'});
          securityUsers.pushObject({id: 'puppet var', name: 'smokeuser', value: 'ambari-qa'});
          securityUsers.pushObject({id: 'puppet var', name: 'zk_user', value: 'zookeeper'});
          securityUsers.pushObject({id: 'puppet var', name: 'oozie_user', value: 'oozie'});
          securityUsers.pushObject({id: 'puppet var', name: 'nagios_user', value: 'nagios'});
          securityUsers.pushObject({id: 'puppet var', name: 'user_group', value: 'hadoop'});
        } else {
          App.router.get('mainAdminSecurityController').setSecurityStatus();
          securityUsers = App.router.get('mainAdminSecurityController').get('serviceUsers');
        }
      }
      var isHbaseInstalled = App.Service.find().findProperty('serviceName', 'HBASE');
      var generalConfigs = configs.filterProperty('serviceName', 'GENERAL');
      var hdfsConfigs = configs.filterProperty('serviceName', 'HDFS');
      var realm = generalConfigs.findProperty('name', 'kerberos_domain').value;
      var smokeUserId = securityUsers.findProperty('name', 'smokeuser').value;
      var hdfsUserId = securityUsers.findProperty('name', 'hdfs_user').value;
      var hbaseUserId = securityUsers.findProperty('name', 'hbase_user').value;
      var mapredUserId = securityUsers.findProperty('name', 'mapred_user').value;
      var hiveUserId = securityUsers.findProperty('name', 'hive_user').value;
      var zkUserId = securityUsers.findProperty('name', 'zk_user').value;
      var oozieUserId = securityUsers.findProperty('name', 'oozie_user').value;
      var nagiosUserId = securityUsers.findProperty('name', 'nagios_user').value;
      var hadoopGroupId = securityUsers.findProperty('name', 'user_group').value;

      var smokeUser = smokeUserId + '@' + realm;
      var hdfsUser = hdfsUserId + '@' + realm;
      var hbaseUser = hbaseUserId + '@' + realm;
      var smokeUserKeytabPath = generalConfigs.findProperty('name', 'smokeuser_keytab').value;
      var hdfsUserKeytabPath = generalConfigs.findProperty('name', 'hdfs_user_keytab').value;
      var hbaseUserKeytabPath = generalConfigs.findProperty('name', 'hbase_user_keytab').value;
      var hadoopHttpPrincipal = hdfsConfigs.findProperty('name', 'hadoop_http_principal_name');
      var hadoopHttpKeytabPath = hdfsConfigs.findProperty('name', 'hadoop_http_keytab').value;
      var componentToOwnerMap = {
        'NAMENODE': hdfsUserId,
        'SECONDARY_NAMENODE': hdfsUserId,
        'DATANODE': hdfsUserId,
        'TASKTRACKER': mapredUserId,
        'JOBTRACKER': mapredUserId,
        'ZOOKEEPER_SERVER': zkUserId,
        'HIVE_SERVER': hiveUserId,
        'OOZIE_SERVER': oozieUserId,
        'NAGIOS_SERVER': nagiosUserId,
        'HBASE_MASTER': hbaseUserId,
        'HBASE_REGIONSERVER': hbaseUserId
      };

      var addedPrincipalsHost = {}; //Keys = host_principal, Value = 'true'

      hosts.forEach(function (host) {
        result.push({
          host: host.get('hostName'),
          component: Em.I18n.t('admin.addSecurity.user.smokeUser'),
          principal: smokeUser,
          keytabFile: stringUtils.getFileFromPath(smokeUserKeytabPath),
          keytab: smokeUserKeytabPath,
          owner: smokeUserId,
          group: hadoopGroupId,
          acl: '440'
        });
        result.push({
          host: host.get('hostName'),
          component: Em.I18n.t('admin.addSecurity.user.hdfsUser'),
          principal: hdfsUser,
          keytabFile: stringUtils.getFileFromPath(hdfsUserKeytabPath),
          keytab: hdfsUserKeytabPath,
          owner: hdfsUserId,
          group: hadoopGroupId,
          acl: '440'
        });
        if (isHbaseInstalled) {
          result.push({
            host: host.get('hostName'),
            component: Em.I18n.t('admin.addSecurity.user.hbaseUser'),
            principal: hbaseUser,
            keytabFile: stringUtils.getFileFromPath(hbaseUserKeytabPath),
            keytab: hbaseUserKeytabPath,
            owner: hbaseUserId,
            group: hadoopGroupId,
            acl: '440'
          });
        }
        if(host.get('hostComponents').someProperty('componentName', 'NAMENODE') ||
          host.get('hostComponents').someProperty('componentName', 'SECONDARY_NAMENODE')){
          result.push({
            host: host.get('hostName'),
            component: Em.I18n.t('admin.addSecurity.hdfs.user.httpUser'),
            principal: hadoopHttpPrincipal.value.replace('_HOST', host.get('hostName').toLowerCase()) + hadoopHttpPrincipal.unit,
            keytabFile: stringUtils.getFileFromPath(hadoopHttpKeytabPath),
            keytab: hadoopHttpKeytabPath,
            owner: 'root',
            group: hadoopGroupId,
            acl: '440'
          });
        }
        if (host.get('hostComponents').someProperty('componentName', 'WEBHCAT_SERVER')) {
          var webHcatConfigs = configs.filterProperty('serviceName', 'WEBHCAT');
          var webHCatHttpPrincipal = webHcatConfigs.findProperty('name', 'webHCat_http_principal_name');
          var webHCatHttpKeytabPath = webHcatConfigs.findProperty('name', 'webhcat_http_keytab').value;
          result.push({
            host: host.get('hostName'),
            component: Em.I18n.t('admin.addSecurity.webhcat.user.httpUser'),
            principal: webHCatHttpPrincipal.value.replace('_HOST', host.get('hostName').toLowerCase()) + webHCatHttpPrincipal.unit,
            keytabFile: stringUtils.getFileFromPath(webHCatHttpKeytabPath),
            keytab: webHCatHttpKeytabPath,
            owner: 'root',
            group: hadoopGroupId,
            acl: '440'
          });
        }
        if (host.get('hostComponents').someProperty('componentName', 'OOZIE_SERVER')) {
          var oozieConfigs = configs.filterProperty('serviceName', 'OOZIE');
          var oozieHttpPrincipal = oozieConfigs.findProperty('name', 'oozie_http_principal_name');
          var oozieHttpKeytabPath = oozieConfigs.findProperty('name', 'oozie_http_keytab').value;
          result.push({
            host: host.get('hostName'),
            component: Em.I18n.t('admin.addSecurity.oozie.user.httpUser'),
            principal: oozieHttpPrincipal.value.replace('_HOST', host.get('hostName').toLowerCase()) + oozieHttpPrincipal.unit,
            keytabFile: stringUtils.getFileFromPath(oozieHttpKeytabPath),
            keytab: oozieHttpKeytabPath,
            owner: 'root',
            group: hadoopGroupId,
            acl: '440'
          });
        }
        host.get('hostComponents').forEach(function(hostComponent){
          if(componentsToDisplay.contains(hostComponent.get('componentName'))){
            var serviceConfigs = configs.filterProperty('serviceName', hostComponent.get('service.serviceName'));
            var principal, keytab;
            serviceConfigs.forEach(function (config) {
              if (config.component && config.component === hostComponent.get('componentName')) {
                if (config.name.endsWith('_principal_name')) {
                  principal = config.value.replace('_HOST', host.get('hostName').toLowerCase()) + config.unit;
                } else if (config.name.endsWith('_keytab') || config.name.endsWith('_keytab_path')) {
                  keytab = config.value;
                }
              } else if (config.components && config.components.contains(hostComponent.get('componentName'))) {
                if (config.name.endsWith('_principal_name')) {
                  principal = config.value.replace('_HOST', host.get('hostName').toLowerCase()) + config.unit;
                } else if (config.name.endsWith('_keytab') || config.name.endsWith('_keytab_path')) {
                  keytab = config.value;
                }
              }
            });
            var displayName = this.changeDisplayName(hostComponent.get('displayName'));
            var key = host.get('hostName') + "--" + principal;
            if (!addedPrincipalsHost[key]) {
              var owner = componentToOwnerMap[hostComponent.get('componentName')];
              if(!owner){
                owner = '';
              }
              result.push({
                host: host.get('hostName'),
                component: displayName,
                principal: principal,
                keytabFile: stringUtils.getFileFromPath(keytab),
                keytab: keytab,
                owner: owner,
                group: hadoopGroupId,
                acl: '400'
              });
              addedPrincipalsHost[key] = true;
            }
          }
        },this);
      },this);
      this.set('hostComponents', result);
    },

    changeDisplayName: function (name) {
      if (name === 'HiveServer2') {
        return 'Hive Metastore and HiveServer2';
      } else {
        return name;
      }
    },
  });
  
});
window.require.register("controllers/main/admin/security/add/step4", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  App.MainAdminSecurityAddStep4Controller = Em.Controller.extend({

    name: 'mainAdminSecurityAddStep4Controller',
    secureMapping: require('data/secure_mapping'),
    secureProperties: require('data/secure_properties').configProperties,
    stages: [],
    configs: [],
    noOfWaitingAjaxCalls: 0,
    secureServices: [],
    serviceConfigTags: [],
    globalProperties: [],
    totalSteps: 3,

    isSubmitDisabled: true,
    isBackBtnDisabled: function () {
      return !this.get('stages').someProperty('isError', true);
    }.property('stages.@each.isCompleted'),

    isOozieSelected: function () {
      return this.get('content.services').someProperty('serviceName', 'OOZIE');
    }.property('content.services'),

    isHiveSelected: function () {
      return this.get('content.services').someProperty('serviceName', 'HIVE');
    }.property('content.services'),

    isNagiosSelected: function () {
      return this.get('content.services').someProperty('serviceName', 'NAGIOS');
    }.property('content.services'),

    isZkSelected: function () {
      return this.get('content.services').someProperty('serviceName', 'ZOOKEEPER');
    }.property('content.services'),

    isWebHcatSelected: function () {
      var installedServices = App.Service.find().mapProperty('serviceName');
      return installedServices.contains('WEBHCAT');
    },

    serviceUsersBinding: 'App.router.mainAdminSecurityController.serviceUsers',
    hasHostPopup: true,
    services: [],
    serviceTimestamp: null,

    isSecurityApplied: function () {
      return this.get('stages').someProperty('stage', 'stage3') && this.get('stages').findProperty('stage', 'stage3').get('isSuccess');
    }.property('stages.@each.isCompleted'),

    clearStep: function () {
      this.get('stages').clear();
      this.set('isSubmitDisabled', true);
      this.set('isBackBtnDisabled', true);
      this.get('serviceConfigTags').clear();
    },

    retry: function () {
      var failedStage = this.get('stages').findProperty('isError', true);
      if (failedStage) {
        failedStage.set('isStarted', false);
        failedStage.set('isError', false);
        this.startStage(failedStage);
      }
    },

    loadStep: function () {
      this.set('secureMapping', require('data/secure_mapping').slice(0));
      this.clearStep();
      var stages = App.db.getSecurityDeployStages();
      this.prepareSecureConfigs();
      if (stages && stages.length > 0) {
        stages.forEach(function (_stage, index) {
          stages[index] = App.Poll.create(_stage);
        }, this);
        if (stages.someProperty('isError', true)) {
          this.get('stages').pushObjects(stages);
          this.addObserver('stages.@each.isSuccess', this.onCompleteStage);
          return;
        } else if (stages.filterProperty('isStarted', true).someProperty('isCompleted', false)) {
          var runningStage = stages.filterProperty('isStarted', true).findProperty('isCompleted', false);
          runningStage.set('isStarted', false);
          this.get('stages').pushObjects(stages);
        } else {
          this.get('stages').pushObjects(stages);
        }
      } else {
        this.loadStages();
        this.addInfoToStages();
        var runningOperations = App.router.get('backgroundOperationsController.services').filterProperty('isRunning');
        var stopAllOperation = runningOperations.findProperty('name', 'Stop All Services');
        var stopStage = this.get('stages').findProperty('name', 'STOP_SERVICES');
        if (stopStage.get('name') === 'STOP_SERVICES' && stopAllOperation) {
          stopStage.set('requestId', stopAllOperation.get('id'));
        }
      }
      this.addObserver('stages.@each.isSuccess', this.onCompleteStage);
      this.moveToNextStage();
    },

    enableSubmit: function () {
      var addSecurityController = App.router.get('addSecurityController');
      if (this.get('stages').someProperty('isError', true) || this.get('stages').everyProperty('isSuccess', true)) {
        this.set('isSubmitDisabled', false);
        if (this.get('stages').someProperty('isError', true)) {
          addSecurityController.setStepsEnable();
        }
      } else {
        this.set('isSubmitDisabled', true);
        addSecurityController.setLowerStepsDisable(4);
      }
    }.observes('stages.@each.isCompleted'),

    updateServices: function () {
      this.services.clear();
      var services = this.get("services");
      this.get("stages").forEach(function (stage) {
        var newService = Ember.Object.create({
          name: stage.label,
          hosts: []
        });
        if (stage && stage.get("polledData")) {
          var hostNames = stage.get("polledData").mapProperty('Tasks.host_name').uniq();
          hostNames.forEach(function (name) {
            newService.hosts.push({
              name: name,
              publicName: name,
              logTasks: stage.polledData.filterProperty("Tasks.host_name", name)
            });
          });
          services.push(newService);
        }
      });
      this.set('serviceTimestamp', new Date().getTime());
    }.observes('stages.@each.polledData'),

    loadStages: function () {
      this.get('stages').pushObjects([
        App.Poll.create({stage: 'stage2', label: Em.I18n.translations['admin.addSecurity.apply.stage2'], isPolling: true, name: 'STOP_SERVICES'}),
        App.Poll.create({stage: 'stage3', label: Em.I18n.translations['admin.addSecurity.apply.stage3'], isPolling: false, name: 'APPLY_CONFIGURATIONS'}),
        App.Poll.create({stage: 'stage4', label: Em.I18n.translations['admin.addSecurity.apply.stage4'], isPolling: true, name: 'START_SERVICES'})
      ]);
    },

    startStage: function (currentStage) {
      if (this.get('stages').length === this.totalSteps) {
        if (!currentStage) {
          var startedStages = this.get('stages').filterProperty('isStarted', true);
          currentStage = startedStages.findProperty('isCompleted', false);
        }
        if (currentStage && currentStage.get('isPolling') === true) {
          currentStage.set('isStarted', true);
          currentStage.start();
        } else if (currentStage && currentStage.get('stage') === 'stage3') {
          currentStage.set('isStarted', true);
          if (App.testMode) {
            currentStage.set('isError', false);
            currentStage.set('isSuccess', true);
          } else {
            this.loadClusterConfigs();
          }
        }
      }
    },

    onCompleteStage: function () {
      if (this.get('stages').length === this.totalSteps) {
        var index = this.get('stages').filterProperty('isSuccess', true).length;
        if (index > 0) {
          var lastCompletedStageResult = this.get('stages').objectAt(index - 1).get('isSuccess');
          if (lastCompletedStageResult) {
            var nextStage = this.get('stages').objectAt(index);
            this.moveToNextStage(nextStage);
          }
        }
      }
    },

    moveToNextStage: function (nextStage) {
      if (!nextStage) {
        nextStage = this.get('stages').findProperty('isStarted', false);
      }
      if (nextStage) {
        this.startStage(nextStage);
      }
    },

    addInfoToStages: function () {
      this.addInfoToStage2();
      this.addInfoToStage4();
    },

    addInfoToStage1: function () {
      var stage1 = this.get('stages').findProperty('stage', 'stage1');
      if (App.testMode) {
        stage1.set('isSuccess', true);
        stage1.set('isStarted', true);
        stage1.set('isCompleted', true);
      }
    },

    addInfoToStage2: function () {
      var stage2 = this.get('stages').findProperty('stage', 'stage2');
      var url = (App.testMode) ? '/data/wizard/deploy/2_hosts/poll_1.json' : App.apiPrefix + '/clusters/' + App.router.getClusterName() + '/services';
      var data = '{"RequestInfo": {"context" :"' + Em.I18n.t('requestInfo.stopAllServices') + '"}, "Body": {"ServiceInfo": {"state": "INSTALLED"}}}';
      stage2.set('url', url);
      stage2.set('data', data);
    },

    addInfoToStage4: function () {
      var stage4 = this.get('stages').findProperty('stage', 'stage4');
      var url = (App.testMode) ? '/data/wizard/deploy/2_hosts/poll_1.json' : App.apiPrefix + '/clusters/' + App.router.getClusterName() + '/services?params/run_smoke_test=true';
      var data = '{"RequestInfo": {"context": "' + Em.I18n.t('requestInfo.startAllServices') + '"}, "Body": {"ServiceInfo": {"state": "STARTED"}}}';
      stage4.set('url', url);
      stage4.set('data', data);
    },

    loadUiSideConfigs: function () {
      var uiConfig = [];
      var configs = this.get('secureMapping').filterProperty('foreignKey', null);
      configs.forEach(function (_config) {
        var value = _config.value;
        if (_config.hasOwnProperty('dependedServiceName')) {
          value = this.checkServiceForConfigValue(value, _config.dependedServiceName);
        }
        value = this.getGlobConfigValue(_config.templateName, value, _config.name);
        uiConfig.pushObject({
          "id": "site property",
          "name": _config.name,
          "value": value,
          "filename": _config.filename
        });
      }, this);
      var dependentConfig = this.get('secureMapping').filterProperty('foreignKey');
      dependentConfig.forEach(function (_config) {
        if (App.Service.find().mapProperty('serviceName').contains(_config.serviceName)) {
          this.setConfigValue(uiConfig, _config);
          uiConfig.pushObject({
            "id": "site property",
            "name": _config._name || _config.name,
            "value": _config.value,
            "filename": _config.filename
          });
        }
      }, this);
      return uiConfig;
    },


    checkServiceForConfigValue: function (value, serviceNames) {
      serviceNames.forEach(function (_serviceName) {
        if (!App.Service.find().mapProperty('serviceName').contains(_serviceName.name)) {
          value = value.replace(_serviceName.replace, '');
        }
      }, this);

      return value;
    },


    /**
     * Set all site property that are derived from other puppet-variable
     */

    getGlobConfigValue: function (templateName, expression, name) {
      var express = expression.match(/<(.*?)>/g);
      var value = expression;
      if (express == null) {
        return expression;
      }
      express.forEach(function (_express) {
        //console.log("The value of template is: " + _express);
        var index = parseInt(_express.match(/\[([\d]*)(?=\])/)[1]);
        var globValue = this.get('globalProperties').findProperty('name', templateName[index]);
        if (globValue) {
          console.log('The template value of templateName ' + '[' + index + ']' + ': ' + templateName[index] + ' is: ' + globValue);
          if (value !== null) {   // if the property depends on more than one template name like <templateName[0]>/<templateName[1]> then don't proceed to the next if the prior is null or not found in the global configs
            value = value.replace(_express, globValue.value);
          }
        } else {
          /*
           console.log("ERROR: The variable name is: " + templateName[index]);
           console.log("ERROR: mapped config from secureMapping file has no corresponding variable in " +
           "content.serviceConfigProperties. Two possible reasons for the error could be: 1) The service is not selected. " +
           "and/OR 2) The service_config metadata file has no corresponding global var for the site property variable");
           */
          value = null;
        }
      }, this);
      return value;
    },

    /**
     * Set all site property that are derived from other site-properties
     */
    setConfigValue: function (uiConfig, config) {
      if (config.value == null) {
        return;
      }
      var fkValue = config.name.match(/<(foreignKey.*?)>/g);
      if (fkValue) {
        fkValue.forEach(function (_fkValue) {
          var index = parseInt(_fkValue.match(/\[([\d]*)(?=\])/)[1]);
          var globalValue;
          if (uiConfig.someProperty('name', config.foreignKey[index])) {
            globalValue = uiConfig.findProperty('name', config.foreignKey[index]).value;
            config._name = config.name.replace(_fkValue, globalValue);
          } else if (this.get('globalProperties').someProperty('name', config.foreignKey[index])) {
            globalValue = this.get('globalProperties').findProperty('name', config.foreignKey[index]).value;
            config._name = config.name.replace(_fkValue, globalValue);
          }
        }, this);
      }
      //For properties in the configMapping file having foreignKey and templateName properties.

      var templateValue = config.value.match(/<(templateName.*?)>/g);
      if (templateValue) {
        templateValue.forEach(function (_value) {
          var index = parseInt(_value.match(/\[([\d]*)(?=\])/)[1]);
          var globValue = this.get('globalProperties').findProperty('name', config.templateName[index]);
          if (globValue) {
            config.value = config.value.replace(_value, globValue.value);
          } else {
            config.value = null;
          }
        }, this);
      }
    },

    prepareSecureConfigs: function () {
      this.loadGlobals();
      var storedConfigs = this.get('content.serviceConfigProperties').filterProperty('id', 'site property');
      var uiConfigs = this.loadUiSideConfigs();
      this.set('configs', storedConfigs.concat(uiConfigs));
    },

    loadGlobals: function () {
      var globals = this.get('content.serviceConfigProperties').filterProperty('id', 'puppet var');
      this.set('globalProperties', globals);
      this.loadStaticGlobal(); //Hack for properties which are declared in config_properties.js and not able to retrieve values declared in secure_properties.js
      this.loadUsersToGlobal();
      this.loadHostNamesToGlobal();
      this.loadPrimaryNamesToGlobals();
    },

    loadUsersToGlobal: function () {
      if (!this.get('serviceUsers').length) {
        this.loadUsersFromServer();
      }
      App.router.get('mainAdminSecurityController.serviceUsers').forEach(function (_user) {
        this.get('globalProperties').pushObject(_user);
      }, this);
    },

    loadHostNamesToGlobal: function () {
      var oozieHostComponent = App.Service.find('OOZIE').get('hostComponents').findProperty('componentName', 'OOZIE_SERVER');
      if (this.get('isOozieSelected') && oozieHostComponent) {
        var oozieHostName = oozieHostComponent.get('host.hostName');
        this.get('globalProperties').pushObject({
          id: 'puppet var',
          name: 'oozieserver_host',
          value: oozieHostName
        });
      }
      var hiveHostComponent = App.Service.find('HIVE').get('hostComponents').findProperty('componentName', 'HIVE_METASTORE');
      if (this.get('isHiveSelected') && hiveHostComponent) {
        var hiveHostName = hiveHostComponent.get('host.hostName');
        this.get('globalProperties').pushObject({
          id: 'puppet var',
          name: 'hivemetastore_host',
          value: hiveHostName
        });
      }
      var webHcatComponent = App.Service.find('WEBHCAT').get('hostComponents').findProperty('componentName', 'WEBHCAT_SERVER');
      if (this.isWebHcatSelected() && webHcatComponent) {
        var webHcatHostName = webHcatComponent.get('host.hostName');
        this.get('globalProperties').pushObject({
          id: 'puppet var',
          name: 'webhcat_server',
          value: webHcatHostName
        });
      }
    },

    loadStaticGlobal: function () {
      var globalProperties = this.get('globalProperties');
      this.get('globalProperties').forEach(function (_property) {
        switch (_property.name) {
          case 'security_enabled':
            _property.value = 'true';
            break;
          case 'dfs_datanode_address':
            _property.value = '1019';
            break;
          case 'dfs_datanode_http_address':
            _property.value = '1022';
            break;
        }
      }, this);
    },

    loadPrimaryNamesToGlobals: function () {
      var principalProperties = this.getPrincipalNames();
      principalProperties.forEach(function (_principalProperty) {
        var name = _principalProperty.name.replace('principal', 'primary');
        var value = _principalProperty.value.split('/')[0];
        this.get('globalProperties').pushObject({name: name, value: value});
      }, this);
    },

    getPrincipalNames: function () {
      var principalNames = [];
      var allPrincipalNames = [];
      this.get('globalProperties').forEach(function (_globalProperty) {
        if (/principal_name?$/.test(_globalProperty.name)) {
          principalNames.pushObject(_globalProperty);
        }
      }, this);
      this.get('secureProperties').forEach(function (_secureProperty) {
        if (/principal_name?$/.test(_secureProperty.name)) {
          var principalName = principalNames.findProperty('name', _secureProperty.name);
          if (!principalName) {
            _secureProperty.value = _secureProperty.defaultValue;
            principalNames.pushObject(_secureProperty);
          }
        }
      }, this);
      return principalNames;
    },

    loadUsersFromServer: function () {
      if (App.testMode) {
        var serviceUsers = this.get('serviceUsers');
        serviceUsers.pushObject({id: 'puppet var', name: 'hdfs_user', value: 'hdfs'});
        serviceUsers.pushObject({id: 'puppet var', name: 'mapred_user', value: 'mapred'});
        serviceUsers.pushObject({id: 'puppet var', name: 'hbase_user', value: 'hbase'});
        serviceUsers.pushObject({id: 'puppet var', name: 'hive_user', value: 'hive'});
      } else {
        App.router.get('mainAdminSecurityController').setSecurityStatus();
      }
    },


    loadClusterConfigs: function () {
      var self = this;
      var url = App.apiPrefix + '/clusters/' + App.router.getClusterName();

      App.ajax.send({
        name: 'admin.security.add.cluster_configs',
        sender: this,
        success: 'loadClusterConfigsSuccessCallback',
        error: 'loadClusterConfigsErrorCallback'
      });
    },

    loadClusterConfigsSuccessCallback: function (data) {
      var self = this;
      //prepare tags to fetch all configuration for a service
      this.get('content.services').forEach(function (_secureService) {
        self.setServiceTagNames(_secureService, data.Clusters.desired_configs);
      });
      this.getAllConfigurations();
    },

    loadClusterConfigsErrorCallback: function (request, ajaxOptions, error) {
      var stage3 = this.get('stages').findProperty('stage', 'stage3');
      if (stage3) {
        stage3.set('isSuccess', false);
        stage3.set('isError', true);
      }
      console.log("TRACE: error code status is: " + request.status);
    },

    /**
     * set tagnames for configuration of the *-site.xml
     */
    setServiceTagNames: function (secureService, configs) {
      //var serviceConfigTags = this.get('serviceConfigTags');
      for (var index in configs) {
        if (secureService.sites && secureService.sites.contains(index)) {
          var serviceConfigObj = {
            siteName: index,
            tagName: configs[index].tag,
            newTagName: null,
            configs: {}
          };
          console.log("The value of serviceConfigTags[index]: " + configs[index]);
          this.get('serviceConfigTags').pushObject(serviceConfigObj);
        }
      }
      return serviceConfigObj;
    },

    applyConfigurationsToCluster: function () {
      this.set('noOfWaitingAjaxCalls', this.get('serviceConfigTags').length);
      this.get('serviceConfigTags').forEach(function (_serviceConfig) {
        this.applyConfigurationToCluster({type: _serviceConfig.siteName, tag: _serviceConfig.newTagName, properties: _serviceConfig.configs});
      }, this);
    },

    applyConfigurationToCluster: function (data) {
      var clusterData = {
        Clusters: {
          desired_config: data
        }
      };
      App.ajax.send({
        name: 'admin.security.apply_configuration',
        sender: this,
        data: {
          clusterData: clusterData
        },
        success: 'applyConfigurationToClusterSuccessCallback',
        error: 'applyConfigurationToClusterErrorCallback'
      });
    },

    applyConfigurationToClusterSuccessCallback: function (data) {
      this.set('noOfWaitingAjaxCalls', this.get('noOfWaitingAjaxCalls') - 1);
      if (this.get('noOfWaitingAjaxCalls') == 0) {
        var currentStage = this.get('stages').findProperty('stage', 'stage3');
        currentStage.set('isSuccess', true);
        currentStage.set('isError', false);
      }
    },

    applyConfigurationToClusterErrorCallback: function (request, ajaxOptions, error) {
      var stage3 = this.get('stages').findProperty('stage', 'stage3');
      if (stage3) {
        stage3.set('isSuccess', false);
        stage3.set('isError', true);
      }
    },

    /**
     * gets site config properties from server and sets it for every configuration
     * @param serviceConfigTags
     */

    getAllConfigurations: function () {
      var urlParams = [];
      this.get('serviceConfigTags').forEach(function (_tag) {
        urlParams.push('(type=' + _tag.siteName + '&tag=' + _tag.tagName + ')');
      }, this);
      if (urlParams.length > 0) {
        App.ajax.send({
          name: 'admin.security.all_configurations',
          sender: this,
          data: {
            urlParams: urlParams.join('|')
          },
          success: 'getAllConfigurationsSuccessCallback',
          error: 'getAllConfigurationsErrorCallback'
        });
      }
    },

    getAllConfigurationsSuccessCallback: function (data) {
      console.log("TRACE: In success function for the GET getServiceConfigsFromServer call");
      var stage3 = this.get('stages').findProperty('stage', 'stage3');
      this.get('serviceConfigTags').forEach(function (_tag) {
        if (!data.items.someProperty('type', _tag.siteName)) {
          console.log("Error: Metadata for secure services (secure_configs.js) is having config tags that are not being retrieved from server");
          if (stage3) {
            stage3.set('isSuccess', false);
            stage3.set('isError', true);
          }
        }
        _tag.configs = data.items.findProperty('type', _tag.siteName).properties;
      }, this);
      if (this.addSecureConfigs()) {
        this.applyConfigurationsToCluster();
      }
    },

    getAllConfigurationsErrorCallback: function (request, ajaxOptions, error) {
      var stage3 = this.get('stages').findProperty('stage', 'stage3');
      if (stage3) {
        stage3.set('isSuccess', false);
        stage3.set('isError', true);
      }
      console.log("TRACE: In error function for the getServiceConfigsFromServer call");
      console.log("TRACE: error code status is: " + request.status);
    },

    addSecureConfigs: function () {
      try {
        this.get('serviceConfigTags').forEach(function (_serviceConfigTags) {
          _serviceConfigTags.newTagName = 'version' + (new Date).getTime();
          if (_serviceConfigTags.siteName === 'global') {
            var realmName = this.get('globalProperties').findProperty('name', 'kerberos_domain');
            if (this.get('isNagiosSelected')) {
              var nagiosPrincipalName = this.get('globalProperties').findProperty('name', 'nagios_principal_name');
              nagiosPrincipalName.value = nagiosPrincipalName.value + '@' + realmName.value;
            }
            if (this.get('isZkSelected')) {
              var zkPrincipalName = this.get('globalProperties').findProperty('name', 'zookeeper_principal_name');
              zkPrincipalName.value = zkPrincipalName.value + '@' + realmName.value;
            }
            this.get('globalProperties').forEach(function (_globalProperty) {
              if (!/_hosts?$/.test(_globalProperty.name)) {
                _serviceConfigTags.configs[_globalProperty.name] = _globalProperty.value;
              }
            }, this);
          }
          else {
            this.get('configs').filterProperty('id', 'site property').filterProperty('filename', _serviceConfigTags.siteName + '.xml').forEach(function (_config) {
              _serviceConfigTags.configs[_config.name] = _config.value;
            }, this);
          }
        }, this);
      } catch (err) {
        var stage3 = this.get('stages').findProperty('stage', 'stage3');
        if (stage3) {
          stage3.set('isSuccess', false);
          stage3.set('isError', true);
        }
        if (err) {
          console.log("Error: Error occurred while applying secure configs to the server. Error message: " + err);
        }
        this.onJsError();
        return false;
      }
      return true;
    },

    onJsError: function () {
      App.ModalPopup.show({
        header: Em.I18n.t('common.error'),
        secondary: false,
        onPrimary: function () {
          this.hide();
        },
        bodyClass: Ember.View.extend({
          template: Ember.Handlebars.compile('<p>{{t admin.security.apply.configuration.error}}</p>')
        })
      });
    },

    saveStagesOnRequestId: function () {
      this.saveStages();
    }.observes('stages.@each.requestId'),

    saveStagesOnCompleted: function () {
      this.saveStages();
    }.observes('stages.@each.isCompleted'),

    saveStages: function () {
      var stages = [];
      if (this.get('stages').length === this.totalSteps) {
        this.get('stages').forEach(function (_stage) {
          var stage = {
            name: _stage.get('name'),
            stage: _stage.get('stage'),
            label: _stage.get('label'),
            isPolling: _stage.get('isPolling'),
            isStarted: _stage.get('isStarted'),
            requestId: _stage.get('requestId'),
            isSuccess: _stage.get('isSuccess'),
            isError: _stage.get('isError'),
            url: _stage.get('url'),
            polledData: _stage.get('polledData'),
            data: _stage.get('data')
          };
          stages.pushObject(stage);
        }, this);
        App.db.setSecurityDeployStages(stages);
        if (!App.testMode) {
          App.clusterStatus.setClusterStatus({
            clusterName: this.get('clusterName'),
            clusterState: 'ADD_SECURITY_STEP_4',
            wizardControllerName: App.router.get('addSecurityController.name'),
            localdb: App.db.data.AddSecurity
          });
        }
      }
    }
  });
});
window.require.register("controllers/main/admin/security/disable", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  App.MainAdminSecurityDisableController = Em.Controller.extend({

    name: 'mainAdminSecurityDisableController',
    secureMapping: require('data/secure_mapping'),
    configMapping: App.config.get('configMapping'),
    secureProperties: require('data/secure_properties').configProperties.slice(0),
    stages: [],
    configs: [],
    noOfWaitingAjaxCalls: 0,
    secureServices: [],
    serviceConfigTags: [],
    globalProperties: [],
    hasHostPopup: true,
    services: [],
    serviceTimestamp: null,
    isSubmitDisabled: true,
    totalSteps: 3,

    clearStep: function () {
      this.get('stages').clear();
      this.get('secureServices').clear();
      this.get('serviceConfigTags').clear();
    },

    retry: function () {
      var failedStage = this.get('stages').findProperty('isError', true);
      if (failedStage) {
        failedStage.set('isStarted', false);
        failedStage.set('isError', false);
        this.startStage(failedStage);
      }
    },

    loadStep: function () {
      this.clearStep();
      var stages = App.db.getSecurityDeployStages();
      if (stages && stages.length > 0) {
        stages.forEach(function (_stage, index) {
          stages[index] = App.Poll.create(_stage);
        }, this);
        if (stages.someProperty('isError', true)) {
          this.get('stages').pushObjects(stages);
          this.loadSecureServices();
          this.addObserver('stages.@each.isSuccess', this.onCompleteStage);
          return;
        } else if (stages.filterProperty('isStarted', true).someProperty('isCompleted', false)) {
          var runningStage = stages.filterProperty('isStarted', true).findProperty('isCompleted', false);
          runningStage.set('isStarted', false);
          this.get('stages').pushObjects(stages);
        } else {
          this.get('stages').pushObjects(stages);
        }
      } else {
        this.loadStages();
        this.addInfoToStages();
        var runningOperations = App.router.get('backgroundOperationsController.services').filterProperty('isRunning');
        var stopAllOperation = runningOperations.findProperty('name', 'Stop All Services');
        var stopStage = this.get('stages').findProperty('name', 'STOP_SERVICES');
        if (stopStage.get('name') === 'STOP_SERVICES' && stopAllOperation) {
          stopStage.set('requestId', stopAllOperation.get('id'));
        }
      }
      this.loadSecureServices();
      this.addObserver('stages.@each.isSuccess', this.onCompleteStage);
      this.moveToNextStage();
    },


    loadStages: function () {
      this.get('stages').pushObjects([
        App.Poll.create({stage: 'stage2', label: Em.I18n.translations['admin.addSecurity.apply.stage2'], isPolling: true, name: 'STOP_SERVICES'}),
        App.Poll.create({stage: 'stage3', label: Em.I18n.translations['admin.addSecurity.apply.stage3'], isPolling: false, name: 'APPLY_CONFIGURATIONS'}),
        App.Poll.create({stage: 'stage4', label: Em.I18n.translations['admin.addSecurity.apply.stage4'], isPolling: true, name: 'START_SERVICES'})
      ]);
    },

    enableSubmit: function () {
      if (this.get('stages').someProperty('isError', true) || this.get('stages').everyProperty('isSuccess', true)) {
        this.set('isSubmitDisabled', false);
      } else {
        this.set('isSubmitDisabled', true);
      }
    }.observes('stages.@each.isCompleted'),

    startStage: function (currentStage) {
      if (this.get('stages').length === this.totalSteps) {
        if (!currentStage) {
          var startedStages = this.get('stages').filterProperty('isStarted', true);
          currentStage = startedStages.findProperty('isCompleted', false);
        }
        if (currentStage && currentStage.get('isPolling') === true) {
          currentStage.set('isStarted', true);
          currentStage.start();
        } else if (currentStage && currentStage.get('stage') === 'stage3') {
          currentStage.set('isStarted', true);
          if (App.testMode) {
            currentStage.set('isError', false);
            currentStage.set('isSuccess', true);
          } else {
            this.loadClusterConfigs();
          }
        }
      }
    },

    onCompleteStage: function () {
      if (this.get('stages').length === this.totalSteps) {
        var index = this.get('stages').filterProperty('isSuccess', true).length;
        if (index > 0) {
          var lastCompletedStageResult = this.get('stages').objectAt(index - 1).get('isSuccess');
          if (lastCompletedStageResult) {
            var nextStage = this.get('stages').objectAt(index);
            this.moveToNextStage(nextStage);
          }
        }
      }
    },

    moveToNextStage: function (nextStage) {
      if (!nextStage) {
        nextStage = this.get('stages').findProperty('isStarted', false);
      }
      if (nextStage) {
        this.startStage(nextStage);
      }
    },

    updateServices: function () {
      this.services.clear();
      var services = this.get("services");
      this.get("stages").forEach(function (stage) {
        var newService = Ember.Object.create({
          name: stage.label,
          hosts: []
        });
        if (stage && stage.get("polledData")) {
          var hostNames = stage.get("polledData").mapProperty('Tasks.host_name').uniq();
          hostNames.forEach(function (name) {
            newService.hosts.push({
              name: name,
              publicName: name,
              logTasks: stage.polledData.filterProperty("Tasks.host_name", name)
            });
          });
          services.push(newService);
        }
      });
      this.set('serviceTimestamp', new Date().getTime());
    }.observes('stages.@each.polledData'),

    addInfoToStages: function () {
      this.addInfoToStage2();
      this.addInfoToStage4();
    },

    addInfoToStage1: function () {
      var stage1 = this.get('stages').findProperty('stage', 'stage1');
      if (App.testMode) {
        stage1.set('isSuccess', true);
        stage1.set('isStarted', true);
        stage1.set('isCompleted', true);
      }
    },

    addInfoToStage2: function () {
      var stage2 = this.get('stages').findProperty('stage', 'stage2');
      var url = (App.testMode) ? '/data/wizard/deploy/2_hosts/poll_1.json' : App.apiPrefix + '/clusters/' + App.router.getClusterName() + '/services';
      var data = '{"RequestInfo": {"context": "' + Em.I18n.t('requestInfo.stopAllServices') + '"}, "Body": {"ServiceInfo": {"state": "INSTALLED"}}}';
      stage2.set('url', url);
      stage2.set('data', data);
    },

    addInfoToStage4: function () {
      var stage4 = this.get('stages').findProperty('stage', 'stage4');
      var url = (App.testMode) ? '/data/wizard/deploy/2_hosts/poll_1.json' : App.apiPrefix + '/clusters/' + App.router.getClusterName() + '/services?params/run_smoke_test=true';
      var data = '{"RequestInfo": {"context": "' + Em.I18n.t('requestInfo.startAllServices') + '"}, "Body": {"ServiceInfo": {"state": "STARTED"}}}';
      stage4.set('url', url);
      stage4.set('data', data);
    },

    /**
     * set tagnames for configuration of the *-site.xml
     */
    setServiceTagNames: function (secureService, configs) {
      for (var index in configs) {
        if (secureService.sites && secureService.sites.contains(index)) {
          var serviceConfigObj = {
            siteName: index,
            tagName: configs[index].tag,
            newTagName: null,
            configs: {}
          };
          console.log("The value of serviceConfigTags[index]: " + configs[index]);
          this.get('serviceConfigTags').pushObject(serviceConfigObj);
        }
      }
      return serviceConfigObj;
    },

    loadClusterConfigs: function () {
      App.ajax.send({
        name: 'admin.security.cluster_configs',
        sender: this,
        success: 'loadClusterConfigsSuccessCallback',
        error: 'loadClusterConfigsErrorCallback'
      });
    },

    loadClusterConfigsSuccessCallback: function (jsonData) {
      //prepare tags to fetch all configuration for a service
      this.get('secureServices').forEach(function (_secureService) {
        this.setServiceTagNames(_secureService, jsonData.Clusters.desired_configs);
      }, this);
      this.getAllConfigurations();
    },

    loadClusterConfigsErrorCallback: function (request, ajaxOptions, error) {
      var stage3 = this.get('stages').findProperty('stage', 'stage3');
      if (stage3) {
        stage3.set('isSuccess', false);
        stage3.set('isError', true);
      }
      console.log("TRACE: error code status is: " + request.status);
    },

    getAllConfigurations: function () {
      var urlParams = [];
      this.get('serviceConfigTags').forEach(function (_tag) {
        urlParams.push('(type=' + _tag.siteName + '&tag=' + _tag.tagName + ')');
      }, this);
      if (urlParams.length > 0) {
        App.ajax.send({
          name: 'admin.security.all_configurations',
          sender: this,
          data: {
            urlParams: urlParams.join('|')
          },
          success: 'getAllConfigurationsSuccessCallback',
          error: 'getAllConfigurationsErrorCallback'
        });
      }
    },

    getAllConfigurationsSuccessCallback: function (data) {
      console.log("TRACE: In success function for the GET getServiceConfigsFromServer call");
      var stage3 = this.get('stages').findProperty('stage', 'stage3');
      this.get('serviceConfigTags').forEach(function (_tag) {
        if (!data.items.someProperty('type', _tag.siteName)) {
          console.log("Error: Metadata for secure services (secure_configs.js) is having config tags that are not being retrieved from server");
          if (stage3) {
            stage3.set('isSuccess', false);
            stage3.set('isError', true);
          }
        }
        _tag.configs = data.items.findProperty('type', _tag.siteName).properties;
      }, this);
      if (this.removeSecureConfigs()) {
        this.applyConfigurationsToCluster();
      }
    },

    getAllConfigurationsErrorCallback: function (request, ajaxOptions, error) {
      var stage3 = this.get('stages').findProperty('stage', 'stage3');
      if (stage3) {
        stage3.set('isSuccess', false);
        stage3.set('isError', true);
      }
      console.log("TRACE: In error function for the getServiceConfigsFromServer call");
      console.log("TRACE: error code status is: " + request.status);
    },


    loadSecureServices: function () {
      var secureServices = require('data/secure_configs');
      var installedServices = App.Service.find().mapProperty('serviceName');
      this.get('secureServices').pushObject(secureServices.findProperty('serviceName', 'GENERAL'));
      //General (only non service tab) tab is always displayed
      installedServices.forEach(function (_service) {
        var secureService = secureServices.findProperty('serviceName', _service);
        if (secureService) {
          this.get('secureServices').pushObject(secureService);
        }
      }, this);
    },

    applyConfigurationsToCluster: function () {
      this.set('noOfWaitingAjaxCalls', this.get('serviceConfigTags').length);
      this.get('serviceConfigTags').forEach(function (_serviceConfig) {
        this.applyConfigurationToCluster({type: _serviceConfig.siteName, tag: _serviceConfig.newTagName, properties: _serviceConfig.configs});
      }, this);
    },

    applyConfigurationToCluster: function (data) {
      var clusterData = {
        Clusters: {
          desired_config: data
        }
      };
      App.ajax.send({
        name: 'admin.security.apply_configuration',
        sender: this,
        data: {
          clusterData: clusterData
        },
        success: 'applyConfigurationToClusterSuccessCallback',
        error: 'applyConfigurationToClusterErrorCallback'
      });
    },

    applyConfigurationToClusterSuccessCallback: function (data) {
      this.set('noOfWaitingAjaxCalls', this.get('noOfWaitingAjaxCalls') - 1);
      if (this.get('noOfWaitingAjaxCalls') == 0) {
        var currentStage = this.get('stages').findProperty('stage', 'stage3');
        currentStage.set('isSuccess', true);
        currentStage.set('isError', false);
      }
    },

    applyConfigurationToClusterErrorCallback: function (request, ajaxOptions, error) {
      var stage3 = this.get('stages').findProperty('stage', 'stage3');
      if (stage3) {
        stage3.set('isSuccess', false);
        stage3.set('isError', true);
      }
    },


    removeSecureConfigs: function () {
      try {
        this.get('serviceConfigTags').forEach(function (_serviceConfigTags, index) {
          _serviceConfigTags.newTagName = 'version' + (new Date).getTime();
          if (_serviceConfigTags.siteName === 'global') {
            this.get('secureProperties').forEach(function (_config) {
              if (_config.name in _serviceConfigTags.configs) {
                delete _serviceConfigTags.configs[_config.name];
              }
            }, this);
            _serviceConfigTags.configs.security_enabled = 'false';
            _serviceConfigTags.configs.dfs_datanode_address = '50010';
            _serviceConfigTags.configs.dfs_datanode_http_address = '50075';
          } else {
            this.get('secureMapping').filterProperty('filename', _serviceConfigTags.siteName + '.xml').forEach(function (_config) {
              var configName = _config.name;
              if (configName in _serviceConfigTags.configs) {
                switch (configName) {
                  case 'dfs.datanode.address':
                    _serviceConfigTags.configs[configName] = '0.0.0.0:50010';
                    break;
                  case 'dfs.datanode.http.address':
                    _serviceConfigTags.configs[configName] = '0.0.0.0:50075';
                    break;
                  case 'mapred.task.tracker.task-controller':
                    _serviceConfigTags.configs[configName] = 'org.apache.hadoop.mapred.DefaultTaskController';
                    break;
                  case 'hbase.security.authentication':
                    _serviceConfigTags.configs[configName] = 'simple';
                    break;
                  case 'hbase.rpc.engine':
                    _serviceConfigTags.configs[configName] = 'org.apache.hadoop.hbase.ipc.WritableRpcEngine';
                    break;
                  case 'hbase.security.authorization':
                    _serviceConfigTags.configs[configName] = 'false';
                    break;
                  case 'zookeeper.znode.parent':
                    _serviceConfigTags.configs[configName] = '/hbase-unsecure';
                    break;
                  default:
                    delete _serviceConfigTags.configs[configName];
                }
              }
              console.log("Not Deleted" + _config.name);
            }, this);
          }
        }, this);
      } catch (err) {
        var stage3 = this.get('stages').findProperty('stage', 'stage3');
        if (stage3) {
          stage3.set('isSuccess', false);
          stage3.set('isError', true);
        }
        if (err) {
          console.log("Error: Error occurred while applying secure configs to the server. Error message: " + err);
        }
        return false;
      }
      return true;
    },

    saveStagesOnRequestId: function () {
      this.saveStages();
    }.observes('stages.@each.requestId'),

    saveStagesOnCompleted: function () {
      var nonPollingStages = this.get('stages').filterProperty('isPolling', false).someProperty('isCompleted', true);
      if (nonPollingStages) {
        this.saveStages();
      }
    }.observes('stages.@each.isCompleted'),

    saveStages: function () {
      var stages = [];
      if (this.get('stages').length === this.totalSteps) {
        this.get('stages').forEach(function (_stage) {
          var stage = {
            name: _stage.get('name'),
            stage: _stage.get('stage'),
            label: _stage.get('label'),
            isPolling: _stage.get('isPolling'),
            isStarted: _stage.get('isStarted'),
            requestId: _stage.get('requestId'),
            isSuccess: _stage.get('isSuccess'),
            isError: _stage.get('isError'),
            url: _stage.get('url'),
            polledData: _stage.get('polledData'),
            data: _stage.get('data')
          };
          stages.pushObject(stage);
        }, this);
        App.db.setSecurityDeployStages(stages);
        if (!App.testMode) {
          App.clusterStatus.setClusterStatus({
            clusterName: this.get('clusterName'),
            clusterState: 'DISABLE_SECURITY',
            wizardControllerName: this.get('name'),
            localdb: App.db.data.AddSecurity
          });
        }
      }
    }

  });
  
});
window.require.register("controllers/main/admin/stack_upgrade_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.StackUpgradeController = App.WizardController.extend({
    name: 'stackUpgradeController',

    totalSteps: 3,

    /**
     * All wizards data will be stored in this variable
     *
     * cluster - cluster name
     * upgradeOptions - upgrade options
     */
    content: Em.Object.create({
      cluster: null,
      upgradeOptions: null,
      servicesInfo: function(){
        return App.router.get('mainAdminClusterController.services');
      }.property('App.router.mainAdminClusterController.services'),
      upgradeVersion: function(){
        return App.router.get('mainAdminClusterController.upgradeVersion');
      }.property('App.router.mainAdminClusterController.upgradeVersion'),
      controllerName: 'stackUpgradeController'
    }),

    /**
     * return new object extended from clusterStatusTemplate
     * @return Object
     */
    getCluster: function(){
      return jQuery.extend({}, this.get('clusterStatusTemplate'), {name: App.router.getClusterName()});
    },
    /**
     * return new object extended from upgradeOptionsTemplate
     * @return Object
     */
    getUpgradeOptions: function(){
      return jQuery.extend({}, this.get('upgradeOptionsTemplate'));
    },
    /**
     * Load data for all steps until <code>current step</code>
     */
    loadAllPriorSteps: function () {
      this.load('cluster');
      this.load('upgradeOptions');
    },
    upgradeOptionsTemplate:{
      localRepo: false
    },
    clear: function () {
      this.set('content', Ember.Object.create({
        servicesInfo: function(){
          return App.router.get('mainAdminClusterController.services');
        }.property('App.router.mainAdminClusterController.services'),
        upgradeVersion: function(){
          return App.router.get('mainAdminClusterController.upgradeVersion');
        }.property('App.router.mainAdminClusterController.upgradeVersion'),
        'controllerName': 'stackUpgradeController'
      }));
      this.set('currentStep', 0);
      this.clearStorageData();
    },
    clearStorageData: function(){
      App.db.setCluster(undefined);
      App.db.setUpgradeOptions(undefined);
    },
    /**
     * Finish upgrade
     */
    finish: function () {
      this.clear();
      this.setCurrentStep('1');
    }
  });
  
});
window.require.register("controllers/main/admin/user", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminUserController = Em.Controller.extend({
    name:'mainAdminUserController',

    /**
     * send request to the server to delete user if selected user is not current user
     * @param event
     */
    deleteRecord:function (event) {
      var self = this;
      if (event.context.get('userName') == App.get('router').getLoginName()) {
        App.ModalPopup.show({
          header:Em.I18n.t('admin.users.delete.yourself.header'),
          body:Em.I18n.t('admin.users.delete.yourself.message'),
          onPrimary:function (event) {
            this.hide();
          },
          secondary:false
        });

        return;
      }

      App.ModalPopup.show({
        header:Em.I18n.t('admin.users.delete.header').format(event.context.get('userName')),
        body:Em.I18n.t('question.sure').format(''),
        primary:Em.I18n.t('yes'),
        secondary:Em.I18n.t('no'),

        onPrimary:function () {
          self.sendCommandToServer('/users/' +  event.context.get("userName"), "DELETE" ,{},
            function (success) {

              if (!success) {
                return;
              }

              event.context.deleteRecord();

              try {
                App.store.commit()
              } catch (err) {

              }
            })
          this.hide();
        },
        onSecondary:function () {
          this.hide();
        }
      });
    },

    /**
     * send request to the server and call callback function with true if request was success or false if request was failed
     * @param url
     * @param method
     * @param postData
     * @param callback
     */
    sendCommandToServer : function(url, method, postData, callback){
      var url =  (App.testMode) ?
          '/data/wizard/deploy/poll_1.json' : //content is the same as ours
          App.apiPrefix + url;

      var method = App.testMode ? 'GET' : method;

      $.ajax({
        type: method,
        url: url,
        data: JSON.stringify(postData),
        dataType: 'json',
        timeout: App.timeout,
        success: function(data){
            callback(true, '');
        },

        error: function (request, ajaxOptions, error) {
          //do something
          var message = $.parseJSON(request.responseText).message;
          message = message.substr(message.indexOf(':') + 1); // Remove classname
          callback(false, message);
          console.log('error on change component host status')
        },

        statusCode: require('data/statusCodes')
      });
    }
  })
});
window.require.register("controllers/main/admin/user/create", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminUserCreateController = Em.Controller.extend({
    name:'mainAdminUserCreateController',
    content:false
  })
  
});
window.require.register("controllers/main/admin/user/edit", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminUserEditController = Em.Controller.extend({
    name:'mainAdminUserEditController',
    content:false
  })
});
window.require.register("controllers/main/apps/item_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAppsItemController = Em.Controller.extend({
    name:'mainAppsItemController',
    /**
     * Was set outside in App.MainAppsView.
     * It's instance of App.Run model
     */
    content: [],
    jobsLoaded:false,

    gettingJobs:function(){
      var currentId = this.get('content.id');
      if(this.get('content.loadAllJobs')){
        return;
      }
      var self = this;

      var url = App.testMode ? '/data/apps/jobs/'+ currentId +'.json' :
        App.apiPrefix + "/jobhistory/job?workflowId=" + currentId;

      var mapper = App.jobsMapper;
      mapper.set('controller', this);
      App.HttpClient.get(url, mapper,{
        complete:function(jqXHR, textStatus) {
          self.set('content.loadAllJobs', true);
        }
      });
    }.observes('content')

  })
  
});
window.require.register("controllers/main/apps_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var misc = require('utils/misc');
  var date = require('utils/date');

  App.MainAppsController = Em.ArrayController.extend({

    name:'mainAppsController',
    content: [],

    loaded : false,
    loading : false,

    /**
     * List of users.
     * Will be used for filtering in user column.
     * Go to App.MainAppsView.userFilterView for more information
     */
    users: function () {
      return this.get('content').mapProperty("userName").uniq().map(function(userName){
        return {
          name: userName,
          checked: false
        };
      });
    }.property('content.length'),

    loadRuns:function () {

      this.set('loading', true);
      var self = this;

      //var runsUrl = App.testMode ? "/data/apps/runs.json" : App.apiPrefix + "/jobhistory/workflow?orderBy=startTime&sortDir=DESC&limit=" + App.maxRunsForAppBrowser;
      var runsUrl = App.testMode ? "/data/apps/runs.json" : App.apiPrefix + this.get("runUrl");

      App.HttpClient.get(runsUrl, App.runsMapper, {
        complete:function (jqXHR, textStatus) {
          self.set('loading', false);
          self.set('loaded', true);
        }
      });
    },

    //Pagination Object

    paginationObject:{
      iTotalDisplayRecords :null,
      iTotalRecords:null,
      startIndex:null,
      endIndex:null
    },

    /*
     Set number of filtered jobs when switching to all jobs
     */
    iTotalDisplayRecordsObserver:function(){
      if(this.get("filterObject.allFilterActivated")){
        this.set("filterObject.allFilterActivated", false);
      }else{
        this.set("filterObject.filteredDisplayRecords",this.get("paginationObject.iTotalDisplayRecords"));
      }
    }.observes("paginationObject.iTotalDisplayRecords"),


    //Filter object

    filterObject : Ember.Object.create({
      sSearch_0:"",
      sSearch_1:"",
      sSearch_2:"",
      sSearch_3:"",
      minJobs:"",
      maxJobs:"",
      minInputBytes:"",
      maxInputBytes:"",
      minOutputBytes:"",
      maxOutputBytes:"",
      minDuration:"",
      maxDuration:"",
      minStartTime:"",
      maxStartTime:"",
      sSearch:"",
      iDisplayLength:"",
      iDisplayStart:"",
      iSortCol_0:"",
      sSortDir_0:"",

      allFilterActivated:false,
      filteredDisplayRecords:null,

      viewType:"all",
      viewTypeClickEvent:false,

      /**
       * Direct binding to job filter field
       */
      runType:"",
      onRunTypeChange:function(){
        if(this.runType == "MapReduce"){
          this.set("sSearch_2","mr");
        }else if(this.runType == "Hive"){
          this.set("sSearch_2","hive");
        }else if(this.runType == "Pig"){
          this.set("sSearch_2","pig");
        }else{
          this.set("sSearch_2","");
        }
      }.observes("runType"),

      /**
       * Direct binding to job filter field
       */
      jobs:"",
      onJobsChange:function(){
        var minMaxTmp = this.parseNumber(this.jobs);
        this.set("minJobs", minMaxTmp.min);
        this.set("maxJobs", minMaxTmp.max);
      }.observes("jobs"),

      /**
       * Direct binding to Input filter field
       */
      input:"",
      onInputChange:function(){
        var minMaxTmp = this.parseBandWidth(this.input);
        this.set("minInputBytes", minMaxTmp.min);
        this.set("maxInputBytes", minMaxTmp.max);
      }.observes("input"),

      /**
       * Direct binding to Output filter field
       */
      output:"",
      onOutputChange:function(){
        var minMaxTmp = this.parseBandWidth(this.output);
        this.set("minOutputBytes", minMaxTmp.min);
        this.set("maxOutputBytes", minMaxTmp.max);
      }.observes("output"),

      /**
       * Direct binding to Duration filter field
       */
      duration:"",
      onDurationChange:function(){
        var minMaxTmp = this.parseDuration(this.duration);
        this.set("minDuration", minMaxTmp.min);
        this.set("maxDuration", minMaxTmp.max);
      }.observes("duration"),

      /**
       * Direct binding to Run Date filter field
       */
      runDate:"",
      onRunDateChange:function(){
        var minMaxTmp = this.parseDate(this.runDate);
        this.set("minStartTime", minMaxTmp.min);
        this.set("maxStartTime", minMaxTmp.max);
      }.observes("runDate"),

      parseDuration:function(value){
        var tmp={
          min:"",
          max:""
        };

        var compareChar = isNaN(value.charAt(0)) ? value.charAt(0) : false;
        var compareScale = value.match(/s|m|h/);
        compareScale = compareScale ? compareScale[0] : "";
        var compareValue = compareChar ? parseFloat(value.substr(1, value.length)) : parseFloat(value.substr(0, value.length));
        if(isNaN(compareValue)){
          return tmp;
        }
        switch (compareScale) {
          case 'h':
          tmp.min = Math.ceil((parseFloat(compareValue)-0.0001)*1000*60*60);
          tmp.max = Math.floor((parseFloat(compareValue)+0.0001)*1000*60*60);
          break;
          case 'm':
          tmp.min = Math.ceil((parseFloat(compareValue)-0.001)*1000*60);
          tmp.max = Math.floor((parseFloat(compareValue)+0.001)*1000*60);
          break;
          case 's':
          tmp.min = Math.ceil((parseFloat(compareValue)-0.01)*1000);
          tmp.max = Math.floor((parseFloat(compareValue)+0.01)*1000);
          break;
          default:
            tmp.min = Math.ceil((parseFloat(compareValue)-0.01)*1000);
            tmp.max = Math.floor((parseFloat(compareValue)+0.01)*1000);
        }
        switch (compareChar) {
          case '<':
            tmp.min="";
            break;
          case '>':
            tmp.max="";
            break;
        }
        return tmp;
      },

      parseDate:function(value){
        var tmp={
          min:"",
          max:""
        };
        var nowTime = new Date().getTime();

        switch (value){
          case 'Any':
            break;
          case 'Past 1 Day':
            tmp.min= nowTime - 86400000;
            break;
          case 'Past 2 Days':
            tmp.min= nowTime - 172800000;
            break;
          case 'Past 7 Days':
            tmp.min= nowTime - 604800000;
            break;
          case 'Past 14 Days':
            tmp.min= nowTime - 1209600000;
            break;
          case 'Past 30 Days':
            tmp.min= nowTime - 2592000000;
            break;
          case 'Running Now':
            tmp.min= nowTime;
            break;
        }
        return tmp;
      },

      parseBandWidth:function(value){
        var tmp={
          min:"",
          max:""
        };

        var compareChar = isNaN(value.charAt(0)) ? value.charAt(0) : false;
        var compareScale = value.match(/kb|k|mb|m|gb|g/);
        compareScale = compareScale ? compareScale[0] : "";
        var compareValue = compareChar ? parseFloat(value.substr(1, value.length)) : parseFloat(value.substr(0, value.length));
        if(isNaN(compareValue)){
          return tmp;
        }
        switch (compareScale) {
          case 'g': case 'gb':
            tmp.min = Math.max(1073741824,Math.ceil((compareValue-0.005)*1073741824));
            tmp.max = Math.floor((compareValue+0.005)*1073741824);
            break;
          case 'm': case 'mb':
            tmp.min = Math.max(1048576,Math.ceil((compareValue-0.05)*1048576));
            tmp.max = Math.min(1073741823,Math.floor((compareValue+0.05)*1048576));
            break;
          case 'k': case 'kb':
            tmp.min = Math.max(1024,Math.ceil((compareValue-0.05)*1024));
            tmp.max = Math.min(1048575,Math.floor((compareValue+0.05)*1024));
            break;
          default:
            tmp.min = Math.max(1024,Math.ceil((compareValue-0.05)*1024));
            tmp.max = Math.min(1048575,Math.floor((compareValue+0.05)*1024));
        }
        switch (compareChar) {
          case '<':
            tmp.min="";
            break;
          case '>':
            tmp.max="";
            break;
        }
        return tmp;
      },
      parseNumber:function(value){
        var tmp={
          min:"",
          max:""
        };
        switch (value.charAt(0)) {
          case '<':
            tmp.max=value.substr(1);
            break;
          case '>':
            tmp.min=value.substr(1);
            break;
          case '=':
            tmp.min=value.substr(1);
            tmp.max=value.substr(1);
            break;
          default:
            tmp.min=value;
            tmp.max=value;
        }
        return tmp;
      },

      /**
       * Create link for server request
       * @return {String}
       */
      createAppLink:function(){
        var link = "/jobhistory/datatable?";


        var arr = [
          "sSearch_0", "sSearch_1", "sSearch_2", "sSearch_3", "minJobs",
          "maxJobs", "minInputBytes", "maxInputBytes", "minOutputBytes",
          "maxOutputBytes", "minDuration", "maxDuration", "minStartTime",
          "maxStartTime", "sSearch", "iDisplayLength", "iDisplayStart",
          "iSortCol_0", "sSortDir_0"
        ];

        var notFilterFields = ["iDisplayLength", "iDisplayStart", "iSortCol_0", "sSortDir_0"];

        var filtersUsed = false;

        for (var n=0; n<arr.length;n++) {
          if(this.get(arr[n])){
            link += arr[n] + "=" + this.get(arr[n]) + "&";
            if (!notFilterFields.contains(arr[n])) {
              filtersUsed = true;
            }
          }
        };

        link = link.slice(0,link.length-1);

        if(!this.get("viewTypeClickEvent")) {
          this.set('viewType', filtersUsed?'filtered':'all');
        }

        return link;
      }
    }),

    /**
     * reset all filters in table
     *
     */
    clearFilters: function () {
      var obj=this.get("filterObject");
      obj.set("sSearch","");
      obj.set("sSearch_0","");
      obj.set("sSearch_1","");
      obj.set("sSearch_2","");
      obj.set("sSearch_3","");
      obj.set("runType","Any");
      obj.set("jobs","");
      obj.set("input","");
      obj.set("output","");
      obj.set("duration","");
      obj.set("runDate","Any");
    },


    runUrl : "/jobhistory/datatable",
    runTimeout : null,

    valueObserver: function(){
      if(this.get('filterObject.iDisplayLength') > this.get('content.length')) {
        this.set('filterObject.iDisplayStart', 0);
      }
      var link = this.get('filterObject').createAppLink();

      if(this.get("filterObject.viewType") == "filtered"){
        this.set("runUrl", link);
      }else{
        this.set("runUrl", "/jobhistory/datatable?iDisplayStart=" + this.get('filterObject.iDisplayStart') + "&iDisplayLength=" + this.get('filterObject.iDisplayLength') +
           '&iSortCol_0=' + this.get('filterObject.iSortCol_0') + '&sSortDir_0=' + this.get('filterObject.sSortDir_0'));
      }

      var timeout = this.get('runTimeout');
      var self = this;

      clearTimeout(timeout);
      timeout = setTimeout(function(){
        console.log(self.get("runUrl"));
        self.loadRuns();
      }, 300);

      this.set('runTimeout', timeout);

    }.observes(
        'filterObject.sSearch_0',
        'filterObject.sSearch_1',
        'filterObject.sSearch_2',
        'filterObject.sSearch_3',
        'filterObject.minJobs',
        'filterObject.maxJobs',
        'filterObject.minInputBytes',
        'filterObject.maxInputBytes',
        'filterObject.minOutputBytes',
        'filterObject.maxOutputBytes',
        'filterObject.minDuration',
        'filterObject.maxDuration',
        'filterObject.minStartTime',
        'filterObject.maxStartTime',
        'filterObject.sSearch',
        'filterObject.iDisplayLength',
        'filterObject.iDisplayStart',
        'filterObject.iSortCol_0',
        'filterObject.sSortDir_0',
        'filterObject.viewType'
    ),

    serverData: "",
    summary: null,

    /**
     * Observer for summary data from server
     */
    summaryInfo: function(){
      var tmp;
      var summary = this.get('serverData');
      if(!summary){
        tmp = {
          'jobs': {
            'avg': '-',
            'min': '-',
            'max': '-'
          },
          'input': {
            'avg': '-',
            'min': '-',
            'max': '-'
          },
          'output': {
            'avg': '-',
            'min': '-',
            'max': '-'
          },
          'duration': {
            'avg': '-',
            'min': '-',
            'max': '-'
          },
          'times': {
            'oldest': '-',
            'youngest': '-'
          }
        };
      }else{
        tmp = {
          'jobs': {
            'avg': summary.jobs.avg.toFixed(2),
            'min': summary.jobs.min,
            'max': summary.jobs.max
          },
          'input': {
            'avg': misc.formatBandwidth(summary.input.avg),
            'min': misc.formatBandwidth(summary.input.min),
            'max': misc.formatBandwidth(summary.input.max)
          },
          'output': {
            'avg': misc.formatBandwidth(summary.output.avg),
            'min': misc.formatBandwidth(summary.output.min),
            'max': misc.formatBandwidth(summary.output.max)
          },
          'duration': {
            'avg': date.timingFormat(Math.round(summary.duration.avg)),
            'min': date.timingFormat(summary.duration.min),
            'max': date.timingFormat(summary.duration.max)
          },
          'times': {
            'oldest': new Date(summary.times.oldest).toDateString(),
            'youngest': new Date(summary.times.youngest).toDateString()
          }
        };
      }
      this.set("summary",tmp);
    }.observes('serverData'),


    columnsName: Ember.ArrayController.create({
      content: [
        { name: Em.I18n.t('apps.table.column.appId'), index: 0 },
        { name: Em.I18n.t('common.name'), index: 1 },
        { name: Em.I18n.t('common.type'), index: 2 },
        { name: Em.I18n.t('common.user'), index: 3 },
        { name: Em.I18n.t('apps.avgTable.jobs'), index: 4 },
        { name: Em.I18n.t('apps.avgTable.input'), index: 5 },
        { name: Em.I18n.t('apps.avgTable.output'), index: 6 },
        { name: Em.I18n.t('apps.avgTable.duration'), index: 7 },
        { name: Em.I18n.t('apps.table.column.runDate'), index: 8 }
      ]
    })


  })
  
});
window.require.register("controllers/main/charts", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainChartsController = Em.ArrayController.extend({
    name:'mainChartsController'
  })
});
window.require.register("controllers/main/charts/heatmap", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.MainChartsHeatmapController = Em.Controller.extend({
    name: 'mainChartsHeatmapController',
    cluster: function () {
      return App.Cluster.find().objectAt(0);
    }.property(''),
    allMetrics: function () {
      var metrics = [
        Em.Object.create({
          label: Em.I18n.t('charts.heatmap.category.host'),
          category: 'host',
          items: [
            App.MainChartHeatmapDiskSpaceUsedMetric.create(),
            App.MainChartHeatmapMemoryUsedMetric.create(),
            App.MainChartHeatmapCpuWaitIOMetric.create()
            /*, App.MainChartHeatmapProcessRunMetric.create()*/
          ]
        }),
        Em.Object.create({
          label: Em.I18n.t('charts.heatmap.category.hdfs'),
          category: 'hdfs',
          items: [
            App.MainChartHeatmapDFSBytesReadMetric.create(),
            App.MainChartHeatmapDFSBytesWrittenMetric.create(),
            App.MainChartHeatmapDFSGCTimeMillisMetric.create(),
            App.MainChartHeatmapDFSMemHeapUsedMetric.create()
          ]
        })
      ];

      if (App.MapReduceService.find().get('length')) {
        metrics.push(
          Em.Object.create({
            label: Em.I18n.t('charts.heatmap.category.mapreduce'),
            category: 'mapreduce',
            items: [
              App.MainChartHeatmapMapreduceMapsRunningMetric.create(),
              App.MainChartHeatmapMapreduceReducesRunningMetric.create(),
              App.MainChartHeatmapMapreduceGCTimeMillisMetric.create(),
              App.MainChartHeatmapMapreduceMemHeapUsedMetric.create()
            ]
          })
        );
      }

      if (App.HBaseService.find().get('length')) {
        metrics.push(
          Em.Object.create({
            label: Em.I18n.t('charts.heatmap.category.hbase'),
            category: 'hbase',
            items: [
              App.MainChartHeatmapHbaseReadReqCount.create(),
              App.MainChartHeatmapHbaseWriteReqCount.create(),
              App.MainChartHeatmapHbaseCompactionQueueSize.create(),
              App.MainChartHeatmapHbaseRegions.create(),
              App.MainChartHeatmapHbaseMemStoreSize.create()
            ]
          })
        );
      }
      return metrics;
    }.property(),

    selectedMetric: null,

    inputMaximum: '',

    validation: function () {
      if (this.get('selectedMetric')) {
        if (/^\d+$/.test(this.get('inputMaximum'))) {
          $('#inputMaximum').removeClass('error');
          this.set('selectedMetric.maximumValue', this.get('inputMaximum'));
        } else {
          $('#inputMaximum').addClass('error');
        }
      }
    }.observes('inputMaximum'),
    /**
     *  route on host detail page
     * @param event
     */
    routeHostDetail: function (event) {
      App.router.transitionTo('main.hosts.hostDetails.summary', event.context)
    },
    showHeatMapMetric: function (event) {
      var metricItem = event.context;
      if (metricItem) {
        this.set('selectedMetric', metricItem);
      }
    },

    hostToSlotMap: function () {
      return this.get('selectedMetric.hostToSlotMap');
    }.property('selectedMetric.hostToSlotMap'),

    loadMetrics: function () {
      var selectedMetric = this.get('selectedMetric');
      if (selectedMetric) {
        selectedMetric.refreshHostSlots();
      }
      this.set('inputMaximum', this.get('selectedMetric.maximumValue'));
    }.observes('selectedMetric'),

    /**
     * return class name for to be used for containing each rack.
     *
     * @this App.MainChartsHeatmapController
     */
    rackClass: function () {
      var rackCount = this.get('cluster.racks.length');
      if (rackCount < 2) {
        return "span12";
      } else if (rackCount == 2) {
        return "span6";
      } else {
        return "span4";
      }
    }.property('cluster')
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');
  var date = require('utils/date');

  /**
   * Base class for any heatmap metric.
   * 
   * This class basically provides the following for each heatmap metric.
   * <ul>
   * <li> Provides number of slots in which temperature can fall.
   * <li> Maintains the maximum value so as to scale slot ranges.
   * <li> Gets JSON data from server and maps response for all hosts into above
   * slots.
   * </ul>
   * 
   */
  App.MainChartHeatmapMetric = Em.Object.extend({
    /**
     * Name of this metric
     */
    name: null,

    /**
     * Number of slots this metric will be mapped into. When changing this value,
     * the color count in 'slotColors' should also be changed.
     */
    numberOfSlots: 5,

    /**
     * Colors for the each of the number of slots defined above. When changing the
     * number of slots, the number of colors also should be updated.
     * 
     * @type {Array}
     */
    slotColors: [ {
      r: 0x00,
      g: 0xcc,
      b: 0x00
    }, // Green
    {
      r: 0x9f,
      g: 0xee,
      b: 0x00
    }, {
      r: 0xff,
      g: 0xff,
      b: 0x00
    }, // Yellow
    {
      r: 0xff,
      g: 0xc0,
      b: 0x00
    }, // Orange
    {
      r: 0xff,
      g: 0x00,
      b: 0x00
    } ],// Red

    /**
     * Minimum value of this metric. Default is 0.
     */
    minimumValue: 0,

    /**
     * Maximum value of this metric. This has to be specified by extending classes
     * so that the range from 'minimumValue' to 'maximumValue' can be split among
     * 'numberOfSlots'. It is recommended that this value be a multiple of
     * 'numberOfSlots'.
     */
    maximumValue: 100,

    /**
     * Units of the maximum value which is shown in UI {String}
     */
    units: '',

    /**
     * Indicates whether this metric is currently loading data from the server.
     * {Boolean}
     */
    loading: false,

    /**
     * Provides following information about slots in an array of objects.
     * <ul>
     * <li> from: {number} Slot starts from this value
     * <li> to: {number} Slot ends at this value (inclusive)
     * <li> label: {String} Slot name to be shown
     * <li> cssStyle: {String} style to be embedded on hosts which fall into this
     * slot.
     * </ul>
     * 
     * Slot count will be the same as specified in 'numberOfSlots'. Slot
     * definitions will be given in increasing temperature from 'minimumValue' to
     * 'maximumValue'.
     * 
     */
    slotDefinitions: function () {
      var min = this.get('minimumValue');
      var max = this.get('maximumValue');
      var slotCount = this.get('numberOfSlots');
      var labelSuffix = this.get('slotDefinitionLabelSuffix');
      var delta = (max - min) / slotCount;
      var defs = [];
      var fractions = max < 5;
      var slotColors = this.get('slotColors');
      var slotColorIndex = 0;
      for ( var c = 0; c < slotCount - 1; c++) {
        var from = this.formatLegendNumber(c * delta);
        var to = this.formatLegendNumber((c + 1) * delta);
        if ($.trim(labelSuffix) == 'ms') {
        	var label = date.timingFormat(from) + " - " + date.timingFormat(to);
        } else {
  	      var label = from + labelSuffix + " - " + to + labelSuffix;
        }
        var slotColor = slotColors[slotColorIndex++];
        defs.push(Em.Object.create({
          from: from,
          to: to,
          label: label,
          cssStyle: "background-color:rgb(" + slotColor.r + "," + slotColor.g + "," + slotColor.b + ")"
        }));
      }
      from = this.formatLegendNumber((slotCount - 1) * delta);
      to = this.formatLegendNumber(max);

      if ($.trim(labelSuffix) == 'ms') {
        var label = date.timingFormat(from) + " - " + date.timingFormat(to);
      } else {
        var label = from + labelSuffix + " - " + to + labelSuffix;
      }

      slotColor = slotColors[slotColorIndex++];
      defs.push(Em.Object.create({
        from: from,
        to: to,
        label: label,
        cssStyle: "background-color:rgb(" + slotColor.r + "," + slotColor.g + "," + slotColor.b + ")"
      }));
      var hatchStyle = "background-color:rgb(135, 206, 250)";
      if(jQuery.browser.webkit){
        hatchStyle = "background-image:-webkit-repeating-linear-gradient(-45deg, #FF1E10, #FF1E10 3px, #ff6c00 3px, #ff6c00 6px)";
      }else if(jQuery.browser.mozilla){
        hatchStyle = "background-image:repeating-linear-gradient(-45deg, #FF1E10, #FF1E10 3px, #ff6c00 3px, #ff6c00 6px)";
      }else if(jQuery.browser.msie && jQuery.browser.version){
        var majorVersion =  parseInt(jQuery.browser.version.split('.')[0]);
        if(majorVersion>9){
          hatchStyle = "background-image:repeating-linear-gradient(-45deg, #FF1E10, #FF1E10 3px, #ff6c00 3px, #ff6c00 6px)";
        }
      }
      defs.push(Em.Object.create({
        from: NaN,
        to: NaN,
        label: Em.I18n.t('charts.heatmap.label.invalidData'),
        cssStyle: hatchStyle
      }));
      defs.push(Em.Object.create({
        from: -1,
        to: -1,
        label: Em.I18n.t('charts.heatmap.label.notApplicable'),
        cssStyle: "background-color:rgb(200, 200, 200)"
      }));
      return defs;
    }.property('minimumValue', 'maximumValue', 'numberOfSlots'),

    /**
     * In slot definitions this value is used to construct the label by appending
     * it to slot min-max values. For example giving '%' here would result in slot
     * definition label being '0% - 10%'.
     */
    slotDefinitionLabelSuffix: '',

    /**
     * URL template from which metrics will be gotten for all hosts. The
     * {metricName} param will be replaced by the 'defaultMetric' value.
     */
    metricUrlTemplate: "/clusters/{clusterName}/hosts?fields={metricName}",

    /**
     * URL from which data for this metric can be gotten from. This should be
     * extended by classes to provide correct value.
     */
    metricUrl: function () {
      var clusterName = App.router.get('clusterController.clusterName');
      var fixedMetricName = this.get('defaultMetric');
      fixedMetricName = fixedMetricName.replace(/\./g, "/");
      return App.formatUrl(App.apiPrefix + this.get('metricUrlTemplate'), {
        clusterName: App.router.get('clusterController.clusterName'),
        metricName: fixedMetricName
      }, "/data/cluster_metrics/cpu_1hr.json");
    }.property('App.router.clusterController.clusterName', 'defaultMetric'),

    defaultMetric: '',

    /**
     * Maps server JSON into an object where keys are hostnames and values are the
     * true metric values. This function by default will map 'defaultMetric' into
     * its corresponding value.
     * 
     * @type Function
     */
    metricMapper: function (json) {
      var hostToValueMap = {};
      var metricName = this.get('defaultMetric');
      if (json.items) {
        var props = metricName.split('.');
        json.items.forEach(function (item) {
          var value = item;
          props.forEach(function (prop) {
            if (value != null && prop in value) {
              value = value[prop];
            } else {
              value = null;
            }
          });
          if (value != null) {
            var hostName = item.Hosts.host_name;
            hostToValueMap[hostName] = value;
          }
        });
      }
      return hostToValueMap;
    },

    hostToValueMap: null,

    hostToSlotMap: function(){
      var hostToValueMap = this.get('hostToValueMap');
      var slotDefs = this.get('slotDefinitions');
      var allHosts = App.Host.find();
      var hostToSlotMap = {};
      if (hostToValueMap && allHosts) {
        allHosts.forEach(function(host, index, list){
          var slot = -1;
          var key = host.get('hostName');
          if (key in hostToValueMap) {
            var value = hostToValueMap[key];
            if (isNaN(value)) {
              slot = slotDefs.length - 2;
            } else {
              for ( var slotIndex = 0; slotIndex < slotDefs.length - 2; slotIndex++) {
                var slotDef = slotDefs[slotIndex];
                if (value >= slotDef.from && value <= slotDef.to) {
                  slot = slotIndex;
                }
              }
              if(slot < 0){
                // Assign it to the last legend
                slot = slotDefs.length - 3;
              }
            }
          } else {
            slot = slotDefs.length - 1;
          }
          if (slot > -1) {
            hostToSlotMap[key] = slot;
          }
        });
      }
      return hostToSlotMap;
    }.property('hostToValueMap', 'slotDefinitions'),

    /**
     * Determines which slot each host falls into. This information is given to
     * the callback's #map(hostnameToSlotObject) method. The
     * 'hostnameToSlotObject' has key as hostname, and the slot index as value.
     */
    refreshHostSlots: function () {
      this.set('loading', true);
      jQuery.ajax({
        url: this.get('metricUrl'),
        dataType: 'json',
        error: jQuery.proxy(function () {
          this.set('loading', false);
        }, this),
        success: jQuery.proxy(function (data) {
          var hostToValueMap = this.metricMapper(data);
          this.set('hostToValueMap', hostToValueMap);
          this.set('loading', false);
        }, this)
      });
    }.observes('slotDefinitions'),

    /**
     * Turns numbers into displayable values. For example 24.345432425 into 24.3
     * etc.
     * 
     * @private
     */
    formatLegendNumber: function (num) {
      var fraction = num % 1;
      if (fraction > 0) {
        return num.toFixed(1);
      }
      return num;
    }
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_cpuWaitIO", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   *
   */
  App.MainChartHeatmapCpuWaitIOMetric = App.MainChartHeatmapMetric.extend({
    name: Em.I18n.t('charts.heatmap.metrics.cpuWaitIO'),
    maximumValue: 100,
    defaultMetric: 'metrics.cpu.cpu_wio',
    units: '%',
    slotDefinitionLabelSuffix: '%',
    metricMapper: function (json) {
      var map = this._super(json);
      for ( var host in map) {
        if (host in map) {
          var val = map[host];
          map[host] = (val * 100).toFixed(1);
        }
      }
      return map;
    }
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_dfs", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * Base class for any HDFS metric.
   */
  App.MainChartHeatmapDFSMetrics = App.MainChartHeatmapMetric.extend({
    metricUrlTemplate: "/clusters/{clusterName}/services/HDFS/components/DATANODE?fields=host_components/{metricName}",

    /**
     * Custom mapper for DFS metrics
     */
    metricMapper: function (json) {
      var hostToValueMap = {};
      var metricName = this.get('defaultMetric');
      if (json.host_components) {
        var props = metricName.split('.');
        transformValueFunction = this.get('transformValue');
        json.host_components.forEach(function (hc) {
          var value = hc;
          props.forEach(function (prop) {
            if (value != null && prop in value) {
              value = value[prop];
            } else {
              value = null;
            }
          });
          if (value != null) {
            if (transformValueFunction) {
              value = transformValueFunction(value);
            }
            var hostName = hc.HostRoles.host_name;
            hostToValueMap[hostName] = value;
          }
        });
      }
      return hostToValueMap;
    },

    /**
     * Utility function which allows extending classes to transform the value
     * assigned to a host.
     * 
     * @type Function
     */
    tranformValue: null
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_bytesread", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * 
   */
  App.MainChartHeatmapDFSBytesReadMetric = App.MainChartHeatmapDFSMetrics.extend({
    name: Em.I18n.t('charts.heatmap.metrics.bytesRead'),
    maximumValue: 1024, // 1GB
    defaultMetric: 'metrics.dfs.datanode.bytes_read',
    units: 'MB',
    slotDefinitionLabelSuffix: 'MB',
    transformValue: function (value) {
      return value / (1 << 6); // bytes divided by 1MB.
    }
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_byteswritten", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * 
   */
  App.MainChartHeatmapDFSBytesWrittenMetric = App.MainChartHeatmapDFSMetrics.extend({
    name: Em.I18n.t('charts.heatmap.metrics.bytesWritten'),
    maximumValue: 1024, // 1GB
    defaultMetric: 'metrics.dfs.datanode.bytes_written',
    units: 'MB',
    slotDefinitionLabelSuffix: 'MB',
    transformValue: function (value) {
      return value / (1 << 6); // bytes divided by 1MB.
    }
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_gctime", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * 
   */
  App.MainChartHeatmapDFSGCTimeMillisMetric = App.MainChartHeatmapDFSMetrics.extend({
    name: Em.I18n.t('charts.heatmap.metrics.DFSGarbageCollection'),
    maximumValue: 10000,
    defaultMetric: 'metrics.jvm.gcTimeMillis',
    units: ' ms',
    slotDefinitionLabelSuffix: ' ms'
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_memHeapUsed", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * 
   */
  App.MainChartHeatmapDFSMemHeapUsedMetric = App.MainChartHeatmapDFSMetrics.extend({
    name: Em.I18n.t('charts.heatmap.metrics.DFSMemHeapUsed'),
    maximumValue: 512,
    defaultMetric: 'metrics.jvm.memHeapUsedM',
    units: 'MB',
    slotDefinitionLabelSuffix: 'MB'
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_diskspaceused", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * 
   */
  App.MainChartHeatmapDiskSpaceUsedMetric = App.MainChartHeatmapMetric.extend({
    name: Em.I18n.t('charts.heatmap.metrics.diskSpaceUsed'),
    maximumValue: 100,
    defaultMetric: 'metrics.disk',
    units: '%',
    slotDefinitionLabelSuffix: '%',
    metricMapper: function (json) {
      var hostToValueMap = {};
      var metricName = this.get('defaultMetric');
      if (json.items) {
        var props = metricName.split('.');
        json.items.forEach(function (item) {
          var value = item;
          props.forEach(function (prop) {
            if (value != null && prop in value) {
              value = value[prop];
            } else {
              value = null;
            }
          });
          if (value != null) {
            var total = value.disk_total;
            var free = value.disk_free;
            value = (((total - free) * 100) / total).toFixed(1);
            var hostName = item.Hosts.host_name;
            hostToValueMap[hostName] = value;
          }
        });
      }
      return hostToValueMap;
    }
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_hbase", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * Base class for any HDFS metric.
   */
  App.MainChartHeatmapHbaseMetrics = App.MainChartHeatmapMetric.extend({
    metricUrlTemplate: "/clusters/{clusterName}/services/HBASE/components/HBASE_REGIONSERVER?fields=host_components/{metricName}",

    /**
     * Custom mapper for DFS metrics
     */
    metricMapper: function (json) {
      var hostToValueMap = {};
      var metricName = this.get('defaultMetric');
      if (json.host_components) {
        var props = metricName.split('.');
        transformValueFunction = this.get('transformValue');
        json.host_components.forEach(function (hc) {
          var value = hc;
          props.forEach(function (prop) {
            if (value != null && prop in value) {
              value = value[prop];
            } else {
              value = null;
            }
          });
          if (value != null) {
            if (transformValueFunction) {
              value = transformValueFunction(value);
            }
            var hostName = hc.HostRoles.host_name;
            hostToValueMap[hostName] = value;
          }
        });
      }
      return hostToValueMap;
    },

    /**
     * Utility function which allows extending classes to transform the value
     * assigned to a host.
     *
     * @type Function
     */
    tranformValue: null
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_hbase_compactionqueue", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   *
   */
  App.MainChartHeatmapHbaseCompactionQueueSize = App.MainChartHeatmapHbaseMetrics.extend({
    name: Em.I18n.t('charts.heatmap.metrics.HbaseRegionServerCompactionQueueSize'),
    maximumValue: 10,
    defaultMetric: 'metrics.hbase.regionserver.compactionQueueSize',
    units: '',
    slotDefinitionLabelSuffix: ''
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_hbase_memstoresize", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   *
   */
  App.MainChartHeatmapHbaseMemStoreSize = App.MainChartHeatmapHbaseMetrics.extend({
    name: Em.I18n.t('charts.heatmap.metrics.HbaseRegionServerMemStoreSize'),
    maximumValue: 100,
    defaultMetric: 'metrics.hbase.regionserver.memstoreSizeMB',
    units: 'MB',
    slotDefinitionLabelSuffix: 'MB'
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_hbase_readrequest", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   *
   */
  App.MainChartHeatmapHbaseReadReqCount = App.MainChartHeatmapHbaseMetrics.extend({
    name: Em.I18n.t('charts.heatmap.metrics.HbaseRegionServerReadCount'),
    maximumValue: 200,
    defaultMetric: 'metrics.hbase.regionserver.readRequestsCount',
    units: '',
    slotDefinitionLabelSuffix: ''
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_hbase_regions", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   *
   */
  App.MainChartHeatmapHbaseRegions = App.MainChartHeatmapHbaseMetrics.extend({
    name: Em.I18n.t('charts.heatmap.metrics.HbaseRegionServerRegions'),
    maximumValue: 10,
    defaultMetric: 'metrics.hbase.regionserver.regions',
    units: '',
    slotDefinitionLabelSuffix: ''
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_hbase_writerequest", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   *
   */
  App.MainChartHeatmapHbaseWriteReqCount = App.MainChartHeatmapHbaseMetrics.extend({
    name: Em.I18n.t('charts.heatmap.metrics.HbaseRegionServerWriteCount'),
    maximumValue: 200,
    defaultMetric: 'metrics.hbase.regionserver.writeRequestsCount',
    units: '',
    slotDefinitionLabelSuffix: ''
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_mapreduce", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * Base class for any MapReduce metric.
   */
  App.MainChartHeatmapMapreduceMetrics = App.MainChartHeatmapMetric.extend({
    metricUrlTemplate: "/clusters/{clusterName}/services/MAPREDUCE/components/TASKTRACKER?fields=host_components/{metricName}",

    /**
     * Custom mapper for DFS metrics
     */
    metricMapper: function (json) {
      var hostToValueMap = {};
      var metricName = this.get('defaultMetric');
      if (json.host_components) {
        var props = metricName.split('.');
        transformValueFunction = this.get('transformValue');
        json.host_components.forEach(function (hc) {
          var value = hc;
          props.forEach(function (prop) {
            if (value != null && prop in value) {
              value = value[prop];
            } else {
              value = null;
            }
          });
          if (value != null) {
            if (transformValueFunction) {
              value = transformValueFunction(value);
            }
            var hostName = hc.HostRoles.host_name;
            hostToValueMap[hostName] = value;
          }
        });
      }
      return hostToValueMap;
    },

    /**
     * Utility function which allows extending classes to transform the value
     * assigned to a host.
     * 
     * @type Function
     */
    tranformValue: null
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_mapreduce_gctime", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * 
   */
  App.MainChartHeatmapMapreduceGCTimeMillisMetric = App.MainChartHeatmapMapreduceMetrics.extend({
    name: Em.I18n.t('charts.heatmap.metrics.MapReduceGCTime'),
    maximumValue: 10000,
    defaultMetric: 'metrics.jvm.gcTimeMillis',
    units: ' ms',
    slotDefinitionLabelSuffix: ' ms'
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_mapreduce_mapsRunning", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * 
   */
  App.MainChartHeatmapMapreduceMapsRunningMetric = App.MainChartHeatmapMapreduceMetrics.extend({
    name: Em.I18n.t('charts.heatmap.metrics.mapsRunning'),
    maximumValue: 100,
    defaultMetric: 'metrics.mapred.tasktracker.maps_running',
    units: ' maps',
    slotDefinitionLabelSuffix: ' Maps'
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_mapreduce_memHeapUsed", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * 
   */
  App.MainChartHeatmapMapreduceMemHeapUsedMetric = App.MainChartHeatmapMapreduceMetrics.extend({
    name: Em.I18n.t('charts.heatmap.metrics.MRMemHeapUsed'),
    maximumValue: 512,
    defaultMetric: 'metrics.jvm.memHeapUsedM',
    units: 'MB',
    slotDefinitionLabelSuffix: 'MB'
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_mapreduce_reducesRunning", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * 
   */
  App.MainChartHeatmapMapreduceReducesRunningMetric = App.MainChartHeatmapMapreduceMetrics.extend({
    name: Em.I18n.t('charts.heatmap.metrics.reducesRunning'),
    maximumValue: 100,
    defaultMetric: 'metrics.mapred.tasktracker.reduces_running',
    units: ' reduces',
    slotDefinitionLabelSuffix: ' Reduces'
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_memoryused", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * Base class for any heatmap metric.
   * 
   * This class basically provides the following for each heatmap metric.
   * <ul>
   * <li> Provides number of slots in which temperature can fall.
   * <li> Maintains the maximum value so as to scale slot ranges.
   * <li> Gets JSON data from server and maps response for all hosts into above
   * slots.
   * </ul>
   * 
   */
  App.MainChartHeatmapMemoryUsedMetric = App.MainChartHeatmapMetric.extend({
    name: Em.I18n.t('charts.heatmap.metrics.memoryUsed'),
    maximumValue: 100,
    defaultMetric: 'metrics.memory',
    units: '%',
    slotDefinitionLabelSuffix: '%',
    metricMapper: function (json) {
      var hostToValueMap = {};
      var metricName = this.get('defaultMetric');
      if (json.items) {
        var props = metricName.split('.');
        json.items.forEach(function (item) {
          var value = item;
          props.forEach(function (prop) {
            if (value != null && prop in value) {
              value = value[prop];
            } else {
              value = null;
            }
          });
          if (value != null) {
            var total = value.mem_total;
            var used = value.mem_total - value.mem_free - value.mem_cached;
            value = ((used * 100) / total).toFixed(1);
            var hostName = item.Hosts.host_name;
            hostToValueMap[hostName] = value;
          }
        });
      }
      return hostToValueMap;
    }
  });
});
window.require.register("controllers/main/charts/heatmap_metrics/heatmap_metric_processrun", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * Base class for any heatmap metric.
   * 
   * This class basically provides the following for each heatmap metric.
   * <ul>
   * <li> Provides number of slots in which temperature can fall.
   * <li> Maintains the maximum value so as to scale slot ranges.
   * <li> Gets JSON data from server and maps response for all hosts into above
   * slots.
   * </ul>
   * 
   */
  App.MainChartHeatmapProcessRunMetric = App.MainChartHeatmapMetric.extend({
    name: Em.I18n.t('charts.heatmap.metrics.processRun'),
    maximumValue: 1,
    defaultMetric: 'metrics.process.proc_run',
    units: 'Processes',
    metricMapper: function (json) {
      var map = this._super(json);
      for ( var host in map) {
        if (host in map) {
          var val = map[host];
          map[host] = val.toFixed(1);
        }
      }
      return map;
    }
  });
});
window.require.register("controllers/main/host", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var validator = require('utils/validator');
  var componentHelper = require('utils/component');

  App.MainHostController = Em.ArrayController.extend({
    name:'mainHostController',
    content: App.Host.find(),

    alerts: function () {
      return App.router.get('clusterController.alerts').filterProperty('isOk', false).filterProperty('ignoredForHosts', false);
    }.property('App.router.clusterController.alerts.length'),

    /**
     * Components which will be shown in component filter
     */
    componentsForFilter:function() {
      var installedComponents = componentHelper.getInstalledComponents();
      installedComponents.setEach('checkedForHostFilter', false);
      return installedComponents;
    }.property('App.router.clusterController.isLoaded'),

    masterComponents:function () {
      return this.get('componentsForFilter').filterProperty('isMaster', true);
    }.property('componentsForFilter'),

    slaveComponents:function () {
      return this.get('componentsForFilter').filterProperty('isSlave', true);
    }.property('componentsForFilter'),

    clientComponents: function() {
      return this.get('componentsForFilter').filterProperty('isClient', true);
    }.property('componentsForFilter'),

    /**
     * Filter hosts by componentName of <code>component</code>
     * @param component App.HostComponent
     */
    filterByComponent:function (component) {
      var id = component.get('componentName');
      var column = 6;
      this.get('componentsForFilter').setEach('checkedForHostFilter', false);

      var filterForComponent = {
        iColumn: column,
        value: id,
        type: 'multiple'
      };

      var filterConditions = App.db.getFilterConditions(this.get('name'));
      if (filterConditions) {
        var component = filterConditions.findProperty('iColumn', column);
        if (component) {
          component.value = id;
        }
        else {
          filterConditions.push(filterForComponent);
        }
        App.db.setFilterConditions(this.get('name'), filterConditions);
      }
      else {
        App.db.setFilterConditions(this.get('name'), [filterForComponent]);
      }
    },
    /**
     * On click callback for delete button
     */
    deleteButtonPopup:function () {
      var self = this;
      App.showConfirmationPopup(function(){
        self.removeHosts();
      });
    },

    showAlertsPopup: function (event) {
      var host = event.context;
      App.ModalPopup.show({
        header: this.t('services.alerts.headingOfList'),
        bodyClass: Ember.View.extend({
          hostAlerts: function () {
            var allAlerts = App.router.get('clusterController.alerts').filterProperty('ignoredForHosts', false);
            if (host) {
              return allAlerts.filterProperty('hostName', host.get('hostName'));
            }
            return 0;
          }.property('App.router.clusterController.alerts'),

          closePopup: function () {
            this.get('parentView').hide();
          },

          templateName: require('templates/main/host/alerts_popup')
        }),
        primary: Em.I18n.t('common.close'),
        onPrimary: function() {
          this.hide();
        },
        secondary : null,
        didInsertElement: function () {
          this.$().find('.modal-footer').addClass('align-center');
          this.$().children('.modal').css({'margin-top': '-350px'});
        }
      });
      event.stopPropagation();
    },

    /**
     * remove selected hosts
     */
    removeHosts:function () {
      var hosts = this.get('content');
      var selectedHosts = hosts.filterProperty('isChecked', true);
      selectedHosts.forEach(function (_hostInfo) {
        console.log('Removing:  ' + _hostInfo.hostName);
      });
      this.get('fullContent').removeObjects(selectedHosts);
    },

    /**
     * remove hosts with id equal host_id
     * @param host_id
     */
    checkRemoved:function (host_id) {
      var hosts = this.get('content');
      var selectedHosts = hosts.filterProperty('id', host_id);
      this.get('fullContent').removeObjects(selectedHosts);
    }

  });
});
window.require.register("controllers/main/host/add_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.AddHostController = App.WizardController.extend({

    name: 'addHostController',

    totalSteps: 7,

    /**
     * Used for hiding back button in wizard
     */
    hideBackButton: true,

    /**
     * All wizards data will be stored in this variable
     *
     * cluster - cluster name
     * hosts - hosts, ssh key, repo info, etc.
     * services - services list
     * hostsInfo - list of selected hosts
     * slaveComponentHosts, hostSlaveComponents - info about slave hosts
     * masterComponentHosts - info about master hosts
     * config??? - to be described later
     */
    content: Em.Object.create({
      cluster: null,
      hosts: null,
      installOptions: null,
      services: null,
      slaveComponentHosts: null,
      masterComponentHosts: null,
      serviceConfigProperties: null,
      advancedServiceConfig: null,
      controllerName: 'addHostController'
    }),

    components:require('data/service_components'),

    /**
     * return new object extended from clusterStatusTemplate
     * @return Object
     */
    getCluster: function(){
      return jQuery.extend({}, this.get('clusterStatusTemplate'), {name: App.router.getClusterName()});
    },

    /**
     * return new object extended from installOptionsTemplate
     * @return Object
     */
    getInstallOptions: function(){
      return jQuery.extend({}, this.get('installOptionsTemplate'));
    },

    /**
     * return empty hosts array
     * @return Array
     */
    getHosts: function(){
      return [];
    },

     /**
     * Remove host from model. Used at <code>Confirm hosts(step2)</code> step
     * @param hosts Array of hosts, which we want to delete
     */
    removeHosts: function (hosts) {
      //todo Replace this code with real logic
      App.db.removeHosts(hosts);
    },

    /**
     * Load services data from server.
     */
    loadServicesFromServer: function() {
      var displayOrderConfig = require('data/services');
      var apiUrl = App.get('stack2VersionURL');
      var apiService = this.loadServiceComponents(displayOrderConfig, apiUrl);
      //
      apiService.forEach(function(item, index){
        apiService[index].isSelected = App.Service.find().someProperty('id', item.serviceName);
        apiService[index].isDisabled = apiService[index].isSelected;
        apiService[index].isInstalled = apiService[index].isSelected;
      });
      this.set('content.services', apiService);
      App.db.setService(apiService);
    },

    /**
     * Load services data. Will be used at <code>Select services(step4)</code> step
     */
    loadServices: function () {
      var servicesInfo = App.db.getService();
      servicesInfo.forEach(function (item, index) {
        servicesInfo[index] = Em.Object.create(item);
      });
      this.set('content.services', servicesInfo);
      console.log('AddHostController.loadServices: loaded data ', servicesInfo);
      var serviceNames = servicesInfo.filterProperty('isSelected', true).mapProperty('serviceName');
      console.log('selected services ', serviceNames);
      this.set('content.skipMasterStep', (!serviceNames.contains('HBASE') && !serviceNames.contains('ZOOKEEPER')) || !App.supports.addMasters);
    },

    /**
     * Load master component hosts data for using in required step controllers
     */
    loadMasterComponentHosts: function () {
      var masterComponentHosts = App.db.getMasterComponentHosts();
      if (!masterComponentHosts) {
        masterComponentHosts = [];
        App.HostComponent.find().filterProperty('isMaster', true).forEach(function (item) {
          masterComponentHosts.push({
            component: item.get('componentName'),
            hostName: item.get('host.hostName'),
            isInstalled: true,
            serviceId: item.get('service.id'),
            display_name: item.get('displayName')
          })
        });
        App.db.setMasterComponentHosts(masterComponentHosts);
      }
      this.set("content.masterComponentHosts", masterComponentHosts);
      console.log("AddHostController.loadMasterComponentHosts: loaded hosts ", masterComponentHosts);
    },

    /**
     * Save HBase and ZooKeeper to main controller
     * @param stepController
     */
    saveHbZk: function(stepController) {
      var self = this;
      var hosts = stepController.get('hosts');
      var headers = stepController.get('headers');
      var masterComponentHosts = App.db.getMasterComponentHosts();

      headers.forEach(function(header) {
        var rm = masterComponentHosts.filterProperty('component', header.get('name'));
        if(rm) {
          masterComponentHosts.removeObjects(rm);
        }
      });

      headers.forEach(function(header) {
        var component = self.get('components').findProperty('component_name', header.get('name'));
        hosts.forEach(function(host) {
          if (host.get('checkboxes').findProperty('title', component.display_name).checked) {
            masterComponentHosts .push({
              display_name: component.display_name,
              component: component.component_name,
              hostName: host.get('hostName'),
              serviceId: component.service_name,
              isInstalled: false
            });
          }
        });
      });

      console.log("installerController.saveMasterComponentHosts: saved hosts ", masterComponentHosts);
      App.db.setMasterComponentHosts(masterComponentHosts);
      this.set('content.masterComponentHosts', masterComponentHosts);
    },

    /**
     * return slaveComponents bound to hosts
     * @return {Array}
     */
    getSlaveComponentHosts: function () {
      var components = [
        {
          name: 'DATANODE',
          service: 'HDFS'
        },
        {
          name: 'TASKTRACKER',
          service: 'MAPREDUCE'
        },
        {
          name: 'HBASE_REGIONSERVER',
          service: 'HBASE'
        }
      ];

      var result = [];
      var services = App.Service.find();
      var selectedServices = this.get('content.services').filterProperty('isSelected', true).mapProperty('serviceName');
      for (var index = 0; index < components.length; index++) {
        var comp = components[index];
        if (!selectedServices.contains(comp.service)) {
          continue;
        }


        var service = services.findProperty('id', comp.service);
        var hosts = [];

        service.get('hostComponents').filterProperty('componentName', comp.name).forEach(function (host_component) {
          hosts.push({
            group: "Default",
            hostName: host_component.get('host.id'),
            isInstalled: true
          });
        }, this);

        result.push({
          componentName: comp.name,
          displayName: App.format.role(comp.name),
          hosts: hosts,
          isInstalled: true
        })
      }

      var clientsHosts = App.HostComponent.find().filterProperty('componentName', 'HDFS_CLIENT');
      var hosts = [];

      clientsHosts.forEach(function (host_component) {
        hosts.push({
          group: "Default",
          hostName: host_component.get('host.id'),
          isInstalled: true
        });
      }, this);

      result.push({
        componentName: 'CLIENT',
        displayName: 'client',
        hosts: hosts,
        isInstalled: true
      })

      return result;
    },

    /**
     * Load master component hosts data for using in required step controllers
     */
    loadSlaveComponentHosts: function () {
      var slaveComponentHosts = App.db.getSlaveComponentHosts();
      if (!slaveComponentHosts) {
        slaveComponentHosts = this.getSlaveComponentHosts();
      }
      this.set("content.slaveComponentHosts", slaveComponentHosts);
      console.log("AddHostController.loadSlaveComponentHosts: loaded hosts ", slaveComponentHosts);
    },

    /**
     * Load information about hosts with clients components
     */
    loadClients: function () {
      var clients = App.db.getClientsForSelectedServices();
      this.set('content.clients', clients);
      console.log("AddHostController.loadClients: loaded list ", clients);
    },

    /**
     * Generate clients list for selected services and save it to model
     * @param stepController step4WizardController
     */
    saveClients: function () {
      var clients = [];
      var serviceComponents = require('data/service_components');
      var hostComponents = App.HostComponent.find();

      this.get('content.services').filterProperty('isSelected', true).forEach(function (_service) {
        var client = serviceComponents.filterProperty('service_name', _service.serviceName).findProperty('isClient', true);
        if (client) {
          clients.pushObject({
            component_name: client.component_name,
            display_name: client.display_name,
            isInstalled: hostComponents.filterProperty('componentName', client.component_name).length > 0
          });
        }
      }, this);

      App.db.setClientsForSelectedServices(clients);
      this.set('content.clients', clients);
      console.log("AddHostController.saveClients: saved list ", clients);
    },

    /**
     * Load data for all steps until <code>current step</code>
     */
    loadAllPriorSteps: function () {
      var step = this.get('currentStep');
      switch (step) {
        case '9':
        case '8':
        case '7':
        case '6':
        case '5':
          this.loadServiceConfigProperties();
        case '4':
        case '3':
          this.loadClients();
          this.loadServices();
          this.loadMasterComponentHosts();
          this.loadSlaveComponentHosts();
          this.load('hosts');
        case '2':
          this.loadServices();
        case '1':
          this.load('hosts');
          this.load('installOptions');
          this.load('cluster');
      }
    },

    /**
     * Remove all loaded data.
     * Created as copy for App.router.clearAllSteps
     */
    clearAllSteps: function () {
      this.clearInstallOptions();
      // clear temporary information stored during the install
      this.set('content.cluster', this.getCluster());
    },

    /**
     * Clear all temporary data
     */
    finish: function () {
      this.setCurrentStep('1');
      this.clearAllSteps();
      this.clearStorageData();
      App.router.get('updateController').updateAll();
      App.updater.immediateRun('updateHost');
    }

  });
  
});
window.require.register("controllers/main/host/configs_service", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.MainHostServiceConfigsController = App.MainServiceInfoConfigsController.extend({
    name: 'mainHostServiceConfigsController',
    host: null,
    /**
     * On load function
     */
    loadStep: function () {
      var content = this.get('content');
      this.set('host', content.host);
      this._super();
    },

    /**
     * Removes categories which are not valid for this host. Ex: Remove JOBTRACKER
     * category on host which does not have it installed.
     */
    renderServiceConfigs: function (serviceConfigs) {
      var newServiceConfigs = jQuery.extend({}, serviceConfigs);
      var hostHostComponentNames = [];
      var hostComponents = this.get('host.hostComponents');
      if (hostComponents) {
        hostComponents.forEach(function (hc) {
          var name = hc.get('componentName');
          if (!hostHostComponentNames.contains(name)) {
            hostHostComponentNames.push(name);
          }
        });
      }
      newServiceConfigs.configCategories = serviceConfigs.configCategories.filter(function (category) {
        var hcNames = category.get('hostComponentNames');
        if (hcNames != null && hcNames.length > 0) {
          var show = false;
          hcNames.forEach(function (name) {
            if (hostHostComponentNames.contains(name)) {
              show = true;
            }
          });
          return show;
        }
        return true;
      });
      this._super(newServiceConfigs);
    },

    typeTagToHostMap: null,

    configKeyToConfigMap: null,

    /**
     * This method will *not load* the overridden properties. However it will
     * replace the value shown for properties which this host has override for.
     */
    loadServiceConfigHostsOverrides: function (serviceConfig) {
      var thisHostName = this.get('host.hostName');
      var configKeyToConfigMap = {};
      serviceConfig.configs.forEach(function (item) {
        configKeyToConfigMap[item.name] = item;
      });
      var typeTagToHostMap = {};
      var urlParams = [];
      for ( var hostname in this.loadedHostToOverrideSiteToTagMap) {
        if (hostname === thisHostName) {
          var overrideTypeTags = this.loadedHostToOverrideSiteToTagMap[hostname];
          for ( var type in overrideTypeTags) {
            var tag = overrideTypeTags[type];
            typeTagToHostMap[type + "///" + tag] = hostname;
            urlParams.push('(type=' + type + '&tag=' + tag + ')');
          }
        }
      }
      this.set('typeTagToHostMap', typeTagToHostMap);
      this.set('configKeyToConfigMap', configKeyToConfigMap);
      if (urlParams.length > 0) {
        App.ajax.send({
          name: 'host.service_config_hosts_overrides',
          sender: this,
          data: {
            urlParams: urlParams.join('|')
          },
          success: 'loadServiceConfigHostsOverridesSuccessCallback',
          error: 'loadServiceConfigHostsOverridesErrorCallback'
        });
      }
    },
    loadServiceConfigHostsOverridesSuccessCallback: function (data) {
      var typeTagToHostMap = this.get('typeTagToHostMap');
      var configKeyToConfigMap = this.get('configKeyToConfigMap');
      data.items.forEach(function (config) {
        var hostname = typeTagToHostMap[config.type + "///" + config.tag];
        var properties = config.properties;
        for ( var prop in properties) {
          var serviceConfig = configKeyToConfigMap[prop];
          var hostOverrideValue = properties[prop];
          if (serviceConfig && serviceConfig.displayType === 'int') {
            if (/\d+m$/.test(hostOverrideValue)) {
              hostOverrideValue = hostOverrideValue.slice(0, hostOverrideValue.length - 1);
            }
          } else if (serviceConfig && serviceConfig.displayType === 'checkbox') {
            switch (hostOverrideValue) {
              case 'true':
                hostOverrideValue = true;
                break;
              case 'false':
                hostOverrideValue = false;
                break;
            }
          }
          if (serviceConfig) {
            // Value of this property is different for this host.
            console.log("loadServiceConfigHostsOverrides(" + this.get('host.hostName') + "): [" + hostname + "] OVERRODE(" + serviceConfig.name + "): " + serviceConfig.value + " -> " + hostOverrideValue);
            serviceConfig.value = hostOverrideValue;
            serviceConfig.defaultValue = hostOverrideValue;
            serviceConfig.isOriginalSCP = false;
            serviceConfig.selectedHostOptions = [this.get('host.hostName')];
          }
        }
      });
      console.log("loadServiceConfigHostsOverrides(" + this.get('host.hostName') + "): Finished loading.");
    },
    loadServiceConfigHostsOverridesErrorCallback: function (request, ajaxOptions, error) {
      console.log("TRACE: error code status is: " + request.status);
    }
  });
});
window.require.register("controllers/main/host/details", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainHostDetailsController = Em.Controller.extend({
    name: 'mainHostDetailsController',
    content: null,
    isFromHosts: false,

    /**
     * open dashboard page
     */
    routeHome: function () {
      App.router.transitionTo('main.dashboard');
    },

    /**
     * open summary page of the selected service
     * @param event
     */
    routeToService: function(event){
      var service = event.context;
      App.router.transitionTo('main.services.service.summary',service);
    },

    /**
     * set new value to isFromHosts property
     * @param isFromHosts new value
     */
    setBack: function(isFromHosts){
      this.set('isFromHosts', isFromHosts);
    },

    /**
     * Send specific command to server
     * @param url
     * @param _method
     * @param postData
     * @param callback
     */
    sendCommandToServer : function(url, postData, _method, callback){
      var url =  (App.testMode) ?
        '/data/wizard/deploy/poll_1.json' : //content is the same as ours
        App.apiPrefix + '/clusters/' + App.router.getClusterName() + url;

      var method = App.testMode ? 'GET' : _method;

      $.ajax({
        type: method,
        url: url,
        data: JSON.stringify(postData),
        dataType: 'json',
        timeout: App.timeout,
        success: function(data){
          if(data && data.Requests){
            callback(data.Requests.id);
          } else{
            callback(null);
            console.log('cannot get request id from ', data);
          }
        },

        error: function (request, ajaxOptions, error) {
          //do something
          callback(null);
          console.log('error on change component host status')
        },

        statusCode: require('data/statusCodes')
      });
    },

    /**
     * send command to server to start selected host component
     * @param event
     */
    startComponent: function (event) {
      var self = this;
      App.showConfirmationPopup(function() {
        var component = event.context;

        self.sendCommandToServer('/hosts/' + self.get('content.hostName') + '/host_components/' + component.get('componentName').toUpperCase(),{
          RequestInfo : {
            "context" : Em.I18n.t('requestInfo.startHostComponent') + " " + component.get('displayName')
          },
          Body:{
            HostRoles:{
              state: 'STARTED'
            }
          }
        }, 'PUT',
          function(requestId){

          if(!requestId){
            return;
          }

          console.log('Send request for STARTING successfully');

          if (App.testMode) {
            component.set('workStatus', App.HostComponentStatus.starting);
            setTimeout(function(){
              component.set('workStatus', App.HostComponentStatus.started);
            },App.testModeDelayForActions);
          } else {
            App.router.get('clusterController').loadUpdatedStatusDelayed(500);
          }

          App.router.get('backgroundOperationsController').showPopup();

        });
      });
    },

    /**
     * send command to server to upgrade selected host component
     * @param event
     */
    upgradeComponent: function (event) {
      var self = this;
      var component = event.context;
      App.showConfirmationPopup(function() {
        self.sendCommandToServer('/hosts/' + self.get('content.hostName') + '/host_components/' + component.get('componentName').toUpperCase(),{
              RequestInfo : {
                "context" : Em.I18n.t('requestInfo.upgradeHostComponent') + " " + component.get('displayName')
              },
              Body:{
                HostRoles:{
                  stack_id: 'HDP-1.2.2',
                  state: 'INSTALLED'
                }
              }
            }, 'PUT',
            function(requestId){
              if(!requestId){
                return;
              }

              console.log('Send request for UPGRADE successfully');

              if (App.testMode) {
                component.set('workStatus', App.HostComponentStatus.starting);
                setTimeout(function(){
                  component.set('workStatus', App.HostComponentStatus.started);
                },App.testModeDelayForActions);
              } else {
                App.router.get('clusterController').loadUpdatedStatusDelayed(500);
              }

              App.router.get('backgroundOperationsController').showPopup();

            });
      });
    },
    /**
     * send command to server to stop selected host component
     * @param event
     */
    stopComponent: function (event) {
      var self = this;
      App.showConfirmationPopup(function() {
        var component = event.context;
        self.sendCommandToServer('/hosts/' + self.get('content.hostName') + '/host_components/' + component.get('componentName').toUpperCase(),{
          RequestInfo : {
            "context" : Em.I18n.t('requestInfo.stopHostComponent')+ " " + component.get('displayName')
          },
          Body:{
            HostRoles:{
              state: 'INSTALLED'
            }
          }
        }, 'PUT',
          function(requestId){
          if(!requestId){
            return;
          }

          console.log('Send request for STOPPING successfully');

          if (App.testMode) {
            component.set('workStatus', App.HostComponentStatus.stopping);
            setTimeout(function(){
              component.set('workStatus', App.HostComponentStatus.stopped);
            },App.testModeDelayForActions);
          } else {
            App.router.get('clusterController').loadUpdatedStatusDelayed(500);
          }

          App.router.get('backgroundOperationsController').showPopup();

        });

      });
    },

    /**
     * send command to server to install selected host component
     * @param event
     */
    addComponent: function (event, context) {
      var self = this;
      var component = event.context;
      var componentName = component.get('componentName').toUpperCase().toString();
      var displayName = component.get('displayName');

      var securityEnabled = App.router.get('mainAdminSecurityController').getUpdatedSecurityStatus();

      if (securityEnabled) {
        App.showConfirmationPopup(function() {
          self.primary(component);
        }, Em.I18n.t('hosts.host.addComponent.securityNote').format(componentName,self.get('content.hostName')));
      }
      else {
        App.ModalPopup.show({
          primary: Em.I18n.t('yes'),
          secondary: Em.I18n.t('no'),
          header: Em.I18n.t('popup.confirmation.commonHeader'),
          bodyClass: Ember.View.extend({
            template: Ember.Handlebars.compile([
              '{{t hosts.delete.popup.body}}<br><br>',
              '{{t hosts.host.addComponent.note}}'
            ].join(''))
          }),
          onPrimary: function () {
            this.hide();
            self.primary(component);
          }
        });
      }
    },
    primary: function(component) {
      var self = this;
      var componentName = component.get('componentName').toUpperCase().toString();
      var displayName = component.get('displayName');

      self.sendCommandToServer('/hosts?Hosts/host_name=' + self.get('content.hostName'), {
          RequestInfo: {
            "context": Em.I18n.t('requestInfo.installHostComponent') + " " + displayName
          },
          Body: {
            host_components: [
              {
                HostRoles: {
                  component_name: componentName
                }
              }
            ]
          }
        },
        'POST',
        function (requestId) {

          console.log('Send request for ADDING NEW COMPONENT successfully');

          self.sendCommandToServer('/host_components?HostRoles/host_name=' + self.get('content.hostName') + '\&HostRoles/component_name=' + componentName + '\&HostRoles/state=INIT', {
              RequestInfo: {
                "context": Em.I18n.t('requestInfo.installNewHostComponent') + " " + displayName
              },
              Body: {
                HostRoles: {
                  state: 'INSTALLED'
                }
              }
            },
            'PUT',
            function (requestId) {
              if (!requestId) {
                return;
              }

              console.log('Send request for INSTALLING NEW COMPONENT successfully');

              if (App.testMode) {
                component.set('workStatus', App.HostComponentStatus.installing);
                setTimeout(function () {
                  component.set('workStatus', App.HostComponentStatus.stopped);
                }, App.testModeDelayForActions);
              } else {
                App.router.get('clusterController').loadUpdatedStatusDelayed(500);
              }

              App.router.get('backgroundOperationsController').showPopup();

            });
        });
    },
    /**
     * send command to server to install selected host component
     * @param event
     * @param context
     */
    installComponent: function (event, context) {
      var self = this;
      var component = event.context;
      var componentName = component.get('componentName').toUpperCase().toString();
      var displayName = component.get('displayName');

      App.ModalPopup.show({
        primary: Em.I18n.t('yes'),
        secondary: Em.I18n.t('no'),
        header: Em.I18n.t('popup.confirmation.commonHeader'),
        bodyClass: Ember.View.extend({
          template: Ember.Handlebars.compile([
            '{{t hosts.delete.popup.body}}<br /><br />',
            '{{t hosts.host.addComponent.note}}'
          ].join(''))
        }),
        onPrimary: function () {
          this.hide();
          self.sendCommandToServer('/hosts/' + self.get('content.hostName') + '/host_components/' + component.get('componentName').toUpperCase(), {
              RequestInfo: {
                "context": Em.I18n.t('requestInfo.installHostComponent') + " " + displayName
              },
              Body: {
                HostRoles: {
                  state: 'INSTALLED'
                }
              }
            },
            'PUT',
            function (requestId) {
              if (!requestId) {
                return;
              }

              console.log('Send request for REINSTALL COMPONENT successfully');

              if (App.testMode) {
                component.set('workStatus', App.HostComponentStatus.installing);
                setTimeout(function () {
                  component.set('workStatus', App.HostComponentStatus.stopped);
                }, App.testModeDelayForActions);
              } else {
                App.router.get('clusterController').loadUpdatedStatusDelayed(500);
              }

              App.router.get('backgroundOperationsController').showPopup();

            });
        }
      });
    },
    /**
     * send command to server to run decommission on DATANODE
     * @param event
     */
    decommission: function(event){
      var self = this;
      var decommissionHostNames = this.get('view.decommissionDataNodeHostNames');
      if (decommissionHostNames == null) {
        decommissionHostNames = [];
      }
      App.showConfirmationPopup(function(){
        var component = event.context;
        // Only HDFS service as of now
        var svcName = component.get('service.serviceName');
        if (svcName === "HDFS") {
          var hostName = self.get('content.hostName');
          var index = decommissionHostNames.indexOf(hostName);
          if (index < 0) {
            decommissionHostNames.push(hostName);
          }
          self.doDatanodeDecommission(decommissionHostNames, true);
        }
        App.router.get('backgroundOperationsController').showPopup();
      });
    },

    /**
     * Performs either Decommission or Recommission by updating the hosts list on
     * server.
     * @param decommission defines context for request (true for decommission and false for recommission)
     */
    doDatanodeDecommission: function(decommissionHostNames, decommission){
      var self = this;
      if (decommissionHostNames == null) {
        decommissionHostNames = [];
      }
      var invocationTag = String(new Date().getTime());
      var context = decommission ? Em.I18n.t('hosts.host.datanode.decommission') : Em.I18n.t('hosts.host.datanode.recommission');
      var clusterName = App.router.get('clusterController.clusterName');
      var clusterUrl = App.apiPrefix + '/clusters/' + clusterName;
      var configsUrl = clusterUrl + '/configurations';
      var configsData = {
        type: "hdfs-exclude-file",
        tag: invocationTag,
        properties: {
          datanodes: decommissionHostNames.join(',')
        }
      };
      var configsAjax = {
        type: 'POST',
        url: configsUrl,
        dataType: 'json',
        data: JSON.stringify(configsData),
        timeout: App.timeout,
        success: function(){
          var actionsUrl = clusterUrl + '/services/HDFS/actions/DECOMMISSION_DATANODE';
          var actionsData = {
            RequestInfo: {
              context: context},
            Body: {
              parameters: {
                excludeFileTag: invocationTag
              }
            }
          };
          var actionsAjax = {
            type: 'POST',
            url: actionsUrl,
            dataType: 'json',
            data: JSON.stringify(actionsData),
            timeout: App.timeout,
            success: function(){
              var persistUrl = App.apiPrefix + '/persist';
              var persistData = {
                "decommissionDataNodesTag": invocationTag
              };
              var persistPutAjax = {
                type: 'POST',
                url: persistUrl,
                dataType: 'json',
                data: JSON.stringify(persistData),
                timeout: App.timeout,
                success: function(){
                  var view = self.get('view');
                  view.loadDecommissionNodesList();
                }
              };
              jQuery.ajax(persistPutAjax);
            },
            error: function(xhr, textStatus, errorThrown){
              console.log(textStatus);
              console.log(errorThrown);
            }
          };
          jQuery.ajax(actionsAjax);
        },
        error: function(xhr, textStatus, errorThrown){
          console.log(textStatus);
          console.log(errorThrown);
        }
      }
      jQuery.ajax(configsAjax);
    },

    /**
     * send command to server to run recommission on DATANODE
     * @param event
     */
    recommission: function(event){
      var self = this;
      var decommissionHostNames = this.get('view.decommissionDataNodeHostNames');
      if (decommissionHostNames == null) {
        decommissionHostNames = [];
      }
      App.showConfirmationPopup(function(){
        var component = event.context;
        // Only HDFS service as of now
        var svcName = component.get('service.serviceName');
        if (svcName === "HDFS") {
          var hostName = self.get('content.hostName');
          var index = decommissionHostNames.indexOf(hostName);
          decommissionHostNames.splice(index, 1);
          self.doDatanodeDecommission(decommissionHostNames, false);
        }
        App.router.get('backgroundOperationsController').showPopup();
      });
    },

    /**
     * Deletion of hosts not supported for this version
     *
     * validateDeletion: function () { var slaveComponents = [ 'DataNode',
     * 'TaskTracker', 'RegionServer' ]; var masterComponents = []; var
     * workingComponents = [];
     *
     * var components = this.get('content.components');
     * components.forEach(function (cInstance) { var cName =
     * cInstance.get('componentName'); if (slaveComponents.contains(cName)) { if
     * (cInstance.get('workStatus') === App.HostComponentStatus.stopped &&
     * !cInstance.get('decommissioned')) { workingComponents.push(cName); } } else {
     * masterComponents.push(cName); } }); // debugger; if
     * (workingComponents.length || masterComponents.length) {
     * this.raiseWarning(workingComponents, masterComponents); } else {
     * this.deleteButtonPopup(); } },
     */

    raiseWarning: function (workingComponents, masterComponents) {
      var self = this;
      var masterString = '';
      var workingString = '';
      if(masterComponents && masterComponents.length) {
        var masterList = masterComponents.join(', ');
        var ml_text = Em.I18n.t('hosts.cant.do.popup.masterList.body');
        masterString = ml_text.format(masterList);
      }
      if(workingComponents && workingComponents.length) {
        var workingList = workingComponents.join(', ');
        var wl_text = Em.I18n.t('hosts.cant.do.popup.workingList.body');
        workingString = wl_text.format(workingList);
      }
      App.ModalPopup.show({
        header: Em.I18n.t('hosts.cant.do.popup.header'),
        html: true,
        body: masterString + workingString,
        primary: Em.I18n.t('ok'),
        secondary: null,
        onPrimary: function() {
          this.hide();
        }
      })
    },

    /**
     * show confirmation popup to delete host
     */
    deleteButtonPopup: function() {
      var self = this;
      App.showConfirmationPopup(function(){
        self.removeHost();
      });
    },

    /**
     * remove host and open hosts page
     */
    removeHost: function () {
      App.router.get('mainHostController').checkRemoved(this.get('content.id'));
      App.router.transitionTo('hosts');
    }

  })
});
window.require.register("controllers/main/mirroring/dataset_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  App.MainMirroringDataSetController = Ember.Controller.extend({
    name: 'mainMirroringDataSetController',

    model: Ember.Object.create(
      {
        newDataSet: null,
        listOfTargetClusterNames: function () {
          var listOfClusterNames = [];
          var listOfTargetClusters = App.TargetCluster.find();
          if (listOfTargetClusters && listOfTargetClusters.content.length) {
            listOfTargetClusters.forEach(function (tcluster) {
              listOfClusterNames.push(tcluster.get('clusterName'));
            });
          }
          return listOfClusterNames;
        }.property('newDataSet.targetCluster'),  // this property will be set when someone clicks the save button

        originalRecord: null,

        isNameError: function (key, value) {
          if (value) {
            return value;
          }
          var controller = App.router.get('mainMirroringDataSetController');
          var isNameError = controller.checkNameErrors();
          return isNameError;
        }.property('newDataSet.name', 'model.newDataSet.name'),

        isSourceDirError: function (key, value) {
          if (value) {
            return value;
          }
          var controller = App.router.get('mainMirroringDataSetController');
          var isSourceDirError = controller.checkSourceDirErrors();
          return isSourceDirError;
        }.property('newDataSet.sourceDir', 'model.newDataSet.sourceDir'),


        isTargetClusterError: function (key, value) {
          if (value) {
            return value;
          }
          var controller = App.router.get('mainMirroringDataSetController');
          var isTargetClusterError = controller.checkTargetClusterErrors();
          return isTargetClusterError;
        }.property('newDataSet.targetCluster', 'model.newDataSet.targetCluster'),

        isTargetDirError: function (key, value) {
          if (value) {
            return value;
          }
          var controller = App.router.get('mainMirroringDataSetController');
          var isTargetDirError = controller.checkTargetDirErrors();
          return isTargetDirError;
        }.property('newDataSet.targetDir', 'model.newDataSet.targetDir'),

        isStartDateError: function (key, value) {
          if (value) {
            return value;
          }
          var controller = App.router.get('mainMirroringDataSetController');
          var isStartDateError = controller.checkStartDateErrors();
          return isStartDateError;
        }.property('newDataSet.schedule.startDate', 'model.newDataSet.schedule.startDate'),

        isEndDateError: function (key, value) {
          if (value) {
            return value;
          }
          var controller = App.router.get('mainMirroringDataSetController');
          var isEndDateError = controller.checkEndDateErrors();
          return isEndDateError;
        }.property('newDataSet.schedule.endDate', 'model.newDataSet.schedule.endDate'),

        isFrequencyError: function (key, value) {
          if (value) {
            return value;
          }
          var controller = App.router.get('mainMirroringDataSetController');
          var isFrequencyError = controller.checkFrequencyErrors();
          return isFrequencyError;
        }.property('newDataSet.schedule.frequency', 'model.newDataSet.schedule.frequency')


      }
    ),

    isSubmitted: null,

    validate: function () {
      var isNameError = this.checkNameErrors();
      var isSourceDirError = this.checkSourceDirErrors();
      var isTargetClusterError = this.checkTargetClusterErrors();
      var isTargetDirError = this.checkTargetDirErrors();
      var isStartDateError = this.checkStartDateErrors();
      var isEndDateError = this.checkEndDateErrors();
      var isFrequencyError = this.checkFrequencyErrors();

      if (isNameError || isSourceDirError || isTargetClusterError || isTargetDirError || isStartDateError || isEndDateError || isFrequencyError) {
        return false;
      }
      return true;
    },

    checkNameErrors: function () {
      if (!this.get('isSubmitted')){
        this.set('nameErrorMessage', "");
        return false;
      }
      var name = this.get('model.newDataSet.name');
      if (!name || name.trim() === "") {
        this.set('model.isNameError', true);
        this.set('nameErrorMessage', Em.I18n.t('mirroring.required.error'));
        return true;
      }
      else {
        this.set('nameErrorMessage', "");
        return false;
      }

    },

    checkSourceDirErrors: function () {
      if (!this.get('isSubmitted')){
        this.set('sourceDirErrorMessage', "");
        return false;
      }
      var sourceDir = this.get('model.newDataSet.sourceDir');
      if (!sourceDir || sourceDir.trim() === "") {
        this.set('model.isSourceDirError', true);
        this.set('sourceDirErrorMessage', Em.I18n.t('mirroring.required.error'));
        return true;
      }
      else {
        this.set('sourceDirErrorMessage', "");
        return false;
      }

    },

    checkTargetClusterErrors: function () {
      if (!this.get('isSubmitted')){
        this.set('targetClusterErrorMessage', "");
        return false;
      }
      var targetCluster = this.get('model.newDataSet.targetCluster.clusterName');
      if (!targetCluster || targetCluster.trim() === "") {
        this.set('model.isTargetClusterError', true);
        this.set('targetClusterErrorMessage', Em.I18n.t('mirroring.required.error'));
        return true;
      }
      else {
        this.set('targetClusterErrorMessage', "");
        return false;
      }


    },
    checkTargetDirErrors: function () {
      if (!this.get('isSubmitted')){
        this.set('targetDirErrorMessage', "");
        return false;
      }
      var targetDir = this.get('model.newDataSet.targetDir');
      if (!targetDir || targetDir.trim() === "") {
        this.set('model.isTargetDirError', true);
        this.set('targetDirErrorMessage', Em.I18n.t('mirroring.required.error'));
        return true;
      }
      else {
        this.set('targetDirErrorMessage', "");
        return false;
      }

    },

    checkStartDateErrors: function () {
      if (!this.get('isSubmitted')){
        this.set('startDateErrorMessage', "");
        return false;
      }
      var startDate = this.get('model.newDataSet.schedule.startDate');
      if (!startDate || startDate.trim() === "") {
        this.set('model.isStartDateError', true);
        this.set('startDateErrorMessage', Em.I18n.t('mirroring.required.error'));
        return true;
      }
      else {
        this.set('startDateErrorMessage', "");
        return false;
      }

    },

    checkEndDateErrors: function () {
      if (!this.get('isSubmitted')){
        this.set('endDateErrorMessage', "");
        return false;
      }
      var startDate = this.get('model.newDataSet.schedule.startDate');
      var endDate = this.get('model.newDataSet.schedule.endDate');
      if (!endDate || endDate.trim() === "") {
        this.set('model.isEndDateError', true);
        this.set('endDateErrorMessage', Em.I18n.t('mirroring.required.error'));
        return true;
      }
      else {

        var sDate = new Date(this.get('model.newDataSet.schedule.startDate'));
        var eDate = new Date(this.get('model.newDataSet.schedule.endDate'));
        if(sDate > eDate){
          this.set('model.isEndDateError', true);
          this.set('endDateErrorMessage', Em.I18n.t('mirroring.dateOrder.error'));
          return true;
        }


        this.set('endDateErrorMessage', "");
        return false;
      }

    },

    checkFrequencyErrors: function () {
      if (!this.get('isSubmitted')){
        this.set('frequencyErrorMessage', "");
        return false;
      }
      var frequency = this.get('model.newDataSet.schedule.frequency');

      if (!frequency || frequency.trim() === "") {
        this.set('model.isFrequencyError', true);
        this.set('frequencyErrorMessage', Em.I18n.t('mirroring.required.error'));
        return true;
      }
      else {

        var startParenthesisindex = frequency.indexOf('(');
        var endParenthesisindex = frequency.indexOf(')');

        if (endParenthesisindex - startParenthesisindex == 1) {
          this.set('model.isFrequencyError', true);
          this.set('frequencyErrorMessage', Em.I18n.t('mirroring.required.error'));
          return true;
        }
        else {
          var frequencyNum = frequency.substring(startParenthesisindex + 1, endParenthesisindex);

          frequencyNum = parseInt(frequencyNum);

          if (isNaN(frequencyNum)) {
            this.set('model.isFrequencyError', true);
            this.set('frequencyErrorMessage', Em.I18n.t('mirroring.required.invalidNumberError'));
            return true;
          }

        }

        this.set('frequencyErrorMessage', "");
        return false;
      }

    },

    nameErrorMessage: null,
    sourceDirErrorMessage: null,
    targetClusterErrorMessage: null,
    targetDirErrorMessage: null,
    startDateErrorMessage: null,
    endDateErrorMessage: null,
    frequencyErrorMessage: null,
    /**
     * Popup with add/edit form
     */
    popup: null,

    /**
     * true - popup with edit form
     * false - popup with add form
     */
    isPopupForEdit: false,

    createNewDataSet: function () {
      var newDataSet = Ember.Object.create({
        name: null,
        sourceDir: null,
        targetCluster: Ember.Object.create(),
        targetDir: null,
        status : 'SCHEDULED',
        schedule: Ember.Object.create()
      });
      this.set('model.newDataSet', newDataSet);
      return newDataSet;
    },

    setDataSet: function (dataset) {
      var newDataSet = Ember.Object.create({
        name: dataset.get('name'),
        sourceDir: dataset.get('sourceDir'),
        targetCluster: dataset.get('targetCluster'),
        targetDir: dataset.get('targetDir'),
        schedule: dataset.get('schedule'),
        status: dataset.get('status')

      });
      this.set('model.newDataSet', newDataSet);
    },

    setOriginalDataSetRecord: function (datasetRecord) {
      this.set('model.originalRecord', datasetRecord);
    },


    getNewDataSet: function () {
      return this.get('model.newDataSet');
    },

    createTargetCluster: function () {
      var controller = App.router.get('mainMirroringTargetClusterController');
      controller.set('returnRoute', App.get('router.currentState.path'));
      App.router.transitionTo('addTargetClusterRoute');
    },

    /**
     * Set old values for all properties in the dataset
     */
    undoChanges: function () {
      this.set('model.newDataSet', this.get('rawDataSet'));
    },

    /**
     * Delete created dataset and its schedule
     */
    deleteNewDataSet: function () {
      var originalRecordSchedule = this.get('model.originalRecord.schedule');
      originalRecordSchedule.deleteRecord();
      originalRecordSchedule.get("transaction").commit();

      var originalRecord = this.get('model.originalRecord');

      originalRecord.deleteRecord();
      originalRecord.get("transaction").commit();
    },

    /**
     * "Delete" button handler
     */
    deleteDatasetClick: function () {
      var self = this;
      App.showConfirmationPopup(function () {
        self.deleteNewDataSet();
        self.get('popup').hide();
        App.router.transitionTo('main.mirroring.index');
      });
    }

  });
});
window.require.register("controllers/main/mirroring/datasets_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainDatasetsController = Em.ArrayController.extend({
    name: 'mainDatasetsController'
  });
  
});
window.require.register("controllers/main/mirroring/jobs_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainJobsController = Em.Controller.extend({
    name: 'mainJobsController',
    jobs: function () {
      return App.DataSetJob.find().filterProperty('dataset', this.get('content'));
    }.property('content'),

    actionDesc: function () {
      var dataset_status = this.get('content.status');
      if (dataset_status === "SCHEDULED") {
        return "Suspend";
      } else {
        return "Schedule";
      }
    }.property('content.status'),

    isScheduled: function () {
      var dataset_status = this.get('content.status');
      return dataset_status === "SCHEDULED";
    }.property('content.status'),

    suspend: function () {
      this.set('content.status', 'SUSPENDED');
    },

    schedule: function () {
      this.set('content.status', 'SCHEDULED');
    }

  });
  
});
window.require.register("controllers/main/mirroring/targetClusterController", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  App.MainMirroringTargetClusterController = Ember.Controller.extend({
    name: 'mainMirroringTargetClusterController',
    model: Ember.Object.create({
      targetCluster: null,
      originalRecord: null,
      isPopupForEdit: false, // set the default to add scenario
      isNameNodeWebUrlError: function (key, value) {
        if (value) {
          return value;
        }
        var controller = App.router.get('mainMirroringTargetClusterController');
        var isNameNodeWebUrlError = controller.checkNameNodeWebUrlErrors();
        return isNameNodeWebUrlError;
      }.property('targetCluster.nameNodeWebUrl', 'model.targetCluster.nameNodeWebUrl'),
      isNameNodeRpcUrlError: function (key, value) {
        if (value) {
          return value;
        }
        var controller = App.router.get('mainMirroringTargetClusterController');
        var isNameNodeRpcUrlError = controller.checkNameNodeRpcUrlErrors();
        return isNameNodeRpcUrlError;
      }.property('targetCluster.nameNodeRpcUrl', 'model.targetCluster.nameNodeRpcUrl'),

      isOozieServerUrlError: function (key, value) {
        if (value) {
          return value;
        }
        var controller = App.router.get('mainMirroringTargetClusterController');
        var isOozieServerUrlError = controller.checkOozieServerUrlErrors();
        return isOozieServerUrlError;
      }.property('targetCluster.oozieServerUrl', 'model.targetCluster.oozieServerUrl'),

      isClusterNameError: function (key, value) {
        if (value) {
          return value;
        }
        var controller = App.router.get('mainMirroringTargetClusterController');
        var isClusterNameError = controller.checkClusterNameErrors();
        return isClusterNameError;
      }.property('targetCluster.clusterName', 'model.targetCluster.clusterName'),

      nameNodeWebUrlErrorMessage: null,
      nameNodeRpcUrlErrorMessage: null,
      oozieServerUrlErrorMessage: null,
      clusterNameErrorMessage: null
    }),

    isSubmitted1: null,
    isSubmitted2: null,

    validate1: function () {
      var isNameNodeWebUrlError = this.checkNameNodeWebUrlErrors();
      var isNameNodeRpcUrlError = this.checkNameNodeRpcUrlErrors();
      var isOozieServerUrlError = this.checkOozieServerUrlErrors();

      if (isNameNodeWebUrlError || isNameNodeRpcUrlError || isOozieServerUrlError) {
        return false;
      }
      return true;
    },

    validate2: function () {
      var isClusterNameError = this.checkClusterNameErrors();

      if (isClusterNameError) {
        return false;
      }
      return true;
    },

    checkNameNodeWebUrlErrors: function () {
      if (!this.get('isSubmitted1')){
        this.set('model.nameNodeWebUrlErrorMessage', "");
        return false;
      }
      var nameNodeWebUrl = this.get('model.targetCluster.nameNodeWebUrl');
      if (!nameNodeWebUrl || nameNodeWebUrl.trim() === "") {
        this.set('model.isNameNodeWebUrlError', true);
        this.set('model.nameNodeWebUrlErrorMessage', Em.I18n.t('mirroring.required.error'));
        return true;
      }
      else {
        this.set('model.nameNodeWebUrlErrorMessage', "");
        return false;
      }

    },

    checkNameNodeRpcUrlErrors: function () {
      if (!this.get('isSubmitted1')){
        this.set('model.nameNodeRpcUrlErrorMessage', "");
        return false;
      }
      var nameNodeRpcUrl = this.get('model.targetCluster.nameNodeRpcUrl');
      if (!nameNodeRpcUrl || nameNodeRpcUrl.trim() === "") {
        this.set('model.isNameNodeRpcUrlError', true);
        this.set('model.nameNodeRpcUrlErrorMessage', Em.I18n.t('mirroring.required.error'));
        return true;
      }
      else {
        this.set('model.nameNodeRpcUrlErrorMessage', "");
        return false;
      }

    },

    checkOozieServerUrlErrors: function () {
      if (!this.get('isSubmitted1')){
        this.set('model.oozieServerUrlErrorMessage', "");
        return false;
      }
      var oozieServerUrl = this.get('model.targetCluster.oozieServerUrl');
      if (!oozieServerUrl || oozieServerUrl.trim() === "") {
        this.set('model.isOozieServerUrlError', true);
        this.set('model.oozieServerUrlErrorMessage', Em.I18n.t('mirroring.required.error'));
        return true;
      }
      else {
        this.set('model.oozieServerUrlErrorMessage', "");
        return false;
      }

    },

    checkClusterNameErrors: function () {
      if (!this.get('isSubmitted1')){
        this.set('model.clusterNameErrorMessage', "");
        return false;
      }
      var clusterName = this.get('model.targetCluster.clusterName');
      if (!clusterName || clusterName.trim() === "") {
        this.set('model.isClusterNameError', true);
        this.set('model.clusterNameErrorMessage', Em.I18n.t('mirroring.required.error'));
        return true;
      }
      else {
        this.set('model.clusterNameErrorMessage', "");
        return false;
      }

    },

    setOriginalRecord: function (targetClusterRecord) {
      this.set('model.originalRecord', targetClusterRecord);
    },

    setTargetCluster: function (targetClusterRecord) {
      var targetCluster = Ember.Object.create({
        id: targetClusterRecord.get('id'),
        clusterName: targetClusterRecord.get('clusterName'),
        nameNodeWebUrl: targetClusterRecord.get('nameNodeWebUrl'),
        nameNodeRpcUrl: targetClusterRecord.get('nameNodeRpcUrl'),
        oozieServerUrl: targetClusterRecord.get('oozieServerUrl')
      });

      this.set('model.targetCluster', targetCluster);
    },


    createTargetCluster: function () {
      var targetCluster = Ember.Object.create({
        clusterName: null,
        nameNodeWebUrl: null,
        nameNodeRpcUrl: null,
        oozieServerUrl: null
      });
      this.set('model.targetCluster', targetCluster);
      return targetCluster;

      /* For future (but on record objects , not on pojos):
       targetCluster.on('didUpdate', function() {
       console.log("------Updated!");
       });
       targetCluster.on('didDelete', function() {
       console.log("------Deleted!");
       });
       targetCluster.on('didCreate', function() {
       console.log("------Created!");
       });
       */

    },
    getTargetCluster: function () {
      return this.get('content.targetCluster');
    },

    popup: null,

    /**
     * "Delete" button handler.
     * A DataSet
     */
    deleteTargetCluster: function () {
      var self = this;
      App.showConfirmationPopup(function () {
        var originalRecord = self.get('model.originalRecord');
        originalRecord.deleteRecord();
        originalRecord.get("transaction").commit();
        self.get('popup').hide();
        App.router.transitionTo('main.mirroring.index');
      });
    }



  });
});
window.require.register("controllers/main/mirroring/testConnectionResults_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  App.TestConnectionResultsController = Ember.Controller.extend({
    name: 'testConnectionResultsController',

    connectStatuses: [
      Ember.Object.create({
        type: 'readonly',
        isConnectionSuccess: false
      }),
      Ember.Object.create({
        type: 'write',
        isConnectionSuccess: false
      }),
      Ember.Object.create({
        type: 'workflow',
        isConnectionSuccess: false
      })

    ],

    isNameNodeWebUIConnected: function () {
      var connectStatus = this.get('connectStatuses').findProperty('type', 'readonly');
      return connectStatus.get('isConnectionSuccess');
    }.property('connectStatuses.@each.isConnectionSuccess'),

    isNameNodeRpcConnected: function () {
      var connectStatus = this.get('connectStatuses').findProperty('type', 'write');
      return connectStatus.get('isConnectionSuccess');
    }.property('connectStatuses.@each.isConnectionSuccess'),

    isOozieServerConnected: function () {
      var connectStatus = this.get('connectStatuses').findProperty('type', 'workflow');
      return connectStatus.get('isConnectionSuccess');
    }.property('connectStatuses.@each.isConnectionSuccess'),

    isConnectionSuccessful: function () {
      return this.get('isNameNodeWebUIConnected') && this.get('isNameNodeRpcConnected') && this.get('isOozieServerConnected');
    }.property('isNameNodeWebUIConnected', 'isNameNodeRpcConnected', 'isOozieServerConnected'),

    shouldBeDisabled: function () {
      return !this.get('isConnectionSuccessful');
    }.property('isConnectionSuccessful'),

    mockDataPrefix: '/data/mirroring/poll/',

    tryConnecting: function () {
      var types = ["readonly", "write", "workflow"];
      var arrayOfPollData = ["testConnection_poll1", "testConnection_poll2", "testConnection_poll3", "testConnection_poll4"];

      var shouldContinuePolling = true;

      var poll_count = 0;

      var interval_id = 0;

      var self = this;

      var connect = function () {
        var method = 'GET';
        console.debug('poll_count : ' + poll_count);
        var url = self.get('mockDataPrefix') + arrayOfPollData[poll_count++] + ".json";
        $.ajax({
          type: method,
          url: url,
          async: true, // shd be chnaged to true
          data: null, // temporarily .this depends upon what the api is expecting.
          dataType: 'text',
          timeout: App.timeout,
          success: function (data) {
            var jsonData = jQuery.parseJSON(data);
            var connectStatuses = self.get('connectStatuses');
            jsonData.tasks.forEach(function (task) {
              var type = task.Tasks.type;
              var status = task.Tasks.status;
              var connectStatus = connectStatuses.findProperty("type", type);
              connectStatus.set('isConnectionSuccess', status === "SUCCESS");
            });

            var totalNum = connectStatuses.length;
            var succeededStatuses = connectStatuses.filterProperty("isConnectionSuccess", true);
            var succeededNum = succeededStatuses.length;

            if (totalNum == succeededNum) {
              clearInterval(interval_id);
              console.debug('Cleared function id ' + interval_id);
            }
            else {
              clearInterval(interval_id);
              console.debug('Cleared function id ' + interval_id + "totalNum : " + totalNum + ', succeededNum : ' + succeededNum);
              interval_id = setInterval(connect, 100);
              console.debug('Generated function id ' + interval_id);
            }

          }
        });
      };

      connect();
    },

    saveClusterName: function () {
      var targetCluster = this.get('content.targetCluster');
      var isEditing = this.get('content.isPopupForEdit');
      if (isEditing) {
        var targetClusterRecord = this.get('content.originalRecord');
        var targetClusterEdited = this.get('content.targetCluster');

        targetClusterRecord.set('id', targetClusterEdited.get('id'));
        targetClusterRecord.set('clusterName', targetClusterEdited.get('clusterName'));
        targetClusterRecord.set('nameNodeWebUrl', targetClusterEdited.get('nameNodeRpcUrl'));
        targetClusterRecord.set('nameNodeRpcUrl', targetClusterEdited.get('id'));
        targetClusterRecord.set('oozieServerUrl', targetClusterEdited.get('oozieServerUrl'));


      } else {
        var targetClusterRecord = App.TargetCluster.createRecord(targetCluster);

        // refresh main page model
        var mainMirroringController = App.router.get('mainMirroringController');
        mainMirroringController.notifyPropertyChange("targetClusters");

        // refresh add/edit dataset model
        var addDataSetController = App.router.get('mainMirroringDataSetController');
        var dataSet = addDataSetController.get('model.newDataSet');
        if (dataSet)  // this may be undefined or null if we try to add cluster from main page. Hence the if check.
          dataSet.set('targetCluster', targetClusterRecord);
      }

      var popup = this.get('controllers.mainMirroringTargetClusterController.popup');
      popup.hide();
    }






  });
});
window.require.register("controllers/main/mirroring/testConnection_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  App.TestConnectionController = Ember.Controller.extend({
    name:'testConnectionController'


  });
});
window.require.register("controllers/main/mirroring_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainMirroringController = Em.ArrayController.extend({
    name: 'mainMirroringController',

    datasets: function () {
      return App.Dataset.find();
    }.property(),

    targetClusters: function () {
      return App.TargetCluster.find();
    }.property()

  });
  
});
window.require.register("controllers/main/service", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainServiceController = Em.ArrayController.extend({
    name:'mainServiceController',
    content: function(){
      if(!App.router.get('clusterController.isLoaded')){
        return [];
      }
      return App.Service.find();
    }.property('App.router.clusterController.isLoaded'),

    cluster: function () {
      if (!App.router.get('clusterController.isLoaded')) {
        return null;
      }
      return App.Cluster.find().objectAt(0);
    }.property('App.router.clusterController.isLoaded'),

    isStartAllDisabled: function(){
      if(this.get('isStartStopAllClicked') == true) {
        return true;
      }
      var stoppedServiceLength = this.get('content').filterProperty('healthStatus','red').length;
      return (stoppedServiceLength === 0); // all green status
    }.property('isStartStopAllClicked', 'content.@each.healthStatus'),
    isStopAllDisabled: function(){
      if(this.get('isStartStopAllClicked') == true) {
        return true;
      }
      var startedService = this.get('content').filterProperty('healthStatus','green');
      var flag = true;
      startedService.forEach(function(item){
        if(!['HCATALOG', 'PIG', 'SQOOP'].contains(item.get('serviceName'))){
          flag = false;
        }
      })
      return flag;
    }.property('isStartStopAllClicked', 'content.@each.healthStatus'),
    isStartStopAllClicked: function(){
      return (App.router.get('backgroundOperationsController').get('allOperationsCount') !== 0);
    }.property('App.router.backgroundOperationsController.allOperationsCount'),

    /**
     * callback for <code>start all service</code> button
     */
    startAllService: function(event){
      if ($(event.target).hasClass('disabled') || $(event.target.parentElement).hasClass('disabled')) {
        return;
      }
      var self = this;
      App.showConfirmationPopup(function() {
        self.allServicesCall('startAllService');
      });
    },

    /**
     * callback for <code>stop all service</code> button
     */
    stopAllService: function(event){
      if ($(event.target).hasClass('disabled') || $(event.target.parentElement).hasClass('disabled')) {
        return;
      }
      var self = this;
      App.showConfirmationPopup(function() {
        self.allServicesCall('stopAllService');
      });
    },

    allServicesCall: function(state) {
      var data;
      if(state == 'stopAllService') {
        data = '{"RequestInfo": {"context" :"'+ Em.I18n.t('requestInfo.stopAllServices') +'"}, "Body": {"ServiceInfo": {"state": "INSTALLED"}}}';
      }
      else {
        data = '{"RequestInfo": {"context" :"'+ Em.I18n.t('requestInfo.startAllServices') +'"}, "Body": {"ServiceInfo": {"state": "STARTED"}}}';
      }

      App.ajax.send({
        name: 'service.start_stop',
        sender: this,
        data: {
          data: data
        },
        success: 'allServicesCallSuccessCallback',
        error: 'allServicesCallErrorCallback'
      });
    },

    allServicesCallSuccessCallback: function(data) {
      console.log("TRACE: Start/Stop all service -> In success function for the start/stop all Service call");
      console.log("TRACE: Start/Stop all service -> value of the received data is: " + data);
      var requestId = data.Requests.id;
      console.log('requestId is: ' + requestId);

      App.router.get('backgroundOperationsController').showPopup();
    },
    allServicesCallErrorCallback: function() {
      console.log("ERROR");
    }
  })
  
});
window.require.register("controllers/main/service/add_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.AddServiceController = App.WizardController.extend({

    name: 'addServiceController',

    totalSteps: 7,

    /**
     * Used for hiding back button in wizard
     */
    hideBackButton: true,

    /**
     * All wizards data will be stored in this variable
     *
     * cluster - cluster name
     * installOptions - ssh key, repo info, etc.
     * services - services list
     * hosts - list of selected hosts
     * slaveComponentHosts, - info about slave hosts
     * masterComponentHosts - info about master hosts
     * config??? - to be described later
     */
    content: Em.Object.create({
      cluster: null,
      hosts: null,
      installOptions: null,
      services: null,
      slaveComponentHosts: null,
      masterComponentHosts: null,
      serviceConfigProperties: null,
      advancedServiceConfig: null,
      controllerName: 'addServiceController'
    }),

    /**
     * return new object extended from clusterStatusTemplate
     * @return Object
     */
    getCluster: function(){
      return jQuery.extend({}, this.get('clusterStatusTemplate'), {name: App.router.getClusterName()});
    },

    /**
     * Load confirmed hosts.
     * Will be used at <code>Assign Masters(step5)</code> step
     */
    loadConfirmedHosts: function(){
      var hosts = App.db.getHosts();
      if(!hosts){
        var hosts = {};

        App.Host.find().forEach(function(item){
          hosts[item.get('id')] = {
            name: item.get('id'),
            cpu: item.get('cpu'),
            memory: item.get('memory'),
            disk_info: item.get('diskInfo'),
            bootStatus: "REGISTERED",
            isInstalled: true
          };
        });
        App.db.setHosts(hosts);
      }

      this.set('content.hosts', hosts);
      console.log('AddServiceController.loadConfirmedHosts: loaded hosts', hosts);
    },

    /**
     * Load services data from server.
     */
    loadServicesFromServer: function() {
      if(App.db.getService()){
        return;
      }
      var displayOrderConfig = require('data/services');
      var apiUrl = App.get('stack2VersionURL');
      var apiService = this.loadServiceComponents(displayOrderConfig, apiUrl);
      //
      apiService.forEach(function(item, index){
        apiService[index].isSelected = App.Service.find().someProperty('id', item.serviceName);
        apiService[index].isDisabled = apiService[index].isSelected;
        apiService[index].isInstalled = apiService[index].isSelected;
      });
      this.set('content.services', apiService);
      App.db.setService(apiService);
    },

    /**
     * Load services data. Will be used at <code>Select services(step4)</code> step
     */
    loadServices: function () {
      var servicesInfo = App.db.getService();
      servicesInfo.forEach(function (item, index) {
        servicesInfo[index] = Em.Object.create(item);
      });
      this.set('content.services', servicesInfo);
      console.log('AddServiceController.loadServices: loaded data ', servicesInfo);

      var serviceNames = servicesInfo.filterProperty('isSelected', true).filterProperty('isDisabled', false).mapProperty('serviceName');
      console.log('selected services ', serviceNames);

      this.set('content.skipSlavesStep', !serviceNames.contains('MAPREDUCE') && !serviceNames.contains('HBASE'));
    },

    /**
     * Save data to model
     * @param stepController App.WizardStep4Controller
     */
    saveServices: function (stepController) {var serviceNames = [];
      App.db.setService(stepController.get('content'));
      console.log('AddServiceController.saveServices: saved data', stepController.get('content'));
      stepController.filterProperty('isSelected', true).filterProperty('isInstalled', false).forEach(function (item) {
        serviceNames.push(item.serviceName);
      });
      this.set('content.selectedServiceNames', serviceNames);
      App.db.setSelectedServiceNames(serviceNames);
      console.log('AddServiceController.selectedServiceNames:', serviceNames);

      this.set('content.skipSlavesStep', !serviceNames.contains('MAPREDUCE') && !serviceNames.contains('HBASE'));
    },

    /**
     * Save Master Component Hosts data to Main Controller
     * @param stepController App.WizardStep5Controller
     */
    saveMasterComponentHosts: function (stepController) {
      var obj = stepController.get('selectedServicesMasters');
      var masterComponentHosts = [];
      var installedComponents = App.HostComponent.find();

      obj.forEach(function (_component) {
          masterComponentHosts.push({
            display_name: _component.display_name,
            component: _component.component_name,
            hostName: _component.selectedHost,
            serviceId: _component.serviceId,
            isInstalled: installedComponents.someProperty('componentName', _component.component_name)
          });
      });

      console.log("AddServiceController.saveMasterComponentHosts: saved hosts ", masterComponentHosts);
      App.db.setMasterComponentHosts(masterComponentHosts);
      this.set('content.masterComponentHosts', masterComponentHosts);

      this.set('content.skipMasterStep', this.get('content.masterComponentHosts').everyProperty('isInstalled', true));
    },

    /**
     * Load master component hosts data for using in required step controllers
     */
    loadMasterComponentHosts: function () {
      var masterComponentHosts = App.db.getMasterComponentHosts();
      if(!masterComponentHosts){
        masterComponentHosts = [];
        App.HostComponent.find().filterProperty('isMaster', true).forEach(function(item){
          masterComponentHosts.push({
            component: item.get('componentName'),
            hostName: item.get('host.hostName'),
            isInstalled: true
          })
        });

      }
      this.set("content.masterComponentHosts", masterComponentHosts);
      console.log("AddServiceController.loadMasterComponentHosts: loaded hosts ", masterComponentHosts);

      this.set('content.skipMasterStep', this.get('content.masterComponentHosts').everyProperty('isInstalled', true));
    },

    /**
     * return slaveComponents bound to hosts
     * @return {Array}
     */
    getSlaveComponentHosts: function () {
      var components = [{
        name : 'DATANODE',
        service : 'HDFS'
      },
      {
        name: 'TASKTRACKER',
        service: 'MAPREDUCE'
      },{
        name: 'HBASE_REGIONSERVER',
        service: 'HBASE'
      }];

      var result = [];
      var services = App.Service.find();
      var selectedServices = this.get('content.services').filterProperty('isSelected', true).mapProperty('serviceName');
      for(var index=0; index < components.length; index++){
        var comp = components[index];
        if(!selectedServices.contains(comp.service)){
          continue;
        }


        var service = services.findProperty('id', comp.service);
        var hosts = [];

        if(!service){
          service = services.findProperty('id', 'HDFS');
          service.get('hostComponents').filterProperty('componentName', 'DATANODE').forEach(function (host_component) {
            hosts.push({
              group: "Default",
              hostName: host_component.get('host.id'),
              isInstalled: false
            });
          }, this);
        } else {
          service.get('hostComponents').filterProperty('componentName', comp.name).forEach(function (host_component) {
            hosts.push({
              group: "Default",
              hostName: host_component.get('host.id'),
              isInstalled: true
            });
          }, this);
        }

        result.push({
          componentName: comp.name,
          displayName: App.format.role(comp.name),
          hosts: hosts
        })
      }

      var clientsHosts = App.HostComponent.find().filterProperty('componentName', 'HDFS_CLIENT');
      var hosts = [];

      clientsHosts.forEach(function (host_component) {
          hosts.push({
            group: "Default",
            hostName: host_component.get('host.id'),
            isInstalled: true
          });
      }, this);

      result.push({
        componentName: 'CLIENT',
        displayName: 'client',
        hosts: hosts
      })

      return result;
    },

    /**
     * Load master component hosts data for using in required step controllers
     */
    loadSlaveComponentHosts: function () {
      var slaveComponentHosts = App.db.getSlaveComponentHosts();
      if(!slaveComponentHosts){
        slaveComponentHosts = this.getSlaveComponentHosts();
      }
      this.set("content.slaveComponentHosts", slaveComponentHosts);
      console.log("AddServiceController.loadSlaveComponentHosts: loaded hosts ", slaveComponentHosts);
    },

    /**
     * Load information about hosts with clients components
     */
    loadClients: function(){
      var clients = App.db.getClientsForSelectedServices();
      this.set('content.clients', clients);
      console.log("AddServiceController.loadClients: loaded list ", clients);
    },

    /**
     * Generate clients list for selected services and save it to model
     * @param stepController step4WizardController
     */
    saveClients: function(stepController){
      var clients = [];
      var serviceComponents = require('data/service_components');
      var hostComponents = App.HostComponent.find();

      stepController.get('content').filterProperty('isSelected',true).forEach(function (_service) {
        var client = serviceComponents.filterProperty('service_name', _service.serviceName).findProperty('isClient', true);
        if (client) {
          clients.pushObject({
            component_name: client.component_name,
            display_name: client.display_name,
            isInstalled: hostComponents.filterProperty('componentName', client.component_name).length > 0
          });
        }
      }, this);

      App.db.setClientsForSelectedServices(clients);
      this.set('content.clients', clients);
      console.log("AddServiceController.saveClients: saved list ", clients);
    },

    /**
     * Load data for all steps until <code>current step</code>
     */
    loadAllPriorSteps: function () {
      var step = this.get('currentStep');
      switch (step) {
        case '7':
        case '6':
        case '5':
          this.load('cluster');
        case '4':
          this.loadServiceConfigProperties();
        case '3':
          this.loadServices();
          this.loadClients();
          this.loadSlaveComponentHosts();//depends on loadServices
        case '2':
          this.loadMasterComponentHosts();
          this.loadConfirmedHosts();
        case '1':
          this.loadServices();
      }
    },

    /**
     * Remove all loaded data.
     * Created as copy for App.router.clearAllSteps
     */
    clearAllSteps: function () {
      this.clearInstallOptions();
      // clear temporary information stored during the install
      this.set('content.cluster', this.getCluster());
    },

    /**
     * Clear all temporary data
     */
    finish: function () {
      this.setCurrentStep('1');
      this.clearAllSteps();
      this.clearStorageData();
      App.router.get('updateController').updateAll();
    }

  });
  
});
window.require.register("controllers/main/service/info/audit", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainServiceInfoAuditController = Em.Controller.extend({
    name: 'mainServiceInfoAuditController'
  });
});
window.require.register("controllers/main/service/info/configs", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  require('controllers/wizard/slave_component_groups_controller');

  App.MainServiceInfoConfigsController = Em.Controller.extend({
    name: 'mainServiceInfoConfigsController',
    dataIsLoaded: false,
    stepConfigs: [], //contains all field properties that are viewed in this service
    selectedService: null,
    serviceConfigTags: null,
    globalConfigs: [],
    uiConfigs: [],
    customConfig: [],
    isApplyingChanges: false,
    serviceConfigs: function(){
      return App.config.get('preDefinedServiceConfigs');
    }.property('App.config.preDefinedServiceConfigs'),
    configMapping: function(){
      return App.config.get('configMapping');
    }.property('App.config.configMapping'),
    customConfigs: require('data/custom_configs'),
    configs: function() {
      return  App.config.get('preDefinedConfigProperties');
    }.property('App.config.preDefinedConfigProperties'),

    secureConfigs: require('data/secure_mapping'),

    
    /**
     * During page load time, we get the host overrides from the server.
     * The current host -> site:tag map is stored below. This will be 
     * useful during save, so that removals can also be determined.
     * 
     * Example:
     * {
     *  'hostname1':{
     *    'global': 'version1',
     *    'core-site': 'version1',
     *    'hdfs-site', 'tag3187261938'
     *  }
     * } 
     *  
     * @see savedHostToOverrideSiteToTagMap
     */
    loadedHostToOverrideSiteToTagMap: {},

    /**
     * During page load time the cluster level site to tag
     * mapping is stored here.
     *
     * Example:
     * {
     *  'global': 'version1',
     *  'hdfs-site': 'version1',
     *  'core-site': 'version1'
     * }
     */
    loadedClusterSiteToTagMap: {},

    /**
     * During page save time, we set the host overrides to the server.
     * The new host -> site:tag map is stored below. This will be 
     * useful during save, to update the host's host components. Also,
     * it will be useful in deletion of overrides.
     * 
     * Example:
     * {
     *  'hostname1': {
     *    'global': {
     *      'tagName': 'tag3187261938_hostname1',
     *      'map': {
     *        'hadoop_heapsize': '2048m'
     *      }
     *    }
     *  }
     * }
     * 
     * @see loadedHostToOverrideSiteToTagMap
     */
    savedHostToOverrideSiteToTagMap: {},

    /**
     * Holds the actual base service-config server data uploaded.
     * This is used by the host-override mechanism to update host
     * specific values.
     */
    savedSiteNameToServerServiceConfigDataMap: {},
    
    isSubmitDisabled: function () {
      return (!(this.stepConfigs.everyProperty('errorCount', 0)) || this.get('isApplyingChanges'));
    }.property('stepConfigs.@each.errorCount', 'isApplyingChanges'),

    slaveComponentGroups: null,

    /**
     * Filter text will be located here
     */
    filter: '',

    /**
     * Dropdown menu items in filter compbobox
     */
    filterColumns: function(){
      var result = [];
      for(var i = 1; i<4; i++){
        result.push(Ember.Object.create({
          name: this.t('common.combobox.dropdown.' + i),
          selected: false
        }));
      }
      return result;
    }.property(),

    /**
     * clear and set properties to default value
     */
    clearStep: function () {
      this.set('dataIsLoaded', false);
      this.set('filter', '');
      this.get('filterColumns').setEach('selected', false);
      this.get('stepConfigs').clear();
      this.get('globalConfigs').clear();
      this.get('uiConfigs').clear();
      this.get('customConfig').clear();
      this.set('loadedHostToOverrideSiteToTagMap', {});
      this.set('savedHostToOverrideSiteToTagMap', {});
      this.set('savedSiteNameToServerServiceConfigDataMap', {});
      if (this.get('serviceConfigTags')) {
        this.set('serviceConfigTags', null);
      }
    },

    serviceConfigProperties: function () {
      return App.db.getServiceConfigProperties();
    }.property('content'),

    /**
     * On load function
     */
    loadStep: function () {
      console.log("TRACE: Loading configure for service");
      this.clearStep();
      this.loadServiceConfigs();
    },

    /**
     * Loads the actual configuration of all host components. 
     * This helps in determining which services need a restart, and also
     * in showing which properties are actually applied or not. 
     * This method also compares the actual_configs with the desired_configs
     * and builds a diff structure.
     * 
     * Internall it calculates an array of host-components which need restart.
     * Example:
     * [
     *  {
     *    componentName: 'DATANODE',
     *    serviceName: 'HDFS',
     *    host: 'host.name',
     *    type: 'core-site',
     *    desiredConfigTags: {tag:'version1'},
     *    actualConfigTags: {tag:'version4'. host_override:'version2'}
     *  },
     *  ...
     * ]
     * 
     * From there it return the following restart-data for this service.
     * It represents the hosts, whose components need restart, and the
     * properties which require restart.
     * 
     * {
     *  hostAndHostComponents: {
     *   'hostname1': {
     *     'DATANODE': {
     *       'property1': 'value1',
     *       'property2': 'value2'
     *     },
     *     'TASKTRACKER': {
     *       'prop1': 'val1'
     *     }
     *    },
     *    'hostname6': {
     *     'ZOOKEEPER': {
     *       'property1': 'value3'
     *     }
     *    }
     *  },
     *  propertyToHostAndComponent: {
     *    'property1': {
     *      'hostname1': ['DATANODE'],
     *      'hostname6': ['ZOOKEEPER']
     *    },
     *    'property2': {
     *      'hostname1': ['DATANODE']
     *    },
     *    'prop1': {
     *      'hostname1': ['TASKTRACKER']
     *    }
     *  }
     * }
     */
    loadActualConfigsAndCalculateRestarts: function () {
      var currentService = this.get('content.serviceName');
      var restartData = {
          hostAndHostComponents: {},
          propertyToHostAndComponent: {}
      };
      var self = this;
      var actualConfigsUrl = this.getUrl('/data/services/host_component_actual_configs.json', '/services?fields=components/host_components/HostRoles/actual_configs');
      $.ajax({
        type: 'GET',
        url: actualConfigsUrl,
        async: false,
        timeout: 10000,
        dataType: 'json',
        success: function (data) {
          var diffHostComponents = [];
          console.debug("loadActualConfigs(" + actualConfigsUrl + "): Data=", data);
          var configsToDownload = [];
          data.items.forEach(function (service) {
            // For current service, do any of the host_components differ in
            // configuration?
            if (currentService === service.ServiceInfo.service_name) {
              service.components.forEach(function (serviceComponent) {
                serviceComponent.host_components.forEach(function (hostComponent) {
                  if (hostComponent.HostRoles.actual_configs) {
                    for ( var site in hostComponent.HostRoles.actual_configs) {
                      var actualConfigsTags = hostComponent.HostRoles.actual_configs[site];
                      var desiredConfigTags = self.getDesiredConfigTag(site, hostComponent.HostRoles.host_name);
                      if (desiredConfigTags.tag !== actualConfigsTags.tag || 
                          (desiredConfigTags.host_override != null && 
                              actualConfigsTags.host_override != null && 
                              desiredConfigTags.host_override !== actualConfigsTags.host_override)) {
                        // Restart may be necessary for this host-component
                        diffHostComponents.push({
                          componentName: hostComponent.HostRoles.component_name,
                          serviceName: serviceComponent.ServiceComponentInfo.service_name,
                          host: hostComponent.HostRoles.host_name,
                          type: site,
                          desiredConfigTags: desiredConfigTags,
                          actualConfigTags: actualConfigsTags
                        });
                        self.addConfigDownloadParam(site, actualConfigsTags.tag, configsToDownload);
                        self.addConfigDownloadParam(site, actualConfigsTags.host_override, configsToDownload);
                        self.addConfigDownloadParam(site, desiredConfigTags.tag, configsToDownload);
                        self.addConfigDownloadParam(site, desiredConfigTags.host_override, configsToDownload);
                      }
                    }
                  }
                });
              });
            }
          });
          if (configsToDownload.length > 0) {
            var url = self.getUrl('/data/configurations/cluster_level_actual_configs.json?' + configsToDownload.join('|'), '/configurations?' + configsToDownload.join('|'));
            $.ajax({
              type: 'GET',
              url: url,
              async: false,
              timeout: 10000,
              dataType: 'json',
              success: function (data) {
                console.log("configsToDownload(): In success for ", url);
                if (data.items) {
                  data.items.forEach(function (item) {
                    App.config.loadedConfigurationsCache[item.type + "_" + item.tag] = item.properties;
                  });
                }
              },
              error: function (request, ajaxOptions, error) {
                console.log("TRACE: In error function for the configsToDownload call");
                console.log("TRACE: value of the url is: " + url);
                console.log("TRACE: error code status is: " + request.status);
              },
              statusCode: require('data/statusCodes')
            });
          }
          // Now all the configurations are loaded.
          // Find the diff in properties
          if (diffHostComponents.length > 0) {
            diffHostComponents.forEach(function (diffHostComponent) {
              var actualConfigs = App.config.loadedConfigurationsCache[diffHostComponent.type + "_" + diffHostComponent.actualConfigTags.tag];
              var desiredConfigs = App.config.loadedConfigurationsCache[diffHostComponent.type + "_" + diffHostComponent.desiredConfigTags.tag];
              var diffs = self.getConfigDifferences(actualConfigs, desiredConfigs);
              if (!jQuery.isEmptyObject(diffs)) {
                var skip = false;
                if (diffHostComponent.type == 'global') {
                  if(!App.config.isServiceEffectedByGlobalChange(
                      diffHostComponent.serviceName, 
                      diffHostComponent.desiredConfigTags.tag, 
                      diffHostComponent.actualConfigTags.tag)){
                    skip = true;
                  }
                }
                if(!skip){
                  // Populate restartData.hostAndHostComponents
                  if (!(diffHostComponent.host in restartData.hostAndHostComponents)) {
                    restartData.hostAndHostComponents[diffHostComponent.host] = {};
                  }
                  if (!(diffHostComponent.componentName in restartData.hostAndHostComponents[diffHostComponent.host])) {
                    restartData.hostAndHostComponents[diffHostComponent.host][diffHostComponent.componentName] = {};
                  }
                  jQuery.extend(restartData.hostAndHostComponents[diffHostComponent.host][diffHostComponent.componentName], diffs);

                  // Populate restartData.propertyToHostAndComponent
                  for ( var diff in diffs) {
                    if (!(diff in restartData.propertyToHostAndComponent)) {
                      restartData.propertyToHostAndComponent[diff] = {};
                    }
                    if (!(diffHostComponent.host in restartData.propertyToHostAndComponent[diff])) {
                      restartData.propertyToHostAndComponent[diff][diffHostComponent.host] = [];
                    }
                    if (!(restartData.propertyToHostAndComponent[diff][diffHostComponent.host].contains(diffHostComponent.componentName))) {
                      restartData.propertyToHostAndComponent[diff][diffHostComponent.host].push(diffHostComponent.componentName);
                    }
                  }
                }
              }
            });
          }
          console.log("loadActualConfigs(): Finished loading. Restart host components = ", diffHostComponents);
        },
        error: function (request, ajaxOptions, error) {
          console.log("loadActualConfigs(): URL:" + actualConfigsUrl + ". Status:", request.status, ", Error:", error);
        },
        statusCode: require('data/statusCodes')
      });
      console.log("loadActualConfigsAndCalculateRestarts(): Restart data = ", restartData);
      return restartData;
    },
    
    /**
     * Determines the differences between desired and actual configs and returns
     * them as an object. The key is the property, and value is actual_config.
     */
    getConfigDifferences: function (actualConfigs, desiredConfigs) {
      var differences = {};
      if (actualConfigs != null && desiredConfigs != null) {
        for(var desiredProp in desiredConfigs){
          if(desiredConfigs[desiredProp] !== actualConfigs[desiredProp]){
            differences[desiredProp] = actualConfigs[desiredProp];
          }
        }
      }
      return differences;
    },
    
    addConfigDownloadParam: function(site, tag, configsToDownload){
      if(tag!=null && !(site+"_"+tag in App.config.loadedConfigurationsCache)){
        var configParam = "(type="+site+"&tag="+tag+")";
        if(!configsToDownload.contains(configParam)){
          configsToDownload.push(configParam);
        }
      }
    },
    
    getDesiredConfigTag: function(site, hostName){
      var tag = {tag: this.loadedClusterSiteToTagMap[site], host_override: null};
      if(hostName in this.loadedHostToOverrideSiteToTagMap){
        var map = this.loadedHostToOverrideSiteToTagMap[hostName];
        if(site in map){
          tag.host_overrides = map[site];
        }
      }
      return tag;
    },

    /**
     * Loads service configurations
     */
    loadServiceConfigs: function () {
      App.ajax.send({
        name: 'config.tags',
        sender: this,
        data: {
          serviceName: this.get('content.serviceName'),
          serviceConfigsDef: this.get('serviceConfigs').findProperty('serviceName', this.get('content.serviceName'))
        },
        success: 'loadServiceTagsSuccess'
      });
    },

    loadServiceTagsSuccess: function(data, opt, params){
      var serviceConfigsDef = params.serviceConfigsDef;
      var serviceName = this.get('content.serviceName');
      console.debug("loadServiceConfigs(): data=", data);

      this.loadedClusterSiteToTagMap = {};
      //STEP 1: handle tags from JSON data
      for ( var site in data.Clusters.desired_configs) {
        if (serviceConfigsDef.sites.indexOf(site) > -1) {
          this.loadedClusterSiteToTagMap[site] = data.Clusters.desired_configs[site]['tag'];
          var overrides = data.Clusters.desired_configs[site].host_overrides;
          if (overrides) {
            overrides.forEach(function (override) {
              var hostname = override.host_name;
              var tag = override.tag;
              if(!this.loadedHostToOverrideSiteToTagMap[hostname]){
                this.loadedHostToOverrideSiteToTagMap[hostname] = {};
              }
              this.loadedHostToOverrideSiteToTagMap[hostname][site] = tag;
            }, this);
          }
        }
      }
      //STEP 2: Create an array of objects defining tag names to be polled and new tag names to be set after submit
      this.setServiceConfigTags(this.loadedClusterSiteToTagMap);
      //STEP 3: Load advanced configs from server
      var advancedConfigs = App.config.loadAdvancedConfig(serviceName) || [];
      //STEP 4: Load on-site config by service from server
      var configGroups = App.config.loadConfigsByTags(this.get('serviceConfigTags'));
      //STEP 5: Merge global and on-site configs with pre-defined
      var configSet = App.config.mergePreDefinedWithLoaded(configGroups, advancedConfigs, this.get('serviceConfigTags'), serviceName);

      //var serviceConfigs = this.getSitesConfigProperties(advancedConfigs);
      var configs = configSet.configs;
      //put global configs into globalConfigs to save them separately
      this.set('globalConfigs', configSet.globalConfigs);

      //STEP 6: add advanced configs
      //App.config.addAdvancedConfigs(configs, advancedConfigs, serviceName);
      //STEP 7: add custom configs
      App.config.addCustomConfigs(configs);
      //STEP 8: add configs as names of host components
      this.addHostNamesToGlobalConfig();

      var allConfigs = this.get('globalConfigs').concat(configs);
      //this.loadServiceConfigHostsOverrides(serviceConfigs, this.loadedHostToOverrideSiteToTagMap);
      //STEP 9: Load and add host override configs
      App.config.loadServiceConfigHostsOverrides(allConfigs, this.loadedHostToOverrideSiteToTagMap);
      var restartData = this.loadActualConfigsAndCalculateRestarts();
      //STEP 10: creation of serviceConfig object which contains configs for current service
      var serviceConfig = App.config.createServiceConfig(serviceName);
      this.checkForRestart(serviceConfig, restartData);
      if (serviceName || serviceConfig.serviceName === 'MISC') {
      //STEP 11: render configs and wrap each in ServiceConfigProperty object
        this.loadComponentConfigs(allConfigs, serviceConfig, restartData);
        this.get('stepConfigs').pushObject(serviceConfig);
      }
      this.set('selectedService', this.get('stepConfigs').objectAt(0));
      this.checkForSecureConfig( this.get('selectedService'));
      this.set('dataIsLoaded', true);
    },
    /**
     * Changes format from Object to Array
     * 
     * {
     *  'core-site': 'version1',
     *  'hdfs-site': 'version1',
     *  'global': 'version2',
     *  ...
     * }
     * 
     * to 
     * 
     * [
     *  {
     *    siteName: 'core-site',
     *    tagName: 'version1',
     *    newTageName: null
     *  },
     *  ...
     * ]
     * 
     * set tagnames for configuration of the *-site.xml
     */
    setServiceConfigTags: function (desiredConfigsSiteTags) {
      console.debug("setServiceConfigTags(): Trying to set ", desiredConfigsSiteTags);
      var newServiceConfigTags = [];
      for (var index in desiredConfigsSiteTags) {
        newServiceConfigTags.pushObject({
          siteName: index,
          tagName: desiredConfigsSiteTags[index],
          newTagName: null
        }, this);
      }
      console.debug("setServiceConfigTags(): Setting 'serviceConfigTags' to ", newServiceConfigTags);
      this.set('serviceConfigTags', newServiceConfigTags);
    },

    /**
     * check whether host component must be restarted
     * @param serviceConfig
     * @param restartData
     */
    checkForRestart: function(serviceConfig, restartData){
      var hostsCount = 0;
      var hostComponentCount = 0;
      var restartHosts = Ember.A([]);
      if(restartData != null && restartData.hostAndHostComponents != null && !jQuery.isEmptyObject(restartData.hostAndHostComponents)){
        serviceConfig.set('restartRequired', true);
        for(var host in restartData.hostAndHostComponents) {
          hostsCount++;
          var componentsArray = Ember.A([]);
          for(var component in restartData.hostAndHostComponents[host]){
            componentsArray.push(Ember.Object.create({name: App.format.role(component)}));
            hostComponentCount++;
          }
          var hostObj = App.Host.find(host);
          restartHosts.push(Ember.Object.create({hostData: hostObj, components: componentsArray}))
        }
        serviceConfig.set('restartRequiredHostsAndComponents', restartHosts);
        serviceConfig.set('restartRequiredMessage', 'Service needs '+hostComponentCount+' components on ' + hostsCount +' hosts to be restarted.')
      }
    },

    /**
     * check whether the config property is a security related knob
     * @param serviceConfig
     */
    checkForSecureConfig: function(serviceConfig) {
      serviceConfig.get('configs').forEach(function(_config){
       this.get('secureConfigs').forEach(function(_secureConfig){
         if(_config.get('name')=== _secureConfig.name) {
           _config.set('isSecureConfig',true);
         }
       },this)
      },this)
    },

    /**
     * Load child components to service config object
     * @param configs
     * @param componentConfig
     * @param restartData
     */
    loadComponentConfigs: function (configs, componentConfig, restartData) {
      configs.forEach(function (_serviceConfigProperty) {
        console.log("config", _serviceConfigProperty);
        if (!_serviceConfigProperty) return;
        var overrides = _serviceConfigProperty.overrides;
        // we will populate the override properties below
        _serviceConfigProperty.overrides = null;

        if (_serviceConfigProperty.isOverridable === undefined) {
          _serviceConfigProperty.isOverridable = true;
        }
        var serviceConfigProperty = App.ServiceConfigProperty.create(_serviceConfigProperty);
        var propertyName = serviceConfigProperty.get('name');
        if (restartData != null && propertyName in restartData.propertyToHostAndComponent) {
          serviceConfigProperty.set('isRestartRequired', true);
          var message = '<ul>';
          for(var host in restartData.propertyToHostAndComponent[propertyName]){
            var appHost = App.Host.find(host);
            message += "<li>"+appHost.get('publicHostName');
            message += "<ul>";
            restartData.propertyToHostAndComponent[propertyName][host].forEach(function(comp){
              message += "<li>"+App.format.role(comp)+"</li>"
            });
            message += "</ul></li>";
          }
          message += "</ul>";
          serviceConfigProperty.set('restartRequiredMessage', message);
        }
        if (serviceConfigProperty.get('serviceName') === this.get('content.serviceName')) {
          // serviceConfigProperty.serviceConfig = componentConfig;
          if (App.get('isAdmin')) {
            serviceConfigProperty.set('isEditable', serviceConfigProperty.get('isReconfigurable'));
          } else {
            serviceConfigProperty.set('isEditable', false);
          }

          console.log("config result", serviceConfigProperty);
        } else {
          serviceConfigProperty.set('isVisible', false);
        }
        if (overrides != null) {
          for(var overridenValue in overrides){
            var hostsArray = overrides[overridenValue];
            var newSCP = App.ServiceConfigProperty.create(_serviceConfigProperty);
            newSCP.set('value', overridenValue);
            newSCP.set('isOriginalSCP', false); // indicated this is overridden value,
            newSCP.set('parentSCP', serviceConfigProperty);
            newSCP.set('selectedHostOptions', Ember.A(hostsArray));
            var parentOverridesArray = serviceConfigProperty.get('overrides');
            if(parentOverridesArray == null){
              parentOverridesArray = Ember.A([]);
              serviceConfigProperty.set('overrides', parentOverridesArray);
            }
            parentOverridesArray.pushObject(newSCP);
            console.debug("createOverrideProperty(): Added:", newSCP, " to main-property:", serviceConfigProperty)
          }
        }
        componentConfig.configs.pushObject(serviceConfigProperty);
        serviceConfigProperty.validate();
      }, this);
    },

    /**
     * Determines which host components are running on each host.
     * @param status 'running' or 'unknown'
     * @return Returned in the following format:
     * {
     *  runningHosts: {
     *    'hostname1': 'NameNode, DataNode, JobTracker',
     *    'hostname2': 'DataNode',
     *  },
     *  runningComponentCount: 5
     * }
     */
    getHostComponentsByStatus: function (services, status) {
      var hosts = [];
      var componentCount = 0;
      var hostToIndexMap = {};
      services.forEach(function (service) {
        var hostComponents = (status == App.HostComponentStatus.started) ? service.get('runningHostComponents') : service.get('unknownHostComponents');
        if (hostComponents != null) {
          hostComponents.forEach(function (hc) {
            var hostName = hc.get('host.publicHostName');
            var componentName = hc.get('displayName');
            componentCount++;
            if (!(hostName in hostToIndexMap)) {
              hosts.push({
                name: hostName,
                components: ""
              });
              hostToIndexMap[hostName] = hosts.length - 1;
            }
            var hostObj = hosts[hostToIndexMap[hostName]];
            if (hostObj.components.length > 0)
              hostObj.components += ", " + componentName;
            else
              hostObj.components += componentName;
          });
          hosts.sort(function (a, b) {
            return a.name.localeCompare(b.name);
          });
        }
      });
      return {
        hosts: hosts,
        componentCount: componentCount
      };
    },
    
    /**
     * open popup with appropriate message
     */
    restartServicePopup: function (event) {
      if(this.get("isSubmitDisabled")){
        return;
      }
      var header;
      var message;
      var messageClass;
      var hasUnknown = false;
      var value;
      var flag = false;
      var runningHosts = null;
      var runningComponentCount = 0;
      var unknownHosts = null;
      var unknownComponentCount = 0;

      var dfd = $.Deferred();
      var self = this;
      var serviceName = this.get('content.serviceName');
      var displayName = this.get('content.displayName');

      if (App.supports.hostOverrides || 
          (serviceName !== 'HDFS' && this.get('content.isStopped') === true) ||
          ((serviceName === 'HDFS') && this.get('content.isStopped') === true && (!App.Service.find().someProperty('id', 'MAPREDUCE') || App.Service.find('MAPREDUCE').get('isStopped')))) {

        // warn the user if any service directories are being changed
        var dirChanged = false;

        if (serviceName === 'HDFS') {
          var hdfsConfigs = self.get('stepConfigs').findProperty('serviceName', 'HDFS').get('configs');
          if (
            hdfsConfigs.findProperty('name', 'dfs_name_dir').get('isNotDefaultValue') ||
            hdfsConfigs.findProperty('name', 'fs_checkpoint_dir').get('isNotDefaultValue') ||
            hdfsConfigs.findProperty('name', 'dfs_data_dir').get('isNotDefaultValue')
          ) {
            dirChanged = true;
          }
        } else if (serviceName === 'MAPREDUCE') {
          var mapredConfigs = self.get('stepConfigs').findProperty('serviceName', 'MAPREDUCE').get('configs');
          if (
            mapredConfigs.findProperty('name', 'mapred_local_dir').get('isNotDefaultValue') ||
            mapredConfigs.findProperty('name', 'mapred_system_dir').get('isNotDefaultValue')
          ) {
            dirChanged = true;
          }
        }

        if (dirChanged) {
          App.showConfirmationPopup(function() {
            dfd.resolve();
          }, Em.I18n.t('services.service.config.confirmDirectoryChange').format(displayName));
        } else {
          dfd.resolve();
        }

        dfd.done(function() {
          var result = self.saveServiceConfigProperties();
          App.router.get('clusterController').updateClusterData();
          flag = result.flag;
          if (result.flag === true) {
            header = Em.I18n.t('services.service.config.saved');
            message = Em.I18n.t('services.service.config.saved.message');
            messageClass = 'alert alert-success';
            // warn the user if any of the components are in UNKNOWN state
            var uhc;
            if (self.get('content.serviceName') !== 'HDFS' || (self.get('content.serviceName') === 'HDFS' && !App.Service.find().someProperty('id', 'MAPREDUCE'))) {
              uhc = self.getHostComponentsByStatus([self.get('content')], App.HostComponentStatus.unknown);
            } else {
              uhc = self.getHostComponentsByStatus([self.get('content'), App.Service.find('MAPREDUCE')], App.HostComponentStatus.unknown);
            }
            unknownHosts = uhc.hosts;
            unknownComponentCount = uhc.componentCount;
          } else {
            header = Em.I18n.t('common.failure');
            message = result.message;
            messageClass = 'alert alert-error';
            value = result.value;
          }
        });
      } else {
        var rhc;
        if (this.get('content.serviceName') !== 'HDFS' || (this.get('content.serviceName') === 'HDFS' && !App.Service.find().someProperty('id', 'MAPREDUCE'))) {
          rhc = this.getHostComponentsByStatus([this.get('content')], App.HostComponentStatus.started);
          header = Em.I18n.t('services.service.config.notSaved');
          message = Em.I18n.t('services.service.config.msgServiceStop');
        } else {
          rhc = this.getHostComponentsByStatus([this.get('content'), App.Service.find('MAPREDUCE')], App.HostComponentStatus.started);
          header = Em.I18n.t('services.service.config.notSaved');
          message = Em.I18n.t('services.service.config.msgHDFSMapRServiceStop');
        }
        messageClass = 'alert alert-error';
        runningHosts = rhc.hosts;
        runningComponentCount = rhc.componentCount;
        dfd.resolve();
      }

      dfd.done(function () {
        App.ModalPopup.show({
          header: header,
          primary: Em.I18n.t('ok'),
          secondary: null,
          onPrimary: function () {
            this.hide();
            if (flag) {
              self.loadStep();
            }
          },
          bodyClass: Ember.View.extend({
            flag: flag,
            message: message,
            messageClass: messageClass,
            runningHosts: runningHosts,
            runningComponentCount: runningComponentCount,
            unknownHosts: unknownHosts,
            unknownComponentCount: unknownComponentCount,
            siteProperties: value,
            getDisplayMessage: function () {
              var displayMsg = [];
              var siteProperties = this.get('siteProperties');
              if (siteProperties) {
                siteProperties.forEach(function (_siteProperty) {
                  var displayProperty = _siteProperty.siteProperty;
                  var displayNames = _siteProperty.displayNames;
                  /////////
                  if (displayNames && displayNames.length) {
                    if (displayNames.length === 1) {
                      displayMsg.push(displayProperty + Em.I18n.t('as') + displayNames[0]);
                    } else {
                      var name;
                      displayNames.forEach(function (_name, index) {
                        if (index === 0) {
                          name = _name;
                        } else if (index === siteProperties.length - 1) {
                          name = name + Em.I18n.t('and') + _name;
                        } else {
                          name = name + ', ' + _name;
                        }
                      }, this);
                      displayMsg.push(displayProperty + Em.I18n.t('as') + name);

                    }
                  } else {
                    displayMsg.push(displayProperty);
                  }
                }, this);
              }
              return displayMsg;

            }.property('siteProperties'),

            runningHostsMessage: function () {
              return Em.I18n.t('services.service.config.stopService.runningHostComponents').format(this.get('runningComponentCount'), this.get('runningHosts.length'));
            }.property('runningComponentCount', 'runningHosts.length'),

            unknownHostsMessage: function () {
              return Em.I18n.t('services.service.config.stopService.unknownHostComponents').format(this.get('unknownComponentCount'), this.get('unknownHosts.length'));
            }.property('unknownComponentCount', 'unknownHosts.length'),

            templateName: require('templates/main/service/info/configs_save_popup')
          })
        })
      });
    },

    /**
     * Save config properties
     */
    saveServiceConfigProperties: function () {
      var result = {
        flag: false,
        message: null,
        value: null
      };
      this.savedHostToOverrideSiteToTagMap = {};
      var configs = this.get('stepConfigs').findProperty('serviceName', this.get('content.serviceName')).get('configs');
      this.saveGlobalConfigs(configs);
      this.saveSiteConfigs(configs);

      /**
       * First we put cluster configurations, which automatically creates /configurations
       * resources. Next we update host level overrides.
       */
      result.flag = this.doPUTClusterConfigurations();
      if (!result.flag) {
        result.message = Em.I18n.t('services.service.config.failSaveConfig');
      }else{
        result.flag = result.flag && this.doPUTHostOverridesConfigurationSites();
        if (!result.flag) {
          result.message = Em.I18n.t('services.service.config.failSaveConfigHostExceptions');
        }
      }
      console.log("The result from applyCreatdConfToService is: " + result);
      return result;
    },

    /**
     * save new or change exist configs in global configs
     * @param configs
     */
    saveGlobalConfigs: function (configs) {
      var globalConfigs = this.get('globalConfigs');
      configs.filterProperty('id', 'puppet var').forEach(function (uiConfigProperty) {
        var displayType = uiConfigProperty.get('displayType');
        if (displayType == 'directories' || displayType === 'directory') {
          var value = uiConfigProperty.get('value').replace(/,/g,' ').trim().split(/\s+/g).join(',');
          uiConfigProperty.set('value', value);
        }
        if (globalConfigs.someProperty('name', uiConfigProperty.name)) {
          var modelGlobalConfig = globalConfigs.findProperty('name', uiConfigProperty.name);
          modelGlobalConfig.value = uiConfigProperty.value;
          var uiOverrides = uiConfigProperty.get('overrides');
          if(uiOverrides!=null && uiOverrides.get('length')>0){
            modelGlobalConfig.overrides = {};
            uiOverrides.forEach(function(uiOverride){
              var value = uiOverride.get('value');
              modelGlobalConfig.overrides[value] = [];
              uiOverride.get('selectedHostOptions').forEach(function(host){
                modelGlobalConfig.overrides[value].push(host);
              });
            });
          }
        } else {
          globalConfigs.pushObject({
            name: uiConfigProperty.name,
            value: uiConfigProperty.value
          });
        }
      }, this);

      this.setHiveHostName(globalConfigs);
      this.setOozieHostName(globalConfigs);
      this.set('globalConfigs', globalConfigs);
    },

    /**
     * set hive hostnames in global configs
     * @param globals
     */
    setHiveHostName: function (globals) {
      if (globals.someProperty('name', 'hive_database')) {
        var hiveDb = globals.findProperty('name', 'hive_database');
        if (hiveDb.value === 'New MySQL Database') {
          var ambariHost = globals.findProperty('name', 'hive_ambari_host');
          if (ambariHost) {
            ambariHost.name = 'hive_hostname';
          }
          globals = globals.without(globals.findProperty('name', 'hive_existing_mysql_host'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_mysql_database'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_oracle_host'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_oracle_database'));
        } else if (hiveDb.value === 'Existing MySQL Database'){
          var existingMySqlHost = globals.findProperty('name', 'hive_existing_mysql_host');
          if (existingMySqlHost) {
            existingMySqlHost.name = 'hive_hostname';
          }
          globals = globals.without(globals.findProperty('name', 'hive_ambari_host'));
          globals = globals.without(globals.findProperty('name', 'hive_ambari_database'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_oracle_host'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_oracle_database'));
        } else { //existing oracle database
          var existingOracleHost = globals.findProperty('name', 'hive_existing_oracle_host');
          if (existingOracleHost) {
            existingOracleHost.name = 'hive_hostname';
          }
          globals = globals.without(globals.findProperty('name', 'hive_ambari_host'));
          globals = globals.without(globals.findProperty('name', 'hive_ambari_database'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_mysql_host'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_mysql_database'));
        }

      }
    },

    /**
     * set oozie hostnames in global configs
     * @param globals
     */
    setOozieHostName: function (globals) {
      if (globals.someProperty('name', 'oozie_database')) {
        var oozieDb = globals.findProperty('name', 'oozie_database');
        if (oozieDb.value === 'New Derby Database'){
          globals = globals.without(globals.findProperty('name', 'oozie_ambari_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_ambari_database'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_mysql_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_mysql_database'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_oracle_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_oracle_database'));
        } else if (oozieDb.value === 'New MySQL Database') {
          var ambariHost = globals.findProperty('name', 'oozie_ambari_host');
          if (ambariHost) {
            ambariHost.name = 'oozie_hostname';
          }
          globals = globals.without(globals.findProperty('name', 'oozie_existing_mysql_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_mysql_database'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_oracle_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_oracle_database'));
          globals = globals.without(globals.findProperty('name', 'oozie_derby_database'));

        } else if (oozieDb.value === 'Existing MySQL Database') {
          var existingMySqlHost = globals.findProperty('name', 'oozie_existing_mysql_host');
          if (existingMySqlHost) {
            existingMySqlHost.name = 'oozie_hostname';
          }
          globals = globals.without(globals.findProperty('name', 'oozie_ambari_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_ambari_database'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_oracle_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_oracle_database'));
          globals = globals.without(globals.findProperty('name', 'oozie_derby_database'));
        } else{ //existing oracle database
          var existingOracleHost = globals.findProperty('name', 'oozie_existing_oracle_host');
          if (existingOracleHost) {
            existingOracleHost.name = 'oozie_hostname';
          }
          globals = globals.without(globals.findProperty('name', 'oozie_ambari_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_ambari_database'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_mysql_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_mysql_database'));
          globals = globals.without(globals.findProperty('name', 'oozie_derby_database'));
        }

      }
    },

    /**
     * save site configs
     * @param configs
     */
    saveSiteConfigs: function (configs) {
      //storedConfigs contains custom configs as well
      var serviceConfigProperties = configs.filterProperty('id', 'site property');
      serviceConfigProperties.forEach(function(_config){
        if(typeof _config.get('value') === "boolean") _config.set('value', _config.value.toString());
      });
      var storedConfigs = serviceConfigProperties.filterProperty('value');
      var allUiConfigs = this.loadUiSideConfigs(this.get('configMapping').all());
      this.set('uiConfigs', storedConfigs.concat(allUiConfigs));
    },

    /**
     * return configs from the UI side
     * @param configMapping array with configs
     * @return {Array}
     */
    loadUiSideConfigs: function (configMapping) {
      var uiConfig = [];
      var configs = configMapping.filterProperty('foreignKey', null);
      this.addDynamicProperties(configs);
      configs.forEach(function (_config) {
        var valueWithOverrides = this.getGlobConfigValueWithOverrides(_config.templateName, _config.value, _config.name);
        if (valueWithOverrides !== null) {
          uiConfig.pushObject({
            "id": "site property",
            "name": _config.name,
            "value": valueWithOverrides.value,
            "filename": _config.filename,
            "overrides": valueWithOverrides.overrides
          });
        }
      }, this);
      return uiConfig;
    },


    addDynamicProperties: function(configs) {
      var allConfigs = this.get('stepConfigs').findProperty('serviceName', this.get('content.serviceName')).get('configs');
      var templetonHiveProperty =  allConfigs.someProperty('name', 'templeton.hive.properties');
      if (!templetonHiveProperty && this.get('content.serviceName') === 'WEBHCAT') {
        configs.pushObject({
          "name": "templeton.hive.properties",
          "templateName": ["hivemetastore_host"],
          "foreignKey": null,
          "value": "hive.metastore.local=false,hive.metastore.uris=thrift://<templateName[0]>:9083,hive.metastore.sasl.enabled=yes,hive.metastore.execute.setugi=true,hive.metastore.warehouse.dir=/apps/hive/warehouse",
          "filename": "webhcat-site.xml"
        });
      }
    },

    /**
     * return global config value
     * @param templateName
     * @param expression
     * @param name
     * @return {
     *   value: '...',
     *   overrides: {
     *    'value1': [h1, h2],
     *    'value2': [h3]
     *   }
     * }
     */
    getGlobConfigValueWithOverrides: function (templateName, expression, name) {
      var express = expression.match(/<(.*?)>/g);
      var value = expression;
      if (express == null) {
        return { value : expression, overrides: {}};      // if site property do not map any global property then return the value
      }
      var overrideHostToValue = {};
      express.forEach(function (_express) {
        //console.log("The value of template is: " + _express);
        var index = parseInt(_express.match(/\[([\d]*)(?=\])/)[1]);
        if (this.get('globalConfigs').someProperty('name', templateName[index])) {
          //console.log("The name of the variable is: " + this.get('content.serviceConfigProperties').findProperty('name', templateName[index]).name);
          var globalObj = this.get('globalConfigs').findProperty('name', templateName[index]);
          var globValue = globalObj.value;
          // Hack for templeton.zookeeper.hosts
          var preReplaceValue = null;
          if (value !== null) {   // if the property depends on more than one template name like <templateName[0]>/<templateName[1]> then don't proceed to the next if the prior is null or not found in the global configs
            preReplaceValue = value;
            value = this._replaceConfigValues(name, _express, value, globValue);
          }
          if(globalObj.overrides!=null){
            for(var ov in globalObj.overrides){
              var hostsArray = globalObj.overrides[ov];
              hostsArray.forEach(function(host){
                if(!(host in overrideHostToValue)){
                  overrideHostToValue[host] = this._replaceConfigValues(name, _express, preReplaceValue, ov);
                }else{
                  overrideHostToValue[host] = this._replaceConfigValues(name, _express, overrideHostToValue[host], ov);
                }
              }, this);
            }
          }
        } else {
          /*
           console.log("ERROR: The variable name is: " + templateName[index]);
           console.log("ERROR: mapped config from configMapping file has no corresponding variable in " +
           "content.serviceConfigProperties. Two possible reasons for the error could be: 1) The service is not selected. " +
           "and/OR 2) The service_config metadata file has no corresponding global var for the site property variable");
           */
          value = null;
        }
      }, this);

      var valueWithOverrides = {
          value: value,
          overrides: {}
      };
      if(!jQuery.isEmptyObject(overrideHostToValue)){
        for(var host in overrideHostToValue){
          var hostVal = overrideHostToValue[host];
          if(!(hostVal in valueWithOverrides.overrides)){
            valueWithOverrides.overrides[hostVal] = [];
          }
          valueWithOverrides.overrides[hostVal].push(host);
        }
      }
      return valueWithOverrides;
    },
    
    _replaceConfigValues: function (name, express, value, globValue) {
      if (name === "templeton.zookeeper.hosts" || name === 'hbase.zookeeper.quorum') {
        var zooKeeperPort = '2181';
        if (typeof globValue === 'string') {
          var temp = [];
          temp.push(globValue);
          globValue = temp;
        }
        if (name === "templeton.zookeeper.hosts") {
          var temp = [];
          globValue.forEach(function (_host, index) {
            temp.push(globValue[index] + ':' + zooKeeperPort);
          }, this);
          globValue = temp;
        }
        value = value.replace(express, globValue.toString());
      } else {
        value = value.replace(express, globValue);
      }
      return value;
    },

    /**
     * Saves cluster level configurations for all necessary sites.
     * PUT calls are made to /api/v1/clusters/clusterName for each site.
     * 
     * @return {Boolean}
     */
    doPUTClusterConfigurations: function () {
      var result = true;
      var serviceConfigTags = this.get('serviceConfigTags');
      this.setNewTagNames(serviceConfigTags);
      var siteNameToServerDataMap = {};
      
      serviceConfigTags.forEach(function (_serviceTags) {
        if (_serviceTags.siteName === 'global') {
          console.log("TRACE: Inside global");
          var serverGlobalConfigs = this.createGlobalSiteObj(_serviceTags.newTagName);
          siteNameToServerDataMap['global'] = serverGlobalConfigs;
          if(this.isConfigChanged(App.config.loadedConfigurationsCache['global_'+this.loadedClusterSiteToTagMap['global']], serverGlobalConfigs.properties)){
            result = result && this.doPUTClusterConfigurationSite(serverGlobalConfigs);
          }
        } else if (_serviceTags.siteName === 'core-site') {
          console.log("TRACE: Inside core-site");
          if (this.get('content.serviceName') === 'HDFS' || this.get('content.serviceName') === 'HCFS') {
            var coreSiteConfigs = this.createCoreSiteObj(_serviceTags.newTagName);
            siteNameToServerDataMap['core-site'] = coreSiteConfigs;
            if(this.isConfigChanged(App.config.loadedConfigurationsCache['core-site_'+this.loadedClusterSiteToTagMap['core-site']], coreSiteConfigs.properties)){
              result = result && this.doPUTClusterConfigurationSite(coreSiteConfigs);
            }
          }
        } else {
          var serverConfigs = this.createSiteObj(_serviceTags.siteName, _serviceTags.newTagName);
          siteNameToServerDataMap[_serviceTags.siteName] = serverConfigs;
          if(this.isConfigChanged(App.config.loadedConfigurationsCache[_serviceTags.siteName+'_'+this.loadedClusterSiteToTagMap[_serviceTags.siteName]], serverConfigs.properties)){
            result = result && this.doPUTClusterConfigurationSite(serverConfigs);
          }
       }
      }, this);
      this.savedSiteNameToServerServiceConfigDataMap = siteNameToServerDataMap;
      return result;
    },
    

    /**
     * Compares the loaded config values with the saving config values.
     */
    isConfigChanged: function (loadedConfig, savingConfig) {
      var changed = false;
      if (loadedConfig != null && savingConfig != null) {
        var seenLoadKeys = [];
        for ( var loadKey in loadedConfig) {
          seenLoadKeys.push(loadKey);
          var loadValue = loadedConfig[loadKey];
          var saveValue = savingConfig[loadKey];
          if("boolean" == typeof(saveValue)){
            saveValue = saveValue.toString();
          }
          if(saveValue==null){
            saveValue = "null";
          }
          if (loadValue !== saveValue) {
            changed = true;
            break;
          }
        }
        for ( var saveKey in savingConfig) {
          if (seenLoadKeys.indexOf(saveKey) < 0) {
            changed = true;
            break;
          }
        }
      }
      return changed;
    },
    
    /**
     * Saves configuration of a particular site. The provided data
     * contains the site name and tag to be used.
     */
    doPUTClusterConfigurationSite: function (data) {
      var result;
      var url = this.getUrl('', '');
      var clusterData = {
          Clusters: {
            desired_config: data
          }
      };
      console.log("applyClusterConfigurationToSite(): PUTting data:", clusterData);
      $.ajax({
        type: 'PUT',
        url: url,
        async: false,
        dataType: 'text',
        data: JSON.stringify(clusterData),
        timeout: 5000,
        success: function (data) {
          console.log("applyClusterConfigurationToSite(): In success for data:", data);
          result = true;
        },
        error: function (request, ajaxOptions, error) {
          console.log('applyClusterConfigurationToSite(): ERROR:', request.responseText, ", error=", error);
          result = false;
        },
        statusCode: require('data/statusCodes')
      });
      console.log("applyClusterConfigurationToSite(): Exiting with result=" + result);
      return result;
    },


    /**
     * Creates host level overrides for service configuration.
     * 
     */
    doPUTHostOverridesConfigurationSites: function(){
      var singlePUTHostData = [];
      var savedHostSiteArray = [];
      for ( var host in this.savedHostToOverrideSiteToTagMap) {
        for ( var siteName in this.savedHostToOverrideSiteToTagMap[host]) {
          var tagName = this.savedHostToOverrideSiteToTagMap[host][siteName].tagName;
          var map = this.savedHostToOverrideSiteToTagMap[host][siteName].map;
          savedHostSiteArray.push(host+"///"+siteName);
          singlePUTHostData.push({
            RequestInfo: {
              query: 'Hosts/host_name='+host
            },
            Body: {
              Hosts: {
                desired_config: {
                  type: siteName,
                  tag: tagName,
                  properties: map
                }
              }
            }
          });
        }
      }
      // Now cleanup removed overrides
      for ( var loadedHost in this.loadedHostToOverrideSiteToTagMap) {
        for ( var loadedSiteName in this.loadedHostToOverrideSiteToTagMap[loadedHost]) {
          if (!(savedHostSiteArray.contains(loadedHost + "///" + loadedSiteName))) {
            // This host-site combination was loaded, but not saved.
            // Meaning it is not needed anymore. Hence send a DELETE command.
            singlePUTHostData.push({
              RequestInfo: {
                query: 'Hosts/host_name='+loadedHost
              },
              Body: {
                Hosts: {
                  desired_config: {
                    type: loadedSiteName,
                    tag: this.loadedHostToOverrideSiteToTagMap[loadedHost][loadedSiteName],
                    selected: false
                  }
                }
              }
            });
          }
        }
      }
      console.debug("createHostOverrideConfigSites(): PUTting host-overrides. Data=",singlePUTHostData);
      if(singlePUTHostData.length>0){
        var url = this.getUrl('', '/hosts');
        var hostOverrideResult = true;
        $.ajax({
          type: 'PUT',
          url: url,
          data: JSON.stringify(singlePUTHostData),
          async: false,
          dataType: 'text',
          timeout: 5000,
          success: function (data) {
            var jsonData = jQuery.parseJSON(data);
            hostOverrideResult = true;
            console.log("createHostOverrideConfigSites(): SUCCESS:", url, ". RESPONSE:",jsonData);
          },
          error: function (request, ajaxOptions, error) {
            hostOverrideResult = false;
            console.log("createHostOverrideConfigSites(): ERROR:", url, ". RESPONSE:",request.responseText);
          },
          statusCode: require('data/statusCodes')
        });
        return hostOverrideResult;
      }
      return true;
    },
     
    /**
     * add newTagName property to each config in serviceConfigs
     * @param serviceConfigs
     */
    setNewTagNames: function (serviceConfigs) {
      var time = (new Date).getTime();
      serviceConfigs.forEach(function (_serviceConfigs) {
        _serviceConfigs.newTagName = 'version' + time;
      }, this);
    },

    /**
     * create global site object
     * @param tagName
     * @return {Object}
     */
    createGlobalSiteObj: function (tagName) {
      var globalSiteProperties = {};
      this.get('globalConfigs').forEach(function (_globalSiteObj) {
        // do not pass any globalConfigs whose name ends with _host or _hosts
        if (!/_hosts?$/.test(_globalSiteObj.name)) {
          // append "m" to JVM memory options except for hadoop_heapsize
          if (/_heapsize|_newsize|_maxnewsize$/.test(_globalSiteObj.name) && _globalSiteObj.name !== 'hadoop_heapsize') {
            _globalSiteObj.value += "m";
          }
          globalSiteProperties[_globalSiteObj.name] = _globalSiteObj.value;
          this.recordHostOverride(_globalSiteObj, 'global', tagName, this);
          //console.log("TRACE: name of the global property is: " + _globalSiteObj.name);
          //console.log("TRACE: value of the global property is: " + _globalSiteObj.value);
        }
      }, this);
      return {"type": "global", "tag": tagName, "properties": globalSiteProperties};
    },
    
    recordHostOverride: function(serviceConfigObj, siteName, tagName, self){
      if('get' in serviceConfigObj){
        return this._recordHostOverrideFromEmberObj(serviceConfigObj, siteName, tagName, self);
      }else{
        return this._recordHostOverrideFromObj(serviceConfigObj, siteName, tagName, self);
      }
    },
    
    /**
     * Records all the host overrides per site/tag
     */
    _recordHostOverrideFromObj: function(serviceConfigObj, siteName, tagName, self){
      var overrides = serviceConfigObj.overrides;
      if(overrides){
        for(var value in overrides){
          overrides[value].forEach(function(host){
            if(!(host in self.savedHostToOverrideSiteToTagMap)){
              self.savedHostToOverrideSiteToTagMap[host] = {};
            }
            if(!(siteName in self.savedHostToOverrideSiteToTagMap[host])){
              self.savedHostToOverrideSiteToTagMap[host][siteName] = {};
              self.savedHostToOverrideSiteToTagMap[host][siteName].map = {};
            }
            var finalTag = tagName + '_' + host;
            console.log("recordHostOverride(): Saving host override for host="+host+", site="+siteName+", tag="+finalTag+", (key,value)=("+serviceConfigObj.name+","+value+")");
            self.savedHostToOverrideSiteToTagMap[host][siteName].tagName = finalTag;
            self.savedHostToOverrideSiteToTagMap[host][siteName].map[serviceConfigObj.name] = value;
          });
        }
      }
    },

    /**
     * Records all the host overrides per site/tag
     */
    _recordHostOverrideFromEmberObj: function(serviceConfigObj, siteName, tagName, self){
      var overrides = serviceConfigObj.get('overrides');
      if(overrides){
        overrides.forEach(function(override){
          override.get('selectedHostOptions').forEach(function(host){
            if(!(host in self.savedHostToOverrideSiteToTagMap)){
              self.savedHostToOverrideSiteToTagMap[host] = {};
            }
            if(!(siteName in self.savedHostToOverrideSiteToTagMap[host])){
              self.savedHostToOverrideSiteToTagMap[host][siteName] = {};
              self.savedHostToOverrideSiteToTagMap[host][siteName].map = {};
            }
            var finalTag = tagName + '_' + host;
            console.log("recordHostOverride(): Saving host override for host="+host+", site="+siteName+", tag="+finalTag+", (key,value)=("+serviceConfigObj.name+","+override.get('value')+")");
            self.savedHostToOverrideSiteToTagMap[host][siteName].tagName = finalTag;
            self.savedHostToOverrideSiteToTagMap[host][siteName].map[serviceConfigObj.name] = override.get('value');
          });
        });
      }
    },

    /**
     * create core site object
     * @param tagName
     * @return {Object}
     */
    createCoreSiteObj: function (tagName) {
      var coreSiteObj = this.get('uiConfigs').filterProperty('filename', 'core-site.xml');
      var coreSiteProperties = {};
      coreSiteObj.forEach(function (_coreSiteObj) {
        coreSiteProperties[_coreSiteObj.name] = _coreSiteObj.value;
        this.recordHostOverride(_coreSiteObj, 'core-site', tagName, this);
      }, this);
      return {"type": "core-site", "tag": tagName, "properties": coreSiteProperties};
    },

    /**
     * create site object
     * @param siteName
     * @param tagName
     * @return {Object}
     */
    createSiteObj: function (siteName, tagName) {
      var siteObj = this.get('uiConfigs').filterProperty('filename', siteName + '.xml');
      var siteProperties = {};
      if (siteName == 'oozie-site') {
        siteObj = this.getOozieSiteObj(siteObj);
      } else if (siteName == 'hive-site') {
        siteObj = this.getHiveSiteObj(siteObj);
      }
      siteObj.forEach(function (_siteObj) {
        siteProperties[_siteObj.name] = _siteObj.value;
        this.recordHostOverride(_siteObj, siteName, tagName, this);
      }, this);
      return {"type": siteName, "tag": tagName, "properties": siteProperties};
    },

    /**
     * create site object for Oozie
     * @param siteObj
     * @return {Object}
     */
    getOozieSiteObj: function (siteObj) {
      var jdbcUrl = siteObj.findProperty('name', 'oozie.service.JPAService.jdbc.url');
      var jdbcDriver = siteObj.findProperty('name', 'oozie.service.JPAService.jdbc.driver');

      var oozieDb = this.get('globalConfigs').findProperty('name', 'oozie_database').value;
      // oozieHost is undefined if the database is derby
      var oozieHost = (oozieDb == 'New Derby Database') ? '' : this.get('globalConfigs').findProperty('name', 'oozie_hostname').value;
      var oozieDbName = this.get('globalConfigs').findProperty('name', 'oozie_database_name').value;
      var defaultJdbcUrl;

      switch (oozieDb) {
        case 'New Derby Database':
          defaultJdbcUrl = "jdbc:derby:${oozie.data.dir}/${oozie.db.schema.name}-db;create=true";
          jdbcDriver.value = "org.apache.derby.jdbc.EmbeddedDriver";
          break;
        case 'Existing MySQL Database':
          defaultJdbcUrl = "jdbc:mysql://" + oozieHost + "/" + oozieDbName;
          jdbcDriver.value = "com.mysql.jdbc.Driver";
          break;
        case 'Existing Oracle Database':
          defaultJdbcUrl = "jdbc:oracle:thin:@//" + oozieHost + ":1521/" + oozieDbName;
          jdbcDriver.value = "oracle.jdbc.driver.OracleDriver";
          break;
      }
      // in case the user upgraded from Ambari version <= 1.2.3, they will not have oozie_jdbc_connection_url global
      var jdbcUrlInGlobal = this.get('globalConfigs').findProperty('name', 'oozie_jdbc_connection_url');
      jdbcUrl.value = jdbcUrlInGlobal ? jdbcUrlInGlobal.value : defaultJdbcUrl;
      return siteObj;
    },

    /**
     * create site object for Hive
     * @param siteObj
     * @return {Object}
     */
    getHiveSiteObj: function (siteObj) {
      var jdbcUrl = siteObj.findProperty('name', 'javax.jdo.option.ConnectionURL');
      var jdbcDriver = siteObj.findProperty('name', 'javax.jdo.option.ConnectionDriverName');

      var hiveDb = this.get('globalConfigs').findProperty('name', 'hive_database').value;
      var hiveHost = this.get('globalConfigs').findProperty('name', 'hive_hostname').value;
      var hiveDbName = this.get('globalConfigs').findProperty('name', 'hive_database_name').value;
      var defaultJdbcUrl;

      switch (hiveDb) {
        case 'New MySQL Database':
          defaultJdbcUrl = "jdbc:mysql://"+ hiveHost + "/" + hiveDbName + "?createDatabaseIfNotExist=true";
          jdbcDriver.value = "com.mysql.jdbc.Driver";
          break;
        case 'Existing MySQL Database':
          defaultJdbcUrl = "jdbc:mysql://"+ hiveHost + "/" + hiveDbName + "?createDatabaseIfNotExist=true";
          jdbcDriver.value = "com.mysql.jdbc.Driver";
          break;
        case 'Existing Oracle Database':
          defaultJdbcUrl = "jdbc:oracle:thin:@//"+ hiveHost + ":1521/" + hiveDbName;
          jdbcDriver.value = "oracle.jdbc.driver.OracleDriver";
          break;
      }
      // in case the user upgraded from Ambari <= 1.2.3, they will not have hive_jdbc_connection_url global
      var jdbcUrlInGlobal = this.get('globalConfigs').findProperty('name', 'hive_jdbc_connection_url');
      jdbcUrl.value = jdbcUrlInGlobal ? jdbcUrlInGlobal.value : defaultJdbcUrl;
      return siteObj;
    },

    /**
     * Set display names of the property from the puppet/global names
     * @param: displayNames: a field to be set with displayNames
     * @param names: array of property puppet/global names
     */
    setPropertyDisplayNames: function (displayNames, names) {
      var stepConfigs = this.get('stepConfigs').findProperty('serviceName', this.get('content.serviceName')).configs;
      names.forEach(function (_name, index) {
        if (stepConfigs.someProperty('name', _name)) {
          displayNames.push(stepConfigs.findProperty('name', _name).displayName);
        }
      }, this);
    },

    /**
     * Set property of the site variable
     */
    setSiteProperty: function (key, value, filename) {
      if (filename === 'core-site.xml' && this.get('uiConfigs').filterProperty('filename', 'core-site.xml').someProperty('name', key)) {
        this.get('uiConfigs').filterProperty('filename', 'core-site.xml').findProperty('name', key).value = value;
        return;
      }
      this.get('uiConfigs').pushObject({
        "id": "site property",
        "name": key,
        "value": value,
        "filename": filename
      });
    },

    /**
     * return either specific url for request if testMode is false or testUrl
     * @param testUrl
     * @param url
     * @return {*}
     */
    getUrl: function (testUrl, url) {
      return (App.testMode) ? testUrl : App.apiPrefix + '/clusters/' + App.router.getClusterName() + url;
    },

    /**
     * Adds host name of master component to global config;
     */
    addHostNamesToGlobalConfig: function () {
      var serviceName = this.get('content.serviceName');
      var globalConfigs = this.get('globalConfigs');
      var serviceConfigs = this.get('serviceConfigs').findProperty('serviceName', serviceName).configs;
      //namenode_host is required to derive "fs.default.name" a property of core-site
      var nameNodeHost = this.get('serviceConfigs').findProperty('serviceName', 'HDFS').configs.findProperty('name', 'namenode_host');
      try {
        nameNodeHost.defaultValue = App.Service.find('HDFS').get('hostComponents').findProperty('componentName', 'NAMENODE').get('host.hostName');
        globalConfigs.push(nameNodeHost);
      } catch (err) {
        console.log("No NameNode Host available.  This is expected if you're using HCFS rather than HDFS.");
      }

      //zooKeeperserver_host
      var zooKeperHost = this.get('serviceConfigs').findProperty('serviceName', 'ZOOKEEPER').configs.findProperty('name', 'zookeeperserver_hosts');
      if (serviceName === 'ZOOKEEPER' || serviceName === 'HBASE' || serviceName === 'WEBHCAT') {
        zooKeperHost.defaultValue = App.Service.find('ZOOKEEPER').get('hostComponents').filterProperty('componentName', 'ZOOKEEPER_SERVER').mapProperty('host.hostName');
        globalConfigs.push(zooKeperHost);
      }

      switch (serviceName) {
        case 'HDFS':
          var sNameNodeHost = serviceConfigs.findProperty('name', 'snamenode_host');
          sNameNodeHost.defaultValue = this.get('content.hostComponents').findProperty('componentName', 'SECONDARY_NAMENODE').get('host.hostName');
          globalConfigs.push(sNameNodeHost);
          break;
        case 'MAPREDUCE':
          var jobTrackerHost = serviceConfigs.findProperty('name', 'jobtracker_host');
          jobTrackerHost.defaultValue = this.get('content.hostComponents').findProperty('componentName', 'JOBTRACKER').get('host.hostName');
          globalConfigs.push(jobTrackerHost);
          break;
        case 'HIVE':
          var hiveMetastoreHost = serviceConfigs.findProperty('name', 'hivemetastore_host');
          hiveMetastoreHost.defaultValue = this.get('content.hostComponents').findProperty('componentName', 'HIVE_SERVER').get('host.hostName');
          globalConfigs.push(hiveMetastoreHost);
          var hiveDb = globalConfigs.findProperty('name', 'hive_database').value;
          if (['Existing MySQL Database', 'Existing Oracle Database'].contains(hiveDb)) {
            globalConfigs.findProperty('name', 'hive_hostname').isVisible = true;
          }
          break;
        case 'OOZIE':
          var oozieServerHost = serviceConfigs.findProperty('name', 'oozieserver_host');
          oozieServerHost.defaultValue = this.get('content.hostComponents').findProperty('componentName', 'OOZIE_SERVER').get('host.hostName');
          globalConfigs.push(oozieServerHost);
          var oozieDb = globalConfigs.findProperty('name', 'oozie_database').value;
          if (['Existing MySQL Database', 'Existing Oracle Database'].contains(oozieDb)) {
            globalConfigs.findProperty('name', 'oozie_hostname').isVisible = true;
          }
          break;
        case 'HBASE':
          var hbaseMasterHost = serviceConfigs.findProperty('name', 'hbasemaster_host');
          hbaseMasterHost.defaultValue = this.get('content.hostComponents').filterProperty('componentName', 'HBASE_MASTER').mapProperty('host.hostName');
          globalConfigs.push(hbaseMasterHost);
          break;
        case 'HUE':
          var hueServerHost = serviceConfigs.findProperty('name', 'hueserver_host');
          hueServerHost.defaultValue = this.get('content.hostComponents').findProperty('componentName', 'HUE_SERVER').get('host.hostName');
          globalConfigs.push(hueServerHost);
          break;
        case 'WEBHCAT':
          var webhcatMasterHost = serviceConfigs.findProperty('name', 'webhcatserver_host');
          webhcatMasterHost.defaultValue = this.get('content.hostComponents').filterProperty('componentName', 'WEBHCAT_SERVER').mapProperty('host.hostName');
          globalConfigs.push(webhcatMasterHost);
          var hiveMetastoreHost = this.get('serviceConfigs').findProperty('serviceName', 'HIVE').configs.findProperty('name', 'hivemetastore_host');
          hiveMetastoreHost.defaultValue = App.Service.find('HIVE').get('hostComponents').findProperty('componentName', 'HIVE_SERVER').get('host.hostName');
          globalConfigs.push(hiveMetastoreHost);
          break;
      }
    },
    
    /**
     * Provides service component name and display-name information for 
     * the current selected service. 
     */
    getCurrentServiceComponents: function () {
      var service = this.get('content');
      var components = service.get('hostComponents');
      var validComponents = Ember.A([]);
      var seenComponents = {};
      components.forEach(function(component){
        var cn = component.get('componentName');
        var cdn = component.get('displayName');
        if(!seenComponents[cn]){
          validComponents.push(Ember.Object.create({
            componentName: cn,
            displayName: cdn,
            selected: false
          }));
          seenComponents[cn] = cn;
        }
      });
      return validComponents;
    }.property('content'),
    
    getAllHosts: function () {
      return App.router.get('mainHostController.content');
    }.property('App.router.mainHostController.content'),
    
    doCancel: function () {
      this.loadStep();
    }
  });
  
});
window.require.register("controllers/main/service/info/summary", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.MainServiceInfoSummaryController = Em.Controller.extend({
    name: 'mainServiceInfoSummaryController',
    allAlerts: function(){
      return App.router.get('clusterController.alerts');
    }.property('App.router.clusterController.alerts'),

    alerts: function () {
      var serviceId = this.get('content.serviceName');
      if (serviceId) {
        return this.get('allAlerts').filter(function (item) {
          return item.get('serviceType').toLowerCase() == serviceId.toLowerCase() && !item.get('ignoredForServices');
        });
      }
      return [];
    }.property('allAlerts', 'content.serviceName'),
    
    nagiosUrl: function(){
      return App.router.get('clusterController.nagiosUrl');
    }.property('App.router.clusterController.nagiosUrl'),
    
    isNagiosInstalled: function(){
      return App.router.get('clusterController.isNagiosInstalled');
    }.property('App.router.clusterController.isNagiosInstalled')
  });
});
window.require.register("controllers/main/service/item", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var service_components = require('data/service_components');

  App.MainServiceItemController = Em.Controller.extend({
    name: 'mainServiceItemController',

    /**
     * Callback functions for start and stop service have few differences
     *
     * Used with currentCallBack property
     */
    callBackConfig: {
      'STARTED': {
        'c': 'STARTING',
        'f': 'starting',
        'c2': 'live',
        'hs': 'started',
        's': 'start'
      },
      'INSTALLED': {
        'c': 'STOPPING',
        'f': 'stopping',
        'c2': 'dead',
        'hs': 'stopped',
        's': 'stop'
      }
    },
    /**
     * Success ajax response processing
     * @param data
     * @param ajaxOptions
     */
    ajaxSuccess: function(data, ajaxOptions) {
      if(data && data.Requests) {
        this.ajaxCallBack(data.Requests.id, (JSON.parse(ajaxOptions.data)).Body.ServiceInfo.state);
      }
      else {
        console.log('cannot get request id from ', data);
      }
    },
    /**
     * Common method for ajax (start/stop service) responses
     * @param requestId
     * @param serviceHealth
     */
    ajaxCallBack: function(requestId, serviceHealth) {
      var config = this.get('callBackConfig')[serviceHealth];
      var self = this;
      console.log('Send request for ' + config.c + ' successfully');
      if (App.testMode) {
        self.set('content.workStatus', App.Service.Health[config.f]);
        self.get('content.hostComponents').setEach('workStatus', App.HostComponentStatus[config.f]);
        setTimeout(function () {
          self.set('content.workStatus', App.Service.Health[config.c2]);
          self.get('content.hostComponents').setEach('workStatus', App.HostComponentStatus[config.hs]);
        }, App.testModeDelayForActions);
      }
      else {
        App.router.get('clusterController').loadUpdatedStatusDelayed(500);// @todo check working without param 500
      }
      App.router.get('backgroundOperationsController').showPopup();
    },
    /**
     * Confirmation popup for start/stop services
     * @param event
     * @param serviceHealth - 'STARTED' or 'INSTALLED'
     */
    startStopPopup: function(event, serviceHealth) {
      if ($(event.target).hasClass('disabled') || $(event.target.parentElement).hasClass('disabled')) {
        return;
      }
      var self = this;
      App.showConfirmationPopup(function() {
        self.set('isPending', true);
        self.startStopPopupPrimary(serviceHealth);
      });
    },

    startStopPopupPrimary: function(serviceHealth) {
      var requestInfo = "";
      if(serviceHealth == "STARTED"){
        requestInfo = 'Start ' + this.get('content.displayName');
      }else{
        requestInfo = 'Stop ' + this.get('content.displayName');
      }

      App.ajax.send({
        'name': 'service.item.start_stop',
        'sender': this,
        'success': 'ajaxSuccess',
        'data': {
          'requestInfo':requestInfo,
          'serviceName': this.get('content.serviceName').toUpperCase(),
          'state': serviceHealth
        }
      });
      this.set('isStopDisabled',true);
      this.set('isStartDisabled',true);
    },

    /**
     * On click callback for <code>start service</code> button
     * @param event
     */
    startService: function (event) {
      this.startStopPopup(event, App.HostComponentStatus.started);
    },

    /**
     * On click callback for <code>stop service</code> button
     * @param event
     */
    stopService: function (event) {
      this.startStopPopup(event, App.HostComponentStatus.stopped);
    },

    /**
     * On click callback for <code>run rebalancer</code> button
     * @param event
     */
    runRebalancer: function (event) {
      var self = this;
      App.showConfirmationPopup(function() {
        self.content.set('runRebalancer', true);
        App.router.get('backgroundOperationsController').showPopup();
      });
    },

    /**
     * On click callback for <code>run compaction</code> button
     * @param event
     */
    runCompaction: function (event) {
      var self = this;
      App.showConfirmationPopup(function() {
        self.content.set('runCompaction', true);
        App.router.get('backgroundOperationsController').showPopup();
      });
    },

    /**
     * On click callback for <code>run smoke test</code> button
     * @param event
     */
    runSmokeTest: function (event) {
      var self = this;
      App.showConfirmationPopup(function() {
        self.runSmokeTestPrimary();
      });
    },

    runSmokeTestPrimary: function() {
      App.ajax.send({
        'name': 'service.item.smoke',
        'sender': this,
        'success':'runSmokeTestSuccessCallBack',
        'data': {
          'serviceName': this.get('content.serviceName'),
          'displayName': this.get('content.displayName'),
          'actionName': this.get('content.serviceName') === 'ZOOKEEPER' ? 'ZOOKEEPER_QUORUM_SERVICE_CHECK' : this.get('content.serviceName') + '_SERVICE_CHECK'
        }
      });
    },

    runSmokeTestSuccessCallBack: function(data) {
      if (data.Requests.id) {
        App.router.get('backgroundOperationsController').showPopup();
      }
      else {
        console.warn('error during runSmokeTestSuccessCallBack');
      }
    },

    /**
     * On click callback for <code>Reassign <master component></code> button
     * @param hostComponent
     */
    reassignMaster: function (hostComponent) {
      var component = App.HostComponent.find().findProperty('componentName', hostComponent.get('componentName'));
      console.log('In Reassign Master', hostComponent);
      var reassignMasterController = App.router.get('reassignMasterController');
      reassignMasterController.saveComponentToReassign(component);
      reassignMasterController.setCurrentStep('1');
      App.router.transitionTo('reassignMaster');
    },

    /**
     * On click callback for <code>action</code> dropdown menu
     * Calls runSmokeTest, runRebalancer, runCompaction or reassignMaster depending on context
     * @param event
     */
    doAction: function (event) {
      if ($(event.target).hasClass('disabled') || $(event.target.parentElement).hasClass('disabled')) {
        return;
      }
      var methodName = event.context.action;
      var context = event.context.context;
      if (methodName) {
        this[methodName](context);
      }
      },


      setStartStopState: function () {
          var serviceName = this.get('content.serviceName');
          var backgroundOperations = App.router.get('backgroundOperationsController.services');
          if(backgroundOperations.length>0) {
              for (var i = 0; i < backgroundOperations.length; i++) {
                  var hosts = backgroundOperations[i].hosts;
                  for (var j = 0; j < hosts.length; j++) {
                      var logTasks = hosts[j].logTasks;
                      for (var k = 0; k < logTasks.length; k++) {
                          var service = service_components.findProperty('component_name', logTasks[k].Tasks.role);
                          if (service && serviceName == service.service_name) {
                              if (logTasks[k].Tasks.status == 'PENDING' || logTasks[k].Tasks.status == 'IN_PROGRESS' || logTasks[k].Tasks.status == 'QUEUED') {
                                  this.set('isPending', true);
                                  return;
                              }
                          }
                      }
                  }
              }
              this.set('isPending', false);
          }
          else {
              this.set('isPending', true);
          }

      }.observes('App.router.backgroundOperationsController.serviceTimestamp'),
      
    isServiceRestartable: function() {
      return this.get('content.serviceName') !== "FLUME";
    }.property('content.serviceName'),

    isStartDisabled: function () {
      if(this.get('isPending')) return true;
      return !(this.get('content.healthStatus') == 'red');
    }.property('content.healthStatus','isPending'),

    isStopDisabled: function () {
      if(this.get('isPending')) return true;
      return !(this.get('content.healthStatus') == 'green');
    }.property('content.healthStatus','isPending'),

    isPending:true

  })
  
});
window.require.register("controllers/main/service/reassign_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.ReassignMasterController = App.WizardController.extend({

    name: 'reassignMasterController',

    totalSteps: 6,

    /**
     * Used for hiding back button in wizard
     */
    hideBackButton: true,

    /**
     * All wizards data will be stored in this variable
     *
     * cluster - cluster name
     * installOptions - ssh key, repo info, etc.
     * services - services list
     * hosts - list of selected hosts
     * slaveComponentHosts, - info about slave hosts
     * masterComponentHosts - info about master hosts
     * config??? - to be described later
     */
    content: Em.Object.create({
      cluster: null,
      hosts: null,
      installOptions: null,
      services: null,
      slaveComponentHosts: null,
      masterComponentHosts: null,
      serviceConfigProperties: null,
      advancedServiceConfig: null,
      controllerName: 'reassignMasterController',
      reassign: null
    }),

    skipStep3: function () {
      return this.get('content.reassign.service_id') == 'GANGLIA';
    }.property('content.reassign.service_id'),

    /**
     * return new object extended from clusterStatusTemplate
     * @return Object
     */
    getCluster: function(){
      return jQuery.extend({}, this.get('clusterStatusTemplate'), {name: App.router.getClusterName()});
    },

    /**
     * Load services data from server.
     */
    loadServicesFromServer: function() {
      var displayOrderConfig = require('data/services');
      var apiUrl = App.get('stack2VersionURL');
      var apiService = this.loadServiceComponents(displayOrderConfig, apiUrl);
      //
      apiService.forEach(function(item, index){
        apiService[index].isSelected = App.Service.find().someProperty('id', item.serviceName);
        apiService[index].isDisabled = apiService[index].isSelected;
        apiService[index].isInstalled = apiService[index].isSelected;
      });
      this.set('content.services', apiService);
      App.db.setService(apiService);
    },

    /**
     * Load confirmed hosts.
     * Will be used at <code>Assign Masters(step5)</code> step
     */
    loadConfirmedHosts: function(){
      var hosts = App.db.getHosts();
      if(!hosts || !hosts.length){
        var hosts = {};

        App.Host.find().forEach(function(item){
          hosts[item.get('id')] = {
            name: item.get('id'),
            cpu: item.get('cpu'),
            memory: item.get('memory'),
            disk_info: item.get('diskInfo'),
            bootStatus: "REGISTERED",
            isInstalled: true
          };
        });
        App.db.setHosts(hosts);
      }

      this.set('content.hosts', hosts);
      console.log('ReassignMasterController.loadConfirmedHosts: loaded hosts', hosts);
    },

    /**
     * Load master component hosts data for using in required step controllers
     */
    loadMasterComponentHosts: function () {
      var masterComponentHosts = App.db.getMasterComponentHosts();
      if(!masterComponentHosts){
        masterComponentHosts = [];
        App.HostComponent.find().filterProperty('isMaster', true).forEach(function(item){
          masterComponentHosts.push({
            component: item.get('componentName'),
            hostName: item.get('host.hostName'),
            isInstalled: true
          })
        });

      }
      this.set("content.masterComponentHosts", masterComponentHosts);
      console.log("ReassignMasterController.loadMasterComponentHosts: loaded hosts ", masterComponentHosts);
    },

    /**
     * Load tasks statuses for step5 of Reassign Master Wizard to restore installation
     */
    loadTasksStatuses: function(){
      var statuses = App.db.getReassignTasksStatuses();
      this.set('content.tasksStatuses', statuses);
      console.log('ReassignMasterController.loadTasksStatuses: loaded statuses', statuses);
    },

    /**
     * save status of the cluster.
     * @param clusterStatus object with status,requestId fields.
     */
    saveClusterStatus: function (clusterStatus) {
      var oldStatus = this.toObject(this.get('content.cluster'));
      clusterStatus = jQuery.extend(oldStatus, clusterStatus);
      if (clusterStatus.requestId) {
        clusterStatus.requestId.forEach(function (requestId) {
          if (clusterStatus.oldRequestsId.indexOf(requestId) === -1) {
            clusterStatus.oldRequestsId.push(requestId)
          }
        }, this);
      }
      this.set('content.cluster', clusterStatus);
      this.save('cluster');
    },

    /**
     * Save Master Component Hosts data to Main Controller
     * @param stepController App.WizardStep5Controller
     */
    saveMasterComponentHosts: function (stepController) {
      var obj = stepController.get('selectedServicesMasters');

      var masterComponentHosts = [];
      obj.forEach(function (_component) {
        masterComponentHosts.push({
          display_name: _component.get('display_name'),
          component: _component.get('component_name'),
          hostName: _component.get('selectedHost'),
          serviceId: _component.get('serviceId'),
          isInstalled: true
        });
      });
      App.db.setMasterComponentHosts(masterComponentHosts);
      this.set('content.masterComponentHosts', masterComponentHosts);
    },

    loadComponentToReassign: function () {
      var masterComponent = App.db.getMasterToReassign();
      if (masterComponent) {
        this.set('content.reassign', masterComponent);
      }
    },

    saveComponentToReassign: function (masterComponent) {
      var component = {
        component_name: masterComponent.get('componentName'),
        display_name: masterComponent.get('displayName'),
        service_id: masterComponent.get('service.serviceName'),
        host_id: masterComponent.get('host.hostName')
      };
      App.db.setMasterToReassign(component);
    },
    saveTasksStatuses: function(statuses){
      App.db.setReassignTasksStatuses(statuses);
      this.set('content.tasksStatuses', statuses);
      console.log('ReassignMasterController.saveTasksStatuses: saved statuses', statuses);
    },

    /**
     * Load data for all steps until <code>current step</code>
     */
    loadAllPriorSteps: function () {
      var step = this.get('currentStep');
      switch (step) {
        case '6':
        case '5':
          this.loadTasksStatuses();
        case '4':
        case '3':
          this.loadServiceConfigProperties();
        case '2':
          this.loadServicesFromServer();
          this.loadMasterComponentHosts();
          this.loadConfirmedHosts();
        case '1':
          this.loadComponentToReassign();
          this.load('cluster');
      }
    },

    /**
     * Remove all loaded data.
     * Created as copy for App.router.clearAllSteps
     */
    clearAllSteps: function () {
      this.clearInstallOptions();
      // clear temporary information stored during the install
      this.set('content.cluster', this.getCluster());
    },

    /**
     * Clear all temporary data
     */
    finish: function () {
      this.setCurrentStep('1');
      this.clearAllSteps();
      this.clearStorageData();
      App.router.get('updateController').updateAll();
    }

  });
  
});
window.require.register("controllers/wizard", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.WizardController = Em.Controller.extend({

    isStepDisabled: null,

    init: function () {
      this.set('isStepDisabled', []);
      this.clusters = App.Cluster.find();
      this.isStepDisabled.pushObject(Ember.Object.create({
        step: 1,
        value: false
      }));
      for (var i = 2; i <= this.get('totalSteps'); i++) {
        this.isStepDisabled.pushObject(Ember.Object.create({
          step: i,
          value: true
        }));
      }
      // window.onbeforeunload = function () {
      // return "You have not saved your document yet.  If you continue, your work will not be saved."
      //}
    },

    setStepsEnable: function () {
      for (var i = 1; i <= this.totalSteps; i++) {
        var step = this.get('isStepDisabled').findProperty('step', i);
        if (i <= this.get('currentStep')) {
          step.set('value', false);
        } else {
          step.set('value', true);
        }
      }
    }.observes('currentStep'),

    setLowerStepsDisable: function (stepNo) {
      for (var i = 1; i < stepNo; i++) {
        var step = this.get('isStepDisabled').findProperty('step', i);
        step.set('value', true);
      }
    },

    /**
     * Set current step to new value.
     * Method moved from App.router.setInstallerCurrentStep
     * @param currentStep
     * @param completed
     */
    currentStep: function () {
      return App.get('router').getWizardCurrentStep(this.get('name').substr(0, this.get('name').length - 10));
    }.property(),

    /**
     * Set current step to new value.
     * Method moved from App.router.setInstallerCurrentStep
     * @param currentStep
     * @param completed
     */
    setCurrentStep: function (currentStep, completed) {
      App.db.setWizardCurrentStep(this.get('name').substr(0, this.get('name').length - 10), currentStep, completed);
      this.set('currentStep', currentStep);
    },

    clusters: null,

    isStep0: function () {
      return this.get('currentStep') == 0;
    }.property('currentStep'),

    isStep1: function () {
      return this.get('currentStep') == 1;
    }.property('currentStep'),

    isStep2: function () {
      return this.get('currentStep') == 2;
    }.property('currentStep'),

    isStep3: function () {
      return this.get('currentStep') == 3;
    }.property('currentStep'),

    isStep4: function () {
      return this.get('currentStep') == 4;
    }.property('currentStep'),

    isStep5: function () {
      return this.get('currentStep') == 5;
    }.property('currentStep'),

    isStep6: function () {
      return this.get('currentStep') == 6;
    }.property('currentStep'),

    isStep7: function () {
      return this.get('currentStep') == 7;
    }.property('currentStep'),

    isStep8: function () {
      return this.get('currentStep') == 8;
    }.property('currentStep'),

    isStep9: function () {
      return this.get('currentStep') == 9;
    }.property('currentStep'),

    isStep10: function () {
      return this.get('currentStep') == 10;
    }.property('currentStep'),

    gotoStep: function (step) {
      if (this.get('isStepDisabled').findProperty('step', step).get('value') !== false) {
        return false;
      }
      // if going back from Step 9 in Install Wizard, delete the checkpoint so that the user is not redirected
      // to Step 9
      if (this.get('content.controllerName') == 'installerController' && this.get('currentStep') === '9' && step < 9) {
        App.clusterStatus.setClusterStatus({
          clusterName: this.get('clusterName'),
          clusterState: 'CLUSTER_NOT_CREATED_1',
          wizardControllerName: 'installerController',
          localdb: App.db.data
        });
      }
      if ((this.get('currentStep') - step) > 1) {
        App.ModalPopup.show({
          header: Em.I18n.t('installer.navigation.warning.header'),
          onPrimary: function () {
            App.router.send('gotoStep' + step);
            this.hide();
          },
          body: "If you proceed to go back to Step " + step + ", you will lose any changes you have made beyond this step"
        });
      } else {
        App.router.send('gotoStep' + step);
      }
      return true;
    },

    gotoStep0: function () {
      this.gotoStep(0);
    },

    gotoStep1: function () {
      this.gotoStep(1);
    },

    gotoStep2: function () {
      this.gotoStep(2);
    },

    gotoStep3: function () {
      this.gotoStep(3);
    },

    gotoStep4: function () {
      this.gotoStep(4);
    },

    gotoStep5: function () {
      this.gotoStep(5);
    },

    gotoStep6: function () {
      this.gotoStep(6);
    },

    gotoStep7: function () {
      this.gotoStep(7);
    },

    gotoStep8: function () {
      this.gotoStep(8);
    },

    gotoStep9: function () {
      this.gotoStep(9);
    },

    gotoStep10: function () {
      this.gotoStep(10);
    },

    /**
     * Initialize host status info for step9
     */
    setInfoForStep9: function () {

      var hostInfo = App.db.getHosts();
      for (var index in hostInfo) {
        hostInfo[index].status = "pending";
        hostInfo[index].message = 'Waiting';
        hostInfo[index].logTasks = [];
        hostInfo[index].tasks = [];
        hostInfo[index].progress = '0';
      }
      App.db.setHosts(hostInfo);
    },

    /**
     * Remove all data for installOptions step
     */
    clearInstallOptions: function () {
      var installOptions = jQuery.extend({}, this.get('installOptionsTemplate'));
      this.set('content.installOptions', installOptions);
      this.save('installOptions');
      this.set('content.hosts', []);
      this.save('hosts');
    },

    toObject: function(object){
      var result = {};
      for(var i in object){
        if(object.hasOwnProperty(i)){
          result[i] = object[i];
        }
      }
      return result;
    },

    /**
     * save status of the cluster. This is called from step8 and step9 to persist install and start requestId
     * @param clusterStatus object with status, isCompleted, requestId, isInstallError and isStartError field.
     */
    saveClusterStatus: function (clusterStatus) {
      var oldStatus = this.toObject(this.get('content.cluster'));
      clusterStatus = jQuery.extend(oldStatus, clusterStatus);
      if (clusterStatus.requestId &&
        clusterStatus.oldRequestsId.indexOf(clusterStatus.requestId) === -1){
        clusterStatus.oldRequestsId.push(clusterStatus.requestId);
      }
      this.set('content.cluster', clusterStatus);
      this.save('cluster');
    },

    /**
     * Invoke installation of selected services to the server and saves the request id returned by the server.
     * @param isRetry
     */
    installServices: function (isRetry) {

      // clear requests since we are installing services
      // and we don't want to get tasks for previous install attempts
      this.set('content.cluster.oldRequestsId', []);
      var clusterName = this.get('content.cluster.name');
      var data;
      var name;

      switch (this.get('content.controllerName')) {
        case 'addHostController':

          var hostnames = [];
          for (var hostname in App.db.getHosts()) {
            hostnames.push(hostname);
          }

          if (isRetry) {
            name = 'wizard.install_services.add_host_controller.is_retry';
          }
          else {
            name = 'wizard.install_services.add_host_controller.not_is_retry';
          }
          data = {
            "RequestInfo": {
              "context": Em.I18n.t('requestInfo.installComponents'),
              "query": "HostRoles/host_name.in(" + hostnames.join(',') + ")"
            },
            "Body": {
              "HostRoles": {"state": "INSTALLED"}
            }
          };
          data = JSON.stringify(data);
          break;
        case 'installerController':
        default:
          if (isRetry) {
            name = 'wizard.install_services.installer_controller.is_retry';
            data = '{"RequestInfo": {"context" :"'+ Em.I18n.t('requestInfo.installComponents') +'"}, "Body": {"HostRoles": {"state": "INSTALLED"}}}';
          }
          else {
            name = 'wizard.install_services.installer_controller.not_is_retry';
            data = '{"RequestInfo": {"context" :"'+ Em.I18n.t('requestInfo.installServices') +'"}, "Body": {"ServiceInfo": {"state": "INSTALLED"}}}';
          }
          break;
      }

      App.ajax.send({
        name: name,
        sender: this,
        data: {
          data: data,
          cluster: clusterName
        },
        success: 'installServicesSuccessCallback',
        error: 'installServicesErrorCallback'
      });
    },

    installServicesSuccessCallback: function (jsonData) {
      var installStartTime = new Date().getTime();
      console.log("TRACE: In success function for the installService call");
      if (jsonData) {
        var requestId = jsonData.Requests.id;
        console.log('requestId is: ' + requestId);
        var clusterStatus = {
          status: 'PENDING',
          requestId: requestId,
          isInstallError: false,
          isCompleted: false,
          installStartTime: installStartTime
        };
        this.saveClusterStatus(clusterStatus);
      } else {
        console.log('ERROR: Error occurred in parsing JSON data');
      }
    },

    installServicesErrorCallback: function (request, ajaxOptions, error) {
      console.log("TRACE: In error function for the installService call");
      console.log("TRACE: error code status is: " + request.status);
      console.log('Error message is: ' + request.responseText);
      var clusterStatus = {
        status: 'PENDING',
        requestId: this.get('content.cluster.requestId'),
        isInstallError: true,
        isCompleted: false
      };
      this.saveClusterStatus(clusterStatus);
      App.showAlertPopup(Em.I18n.t('common.errorPopup.header'), request.responseText);
    },

    bootstrapRequestId: null,

    /*
     Bootstrap selected hosts.
     */
    launchBootstrap: function (bootStrapData) {
      App.ajax.send({
        name: 'wizard.launch_bootstrap',
        sender: this,
        data: {
          bootStrapData: bootStrapData
        },
        success: 'launchBootstrapSuccessCallback',
        error: 'launchBootstrapErrorCallback'
      });

      return this.get('bootstrapRequestId');
    },

    launchBootstrapSuccessCallback: function (data) {
      console.log("TRACE: POST bootstrap succeeded");
      this.set('bootstrapRequestId', data.requestId);
    },

    launchBootstrapErrorCallback: function () {
      console.log("ERROR: POST bootstrap failed");
      alert('Bootstrap call failed. Please try again.');
    },

    /**
     * Load <code>content.<name></code> variable from localStorage, if wasn't loaded before.
     * If you specify <code>reload</code> to true - it will reload it.
     * @param name
     * @param reload
     * @return {Boolean}
     */
    load: function (name, reload) {
      if (this.get('content.' + name) && !reload) {
        return false;
      }
      var result = App.db['get' + name.capitalize()]();
      if (!result){
        result = this['get' + name.capitalize()]();
        App.db['set' + name.capitalize()](result);
        console.log(this.get('name') + ": created " + name, result);
      }
      this.set('content.' + name, result);
      console.log(this.get('name') + ": loaded " + name, result);
    },

    save: function(name){
      var value = this.toObject(this.get('content.' + name));
      App.db['set' + name.capitalize()](value);
      console.log(this.get('name') + ": saved " + name, value);
    },

    clear: function () {
      this.set('content', Ember.Object.create({
        'controllerName': this.get('content.controllerName')
      }));
      this.set('currentStep', 0);
      this.clearStorageData();
    },

    clusterStatusTemplate : {
      name: "",
      status: "PENDING",
      isCompleted: false,
      requestId: null,
      installStartTime: null,
      installTime: null,
      isInstallError: false,
      isStartError: false,
      oldRequestsId: []
    },

    clearStorageData: function(){
      App.db.setService(undefined); //not to use this data at AddService page
      App.db.setHosts(undefined);
      App.db.setMasterComponentHosts(undefined);
      App.db.setSlaveComponentHosts(undefined);
      App.db.setCluster(undefined);
      App.db.setAllHostNames(undefined);
      App.db.setInstallOptions(undefined);
      App.db.setAllHostNamesPattern(undefined);
    },

    installOptionsTemplate: {
      hostNames: "", //string
      manualInstall: false, //true, false
      useSsh: true, //bool
      isJavaHome : false, //bool
      javaHome: App.defaultJavaHome, //string
      localRepo: false, //true, false
      sshKey: "", //string
      bootRequestId: null, //string
      sshUser: "root" //string
    },

    loadedServiceComponents: null,

    /**
     * Generate serviceComponents as pr the stack definition  and save it to localdata
     * called form stepController step4WizardController
     */
    loadServiceComponents: function () {
      App.ajax.send({
        name: 'wizard.service_components',
        sender: this,
        data: {
          stackUrl: App.get('stack2VersionURL'),
          stackVersion: App.get('currentStackVersionNumber')
        },
        success: 'loadServiceComponentsSuccessCallback',
        error: 'loadServiceComponentsErrorCallback'
      });
      return this.get('loadedServiceComponents');
    },

    loadServiceComponentsSuccessCallback: function (jsonData) {
      var displayOrderConfig = require('data/services');
      console.log("TRACE: getService ajax call  -> In success function for the getServiceComponents call");
      console.log("TRACE: jsonData.services : " + jsonData.items);

      // Creating Model
      var Service = Ember.Object.extend({
        serviceName: null,
        displayName: null,
        isDisabled: true,
        isSelected: true,
        isInstalled: false,
        description: null,
        version: null
      });

      var data = [];

      // loop through all the service components
      for (var i = 0; i < displayOrderConfig.length; i++) {
        var entry = jsonData.items.findProperty("StackServices.service_name", displayOrderConfig[i].serviceName);
        if (entry) {
          var myService = Service.create({
            serviceName: entry.StackServices.service_name,
            displayName: displayOrderConfig[i].displayName,
            isDisabled: displayOrderConfig[i].isDisabled,
            isSelected: displayOrderConfig[i].isSelected,
            canBeSelected: displayOrderConfig[i].canBeSelected,
            isInstalled: false,
            isHidden: displayOrderConfig[i].isHidden,
            description: entry.StackServices.comments,
            version: entry.StackServices.service_version
          });

          data.push(myService);
        }
        else {
          console.warn('Service not found - ', displayOrderConfig[i].serviceName);
        }
      }

      this.set('loadedServiceComponents', data);
      console.log('TRACE: service components: ' + JSON.stringify(data));

    },

    loadServiceComponentsErrorCallback: function (request, ajaxOptions, error) {
      console.log("TRACE: STep5 -> In error function for the getServiceComponents call");
      console.log("TRACE: STep5 -> error code status is: " + request.status);
      console.log('Step8: Error message is: ' + request.responseText);
    },

    loadServicesFromServer: function() {
      var services = App.db.getService();
      if (services) {
        return;
      }
      var apiService = this.loadServiceComponents();
      this.set('content.services', apiService);
      App.db.setService(apiService);
    },

    registerErrPopup: function (header, message) {
      App.ModalPopup.show({
        header: header,
        secondary: false,
        onPrimary: function () {
          this.hide();
        },
        bodyClass: Ember.View.extend({
          template: Ember.Handlebars.compile(['<p>{{view.message}}</p>'].join('\n')),
          message: message
        })
      });
    },

    /**
     * Save hosts that the user confirmed to proceed with from step 3
     * @param stepController App.WizardStep3Controller
     */
    saveConfirmedHosts: function (stepController) {
      var hostInfo = {};

      stepController.get('content.hosts').forEach(function (_host) {
        hostInfo[_host.name] = {
          name: _host.name,
          cpu: _host.cpu,
          memory: _host.memory,
          disk_info: _host.disk_info,
          bootStatus: _host.bootStatus,
          isInstalled: false
        };
      });
      console.log('wizardController:saveConfirmedHosts: save hosts ', hostInfo);
      App.db.setHosts(hostInfo);
      this.set('content.hosts', hostInfo);
    },

    /**
     * Save data after installation to main controller
     * @param stepController App.WizardStep9Controller
     */
    saveInstalledHosts: function (stepController) {
      var hosts = stepController.get('hosts');
      var hostInfo = App.db.getHosts();

      for (var index in hostInfo) {
        hostInfo[index].status = "pending";
        var host = hosts.findProperty('name', hostInfo[index].name);
        if (host) {
          hostInfo[index].status = host.status;
          hostInfo[index].message = host.message;
          hostInfo[index].progress = host.progress;
        }
      }
      this.set('content.hosts', hostInfo);
      this.save('hosts');
      console.log('wizardController:saveInstalledHosts: save hosts ', hostInfo);
    },

    /**
     * Save slaveHostComponents to main controller
     * @param stepController
     */
    saveSlaveComponentHosts: function (stepController) {

      var hosts = stepController.get('hosts');
      var headers = stepController.get('headers');

      var formattedHosts = Ember.Object.create();
      headers.forEach(function(header) {
        formattedHosts.set(header.get('name'), []);
      });

      hosts.forEach(function (host) {

        var checkboxes = host.get('checkboxes');
        headers.forEach(function(header) {
          var cb = checkboxes.findProperty('title', header.get('label'));
          if (cb.get('checked')) {
            formattedHosts.get(header.get('name')).push({
              hostName: host.hostName,
              group: 'Default',
              isInstalled: cb.get('isInstalled')
            });
          }
        });
      });

      var slaveComponentHosts = [];

      headers.forEach(function(header) {
        slaveComponentHosts.push({
          componentName: header.get('name'),
          displayName: header.get('label').replace(/\s/g, ''),
          hosts: formattedHosts.get(header.get('name'))
        });
      });

      App.db.setSlaveComponentHosts(slaveComponentHosts);
      console.log('wizardController.slaveComponentHosts: saved hosts', slaveComponentHosts);
      this.set('content.slaveComponentHosts', slaveComponentHosts);
    },

    /**
     * Return true if cluster data is loaded and false otherwise.
     * This is used for all wizard controllers except for installer wizard.
     */
    dataLoading: function(){
      var dfd = $.Deferred();
      this.connectOutlet('loading');
      if (App.router.get('clusterController.isLoaded')){
        dfd.resolve();
      } else{
        var interval = setInterval(function(){
          if (App.router.get('clusterController.isLoaded')){
            dfd.resolve();
            clearInterval(interval);
          }
        },50);
      }
      return dfd.promise();
    },

    /**
     * Save cluster status before going to deploy step
     * @param name cluster state. Unique for every wizard
     */
    saveClusterState: function(name){
      App.clusterStatus.setClusterStatus({
        clusterName: this.get('content.cluster.name'),
        clusterState: name,
        wizardControllerName: this.get('content.controllerName'),
        localdb: App.db.data
      });
    },

    /**
     * load advanced configs from server
     */
    loadAdvancedConfigs: function () {
      var configs = (App.db.getAdvancedServiceConfig()) ? App.db.getAdvancedServiceConfig() : [];
      this.get('content.services').filterProperty('isSelected', true).mapProperty('serviceName').forEach(function (_serviceName) {
        var serviceComponents = App.config.loadAdvancedConfig(_serviceName);
        if(serviceComponents){
          configs = configs.concat(serviceComponents);
        }
      }, this);
      this.set('content.advancedServiceConfig', configs);
      App.db.setAdvancedServiceConfig(configs);
    },
    /**
     * Load serviceConfigProperties to model
     */
    loadServiceConfigProperties: function () {
      var serviceConfigProperties = App.db.getServiceConfigProperties();
      this.set('content.serviceConfigProperties', serviceConfigProperties);
      console.log("AddHostController.loadServiceConfigProperties: loaded config ", serviceConfigProperties);
    },
    /**
     * Save config properties
     * @param stepController Step7WizardController
     */
    saveServiceConfigProperties: function (stepController) {
      var serviceConfigProperties = [];
      stepController.get('stepConfigs').forEach(function (_content) {
        _content.get('configs').forEach(function (_configProperties) {
          var displayType = _configProperties.get('displayType');
          if (displayType === 'directories' || displayType === 'directory') {
            var value = _configProperties.get('value').trim().split(/\s+/g).join(',');
            _configProperties.set('value', value);
          }
          var overrides = _configProperties.get('overrides');
          var overridesArray = [];
          if(overrides!=null){
            overrides.forEach(function(override){
              var overrideEntry = {
                value: override.get('value'),
                hosts: []
              };
              override.get('selectedHostOptions').forEach(function(host){
                overrideEntry.hosts.push(host);
              });
              overridesArray.push(overrideEntry);
            });
          }
          overridesArray = (overridesArray.length) ? overridesArray : null;
          var configProperty = {
            id: _configProperties.get('id'),
            name: _configProperties.get('name'),
            value: _configProperties.get('value'),
            defaultValue: _configProperties.get('defaultValue'),
            serviceName: _configProperties.get('serviceName'),
            domain:  _configProperties.get('domain'),
            filename: _configProperties.get('filename'),
            overrides: overridesArray
          };
          serviceConfigProperties.push(configProperty);
        }, this);
      }, this);
      App.db.setServiceConfigProperties(serviceConfigProperties);
      this.set('content.serviceConfigProperties', serviceConfigProperties);
    }
  })
  
});
window.require.register("controllers/wizard/slave_component_groups_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var App = require('app');
  /**
   * Used to manage slave component config. User could create different settings for separate group
   * @type {*}
   */
  App.SlaveComponentGroupsController = Em.ArrayController.extend({

    name: 'slaveComponentGroupsController',

    contentBinding: 'App.router.wizardStep7Controller.slaveComponentHosts',

    stepConfigsBinding: 'App.router.wizardStep7Controller.stepConfigs',

    serviceBinding: 'App.router.wizardStep7Controller.selectedService',

    servicesBinding: 'App.router.wizardStep7Controller.content.services',

    clearStep: function () {

    },

    loadStep: function () {
      this.clearStep();
      this.loadGroups();
    },

    loadGroups: function () {

      this.get('stepConfigs').forEach(function (_serviceConfig) {
        var categoryConfig = _serviceConfig.get('configCategories');
        if (categoryConfig.someProperty('isForSlaveComponent', true)) {
          var slaveCategory = categoryConfig.findProperty('isForSlaveComponent', true);
          // this.get('content') -> Output of Step 6: Mapping of each slave component and set of hosts it runs on
          if (this.get('content')) {
            if (this.get('content').someProperty('componentName', slaveCategory.get('primaryName'))) {
              // component --> each column in Step 6 is a component ( slave component )
              var component = this.get('content').findProperty('componentName', slaveCategory.get('primaryName'));
              // slaveConfigs --> originally set as null in the class App.SlaveCategory in model/service_config.js
              var slaveConfigs = slaveCategory.get('slaveConfigs');
              
              slaveCategory.set('slaveConfigs', App.SlaveConfigs.create(component));
              var slaveGroups = [];
              if (component.groups) {
                component.groups.forEach(function (_group) {
                  slaveGroups.pushObject(_group);
                }, this);
                slaveCategory.set('slaveConfigs.groups', slaveGroups);
              }
              slaveCategory.set('slaveConfigs.componentName', component.componentName);
              slaveCategory.set('slaveConfigs.displayName', component.displayName);
              /*slaveCategory.set('slaveConfigs.groups.name', component.get('name'));
               slaveCategory.set('slaveConfigs.groups.index', component.get('index'));
               slaveCategory.set('slaveConfigs.groups.type', component.get('type'));
               slaveCategory.set('slaveConfigs.groups.active', component.get('active'));*/
              if (!slaveCategory.get('slaveConfigs.groups')) {
                slaveCategory.set('slaveConfigs.groups', []);
                var componentProperties = this.componentProperties(_serviceConfig.serviceName);
                var defaultGroup = {name: 'Default', index: 'default', type: 'default', active: true, properties: componentProperties};
                slaveCategory.get('slaveConfigs.groups').pushObject(App.Group.create(defaultGroup));
              }
            }
          }
        }
      }, this);
    },

    // returns key-value pairs i.e. all fields for slave component for this specific service.
    componentProperties: function (serviceName) {

      var serviceConfigs = App.config.get('preDefinedServiceConfigs').findProperty('serviceName', serviceName);

      var configs = [];
      var componentName = null;
      switch (serviceName) {
        case 'HDFS':
          componentName = 'DataNode';
          break;
        case 'MAPREDUCE':
          componentName = 'TaskTracker';
          break;
        case 'HBASE':
          componentName = 'RegionServer';
      }
      var slaveConfigs = serviceConfigs.configs.filterProperty('category', componentName);
      slaveConfigs.forEach(function (_serviceConfigProperty) {
        var serviceConfigProperty = App.ServiceConfigProperty.create(_serviceConfigProperty);

        switch(serviceConfigProperty.name){
          case 'dfs_data_dir' :
            serviceConfigProperty.initialValue();
            break;
          case 'mapred_local_dir' :
            serviceConfigProperty.initialValue();
            break;
        }
        configs.pushObject(serviceConfigProperty);
        serviceConfigProperty.validate();
      }, this);
      return configs;
    },

    selectedComponentName: function () {
      switch (App.router.get('wizardStep7Controller.selectedService.serviceName')) {
        case 'HDFS':
          return { name: 'DATANODE',
            displayName: 'DataNode'};
        case 'MAPREDUCE':
          return { name: 'TASKTRACKER',
            displayName: 'TaskTracker'};

        case 'HBASE':
          return { name: 'HBASE_REGIONSERVER',
            displayName: 'RegionServer'};
        default:
          return null;
      }

    }.property('service'),

    selectedComponentDisplayName: function() {
      return App.format.role(this.get('selectedComponentName'));
    }.property('selectedComponentName'),

    selectedSlaveComponent: function () {
      var selectedComponentName = this.get('selectedComponentName') ? this.get('selectedComponentName').displayName : null;
      var configs = null;
      if (selectedComponentName) {
        App.router.get('wizardStep7Controller.stepConfigs').forEach(function (_serviceConfig) {
          var categoryConfig = _serviceConfig.get('configCategories');
          if (categoryConfig.someProperty('name', selectedComponentName)) {
            configs = categoryConfig.findProperty('name', selectedComponentName).get('slaveConfigs');
          }
        }, this);
      }
      return configs;
    }.property('selectedComponentName', 'stepConfigs.@each.configCategories', 'stepConfigs.@each.configCategories.@each.slaveConfigs'),

    hosts: function () {
      if (this.get('selectedSlaveComponent')) {
        return this.get('selectedSlaveComponent').get('hosts');
      }
    }.property('selectedSlaveComponent'),

    groups: function () {
      var hosts = this.get('hosts');
      if(hosts){
        return hosts.mapProperty('group').uniq();
      }
    }.property('hosts'),

    componentGroups: function () {
      var component = this.get('selectedSlaveComponent');
      if (component && component.get('groups')) {
        return component.get('groups');
      }
      return [];
    }.property('selectedSlaveComponent', 'selectedSlaveComponent.groups', 'stepConfigs.@each.configCategories.@each.slaveConfigs.groups.@each.properties.@each.value'),


    getGroupsForDropDown: function () {
      return this.get('componentGroups').getEach('name');
    }.property('selectedComponentName', 'componentGroups.@each.name'),

    activeGroup: function () {
      var componentGroups = this.get('componentGroups');
      if (componentGroups) {
        var active = componentGroups.findProperty('active', true);
        if (active){
          return active;
        }
      }
      return null;
    }.property('componentGroups.@each.active', 'componentGroups.@each.name', 'componentGroups.@each.properties.@each.value'),


    /**
     * Show slave hosts to groups popup
     * @param event
     */
    showAddSlaveComponentGroup: function (event) {
      var componentName = event.context;
      var component = this.get('selectedSlaveComponent');
      App.ModalPopup.show({
        header: componentName + Em.I18n.t('installer.controls.slaveComponentGroups'),
        bodyClass: Ember.View.extend({
          controllerBinding: 'App.router.slaveComponentGroupsController',
          header: Em.I18n.t('installer.slaveComponentHostsPopup.header').format(this.get('selectedComponentDisplayName')),
          templateName: require('templates/wizard/slave_component_hosts_popup')
        }),
        onPrimary: function (event) {
          if (component.tempSelectedGroups && component.tempSelectedGroups.length) {
            component.tempSelectedGroups.forEach(function (item) {
              var changed = component.get('hosts').filterProperty('hostName', item.hostName);
              changed.setEach('group', item.groupName);
            })
          }
          delete component.tempSelectedGroups;
          this.hide();
        },
        onSecondary: function (event) {
          delete component.tempSelectedGroups;
          this.hide();
        },
        onClose: function (event) {
          delete component.tempSelectedGroups;
          this.hide();
        }
      });
    },

    /**
     * Utility method. Save temporary info about changes in <code>slave hosts to groups</code> popup
     * @param host
     * @param groupName
     */
    changeHostGroup: function (host, groupName) {
      var component = this.get('selectedSlaveComponent');
      if (component.tempSelectedGroups === undefined) {
        component.tempSelectedGroups = [];
      }
      var values = component.tempSelectedGroups.filterProperty('hostName', host.hostName);
      if (values.length === 0)
        component.tempSelectedGroups.pushObject({hostName: host.hostName, groupName: groupName});
      else
        values.setEach('groupName', groupName);

    },

    /**
     * add new group to component(click on button)
     */
    addSlaveComponentGroup: function () {
      var component = this.get('selectedSlaveComponent');
      var newGroupName = 'New Group';
      component.get('groups').setEach('active', false);
      var newGroups = component.get('groups').filterProperty('name', newGroupName);
      if (newGroups.length === 0){
        component.newGroupIndex = 0;
      }
      else {
        component.newGroupIndex = component.newGroupIndex || 0;
        this.checkGroupName();
        newGroupName = 'New Group ' + component.newGroupIndex;
      }
      var newGroup = {name: newGroupName, index: component.newGroupIndex, type: 'new', active: true, properties: this.componentProperties(App.router.get('wizardStep7Controller.selectedService.serviceName'))};
      component.groups.pushObject(App.Group.create(newGroup));
      $('.remove-group-error').hide();
    },

    checkGroupName: function () {
      var component = this.get('selectedSlaveComponent');
      component.newGroupIndex++;
      var newGroupName = 'New Group ' + component.newGroupIndex;
      var groups = component.get('groups').filterProperty('name', newGroupName);
      if (groups.length !== 0) {
        this.checkGroupName();
      }
    },

    /**
     * Onclick handler for <code>choose hosts for slave group</code> link
     * @param event
     */
    showEditSlaveComponentGroups: function (event) {
      this.showAddSlaveComponentGroup(event);
    },

    getHostsByGroup: function (group) {
      var hosts = this.get('hosts');
      if(hosts){
        return hosts.filterProperty('group', group.name);
      }
    },

    /**
     * Change tab
     * @param event
     */
    showSlaveComponentGroup: function (event) {
      var component = this.get('selectedSlaveComponent');
      if(!component.groups){

      }
      component.get('groups').setEach('active', false);
      var group = component.get('groups').filterProperty('name', event.context.name);
      group.setEach('active', true);
      var assignedHosts = component.get('hosts').filterProperty('group', event.context.name);
      if (assignedHosts.length === 0) {
        $('.remove-group-error').hide();
      }
    },

    /**
     * Remove tab
     * @param event
     */
    removeSlaveComponentGroup: function (event) {
      var group = event.context;
      var component = this.get('selectedSlaveComponent');
      var assignedHosts = component.get('hosts').filterProperty('group', group.name);
      if (assignedHosts.length !== 0) {
        $('.remove-group-error').show();
      } else {
        $('.remove-group-error').hide();
        var key = component.groups.indexOf(group);
        component.groups.removeObject(component.groups[key]);

        var newGroups = component.groups.filterProperty('type', 'new');
        if (newGroups.length == 0)
          component.newGroupIndex = 0;
        else {
          var lastNewGroup = newGroups[newGroups.length - 1];
          component.newGroupIndex = lastNewGroup.index;
        }
        if (group.active) {
          var lastGroup;
          if (key === component.groups.length)
            lastGroup = component.groups.slice(key - 1, key);
          else lastGroup = component.groups.slice(key, key + 1);
          lastGroup.setEach('active', true);
        }
      }
    },

    /**
     * change group name of slave component
     * @param group
     * @param newGroupName
     * @return {Boolean}
     */
    changeSlaveGroupName: function (group, newGroupName) {
      var component = this.get('selectedSlaveComponent');
      var isExist = component.get('groups').filterProperty('name', newGroupName);
      if (isExist.length !== 0)
        return true;
      else {
        var assignedHosts = component.get('hosts').filterProperty('group', group.name);
        if (assignedHosts.length !== 0){
          assignedHosts.setEach('group', newGroupName);
        }
        var groupFilter = component.get('groups').filterProperty('name', group.name);
        groupFilter.setEach('name', newGroupName);
      }
      return false;
    }

  });
  
});
window.require.register("controllers/wizard/stack_upgrade/step1_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.StackUpgradeStep1Controller = Em.Controller.extend({
    name: 'stackUpgradeStep1Controller'
  });
  
});
window.require.register("controllers/wizard/stack_upgrade/step2_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.StackUpgradeStep2Controller = Em.Controller.extend({
    name: 'stackUpgradeStep2Controller',
    /**
     * check whether all services are running
     * @return {Array}
     */
    isAllServicesRunning: function(){
      var masterComponents = App.HostComponent.find().filterProperty('isMaster', true);
      return masterComponents.everyProperty('workStatus', 'STARTED');
    },
    /**
     * callback, which save step data and route to next step
     * @param event
     */
    upgradeAction: function(event){
      if(this.isAllServicesRunning()){
        App.router.send('next');
      } else {
        this.showWarningPopup();
      }
    },
    /**
     * show warning popup if not all services are running
     */
    showWarningPopup: function(){
      App.ModalPopup.show({
        header: Em.I18n.t('installer.step2.manualInstall.popup.header'),
        onPrimary: function () {
          this.hide();
        },
        secondary: null,
        bodyClass: Ember.View.extend({
          template: Em.Handlebars.compile('{{t installer.stackUpgrade.step2.popup.body}}')
        })
      });
    }
  });
  
});
window.require.register("controllers/wizard/stack_upgrade/step3_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.StackUpgradeStep3Controller = Em.Controller.extend({
    name: 'stackUpgradeStep3Controller',

    POLL_INTERVAL: 4000,
    isPolling: false,
    /**
     * STOP_SERVICES internal statuses:
     * - PENDING
     * - IN_PROGRESS
     * - SUCCESS
     * - FAILED
     * UPGRADE_SERVICES internal statuses:
     * - PENDING
     * - IN_PROGRESS
     * - SUCCESS
     * - FAILED
     * - WARNING
     */
    processes:[
      Em.Object.create({
        name: 'STOP_SERVICES',
        displayName: Em.I18n.t('installer.stackUpgrade.step3.stop.header'),
        progress:0,
        status: 'PENDING',
        message: null,
        isRunning: false,
        hosts: [],
        isRetry: false
      }),
      Em.Object.create({
        name: 'UPGRADE_SERVICES',
        displayName: Em.I18n.t('installer.stackUpgrade.step3.upgrade.header'),
        progress: 0,
        status: 'PENDING',
        message:'',
        isRunning: false,
        hosts: [],
        isRetry: false
      })
    ],
    /**
     * pass processes as services to popup
     */
    services: function(){
      return this.get('processes');
    }.property('processes'),
    /**
     * save current requestId and clusterState
     * to localStorage and put it to server
     *
     * STOP_SERVICES cluster status:
     * - STOPPING_SERVICES,
     * UPGRADE_SERVICES cluster status:
     * - STACK_UPGRADING,
     * - STACK_UPGRADE_FAILED,
     * - STACK_UPGRADED,
     * - STACK_UPGRADE_COMPLETED
     */
    saveClusterStatus: function(clusterStatus){
      var oldStatus = this.get('content.cluster');
      clusterStatus = jQuery.extend(oldStatus, clusterStatus);
      this.set('content.cluster', clusterStatus);
      App.router.get(this.get('content.controllerName')).save('cluster');
      if(!App.testMode){
        App.clusterStatus.setClusterStatus({
          clusterName: this.get('content.cluster.name'),
          clusterState: clusterStatus.status,
          wizardControllerName: 'stackUpgradeController',
          localdb: App.db.data
        });
      }
    },
    // provide binding for Host Popup data
    serviceTimestamp: null,
    /**
     * load hosts for each process
     */
    loadHosts: function () {
      var hosts = [];
      var installedHosts = App.Host.find();
      this.get('processes').forEach(function(process){
        var hosts = [];
        installedHosts.forEach(function (host) {
          hosts.push(Em.Object.create({
            name: host.get('hostName'),
            publicName: host.get('publicHostName'),
            logTasks: []
          }));
        });
        process.set('hosts', hosts);
      });
    }.observes('content.servicesInfo'),
    submitButton: null,
    /**
     * restart upgrade
     * restart stop services
     * @param event
     */
    retry: function(event){
      var processName = event.context;
      var process = this.get('processes').findProperty('name', processName);
      this.resetProgress(process);
      this.resetMockConfig();
      if(processName == 'STOP_SERVICES'){
        this.stopServices();
      } else {
        this.set('submitButton', false);
        this.runUpgrade();
      }
    },
    /**
     * reset progress and status to retry
     * @param process
     */
    resetProgress: function(process){
      process.set('isRetry', false);
      process.set('status', 'PENDING');
      process.set('progress', 0);
      process.get('hosts').forEach(function(host){host.get('logTasks').clear()});
    },
    /**
     * run stop services
     */
    stopServices: function () {
      var process = this.get('processes').findProperty('name', 'STOP_SERVICES');
      process.set('isRunning', true);
      if (App.testMode) {
        this.startPolling();
        this.saveClusterStatus({
          requestId: 1,
          status: 'STOPPING_SERVICES',
          isCompleted: false
        });
      }
      else {
        var data = '{"RequestInfo": {"context": "'+ Em.I18n.t("requestInfo.stopAllServices") +'"}, "Body": {"ServiceInfo": {"state": "INSTALLED"}}}';
        App.ajax.send({
          name: 'admin.stack_upgrade.stop_services',
          sender: this,
          data: {
            data: data
          },
          success: 'stopServicesSuccessCallback',
          error: 'stopServicesErrorCallback'
        });
      }
    },
    stopServicesSuccessCallback: function (data) {
      var process = this.get('processes').findProperty('name', 'STOP_SERVICES');
      var requestId = data.Requests.id;
      var clusterStatus = {
        requestId: requestId,
        status: 'STOPPING_SERVICES',
        isCompleted: false
      };
      process.set('status', 'IN_PROGRESS');
      this.saveClusterStatus(clusterStatus);
      this.startPolling();
      console.log('Call to stop service successful')
    },
    stopServicesErrorCallback: function () {
      var process = this.get('processes').findProperty('name', 'STOP_SERVICES');
      this.finishProcess(process, 'FAILED');
      process.set('status', 'FAILED');
      console.log("Call to stop services failed");
    },
    /**
     * send request to run upgrade all services
     */
    runUpgrade: function () {
      var process = this.get('processes').findProperty('name', 'UPGRADE_SERVICES');
      process.set('isRunning', true);
      if (App.testMode) {
        this.startPolling();
        this.saveClusterStatus({
          requestId: 1,
          status: 'STACK_UPGRADING',
          isCompleted: false
        });
      }
      else {
        var data = '{"Clusters": {"version" : "' + this.get('content.upgradeVersion') + '"}}';
        App.ajax.send({
          name: 'admin.stack_upgrade.run_upgrade',
          sender: this,
          data: {
            data: data
          },
          success: 'runUpgradeSuccessCallback',
          error: 'runUpgradeErrorCallback'
        });
      }
    },
    runUpgradeSuccessCallback: function (jsonData) {
      var process = this.get('processes').findProperty('name', 'UPGRADE_SERVICES');
      var requestId = jsonData.Requests.id;
      var clusterStatus = {
        status: 'STACK_UPGRADING',
        requestId: requestId,
        isCompleted: false
      };
      process.set('status', 'IN_PROGRESS');
      this.saveClusterStatus(clusterStatus);
      this.startPolling();
    },

    runUpgradeErrorCallback: function (request, ajaxOptions, error) {
      var process = this.get('processes').findProperty('name', 'UPGRADE_SERVICES');
      this.finishProcess(process, 'FAILED');
      process.set('status', 'FAILED');
    },

    /**
     * start polling tasks for current process
     */
    startPolling: function(){
      if(!this.get('isPolling')){
        this.set('isPolling', true);
        if (App.testMode) {
          this.simulatePolling();
        } else {
          //pass an interval "1" to start poll immediately first time
          this.doPoll(1);
        }
      }
    },
    simulateAttempt:0,
    mockUrl:'',
    /**
     * simulate actual poll, using mock data
     */
    simulatePolling: function(){
      var simulateAttempt = this.get('simulateAttempt');
      var process = this.get('processes').findProperty('isRunning', true);
      var upgradeURLs = [
        '/upgrade/poll_1.json',
        '/upgrade/poll_2.json',
        '/upgrade/poll_3.json',
        '/upgrade/poll_4.json',
        '/upgrade/poll_5.json'
      ];
      var stopURLs = [
        '/stop_services/poll_1.json',
        '/stop_services/poll_2.json',
        '/stop_services/poll_3.json',
        '/stop_services/poll_4.json'
      ];
      if(process.get('name') == 'STOP_SERVICES'){
        if(simulateAttempt < 4){
          this.set('mockUrl', stopURLs[simulateAttempt]);
          this.doPoll();
          this.set('simulateAttempt', ++simulateAttempt);
        }
      } else {
        if(simulateAttempt < 5){
          this.set('mockUrl', upgradeURLs[simulateAttempt]);
          this.doPoll();
          this.set('simulateAttempt', ++simulateAttempt);
        }
      }
    },
    getUrl:function(){
      var requestId = this.get('content.cluster.requestId');
      var clusterName = this.get('content.cluster.name');
      if(App.testMode){
        return this.get('mockUrl');
      }
      return App.apiPrefix + '/clusters/' + clusterName + '/requests/' + requestId + '?fields=tasks/*';
    },
    /**
     * poll server for tasks, which contain process progress data
     * @param interval
     */
    doPoll: function(interval) {
      var self = this;
      var pollInterval = interval || self.POLL_INTERVAL;
      if (self.get('isPolling')) {
        setTimeout(function () {

          App.ajax.send({
            name: 'admin.stack_upgrade.do_poll',
            sender: self,
            data: {
              cluster: self.get('content.cluster.name'),
              requestId: self.get('content.cluster.requestId'),
              mock: self.get('mockUrl')
            },
            success: 'doPollSuccessCallback',
            error: 'doPollErrorCallback'
          }).retry({
              times: App.maxRetries,
              timeout: App.timeout
            }).then(
              null,
              function () {
                App.showReloadPopup();
                console.log('Install services all retries failed');
              });
        }, pollInterval);
      }
    },

    doPollSuccessCallback: function (data) {
      var result = this.parseTasks(data);
      if(result){
        if (App.testMode) {
          this.simulatePolling();
        }
        else {
          this.doPoll();
        }
      }
    },

    doPollErrorCallback: function () {
      console.log('ERROR: poll request failed')
    },

    /**
     * parse tasks from poll
     * change status, message, progress on services according to tasks
     * @param data
     * @return {Boolean}
     */
    parseTasks: function(data){
      var tasks = data.tasks || [];
      var process = this.get('processes').findProperty('isRunning', true);
      // if process was finished then it terminates next poll
      var continuePolling = true;

      this.progressOnProcess(tasks, process);
      continuePolling = this.statusOnProcess(tasks, process);
      if(process.get('hosts').length && tasks.length){
        process.get('hosts').forEach(function (host) {
          var tasksPerHost = tasks.filterProperty('Tasks.host_name', host.name);
          if (tasksPerHost.length) {
            this.setLogTasksStatePerHost(tasksPerHost, host);
          }
        }, this);
      }
      this.set('serviceTimestamp', new Date().getTime());
      return continuePolling;
    },
    /**
     * calculate progress according to tasks status
     * @param actions
     * @param process
     */
    progressOnProcess: function(actions, process){
      var progress = 0;
      var actionsNumber = actions.length;
      var completedActions = actions.filterProperty('Tasks.status', 'COMPLETED').length
        + actions.filterProperty('Tasks.status', 'FAILED').length
        + actions.filterProperty('Tasks.status', 'ABORTED').length
        + actions.filterProperty('Tasks.status', 'TIMEDOUT').length;
      var queuedActions = actions.filterProperty('Tasks.status', 'QUEUED').length;
      var inProgressActions = actions.filterProperty('Tasks.status', 'IN_PROGRESS').length;
      progress = Math.ceil(((queuedActions * 0.09) + (inProgressActions * 0.35) + completedActions ) / actionsNumber * 100);
      console.log('INFO: progress is: ' + progress);
      process.set('progress', progress);
    },
    /**
     * evaluate status of process according to task status
     * @param actions
     * @param process
     */
    statusOnProcess: function(actions, process){
      var status = null;
      var message = '';
      var continuePolling = true;
      var errorActions = actions.filter(function (action) {
        if (action.Tasks.status == 'FAILED' || action.Tasks.status == 'ABORTED' || action.Tasks.status == 'TIMEDOUT') {
          return true;
        }
      });
      var masterComponents = ['NAMENODE', 'SECONDARY_NAMENODE', 'SNAMENODE', 'JOBTRACKER', 'ZOOKEEPER_SERVER', 'HIVE_SERVER',
        'HIVE_METASTORE', 'MYSQL_SERVER', 'HBASE_MASTER', 'NAGIOS_SERVER', 'GANGLIA_SERVER', 'OOZIE_SERVER', 'WEBHCAT_SERVER'];
      var failedComponents = errorActions.mapProperty('Tasks.role');
      if (failedComponents.length) {
        for (var i = 0; i < failedComponents.length; i++) {
          if (masterComponents.contains(failedComponents[i])) {
            status = "FAILED";
            continuePolling = false;
            this.finishProcess(process, status);
            break;
          } else if(process.get('progress') == 100){
            status = "WARNING";
            if(process.get('name') == 'UPGRADE_SERVICES'){
              continuePolling = false;
              this.finishProcess(process, status);
            }
          }
        }
      }
      if(!status || ((status == 'WARNING') && (process.get('name') == 'STOP_SERVICES'))){
        if (actions.everyProperty('Tasks.status', 'COMPLETED')) {
          status = 'SUCCESS';
          continuePolling = false;
          this.finishProcess(process, status);
        } else {
          var activeAction = actions.findProperty('Tasks.status', 'IN_PROGRESS');
          status = 'IN_PROGRESS';
          if (activeAction === undefined || activeAction === null) {
            activeAction = actions.findProperty('Tasks.status', 'QUEUED');
            status = 'PENDING';
          }
          if (activeAction === undefined || activeAction === null) {
            activeAction = actions.findProperty('Tasks.status', 'PENDING');
            status = 'PENDING';
          }
          if (activeAction) {
            message = this.displayMessage(activeAction.Tasks);
          }
        }
      }
      console.log('INFO: status is: ' + status);
      process.set('status', status);
      process.set('message', message);
      return continuePolling;
    },
    /**
     * complete process phase
     * accept FAILED, SUCCESS, WARNING process status
     * @param process
     * @param status
     */
    finishProcess: function(process, status){
      this.set('isPolling', false);
      if(process.get('name') == 'STOP_SERVICES'){
        if(status == 'SUCCESS'){
          process.set('isRunning', false);
          this.resetMockConfig();
          this.runUpgrade();
        } else {
          process.set('isRetry', true);
        }
      }
      if(process.get('name') == 'UPGRADE_SERVICES'){
        if(status == 'SUCCESS'){
          this.set('submitButton', Em.I18n.t('common.done'));
          this.saveClusterStatus({
            status: 'STACK_UPGRADED',
            isCompleted: true
          })
        } else if(status == 'FAILED') {
          process.set('isRetry', true);
          this.set('submitButton', false);
          this.saveClusterStatus({
            status: 'STACK_UPGRADE_FAILED',
            isCompleted: false
          })
        } else if(status == 'WARNING'){
          this.set('submitButton', Em.I18n.t('installer.stackUpgrade.step3.ProceedWithWarning'));
          process.set('isRetry', true);
          this.saveClusterStatus({
            status: 'STACK_UPGRADED',
            isCompleted: true
          })
        }
      }
    },
    /**
     * set and update logTasks to each host
     * @param tasksPerHost
     * @param host
     */
    setLogTasksStatePerHost: function (tasksPerHost, host) {
      console.log('In step3 setTasksStatePerHost function.');
      tasksPerHost.forEach(function (_task) {
        console.log('In step3 _taskPerHost function.');
        var task = host.get('logTasks').findProperty('Tasks.id', _task.Tasks.id);
        if (task) {
          host.get('logTasks').removeObject(task);
        }
        host.get('logTasks').pushObject(_task);
        //}
      }, this);
    },
    /**
     * reset mock configs to run upgrade simulation again
     */
    resetMockConfig: function(retry){
      this.set('simulateAttempt', 0);
    },
    /**
     * resume wizard on last operation
     */
    resumeStep: function () {
      var clusterStatus = this.get('content.cluster.status');
      var upgrade = this.get('processes').findProperty('name', 'UPGRADE_SERVICES');
      var stop = this.get('processes').findProperty('name', 'STOP_SERVICES');
      if(App.testMode){
        if(this.get('processes').everyProperty('isRunning', false)){
          stop.set('isRunning', true);
        }
        clusterStatus = (this.get('processes').findProperty('name', 'UPGRADE_SERVICES').get('isRunning'))?
         'STACK_UPGRADING':
         'STOPPING_SERVICES';
        upgrade.set('isRetry', false);
        stop.set('isRetry', false);
      }
      if (clusterStatus == 'STOPPING_SERVICES') {
        this.startPolling();
        stop.set('isRunning', true);
        upgrade.set('isRunning', false);
      } else if(clusterStatus != 'PENDING'){
        stop.set('status', 'SUCCESS');
        stop.set('progress', 100);
        stop.set('isRunning', false);
        upgrade.set('isRunning', true);
        if (clusterStatus == 'STACK_UPGRADING') {
          upgrade.set('status', 'IN_PROGRESS');
          this.startPolling();
        } else if (clusterStatus == 'STACK_UPGRADE_FAILED') {
          upgrade.set('status', 'FAILED');
          upgrade.set('isRetry', true);
        } else if (clusterStatus == 'STACK_UPGRADED') {
          upgrade.set('status', 'SUCCESS');
          upgrade.set('progress', 100);
          this.startPolling();
          this.set('isPolling', false);
        }
      }
    },
    /**
     * determine description of current running process
     * @param task
     * @return {*}
     */
    displayMessage: function (task) {
      var role = App.format.role(task.role);
      console.log("In display message with task command value: " + task.command);
      switch (task.command){
        case 'UPGRADE':
          switch (task.status) {
            case 'PENDING':
              return Em.I18n.t('installer.step9.serviceStatus.upgrade.pending') + role;
            case 'QUEUED' :
              return Em.I18n.t('installer.step9.serviceStatus.upgrade.queued') + role;
            case 'IN_PROGRESS':
              return Em.I18n.t('installer.step9.serviceStatus.upgrade.inProgress') + role;
            case 'COMPLETED' :
              return Em.I18n.t('installer.step9.serviceStatus.upgrade.completed') + role;
            case 'FAILED':
              return Em.I18n.t('installer.step9.serviceStatus.upgrade.failed') + role;
          }
          break;
        case 'STOP' :
          switch (task.status) {
            case 'PENDING':
              return Em.I18n.t('installer.step9.serviceStatus.stop.pending') + role;
            case 'QUEUED' :
              return Em.I18n.t('installer.step9.serviceStatus.stop.queued') + role;
            case 'IN_PROGRESS':
              return Em.I18n.t('installer.step9.serviceStatus.stop.inProgress') + role;
            case 'COMPLETED' :
              return role + Em.I18n.t('installer.step9.serviceStatus.stop.completed');
            case 'FAILED':
              return role + Em.I18n.t('installer.step9.serviceStatus.stop.failed');
          }
      }
    }
  });
});
window.require.register("controllers/wizard/step0_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.WizardStep0Controller = Em.Controller.extend({
    name: 'wizardStep0Controller',

    hasSubmitted : false,

    loadStep: function () {
      this.set('hasSubmitted',false);
    },
    /**
     * validate cluster name
     * set clusterNameError if validation fails
     */
    invalidClusterName : function(){
      if(!this.get('hasSubmitted')){
        this.set('clusterNameError', '');
        return false;
      }

      var clusterName = this.get('content.cluster.name');
      if (clusterName == '') {
        this.set('clusterNameError', Em.I18n.t('installer.step0.clusterName.error.required'));
        return true;
      } else if (/\s/.test(clusterName)) {
        this.set('clusterNameError', Em.I18n.t('installer.step0.clusterName.error.whitespaces'));
        return true;
      } else if (/[^\w\s]/gi.test(clusterName)) {
        this.set('clusterNameError', Em.I18n.t('installer.step0.clusterName.error.specialChar'));
        return true;
      } else {
        this.set('clusterNameError', '');
        return false;
      }
    }.property('hasSubmitted', 'content.cluster.name').cacheable(),

    /**
     * calculates by <code>invalidClusterName</code> property
     */
    //todo: mix this and previous variables in one
    clusterNameError: '',

    /**
     * Onclick handler for <code>next</code> button
     */
    submit: function () {
      this.set('hasSubmitted', true);
      if (!this.get('invalidClusterName')) {
        App.clusterStatus.set('clusterName', this.get('content.cluster.name'));
        this.set('content.cluster.status', 'PENDING');
        this.set('content.cluster.isCompleted', false);
        App.router.send('next');
      }
    }

  });
  
});
window.require.register("controllers/wizard/step10_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.WizardStep10Controller = Em.Controller.extend({
    clusterInfo: [],

    isNagiosRestartRequired: function() {
      return this.get('content.controllerName') !== 'installerController' && App.Service.find('NAGIOS').get('isLoaded');
    }.property(),

    clearStep: function () {
      this.get('clusterInfo').clear();
    },

    loadStep: function () {
      console.log("TRACE: Loading step10: Summary Page");
      this.clearStep();
      this.loadInstalledHosts(this.loadRegisteredHosts());
      var installFlag = true;
      var startFlag = true;
      if (this.get('content.controllerName') == 'installerController') {
        installFlag = this.loadMasterComponents();
        startFlag = this.loadStartedServices();
      }
      if (installFlag && startFlag) {
        this.loadInstallTime();
      }
    },

    loadRegisteredHosts: function () {
      var masterHosts = this.get('content.masterComponentHosts').mapProperty('hostName').uniq();
      var slaveHosts = this.get('content.slaveComponentHosts');
      var hostObj = [];
      slaveHosts.forEach(function (_hosts) {
        hostObj = hostObj.concat(_hosts.hosts);
      }, this);
      slaveHosts = hostObj.mapProperty('hostName').uniq();
      var registeredHosts = App.Host.find().mapProperty('hostName').concat(masterHosts.concat(slaveHosts)).uniq();
      var registerHostsStatement = Em.I18n.t('installer.step10.hostsSummary').format(registeredHosts.length);
      var registerHostsObj = Ember.Object.create({
        id: 1,
        color: 'text-info',
        displayStatement: registerHostsStatement,
        status: []
      });
      this.get('clusterInfo').pushObject(registerHostsObj);

      return registerHostsObj;
    },

    loadInstalledHosts: function (host) {
      var hosts = this.get('content.hosts');
      var hostsInfo = [];
      for (var index in hosts) {
        hostsInfo.pushObject(hosts[index]);
        console.log('Step10 SUMMARY: value of hosts is: ' + hosts[index].status);
      }
      var succeededHosts = hostsInfo.filterProperty('status', 'success');
      var warnedHosts = hostsInfo.filterProperty('status', 'warning').concat(hostsInfo.filterProperty('status', 'failed'));
      if (succeededHosts.length) {
        var successStatement = Em.I18n.t('installer.step10.servicesSummary').format(succeededHosts.length) + ((succeededHosts.length > 1) ? Em.I18n.t('installer.step8.hosts') : Em.I18n.t('installer.step8.host'));
        this.get('clusterInfo').findProperty('id', 1).get('status').pushObject(Ember.Object.create({
          id: 1,
          color: 'text-success',
          displayStatement: successStatement
        }));
      }

      if (warnedHosts.length) {
        var warnStatement = warnedHosts.length + Em.I18n.t('installer.step10.warnings');
        this.get('clusterInfo').findProperty('id', 1).get('status').pushObject(Ember.Object.create({
          id: 2,
          color: 'text-warning',
          displayStatement: warnStatement,
          statements: []
        }));

        warnedHosts.forEach(function (_host) {
          var clusterState;
          console.log("Content.cluster.status is: " + this.get('content.cluster.status'));
          if (this.get('content.cluster.status') === 'INSTALL FAILED') {
            clusterState = Em.I18n.t('installer.step10.clusterState.installing');
          } else if (this.get('content.cluster.status') === 'START FAILED') {
            clusterState = Em.I18n.t('installer.step10.clusterState.starting');
          }
          console.log('host value is: ' + JSON.stringify(_host));
          var failedTasks = _host.tasks.filterProperty('Tasks.status', 'FAILED');
          failedTasks.forEach(function (_task) {
            var taskStatement = clusterState + App.format.role(_task.Tasks.role) + Em.I18n.t('installer.step10.taskStatus.failed') + _host.name;
            this.get('clusterInfo').findProperty('id', 1).get('status').findProperty('id', 2).get('statements').pushObject(Ember.Object.create({
              status: 'failed',
              color: 'text-info',
              displayStatement: taskStatement
            }));
          }, this);

          var abortedTasks = _host.tasks.filterProperty('Tasks.status', 'ABORTED');
          abortedTasks.forEach(function (_task) {
            var abortStatement = clusterState + App.format.role(_task.Tasks.role) + Em.I18n.t('installer.step10.taskStatus.aborted') + _host.name;
            this.get('clusterInfo').findProperty('id', 1).get('status').findProperty('id', 2).get('statements').pushObject(Ember.Object.create({
              status: 'aborted',
              color: 'text-info',
              displayStatement: abortStatement
            }));
          }, this);

          var timedOutTasks = _host.tasks.filterProperty('Tasks.status', 'TIMEDOUT');
          timedOutTasks.forEach(function (_task) {
            var timedOutStatement = clusterState + App.format.role(_task.Tasks.role) + Em.I18n.t('installer.step10.taskStatus.timedOut') + _host.name;
            this.get('clusterInfo').findProperty('id', 1).get('status').findProperty('id', 2).get('statements').pushObject(Ember.Object.create({
              status: 'timedout',
              color: 'text-info',
              displayStatement: timedOutStatement
            }));
          }, this);
        }, this);
      }
    },

    loadMasterComponents: function () {
      var components = this.get('content.masterComponentHosts');
      var statement;
      if (this.get('content.cluster.status') === 'INSTALL FAILED') {
        this.get('clusterInfo').pushObject(Ember.Object.create({
          id: 2,
          displayStatement: Em.I18n.t('installer.step10.installStatus.failed'),
          color: 'text-error',
          status: []
        }));
        return false;
      } else {
        this.get('clusterInfo').pushObject(Ember.Object.create({
          id: 2,
          displayStatement: Em.I18n.t('installer.step10.installStatus.installed'),
          color: 'text-success',
          status: []
        }));
      }

      console.log('STEP10 master components:  ' + JSON.stringify(components));
      components.forEach(function (_component) {
        var component = Ember.Object.create(_component);
        switch (component.component) {
          case 'NAMENODE':
            this.loadNn(component);
            break;
          case 'SECONDARY_NAMENODE':
            this.loadSnn(component);
            break;
          case 'JOBTRACKER' :
            this.loadJt(component);
            break;
          case 'HISTORYSERVER':
            this.loadHS(component);
            break;
          case 'RESOURCEMANAGER':
            this.loadRM(component);
            break;
          case 'ZOOKEEPER_SERVER' :
            // TODO: Fix this; redundant entries and wrong number
            //this.loadZk(component);
            break;
          case 'HBASE_MASTER':
            this.loadHb(component);
            break;
          case 'HIVE_SERVER':
            this.loadHiveServer(component);
            break;
          case 'OOZIE_SERVER':
            this.loadOozieServer(component);
            break;
          case 'GANGLIA_SERVER':
            this.loadGanglia(component)
            break;
          case 'NAGIOS_SERVER':
            this.loadNagios(component);
            break;
        }
      }, this);
      return true;
    },

    loadHS: function (component) {
      if (component.get('hostName')) {
        var statement = Em.I18n.t('installer.step10.master.historyServer') + component.get('hostName');
        this.get('clusterInfo').findProperty('id', 2).get('status').pushObject(Ember.Object.create({
          id: 1,
          color: 'text-info',
          displayStatement: statement
        }));
      } else {
        console.log('ERROR: no host name assigned to HistoryServer component');
      }
    },

    loadRM: function (component) {
      if (component.get('hostName')) {
        var statement = Em.I18n.t('installer.step10.master.resourceManager') + component.get('hostName');
        this.get('clusterInfo').findProperty('id', 2).get('status').pushObject(Ember.Object.create({
          id: 1,
          color: 'text-info',
          displayStatement: statement
        }));
      } else {
        console.log('ERROR: no host name assigned to ResourceManager component');
      }
    },

    loadNn: function (component) {
      if (component.get('hostName')) {
        var statement = Em.I18n.t('installer.step10.master.nameNode') + component.get('hostName');
        this.get('clusterInfo').findProperty('id', 2).get('status').pushObject(Ember.Object.create({
          id: 1,
          color: 'text-info',
          displayStatement: statement
        }));
      } else {
        console.log('ERROR: no host name assigned to NameNode component');
      }
    },

    loadSnn: function (component) {
      if (component.get('hostName')) {
        var statement = Em.I18n.t('installer.step10.master.secondaryNameNode') + component.get('hostName');
        this.get('clusterInfo').findProperty('id', 2).get('status').pushObject(Ember.Object.create({
          id: 1,
          color: 'text-info',
          displayStatement: statement
        }));
      } else {
        console.log('ERROR: no host name assigned to SecondaryNameNode component');
      }
    },

    loadJt: function (component) {
      if (component.get('hostName')) {
        var statement = Em.I18n.t('installer.step10.master.jobTracker') + component.get('hostName');
        this.get('clusterInfo').findProperty('id', 2).get('status').pushObject(Ember.Object.create({
          id: 1,
          color: 'text-info',
          displayStatement: statement
        }));
      } else {
        console.log('ERROR: no host name assigned to JobTracker component');
      }
    },

    loadZk: function (component) {
      var hostLength = component.get('hostName').length;
      if (hostLength) {
        var hostVal;
        if (hostLength === 1) {
          hostVal = Em.I18n.t('installer.step8.host');
        } else {
          hostVal = Em.I18n.t('installer.step8.hosts');
        }
        var statement = Em.I18n.t('installer.step10.master.zooKeeper') + component.get('hostName').length + ' ' + hostVal;
        this.get('clusterInfo').findProperty('id', 2).get('status').pushObject(Ember.Object.create({
          id: 1,
          color: 'text-info',
          displayStatement: statement
        }));
      } else {
        console.log('ERROR: no host name assigned to Zookeeper component');
      }
    },

    loadHb: function (component) {
      if (component.get('hostName')) {
        var statement = Em.I18n.t('installer.step10.master.hbase') + component.get('hostName');
        this.get('clusterInfo').findProperty('id', 2).get('status').pushObject(Ember.Object.create({
          id: 1,
          color: 'text-info',
          displayStatement: statement
        }));
      } else {
        console.log('ERROR: no host name assigned to HBase Master component');
      }
    },

    loadHiveServer: function (component) {
      if (component.get('hostName')) {
        var statement = Em.I18n.t('installer.step10.master.hiveMetastore') + component.get('hostName');
        this.get('clusterInfo').findProperty('id', 2).get('status').pushObject(Ember.Object.create({
          id: 1,
          color: 'text-info',
          displayStatement: statement
        }));
      } else {
        console.log('ERROR: no host name assigned to Hive server component');
      }
    },

    loadOozieServer: function (component) {
      if (component.get('hostName')) {
        var statement = Em.I18n.t('installer.step10.master.oozie') + component.get('hostName');
        this.get('clusterInfo').findProperty('id', 2).get('status').pushObject(Ember.Object.create({
          id: 1,
          color: 'text-info',
          displayStatement: statement
        }));
      } else {
        console.log('ERROR: no host name assigned to Oozie server component');
      }
    },

    loadGanglia: function (component) {
      if (component.get('hostName')) {
        var statement = Em.I18n.t('installer.step10.master.ganglia') + component.get('hostName');
        this.get('clusterInfo').findProperty('id', 2).get('status').pushObject(Ember.Object.create({
          id: 1,
          color: 'text-info',
          displayStatement: statement
        }));
      } else {
        console.log('ERROR: no host name assigned to Ganglia server component');
      }
    },

    loadNagios: function (component) {
      if (component.get('hostName')) {
        var statement = Em.I18n.t('installer.step10.master.nagios') + component.get('hostName');
        this.get('clusterInfo').findProperty('id', 2).get('status').pushObject(Ember.Object.create({
          id: 1,
          color: 'text-info',
          displayStatement: statement
        }));
      } else {
        console.log('ERROR: no host name assigned to Nagios server component');
      }
    },

    loadStartedServices: function (component) {
      if (this.get('content.cluster.status') === 'STARTED') {
        var statement = Em.I18n.t('installer.step10.startStatus.started');
        this.get('clusterInfo').pushObject(Ember.Object.create({
          id: 3,
          color: 'text-success',
          displayStatement: Em.I18n.t('installer.step10.startStatus.started'),
          status: []
        }));
        this.get('clusterInfo').pushObject(Ember.Object.create({
          id: 4,
          color: 'text-success',
          displayStatement: Em.I18n.t('installer.step10.startStatus.passed'),
          status: []
        }));
        return true;
      } else {
        this.get('clusterInfo').pushObject(Ember.Object.create({
          id: 3,
          color: 'text-error',
          displayStatement: Em.I18n.t('installer.step10.startStatus.failed'),
          status: []
        }));
        return false;
      }
    },

    loadInstallTime: function () {
      var statement;
      var time;
      if (this.get('content.cluster.installTime')) {
        time = this.calculateInstallTime(this.get('content.cluster.installTime'));
        if (time.minutes !== 0) {
          statement = Em.I18n.t('installer.step10.installTime.minutes').format(time.minutes, time.seconds);
        } else {
          statement = Em.I18n.t('installer.step10.installTime.seconds').format(time.seconds);
        }
        this.get('clusterInfo').pushObject(Ember.Object.create({
          id: 5,
          color: 'text-info',
          displayStatement: statement,
          status: []
        }));
      }
    },
    calculateInstallTime: function(installTime){
      var secondsPerMinute = 60;
      var minutes = Math.floor(installTime);
      var seconds = Math.floor((installTime - minutes) * secondsPerMinute);
      return {
        minutes: minutes,
        seconds: seconds
      }
    }
  });

  
});
window.require.register("controllers/wizard/step11_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.WizardStep11Controller = Em.Controller.extend();

  
});
window.require.register("controllers/wizard/step12_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  App.WizardStep12Controller = App.MainServiceInfoConfigsController.extend({

    modifiedConfigs: [],
    oldConfigs: [],

    afterLoad: function () {
      if (this.get('dataIsLoaded')) {
        this.get('stepConfigs').objectAt(0).get('configs').filterProperty('isEditable', false).setEach('isEditable', true);
        this.get('stepConfigs').objectAt(0).get('configs').filterProperty('displayType', 'masterHost').setEach('isVisible', false);
        this.get('oldConfigs').clear();
        this.get('modifiedConfigs').clear();
        this.get('stepConfigs').objectAt(0).get('configs').forEach(function (config) {
              this.get('oldConfigs').push(jQuery.extend({}, config));
            }, this
        );
      }
    }.observes('dataIsLoaded'),

    addHostNamesToGlobalConfig: function () {
      var hostComponents = [];
      this.get('content.masterComponentHosts').forEach(function (component) {
        hostComponents.push(Ember.Object.create({
          componentName: component.component,
          host: {hostName: component.hostName}
        }))
      });
      this.set('content.hostComponents', hostComponents);
      this._super();
    },

    submit: function () {
      if (this.get('isSubmitDisabled')) {
        return false;
      }
      this.get('stepConfigs').objectAt(0).get('configs').forEach(function (config) {
        var oldConfig = this.get('oldConfigs').filterProperty('name', config.get('name')).findProperty('id', config.get('id'));
        if (!oldConfig || oldConfig.get('value') !== config.get('value')) {
          this.get('modifiedConfigs').push({
            name: config.get('displayName'),
            oldValue: !oldConfig ? 'null' : oldConfig.get('value') + ' ' + (oldConfig.get('unit') || ''),
            value: config.get('value') + ' ' + (config.get('unit') || '')
          });
        }
      }, this);
      App.router.send('next');
    }
  });
  
});
window.require.register("controllers/wizard/step13_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.WizardStep13Controller = Em.Controller.extend()
  
});
window.require.register("controllers/wizard/step14_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.WizardStep14Controller = Em.Controller.extend({

    status: 'IN_PROGRESS',

    onStatusChange: function () {
      if (this.get('tasks').someProperty('status', 'FAILED')) {
        this.set('status', 'FAILED');
        if (this.get('tasks')[5].status == 'FAILED' || this.get('tasks')[6].status == 'FAILED') {
          this.set('showRetry', true);
        }
      } else if (this.get('tasks').everyProperty('status', 'COMPLETED')) {
        this.set('status', 'COMPLETED');
        this.set('isSubmitDisabled', false);
      } else {
        this.set('status', 'IN_PROGRESS')
      }
      var statuses = this.get('tasks').mapProperty('status');
      App.router.get(this.get('content.controllerName')).saveTasksStatuses(statuses);
      App.clusterStatus.setClusterStatus({
        clusterName: this.get('content.cluster.name'),
        clusterState: 'REASSIGN_MASTER_INSTALLING',
        wizardControllerName: this.get('content.controllerName'),
        localdb: App.db.data
      });
      this.setTasksMessages();
      this.navigateStep();
    },

    tasks: [],

    /**
     * Set messages for tasks depending on their status
     */
    setTasksMessages: function () {
      var service = this.get('service.displayName');
      var master = this.get('masterComponent.display_name');
      if (this.get('isCohosted')) {
        service = 'Hive, WebHCat';
        master = Em.I18n.t('installer.step5.hiveGroup');
      }
      for (i = 0; i < this.get('tasks').length; i++) {
        var status = this.get('tasks')[i].status.toLowerCase().replace('initialize', 'pending').replace('_', ' ');
        if (i == 0 || i == 6) {
          this.get('tasks')[i].set('message', Em.I18n.t('installer.step14.task' + i).format(service) + ' ' + status);
        } else {
          this.get('tasks')[i].set('message', Em.I18n.t('installer.step14.task' + i).format(master) + ' ' + status);
        }
      }
    },

    configs: [],
    globals: [],
    configMapping: App.config.get('configMapping').all(),
    newConfigsTag: null,
    createdConfigs: [],

    currentRequestId: [],

    isSubmitDisabled: true,

    showRetry: false,

    service: function () {
      return App.Service.find().findProperty('serviceName', this.get('masterComponent.service_id'));
    }.property('masterComponent'),

    masterComponent: function () {
      return this.get('content.reassign');
    }.property('content.reassign'),

    isCohosted: function () {
      return this.get('masterComponent.component_name') == 'HIVE_SERVER';
    }.property('masterComponent'),

    loadStep: function () {
      this.clearStep();
      this.loadTasks();
      this.addObserver('tasks.@each.status', this, 'onStatusChange');
      this.onStatusChange();
    },

    clearStep: function () {
      this.removeObserver('tasks.@each.status', this, 'onStatusChange');
      this.removeObserver('createdConfigs.length', this, 'onCreateConfigsCompleted');
      var tasks = [];
      for (var i = 0; i < 8; i++) {
        tasks.pushObject(Ember.Object.create({
          status: 'INITIALIZE',
          logs: '',
          message: '',
          progress: 0
        }));
      }
      this.set('tasks', tasks);
      this.set('createdConfigsCount', 0);
      this.set('queueTasksCompleted', 0);
      this.set('dataPollCounter', 1);
      this.set('showRetry', false);
      this.set('isSubmitDisabled', true);
      this.get('configs').clear();
      this.get('globals').clear();
      this.get('createdConfigs').clear();
    },

    loadTasks: function () {
      var statuses = this.get('content.tasksStatuses');
      if (statuses) {
        statuses.forEach(function (status, index) {
          this.get('tasks')[index].status = status;
        }, this)
      }
      var statusesForRequestId = ['PENDING', 'QUEUED', 'IN_PROGRESS'];
      if (statusesForRequestId.contains(statuses[0]) || statusesForRequestId.contains(statuses[5]) || statusesForRequestId.contains(statuses[6])) {
        this.set('currentRequestId', this.get('content.cluster.requestId'));
        this.getLogsByRequest();
      }
    },

    /**
     * Run tasks in proper way
     */
    navigateStep: function () {
      if (this.get('tasks')[0].status == 'INITIALIZE') {
        this.stopService();
      }
      else if (this.taskIsReady(1)) {
        this.createMasterComponent();
      }
      else if (this.taskIsReady(2)) {
        this.createConfigs();
      }
      else if (this.taskIsReady(3)) {
        this.applyConfigs();
      }
      else if (this.taskIsReady(4)) {
        this.putInMaintenanceMode();
      }
      else if (this.taskIsReady(5)) {
        this.installComponent();
      }
      else if (this.taskIsReady(6)) {
        this.startComponents();
      }
      else if (this.taskIsReady(7)) {
        this.removeComponent();
      }
    },

    /**
     * Determine preparedness to run task
     * @param task
     * @return {Boolean}
     */
    taskIsReady: function (task) {
      if (this.get('tasks')[task].status != 'INITIALIZE') {
        return false;
      }
      var tempArr = this.get('tasks').mapProperty('status').slice(0, task).uniq();
      return tempArr.length == 1 && tempArr[0] == 'COMPLETED';
    },

    queueTasksCompleted: 0,

    /**
     * Change status of the task
     * @param task
     * @param status
     */
    setTasksStatus: function (task, status) {
      if (status == 'COMPLETED' && this.get('isCohosted') && [1, 4, 7].contains(task) && this.get('queueTasksCompleted') < 2) {
        this.set('queueTasksCompleted', this.get('queueTasksCompleted') + 1);
      } else {
        this.get('tasks')[task].set('status', status);
      }
    },

    saveClusterStatus: function (requestId, status) {
      var clusterStatus = {
        status: status,
        requestId: requestId
      };
      App.router.get(this.get('content.controllerName')).saveClusterStatus(clusterStatus);
    },

    stopService: function () {
      this.set('currentRequestId', []);
      var serviceNames = [this.get('masterComponent.service_id')];
      if (this.get('isCohosted')) {
        serviceNames = ['HIVE', 'WEBHCAT'];
      }
      serviceNames.forEach(function (serviceName) {
        App.ajax.send({
          name: 'reassign.stop_service',
          sender: this,
          data: {
            serviceName: serviceName,
            displayName: App.Service.find().findProperty('serviceName', serviceName).get('displayName')
          },
          beforeSend: 'onStopServiceBeforeSend',
          success: 'onStopServiceSuccess',
          error: 'onStopServiceError'
        });
      }, this);
    },

    onStopServiceBeforeSend: function () {
      this.setTasksStatus(0, 'PENDING');
    },

    onStopServiceSuccess: function (data) {
      if (data) {
        var requestId = data.Requests.id;
        this.get('currentRequestId').push(requestId);
        this.saveClusterStatus(this.get('currentRequestId'), 'PENDING');
        if ((this.get('isCohosted') && this.get('currentRequestId.length') == 2) || !this.get('isCohosted')) {
          this.getLogsByRequest();
        }
      } else {
        this.setTasksStatus(0, 'FAILED');
      }
    },

    onStopServiceError: function () {
      this.setTasksStatus(0, 'FAILED');
    },

    createMasterComponent: function () {
      var hostName = this.get('content.masterComponentHosts').findProperty('component', this.get('content.reassign.component_name')).hostName;
      var componentNames = [this.get('masterComponent.component_name')];
      if (this.get('isCohosted')) {
        this.set('queueTasksCompleted', 0);
        componentNames = ['HIVE_SERVER', 'WEBHCAT_SERVER', 'MYSQL_SERVER'];
      }
      componentNames.forEach(function (componentName) {
        if (App.testMode) {
          this.setTasksStatus(1, 'COMPLETED');
        } else {
          App.ajax.send({
            name: 'reassign.create_master',
            sender: this,
            data: {
              hostName: hostName,
              componentName: componentName
            },
            beforeSend: 'onCreateMasterComponentBeforeSend',
            success: 'onCreateMasterComponentSuccess',
            error: 'onCreateMasterComponentError'
          });
        }
      }, this);
    },

    onCreateMasterComponentBeforeSend: function () {
      this.setTasksStatus(1, 'PENDING');
    },

    onCreateMasterComponentSuccess: function () {
      this.setTasksStatus(1, 'COMPLETED');
    },

    onCreateMasterComponentError: function () {
      this.setTasksStatus(1, 'FAILED');
    },

    createConfigs: function () {
      if (this.get('service.serviceName') == 'GANGLIA' || App.testMode) {
        this.setTasksStatus(2, 'COMPLETED');
      } else {
        this.setTasksStatus(2, 'PENDING');
        this.loadGlobals();
        this.loadConfigs();
        this.set('newConfigsTag', 'version' + (new Date).getTime());
        var serviceName = this.get('service.serviceName');
        this.createConfigSite(this.createGlobalSiteObj());
        this.createConfigSite(this.createCoreSiteObj());
        if (serviceName == 'HDFS') {
          this.createConfigSite(this.createSiteObj('hdfs-site'));
        }
        if (serviceName == 'MAPREDUCE') {
          this.createConfigSite(this.createSiteObj('mapred-site'));
        }
        if (serviceName == 'HBASE') {
          this.createConfigSite(this.createSiteObj('hbase-site'));
        }
        if (serviceName == 'OOZIE') {
          this.createConfigSite(this.createSiteObj('oozie-site'));
        }
        if (serviceName == 'HIVE' || this.get('isCohosted')) {
          this.createConfigSite(this.createSiteObj('hive-site'));
        }
        if (serviceName == 'WEBHCAT' || this.get('isCohosted')) {
          this.createConfigSite(this.createSiteObj('webhcat-site'));
        }
        this.addObserver('createdConfigs.length', this, 'onCreateConfigsCompleted');
        this.onCreateConfigsCompleted();
      }
    },

    createConfigSite: function (configs) {
      configs.tag = this.get('newConfigsTag');
      App.ajax.send({
        name: 'reassign.create_configs',
        sender: this,
        data: {
          configs: configs
        },
        beforeSend: 'onCreateConfigsBeforeSend',
        success: 'onCreateConfigsSuccess',
        error: 'onCreateConfigsError'
      });
    },

    onCreateConfigsBeforeSend: function () {
      this.set('createdConfigsCount', this.get('createdConfigsCount') + 1);
    },

    onCreateConfigsSuccess: function (data, opts) {
      this.get('createdConfigs').pushObject(opts.configs.type);
    },

    onCreateConfigsError: function () {
      this.setTasksStatus(2, 'FAILED');
    },

    createdConfigsCount: 0,

    onCreateConfigsCompleted: function () {
      if (this.get('createdConfigs.length') == this.get('createdConfigsCount')) {
        this.setTasksStatus(2, 'COMPLETED');
      }
    },

    loadGlobals: function () {
      var globals = this.get('content.serviceConfigProperties').filterProperty('id', 'puppet var');
      if (globals.someProperty('name', 'hive_database')) {
        //TODO: Hive host depends on the type of db selected. Change puppet variable name if postgres is not the default db
        var hiveDb = globals.findProperty('name', 'hive_database');
        if (hiveDb.value === 'New MySQL Database') {
          if (globals.someProperty('name', 'hive_ambari_host')) {
            globals.findProperty('name', 'hive_ambari_host').name = 'hive_mysql_hostname';
          }
          globals = globals.without(globals.findProperty('name', 'hive_existing_host'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_database'));
        } else {
          globals.findProperty('name', 'hive_existing_host').name = 'hive_mysql_hostname';
          globals = globals.without(globals.findProperty('name', 'hive_ambari_host'));
          globals = globals.without(globals.findProperty('name', 'hive_ambari_database'));
        }
      }
      this.set('globals', globals);
    },

    loadConfigs: function () {
      var storedConfigs = this.get('content.serviceConfigProperties').filterProperty('id', 'site property').filterProperty('value');
      var uiConfigs = this.loadUiSideConfigs();
      this.set('configs', storedConfigs.concat(uiConfigs));
    },

    loadUiSideConfigs: function () {
      var uiConfig = [];
      var configs = this.get('configMapping').filterProperty('foreignKey', null);
      configs.forEach(function (_config) {
        var value = this.getGlobConfigValue(_config.templateName, _config.value, _config.name);
        uiConfig.pushObject({
          "id": "site property",
          "name": _config.name,
          "value": value,
          "filename": _config.filename
        });
      }, this);
      var dependentConfig = this.get('configMapping').filterProperty('foreignKey');
      dependentConfig.forEach(function (_config) {
        App.config.setConfigValue(uiConfig, this.get('content.serviceConfigProperties'), _config, this.get('globals'));
        uiConfig.pushObject({
          "id": "site property",
          "name": _config._name || _config.name,
          "value": _config.value,
          "filename": _config.filename
        });
      }, this);
      return uiConfig;
    },

    getGlobConfigValue: function (templateName, expression, name) {
      var express = expression.match(/<(.*?)>/g);
      var value = expression;
      if (express == null) {
        return expression;
      }
      express.forEach(function (_express) {
        var index = parseInt(_express.match(/\[([\d]*)(?=\])/)[1]);
        if (this.get('globals').someProperty('name', templateName[index])) {
          var globValue = this.get('globals').findProperty('name', templateName[index]).value;
          // Hack for templeton.zookeeper.hosts
          if (value !== null) {   // if the property depends on more than one template name like <templateName[0]>/<templateName[1]> then don't proceed to the next if the prior is null or not found in the global configs
            if (name === "templeton.zookeeper.hosts" || name === 'hbase.zookeeper.quorum') {
              // globValue is an array of ZooKeeper Server hosts
              var zooKeeperPort = '2181';
              if (name === "templeton.zookeeper.hosts") {
                var zooKeeperServers = globValue.map(function (item) {
                  return item + ':' + zooKeeperPort;
                }).join(',');
                value = value.replace(_express, zooKeeperServers);
              } else {
                value = value.replace(_express, globValue.join(','));
              }
            } else {
              value = value.replace(_express, globValue);
            }
          }
        } else {
          value = null;
        }
      }, this);
      return value;
    },

    /**
     * Set property of the site variable
     */
    setSiteProperty: function (key, value, filename) {
      this.get('configs').pushObject({
        "id": "site property",
        "name": key,
        "value": value,
        "filename": filename
      });
    },

    createGlobalSiteObj: function () {
      var globalSiteProperties = {};
      //this.get('globals').filterProperty('domain', 'global').forEach(function (_globalSiteObj) {
      this.get('globals').forEach(function (_globalSiteObj) {
        // do not pass any globals whose name ends with _host or _hosts
        if (!/_hosts?$/.test(_globalSiteObj.name)) {
          // append "m" to JVM memory options except for hadoop_heapsize
          if (/_heapsize|_newsize|_maxnewsize$/.test(_globalSiteObj.name) && _globalSiteObj.name !== 'hadoop_heapsize') {
            globalSiteProperties[_globalSiteObj.name] = _globalSiteObj.value + "m";
          } else {
            globalSiteProperties[_globalSiteObj.name] = _globalSiteObj.value;
          }
        }
      }, this);
      return {"type": "global", "properties": globalSiteProperties};
    },

    createCoreSiteObj: function () {
      var serviceName = this.get('service.serviceName');
      var coreSiteObj = this.get('configs').filterProperty('filename', 'core-site.xml');
      var coreSiteProperties = {};
      // hadoop.proxyuser.oozie.hosts needs to be skipped if oozie is not selected
      var isOozieSelected = serviceName == 'OOZIE';
      var oozieUser = this.get('globals').someProperty('name', 'oozie_user') ? this.get('globals').findProperty('name', 'oozie_user').value : null;
      var isHiveSelected = serviceName == 'HIVE';
      var hiveUser = this.get('globals').someProperty('name', 'hive_user') ? this.get('globals').findProperty('name', 'hive_user').value : null;
      var isHcatSelected = serviceName == 'WEBHCAT';
      var hcatUser = this.get('globals').someProperty('name', 'hcat_user') ? this.get('globals').findProperty('name', 'hcat_user').value : null;
      coreSiteObj.forEach(function (_coreSiteObj) {
        if ((isOozieSelected || (_coreSiteObj.name != 'hadoop.proxyuser.' + oozieUser + '.hosts' && _coreSiteObj.name != 'hadoop.proxyuser.' + oozieUser + '.groups')) && (isHiveSelected || (_coreSiteObj.name != 'hadoop.proxyuser.' + hiveUser + '.hosts' && _coreSiteObj.name != 'hadoop.proxyuser.' + hiveUser + '.groups')) && (isHcatSelected || (_coreSiteObj.name != 'hadoop.proxyuser.' + hcatUser + '.hosts' && _coreSiteObj.name != 'hadoop.proxyuser.' + hcatUser + '.groups'))) {
          coreSiteProperties[_coreSiteObj.name] = _coreSiteObj.value;
        }
      }, this);
      return {"type": "core-site", "properties": coreSiteProperties};
    },

    createSiteObj: function (name) {
      var fileName = name + '.xml';
      var configs = this.get('configs').filterProperty('filename', fileName);
      var properties = {};
      configs.forEach(function (_configProperty) {
        properties[_configProperty.name] = _configProperty.value;
      }, this);
      return {type: name, properties: properties};
    },

    applyConfigs: function () {
      if (this.get('service.serviceName') == 'GANGLIA' || App.testMode) {
        this.setTasksStatus(3, 'COMPLETED');
      } else {
        var serviceName = this.get('service.serviceName');
        App.ajax.send({
          name: 'reassign.check_configs',
          sender: this,
          data: {
            serviceName: serviceName
          },
          success: 'onCheckConfigsSuccess',
          error: 'onCheckConfigsError'
        });
      }
    },

    onCheckConfigsSuccess: function (configs) {
      var configTags = configs.ServiceInfo.desired_configs;
      if (!configTags) {
        this.setTasksStatus(0, 'FAILED');
        return;
      }

      for (var tag in configTags) {
        if (this.get('createdConfigs').contains(tag)) {
          configTags[tag] = this.get('newConfigsTag');
        }
      }
      var data = {config: configTags};
      var serviceName = this.get('service.serviceName');
      App.ajax.send({
        name: 'reassign.apply_configs',
        sender: this,
        data: {
          serviceName: serviceName,
          configs: data
        },
        beforeSend: 'onApplyConfigsBeforeSend',
        success: 'onApplyConfigsSuccess',
        error: 'onApplyConfigsError'
      });
    },

    onCheckConfigsError: function () {
      this.setTasksStatus(3, 'FAILED');
    },

    onApplyConfigsBeforeSend: function () {
      this.setTasksStatus(3, 'PENDING');
    },

    onApplyConfigsSuccess: function () {
      this.setTasksStatus(3, 'COMPLETED');
    },

    onApplyConfigsError: function () {
      this.setTasksStatus(3, 'FAILED');
    },

    putInMaintenanceMode: function () {
      if (App.testMode) {
        this.setTasksStatus(4, 'COMPLETED');
      } else {
        var hostName = this.get('content.reassign.host_id');
        var componentNames = [this.get('masterComponent.component_name')];
        if (this.get('isCohosted')) {
          componentNames = ['HIVE_SERVER', 'WEBHCAT_SERVER', 'MYSQL_SERVER'];
          this.set('queueTasksCompleted', 0);
        }
        componentNames.forEach(function (componentName) {
          App.ajax.send({
            name: 'reassign.maintenance_mode',
            sender: this,
            data: {
              hostName: hostName,
              componentName: componentName
            },
            beforeSend: 'onPutInMaintenanceModeBeforeSend',
            success: 'onPutInMaintenanceModeSuccess',
            error: 'onPutInMaintenanceModeError'
          });
        }, this);
      }
    },

    onPutInMaintenanceModeBeforeSend: function () {
      this.setTasksStatus(4, 'PENDING');
    },

    onPutInMaintenanceModeSuccess: function () {
      this.setTasksStatus(4, 'COMPLETED');
    },

    onPutInMaintenanceModeError: function () {
      this.setTasksStatus(4, 'FAILED');
    },

    installComponent: function () {
      this.set('currentRequestId', []);
      var componentNames = [this.get('masterComponent.component_name')];
      if (this.get('isCohosted')) {
        componentNames = ['HIVE_SERVER', 'WEBHCAT_SERVER', 'MYSQL_SERVER'];
      }
      var hostName = this.get('content.masterComponentHosts').findProperty('component', this.get('content.reassign.component_name')).hostName;
      componentNames.forEach(function (componentName) {
        App.ajax.send({
          name: 'reassign.install_component',
          sender: this,
          data: {
            hostName: hostName,
            componentName: componentName,
            displayName: App.format.role(componentName)
          },
          beforeSend: 'onInstallComponentBeforeSend',
          success: 'onInstallComponentSuccess',
          error: 'onInstallComponentError'
        });
      }, this);
    },

    onInstallComponentBeforeSend: function () {
      this.setTasksStatus(5, 'PENDING');
    },

    onInstallComponentSuccess: function (data) {
      if (data) {
        var requestId = data.Requests.id;
        this.get('currentRequestId').push(requestId);
        this.saveClusterStatus(this.get('currentRequestId'), 'PENDING');
        if ((this.get('isCohosted') && this.get('currentRequestId.length') == 3) || !this.get('isCohosted')) {
          this.getLogsByRequest();
        }
      } else {
        this.setTasksStatus(5, 'FAILED');
      }
    },

    onInstallComponentError: function () {
      this.setTasksStatus(5, 'FAILED');
    },

    startComponents: function () {
      this.set('currentRequestId', []);
      var serviceNames = [this.get('masterComponent.service_id')];
      if (this.get('isCohosted')) {
        serviceNames = ['HIVE', 'WEBHCAT'];
      }
      serviceNames.forEach(function (serviceName) {
        App.ajax.send({
          name: 'reassign.start_components',
          sender: this,
          data: {
            serviceName: serviceName,
            displayName: App.Service.find().findProperty('serviceName', serviceName).get('displayName')
          },
          beforeSend: 'onStartComponentsBeforeSend',
          success: 'onStartComponentsSuccess',
          error: 'onStartComponentsError'
        });
      }, this);
    },

    onStartComponentsBeforeSend: function () {
      this.setTasksStatus(6, 'PENDING');
    },

    onStartComponentsSuccess: function (data) {
      if (data) {
        var requestId = data.Requests.id;
        this.get('currentRequestId').push(requestId);
        this.saveClusterStatus(this.get('currentRequestId'), 'PENDING');
        if ((this.get('isCohosted') && this.get('currentRequestId.length') == 2) || !this.get('isCohosted')) {
          this.getLogsByRequest();
        }
      } else {
        this.setTasksStatus(6, 'FAILED');
      }
    },

    onStartComponentsError: function () {
      this.setTasksStatus(6, 'FAILED');
    },

    /**
     * Parse logs to define status of Start, Stop ot Install task
     * @param logs
     */
    parseLogs: function (logs) {
      var self = this;
      var task;
      var stopPolling = false;
      var polledData = [];
      logs.forEach(function (item) {
        polledData = polledData.concat(item.tasks);
      }, this);
      if (this.get('tasks')[0].status == 'COMPLETED') {
        task = this.get('tasks')[5].status == 'COMPLETED' ? 6 : 5;
      } else {
        task = 0;
      }
      if (!polledData.someProperty('Tasks.status', 'PENDING') && !polledData.someProperty('Tasks.status', 'QUEUED') && !polledData.someProperty('Tasks.status', 'IN_PROGRESS')) {
        if (polledData.everyProperty('Tasks.status', 'COMPLETED')) {
          this.setTasksStatus(task, 'COMPLETED');
        } else {
          this.setTasksStatus(task, 'FAILED');
        }
        stopPolling = true;
      } else {
        if (polledData.length == 1) {
          this.get('tasks')[task].set('progress', 50);
        } else {
          var progress = polledData.filterProperty('Tasks.status', 'COMPLETED').length / polledData.length * 100;
          this.get('tasks')[task].set('progress', Math.round(progress));
        }
        this.setTasksStatus(task, 'IN_PROGRESS');
      }
      if (!stopPolling) {
        window.setTimeout(function () {
          self.getLogsByRequest()
        }, self.POLL_INTERVAL);
      }
    },

    POLL_INTERVAL: 4000,
    dataPollCounter: 0,

    getLogsByRequest: function () {
      this.set('logs', []);
      var requestIds = this.get('currentRequestId');

      if (this.get('dataPollCounter') == 5) {
        this.set('dataPollCounter', 0);
      }
      this.set('dataPollCounter', this.get('dataPollCounter') + 1);

      requestIds.forEach(function (requestId) {
        App.ajax.send({
          name: 'reassign.get_logs',
          sender: this,
          data: {
            requestId: requestId,
            pollCounter: this.get('dataPollCounter')
          },
          success: 'onGetLogsByRequestSuccess',
          error: 'onGetLogsByRequestError'
        });
      }, this);

    },

    logs: [],

    onGetLogsByRequestSuccess: function (data) {
      this.get('logs').push(data);
      if (this.get('logs.length') == this.get('currentRequestId.length')) {
        this.parseLogs(this.get('logs'))
      }
    },

    onGetLogsByRequestError: function () {
      this.set('status', 'FAILED');
    },

    removeComponent: function () {
      if (App.testMode) {
        this.setTasksStatus(7, 'COMPLETED');
      } else {
        var hostName = this.get('content.reassign.host_id');
        var componentNames = [this.get('masterComponent.component_name')];
        if (this.get('isCohosted')) {
          componentNames = ['HIVE_SERVER', 'WEBHCAT_SERVER', 'MYSQL_SERVER'];
          this.set('queueTasksCompleted', 0);
        }
        componentNames.forEach(function (componentName) {
          App.ajax.send({
            name: 'reassign.remove_component',
            sender: this,
            data: {
              hostName: hostName,
              componentName: componentName
            },
            beforeSend: 'onRemoveComponentBeforeSend',
            success: 'onRemoveComponentSuccess',
            error: 'onRemoveComponentError'
          });
        }, this);
      }
    },

    onRemoveComponentBeforeSend: function () {
      this.setTasksStatus(7, 'PENDING');
    },

    onRemoveComponentSuccess: function () {
      this.setTasksStatus(7, 'COMPLETED');
    },

    onRemoveComponentError: function () {
      this.setTasksStatus(7, 'FAILED');
    },

    retry: function () {
      if (this.get('tasks')[5].status == 'FAILED') {
        this.installComponent();
      } else {
        this.startComponents();
      }
      this.set('showRetry', false);
    },

    abort: function () {
      var hostName = this.get('content.masterComponentHosts').findProperty('component', this.get('content.reassign.component_name')).hostName;
      var componentNames = [this.get('masterComponent.component_name')];
      if (this.get('isCohosted')) {
        componentNames = ['HIVE_SERVER', 'WEBHCAT_SERVER', 'MYSQL_SERVER'];
        this.set('queueTasksCompleted', 0);
      }
      componentNames.forEach(function (componentName) {
        App.ajax.send({
          name: 'reassign.maintenance_mode',
          sender: this,
          data: {
            hostName: hostName,
            componentName: componentName
          },
          success: 'onAbortMaintenance',
          error: 'onAbortError'
        });
      }, this);
    },


    onAbortMaintenance: function () {
      if (this.get('isCohosted') && this.get('queueTasksCompleted') < 2) {
        this.set('queueTasksCompleted', this.get('queueTasksCompleted') + 1);
      } else {
        var hostName = this.get('content.masterComponentHosts').findProperty('component', this.get('content.reassign.component_name')).hostName;
        var componentNames = [this.get('masterComponent.component_name')];
        if (this.get('isCohosted')) {
          componentNames = ['HIVE_SERVER', 'WEBHCAT_SERVER', 'MYSQL_SERVER'];
          this.set('queueTasksCompleted', 0);
        }
        componentNames.forEach(function (componentName) {
          App.ajax.send({
            name: 'reassign.remove_component',
            sender: this,
            data: {
              hostName: hostName,
              componentName: componentName
            },
            success: 'onAbortRemoveComponent',
            error: 'onAbortError'
          });
        }, this);
      }
    },

    onAbortRemoveComponent: function () {
      if (this.get('isCohosted') && this.get('queueTasksCompleted') < 2) {
        this.set('queueTasksCompleted', this.get('queueTasksCompleted') + 1);
      } else {
        var hostName = this.get('content.reassign.host_id');
        var componentNames = [this.get('masterComponent.component_name')];
        if (this.get('isCohosted')) {
          componentNames = ['HIVE_SERVER', 'WEBHCAT_SERVER', 'MYSQL_SERVER'];
          this.set('queueTasksCompleted', 0);
        }
        componentNames.forEach(function (componentName) {
          App.ajax.send({
            name: 'reassign.install_component',
            sender: this,
            data: {
              hostName: hostName,
              componentName: componentName
            },
            success: 'onAbortCompleted',
            error: 'onAbortError'
          });
        }, this);
      }
    },

    onAbortCompleted: function () {
      if (this.get('isCohosted') && this.get('queueTasksCompleted') < 2) {
        this.set('queueTasksCompleted', this.get('queueTasksCompleted') + 1);
      } else {
        App.clusterStatus.setClusterStatus({
          clusterName: this.get('content.cluster.name'),
          clusterState: 'REASSIGN_MASTER_ABORTED',
          wizardControllerName: this.get('content.controllerName'),
          localdb: App.db.data
        });
        App.router.send('back');
      }
    },

    onAbortError: function () {
      App.ModalPopup.show({
        header: Em.I18n.translations['common.error'],
        secondary: false,
        onPrimary: function () {
          this.hide();
        },
        bodyClass: Ember.View.extend({
          template: Ember.Handlebars.compile('<p>{{t installer.step14.abortError}}</p>')
        })
      });
    }
  })
  
});
window.require.register("controllers/wizard/step1_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.WizardStep1Controller = Em.Controller.extend({
    name: 'wizardStep1Controller'
  });
  
});
window.require.register("controllers/wizard/step2_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var validator = require('utils/validator');

  App.WizardStep2Controller = Em.Controller.extend({
    name: 'wizardStep2Controller',
    hostNameArr: [],
    isPattern: false,
    bootRequestId:  null,
    hasSubmitted: false,
    inputtedAgainHostNames: [],

    isInstaller: function () {
      return this.get('content.controllerName') == 'installerController';
    }.property('content.controllerName'),

    hostNames: function () {
      return this.get('content.installOptions.hostNames');
    }.property('content.installOptions.hostNames'),

    manualInstall: function () {
      return this.get('content.installOptions.manualInstall');
    }.property('content.installOptions.manualInstall'),

    sshKey: function () {
      return this.get('content.installOptions.sshKey');
    }.property('content.installOptions.sshKey'),

    sshUser: function () {
      return this.get('content.installOptions.sshUser');
    }.property('content.installOptions.sshUser'),

    installType: function () {
      return this.get('manualInstall') ? 'manualDriven' : 'ambariDriven';
    }.property('manualInstall'),

    isHostNameValid: function (hostname) {
      return validator.isHostname(hostname);
    },
    /**
     * set not installed hosts to the hostNameArr
     */
    updateHostNameArr: function(){
      this.hostNameArr = this.get('hostNames').trim().split(new RegExp("\\s+", "g"));
      this.patternExpression();
      this.get('inputtedAgainHostNames').clear();
      var installedHostNames = App.Host.find().mapProperty('hostName');
      var tempArr = [];
      for (var i = 0; i < this.hostNameArr.length; i++) {
        if (!installedHostNames.contains(this.hostNameArr[i])) {
          tempArr.push(this.hostNameArr[i]);
        } else {
          this.get('inputtedAgainHostNames').push(this.hostNameArr[i]);
        }
      }
      this.set('hostNameArr', tempArr);
    },

    invalidHostNames: [],

    /**
     * validate host names
     * @return {Boolean}
     */
    isAllHostNamesValid: function () {
      var result = true;
      this.updateHostNameArr();
      this.get('invalidHostNames').clear();
      this.hostNameArr.forEach(function(hostName){
        if (!this.isHostNameValid(hostName)) {
          this.get('invalidHostNames').push(hostName);
          result = false;
        }
      }, this);

      return result;
    },

    hostsError: null,
    /**
     * set hostsError if host names don't pass validation
     */
    checkHostError: function () {
      if (this.get('hostNames').trim() === '') {
        this.set('hostsError', Em.I18n.t('installer.step2.hostName.error.required'));
      }
      else {
        this.set('hostsError', null);
      }
    },

    checkHostAfterSubmitHandler: function() {
      if (this.get('hasSubmitted')) {
        this.checkHostError();
      }
    }.observes('hasSubmitted', 'hostNames'),

    sshKeyError: function () {
      if (this.get('hasSubmitted') && this.get('manualInstall') === false && this.get('sshKey').trim() === '') {
        return Em.I18n.t('installer.step2.sshKey.error.required');
      }
      return null;
    }.property('sshKey', 'manualInstall', 'hasSubmitted'),

    sshUserError: function(){
      if (this.get('manualInstall') === false && this.get('sshUser').trim() === '') {
        return Em.I18n.t('installer.step2.sshUser.required');
      }
      return null;
    }.property('sshUser', 'hasSubmitted', 'manualInstall'),

    /**
     * Get host info, which will be saved in parent controller
     */
    getHostInfo: function () {

      var hostNameArr = this.get('hostNameArr');
      var hostInfo = {};
      for (var i = 0; i < hostNameArr.length; i++) {
        hostInfo[hostNameArr[i]] = {
          name: hostNameArr[i],
          installType: this.get('installType'),
          bootStatus: 'PENDING'
        };
      }

      return hostInfo;
    },

    /**
     * Used to set sshKey from FileUploader
     * @param sshKey
     */
    setSshKey: function(sshKey){
      this.set("content.installOptions.sshKey", sshKey);
    },

    /**
     * Onclick handler for <code>next button</code>. Do all UI work except data saving.
     * This work is doing by router.
     * @return {Boolean}
     */
    evaluateStep: function () {
      console.log('TRACE: Entering controller:WizardStep2:evaluateStep function');

      if (this.get('isSubmitDisabled')) {
        return false;
      }

      this.set('hasSubmitted', true);

      this.checkHostError();
      if (this.get('hostsError') || this.get('sshUserError') || this.get('sshKeyError')) {
        return false;
      }

      this.updateHostNameArr();

      if (!this.hostNameArr.length) {
        this.set('hostsError', Em.I18n.t('installer.step2.hostName.error.already_installed'));
        return false;
      }

      if(this.isPattern)
      {
        this.hostNamePatternPopup(this.hostNameArr);
        return false;
      }
      if (this.get('inputtedAgainHostNames').length) {
        this.installedHostsPopup();
      } else {
        this.proceedNext();
      }
    },
    /**
     * check is there a pattern expression in host name textarea
     * push hosts that match pattern in hostNamesArr
     */
    patternExpression: function(){
      this.isPattern = false;
      var self = this;
      var hostNames = [];
      $.each(this.hostNameArr, function(e,a){
        var start, end, extra = {0:""};
        if(/\[\d*\-\d*\]/.test(a)){
          start=a.match(/\[\d*/);
          end=a.match(/\-\d*]/);

          start=start[0].substr(1);
          end=end[0].substr(1);

          if(parseInt(start) <= parseInt(end, 10) && parseInt(start, 10) >= 0){
            self.isPattern = true;

            if(start[0] == "0" && start.length > 1) {
              extra = start.match(/0*/);
            }

            for (var i = parseInt(start, 10); i < parseInt(end, 10) + 1; i++) {
              hostNames.push(a.replace(/\[\d*\-\d*\]/,extra[0].substring(0,start.length-i.toString().length)+i))
            }

          }else{
            hostNames.push(a);
          }
        }else{
          hostNames.push(a);
        }
      });
      this.hostNameArr =  hostNames;
    },
    /**
     * launch hosts to bootstrap
     * and save already registered hosts
     * @return {Boolean}
     */
    proceedNext: function(warningConfirmed){
      if (this.isAllHostNamesValid() !== true && !warningConfirmed) {
        this.warningPopup();
        return false;
      }

      if (this.get('manualInstall') === true) {
        this.manualInstallPopup();
        return false;
      }

      var bootStrapData = JSON.stringify({'verbose': true, 'sshKey': this.get('sshKey'), 'hosts': this.get('hostNameArr'), 'user': this.get('sshUser')});

      if (App.skipBootstrap) {
        this.saveHosts();
        return true;
      }

      var requestId = App.router.get(this.get('content.controllerName')).launchBootstrap(bootStrapData);
      if (requestId == '0') {
        var controller = App.router.get(App.clusterStatus.wizardControllerName);
        controller.registerErrPopup(Em.I18n.t('common.information'), Em.I18n.t('installer.step2.evaluateStep.hostRegInProgress'));
      } else if (requestId) {
        this.set('content.installOptions.bootRequestId', requestId);
        this.saveHosts();
      }
    },

    /**
     * show warning for host names without dots or IP addresses
     */
    warningPopup: function () {
      var self = this;
      App.ModalPopup.show({
        header: Em.I18n.t('common.warning'),
        onPrimary: function () {
          this.hide();
          self.proceedNext(true);
        },
        bodyClass: Ember.View.extend({
          template: Ember.Handlebars.compile(Em.I18n.t('installer.step2.warning.popup.body').format(self.get('invalidHostNames').join(', ')))
        })
      });
    },

    /**
     * show popup with the list of hosts that are already part of the cluster
     */
    installedHostsPopup: function () {
      var self = this;
      App.ModalPopup.show({
        header: Em.I18n.t('common.warning'),
        onPrimary: function () {
          self.proceedNext();
          this.hide();
        },
        bodyClass: Ember.View.extend({
          template: Ember.Handlebars.compile('<p>{{t installer.step2.evaluateStep.installedHosts}}</p><p>' + self.get('inputtedAgainHostNames').join(', ') + '</p><p>{{t installer.step2.evaluateStep.continueConfirm}}</p>')
        })
      });
    },

    /**
     * show popup with hosts generated by pattern
     * @param hostNames
     */
    hostNamePatternPopup: function (hostNames) {
      var self = this;
      App.ModalPopup.show({
        header: Em.I18n.t('installer.step2.hostName.pattern.header'),
        onPrimary: function () {
          self.proceedNext();
          this.hide();
        },
        bodyClass: Ember.View.extend({
          template: Ember.Handlebars.compile(['{{#each host in view.hostNames}}<p>{{host}}</p>{{/each}}'].join('\n')),
          hostNames: hostNames
        })
      });
    },
    /**
     * show notify that installation is manual
     * save hosts
     */
    manualInstallPopup: function () {
      var self = this;
      App.ModalPopup.show({
        header: Em.I18n.t('installer.step2.manualInstall.popup.header'),
        onPrimary: function () {
          this.hide();
          self.saveHosts();
        },
        bodyClass: Ember.View.extend({
          templateName: require('templates/wizard/step2ManualInstallPopup')
        })
      });
    },

    isSubmitDisabled: function () {
      return (this.get('hostsError') || this.get('sshKeyError') || this.get('sshUserError'))  ;
    }.property('hostsError', 'sshKeyError', 'sshUserError'),

    saveHosts: function(){
      this.set('content.hosts', this.getHostInfo());
      App.router.send('next');
    }

  });
  
});
window.require.register("controllers/wizard/step3_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.WizardStep3Controller = Em.Controller.extend({
    name: 'wizardStep3Controller',
    hosts: [],
    content: [],
    bootHosts: [],
    registrationStartedAt: null,
    registrationTimeoutSecs: 120,
    stopBootstrap: false,
    isSubmitDisabled: true,

    categoryObject: Em.Object.extend({
      hostsCount: function () {
        var category = this;
        var hosts = this.get('controller.hosts').filter(function(_host) {
          if (_host.get('bootStatus') == category.get('hostsBootStatus')) {
            return true;
          } else if (_host.get('bootStatus') == 'DONE' && category.get('hostsBootStatus') == 'REGISTERING') {
            return true;
          } else {
            return false;
          }
        }, this);
        return hosts.get('length');
      }.property('controller.hosts.@each.bootStatus'), // 'hosts.@each.bootStatus'
      label: function () {
        return "%@ (%@)".fmt(this.get('value'), this.get('hostsCount'));
      }.property('value', 'hostsCount')
    }),
    getCategory: function(field, value){
      return this.get('categories').find(function(item){
        return item.get(field) == value;
      });
    },

    categories: function () {
      var self = this;
      self.categoryObject.reopen({
        controller: self,
        isActive: function(){
          return this.get('controller.category') == this;
        }.property('controller.category'),
        itemClass: function(){
          return this.get('isActive') ? 'active' : '';
        }.property('isActive')
      });

      var categories = [
        self.categoryObject.create({value: Em.I18n.t('common.all'), hostsCount: function () {
          return this.get('controller.hosts.length');
        }.property('controller.hosts.length') }),
        self.categoryObject.create({value: Em.I18n.t('installer.step3.hosts.status.installing'), hostsBootStatus: 'RUNNING'}),
        self.categoryObject.create({value: Em.I18n.t('installer.step3.hosts.status.registering'), hostsBootStatus: 'REGISTERING'}),
        self.categoryObject.create({value: Em.I18n.t('common.success'), hostsBootStatus: 'REGISTERED' }),
        self.categoryObject.create({value: Em.I18n.t('common.fail'), hostsBootStatus: 'FAILED', last: true })
      ];

      this.set('category', categories.get('firstObject'));

      return categories;
    }.property(),

    category: false,

    allChecked: false,

    onAllChecked: function () {
      var hosts = this.get('visibleHosts');
      hosts.setEach('isChecked', this.get('allChecked'));
    }.observes('allChecked'),

    noHostsSelected: function () {
      return !(this.hosts.someProperty('isChecked', true));
    }.property('hosts.@each.isChecked'),

    isRetryDisabled: true,

    navigateStep: function () {
      this.loadStep();
      if (this.get('content.installOptions.manualInstall') !== true) {
        if (!App.db.getBootStatus()) {
          this.startBootstrap();
        }
      } else {
        this.set('bootHosts', this.get('hosts'));
        if (App.testMode) {
          this.getHostInfo();
          this.get('bootHosts').setEach('bootStatus', 'REGISTERED');
          this.get('bootHosts').setEach('cpu', '2');
          this.get('bootHosts').setEach('memory', '2000000');
          this.set('isSubmitDisabled', false);
        } else {
          this.set('registrationStartedAt', null);
          this.get('bootHosts').setEach('bootStatus', 'DONE');
          this.startRegistration();
        }
      }
    },

    clearStep: function () {
      this.set('stopBootstrap', false);
      this.hosts.clear();
      this.bootHosts.clear();
      App.db.setBootStatus(false);
      this.set('isSubmitDisabled', true);
      this.set('isRetryDisabled', true);
    },

    loadStep: function () {
      console.log("TRACE: Loading step3: Confirm Hosts");
      this.set('registrationStartedAt', null);

      this.clearStep();
      var hosts = this.loadHosts();
      // hosts.setEach('bootStatus', 'RUNNING');
      this.renderHosts(hosts);
    },

    /* Loads the hostinfo from localStorage on the insertion of view. It's being called from view */
    loadHosts: function () {
      var hostInfo = this.get('content.hosts');
      var hosts = new Ember.Set();
      for (var index in hostInfo) {
        hosts.add(hostInfo[index]);
        console.log("TRACE: host name is: " + hostInfo[index].name);
      }
      return hosts;
    },

    /* Renders the set of passed hosts */
    renderHosts: function (hostsInfo) {
      var self = this;
      hostsInfo.forEach(function (_hostInfo) {
        var hostInfo = App.HostInfo.create({
          name: _hostInfo.name,
          bootStatus: _hostInfo.bootStatus,
          isChecked: false
        });

        console.log('pushing ' + hostInfo.name);
        self.hosts.pushObject(hostInfo);
      });
    },

    /**
     * Parses and updates the content based on bootstrap API response.
     * Returns true if polling should continue (some hosts are in "RUNNING" state); false otherwise
     */
    parseHostInfo: function (hostsStatusFromServer) {
      hostsStatusFromServer.forEach(function (_hostStatus) {
        var host = this.get('bootHosts').findProperty('name', _hostStatus.hostName);
        // check if hostname extracted from REST API data matches any hostname in content
        // also, make sure that bootStatus modified by isHostsRegistered call does not get overwritten
        // since these calls are being made in parallel
        if (host && !['REGISTERED', 'REGISTERING'].contains(host.get('bootStatus'))) {
          host.set('bootStatus', _hostStatus.status);
          host.set('bootLog', _hostStatus.log);
        }
      }, this);
      // if the data rendered by REST API has hosts in "RUNNING" state, polling will continue
      return this.get('bootHosts').length != 0 && this.get('bootHosts').someProperty('bootStatus', 'RUNNING');
    },

    /* Returns the current set of visible hosts on view (All, Succeeded, Failed) */
    visibleHosts: function () {
      var self = this;
      if (this.get('category.hostsBootStatus')) {
        return this.hosts.filterProperty('bootStatus', self.get('category.hostsBootStatus'));
      } else { // if (this.get('category') === 'All Hosts')
        return this.hosts;
      }
    }.property('category', 'hosts.@each.bootStatus'),

    removeHosts: function (hosts) {
      var self = this;
      App.showConfirmationPopup(function() {
        App.router.send('removeHosts', hosts);
        self.hosts.removeObjects(hosts);
        if (!self.hosts.length) {
          self.set('isSubmitDisabled', true);
        }
      },Em.I18n.t('installer.step3.hosts.remove.popup.body'));
    },

    /* Removes a single element on the trash icon click. Called from View */
    removeHost: function (hostInfo) {
      this.removeHosts([hostInfo]);
    },

    removeSelectedHosts: function () {
      if (!this.get('noHostsSelected')) {
        var selectedHosts = this.get('visibleHosts').filterProperty('isChecked', true);
        selectedHosts.forEach(function (_hostInfo) {
          console.log('Removing:  ' + _hostInfo.name);
        });
        this.removeHosts(selectedHosts);
      }
    },

    retryHost: function (hostInfo) {
      this.retryHosts([hostInfo]);
    },

    retryHosts: function (hosts) {
      var bootStrapData = JSON.stringify({'verbose': true, 'sshKey': this.get('content.installOptions.sshKey'), 'hosts': hosts.mapProperty('name'), 'user': this.get('content.installOptions.sshUser')});
      this.numPolls = 0;
      if (this.get('content.installOptions.manualInstall') !== true) {
        var requestId = App.router.get('installerController').launchBootstrap(bootStrapData);
        this.set('content.installOptions.bootRequestId', requestId);
        this.set('registrationStartedAt', null);
        this.doBootstrap();
      } else {
        this.set('registrationStartedAt', null);
        this.get('bootHosts').setEach('bootStatus', 'DONE');
        this.startRegistration();
      }
    },

    retrySelectedHosts: function () {
      //to display all hosts
      this.set('category', 'All');
      if (!this.get('isRetryDisabled')) {
        this.set('isRetryDisabled', true);
        var selectedHosts = this.get('bootHosts').filterProperty('bootStatus', 'FAILED');
        selectedHosts.forEach(function (_host) {
          _host.set('bootStatus', 'RUNNING');
          _host.set('bootLog', 'Retrying ...');
        }, this);
        this.retryHosts(selectedHosts);
      }
    },

    numPolls: 0,

    startBootstrap: function () {
      //this.set('isSubmitDisabled', true);    //TODO: uncomment after actual hookup
      this.numPolls = 0;
      this.set('registrationStartedAt', null);
      this.set('bootHosts', this.get('hosts'));
      this.get('bootHosts').setEach('bootStatus', 'PENDING');
      this.doBootstrap();
    },

    isInstallInProgress: function(){
      var bootStatuses = this.get('bootHosts').getEach('bootStatus');
      if(bootStatuses.length &&
        (bootStatuses.contains('REGISTERING') ||
          bootStatuses.contains('DONE') ||
          bootStatuses.contains('RUNNING') ||
          bootStatuses.contains('PENDING'))){
        return true;
      }
      return false;
    }.property('bootHosts.@each.bootStatus'),

    disablePreviousSteps: function(){
      if(this.get('isInstallInProgress')){
        App.router.get('installerController').setLowerStepsDisable(3);
        this.set('isSubmitDisabled', true);
      } else {
        App.router.get('installerController.isStepDisabled').filter(function(step){
          if(step.step >= 0 && step.step <= 2) return true;
        }).setEach('value', false);
      }
    }.observes('isInstallInProgress'),

    doBootstrap: function () {
      if (this.get('stopBootstrap')) {
        return;
      }
      this.numPolls++;

      App.ajax.send({
        name: 'wizard.step3.bootstrap',
        sender: this,
        data: {
          bootRequestId: this.get('content.installOptions.bootRequestId'),
          numPolls: this.numPolls
        },
        success: 'doBootstrapSuccessCallback'
      }).
        retry({
          times: App.maxRetries,
          timeout: App.timeout
        }).
        then(
          null,
          function () {
            App.showReloadPopup();
            console.log('Bootstrap failed');
          }
        );
    },

    doBootstrapSuccessCallback: function (data) {
      if (data.hostsStatus !== null) {
        // in case of bootstrapping just one host, the server returns an object rather than an array, so
        // force into an array
        if (!(data.hostsStatus instanceof Array)) {
          data.hostsStatus = [ data.hostsStatus ];
        }
        console.log("TRACE: In success function for the GET bootstrap call");
        var keepPolling = this.parseHostInfo(data.hostsStatus);

        // Single host : if the only hostname is invalid (data.status == 'ERROR')
        // Multiple hosts : if one or more hostnames are invalid
        // following check will mark the bootStatus as 'FAILED' for the invalid hostname
        if (data.status == 'ERROR' || data.hostsStatus.length != this.get('bootHosts').length) {

          var hosts = this.get('bootHosts');

          for (var i = 0; i < hosts.length; i++) {

            var isValidHost = data.hostsStatus.someProperty('hostName', hosts[i].get('name'));
            if(hosts[i].get('bootStatus') !== 'REGISTERED'){
              if (!isValidHost) {
                hosts[i].set('bootStatus', 'FAILED');
                hosts[i].set('bootLog', Em.I18n.t('installer.step3.hosts.bootLog.failed'));
              }
            }
          }
        }

        if (data.hostsStatus.someProperty('status', 'DONE') || data.hostsStatus.someProperty('status', 'FAILED')) {
          // kicking off registration polls after at least one host has succeeded
          this.startRegistration();
        }
        if (keepPolling) {
          var self = this;
          window.setTimeout(function () {
            self.doBootstrap()
          }, 3000);
        }
      }
    },

    startRegistration: function () {
      if (this.get('registrationStartedAt') == null) {
        this.set('registrationStartedAt', new Date().getTime());
        console.log('registration started at ' + this.get('registrationStartedAt'));
        this.isHostsRegistered();
      }
    },

    isHostsRegistered: function () {
      if (this.get('stopBootstrap')) {
        return;
      }
      App.ajax.send({
        name: 'wizard.step3.is_hosts_registered',
        sender: this,
        success: 'isHostsRegisteredSuccessCallback'
      }).
        retry({
          times: App.maxRetries,
          timeout: App.timeout
        }).
          then(
            null,
            function () {
              App.showReloadPopup();
              console.log('Error: Getting registered host information from the server');
            }
          );
    },

    isHostsRegisteredSuccessCallback: function (data) {
      console.log('registration attempt...');
      var hosts = this.get('bootHosts');
      var jsonData = data;
      if (!jsonData) {
        console.warn("Error: jsonData is null");
        return;
      }

      // keep polling until all hosts have registered/failed, or registrationTimeout seconds after the last host finished bootstrapping
      var stopPolling = true;
      hosts.forEach(function (_host, index) {
        // Change name of first host for test mode.
        if (App.testMode) {
          if (index == 0) {
            _host.set('name', 'localhost.localdomain');
          }
        }
        // actions to take depending on the host's current bootStatus
        // RUNNING - bootstrap is running; leave it alone
        // DONE - bootstrap is done; transition to REGISTERING
        // REGISTERING - bootstrap is done but has not registered; transition to REGISTERED if host found in polling API result
        // REGISTERED - bootstrap and registration is done; leave it alone
        // FAILED - either bootstrap or registration failed; leave it alone
        console.log(_host.name + ' bootStatus=' + _host.get('bootStatus'));
        switch (_host.get('bootStatus')) {
          case 'DONE':
            _host.set('bootStatus', 'REGISTERING');
            _host.set('bootLog', (_host.get('bootLog') != null ? _host.get('bootLog') : '') + Em.I18n.t('installer.step3.hosts.bootLog.registering'));
            // update registration timestamp so that the timeout is computed from the last host that finished bootstrapping
            this.set('registrationStartedAt', new Date().getTime());
            stopPolling = false;
            break;
          case 'REGISTERING':
            if (jsonData.items.someProperty('Hosts.host_name', _host.name)) {
              console.log(_host.name + ' has been registered');
              _host.set('bootStatus', 'REGISTERED');
              _host.set('bootLog', (_host.get('bootLog') != null ? _host.get('bootLog') : '') + Em.I18n.t('installer.step3.hosts.bootLog.registering'));
            } else {
              console.log(_host.name + ' is registering...');
              stopPolling = false;
            }
            break;
          case 'RUNNING':
            stopPolling = false;
            break;
          case 'REGISTERED':
          case 'FAILED':
          default:
            break;
        }
      }, this);

      if (stopPolling) {
        this.getHostInfo();
      } else if (hosts.someProperty('bootStatus', 'RUNNING') || new Date().getTime() - this.get('registrationStartedAt') < this.get('registrationTimeoutSecs') * 1000) {
        // we want to keep polling for registration status if any of the hosts are still bootstrapping (so we check for RUNNING).
        var self = this;
        window.setTimeout(function () {
          self.isHostsRegistered();
        }, 3000);
      } else {
        // registration timed out.  mark all REGISTERING hosts to FAILED
        console.log('registration timed out');
        hosts.filterProperty('bootStatus', 'REGISTERING').forEach(function (_host) {
          _host.set('bootStatus', 'FAILED');
          _host.set('bootLog', (_host.get('bootLog') != null ? _host.get('bootLog') : '') + Em.I18n.t('installer.step3.hosts.bootLog.failed'));
        });
        this.getHostInfo();
      }
    },

    allHostsComplete: function() {
      var result = true;
      this.get('bootHosts').forEach(function(host) {
        var status = host.get('bootStatus');
        if (status != 'REGISTERED' && status != 'FAILED') {
          result = false;
        }
      });
      return result;
    }.property('bootHosts.@each.bootStatus'),

    registerErrPopup: function (header, message) {
      App.ModalPopup.show({
        header: header,
        secondary: false,
        onPrimary: function () {
          this.hide();
        },
        bodyClass: Ember.View.extend({
          template: Ember.Handlebars.compile(['<p>{{view.message}}</p>'].join('\n')),
          message: message
        })
      });
    },

    /**
     * Get disk info and cpu count of booted hosts from server
     */
    getHostInfo: function () {
      App.ajax.send({
        name: 'wizard.step3.host_info',
        sender: this,
        success: 'getHostInfoSuccessCallback',
        error: 'getHostInfoErrorCallback'
      });
    },

    getHostInfoSuccessCallback: function (jsonData) {
      var hosts = this.get('bootHosts');
      this.parseWarnings(jsonData);
      hosts.forEach(function (_host) {
        var host = (App.testMode) ? jsonData.items[0] : jsonData.items.findProperty('Hosts.host_name', _host.name);
        if (App.skipBootstrap) {
          _host.cpu = 2;
          _host.memory = ((parseInt(2000000))).toFixed(2);
          _host.disk_info = [{"mountpoint": "/", "type":"ext4"},{"mountpoint": "/grid/0", "type":"ext4"}, {"mountpoint": "/grid/1", "type":"ext4"}, {"mountpoint": "/grid/2", "type":"ext4"}];
        } else if (host) {
          _host.cpu = host.Hosts.cpu_count;
          _host.memory = ((parseInt(host.Hosts.total_mem))).toFixed(2);
          _host.disk_info = host.Hosts.disk_info;

          console.log("The value of memory is: " + _host.memory);
        }
      });
      this.set('bootHosts', hosts);
      console.log("The value of hosts: " + JSON.stringify(hosts));
      this.stopRegistration();
    },

    getHostInfoErrorCallback: function () {
      console.log('INFO: Getting host information(cpu_count and total_mem) from the server failed');
      this.registerErrPopup(Em.I18n.t('installer.step3.hostInformation.popup.header'), Em.I18n.t('installer.step3.hostInformation.popup.body'));
    },

    stopRegistration: function () {
      this.set('isSubmitDisabled', !this.get('bootHosts').someProperty('bootStatus', 'REGISTERED'));
      this.set('isRetryDisabled', !this.get('bootHosts').someProperty('bootStatus', 'FAILED'));
    },

    selectCategory: function(event, context){
      this.set('category', event.context);
    },

    submit: function () {
      if (!this.get('isSubmitDisabled')) {
          if(this.get('isHostHaveWarnings')) {
              var self = this;
              App.showConfirmationPopup(
                  function(){
                      self.set('content.hosts', self.get('bootHosts'));
                      App.router.send('next');
                  },
                  Em.I18n.t('installer.step3.hostWarningsPopup.hostHasWarnings'));
          }
          else {
                this.set('content.hosts', this.get('bootHosts'));
                App.router.send('next');
          }
      }
    },

    hostLogPopup: function (event, context) {
      var host = event.context;

      App.ModalPopup.show({

        header: Em.I18n.t('installer.step3.hostLog.popup.header').format(host.get('name')),
        secondary: null,

        onPrimary: function () {
          this.hide();
        },

        bodyClass: Ember.View.extend({
          templateName: require('templates/wizard/step3_host_log_popup'),
          host: host,
          didInsertElement: function () {
            var self = this;
            var button = $(this.get('element')).find('.textTrigger');
            button.click(function () {
              if (self.get('isTextArea')) {
                $(this).text(Em.I18n.t('installer.step3.hostLogPopup.highlight'));
              } else {
                $(this).text(Em.I18n.t('installer.step3.hostLogPopup.copy'));
              }
              self.set('isTextArea', !self.get('isTextArea'));
            });
            $(this.get('element')).find('.content-area').mouseenter(
              function () {
                var element = $(this);
                element.css('border', '1px solid #dcdcdc');
                button.css('visibility', 'visible');
              }).mouseleave(
              function () {
                var element = $(this);
                element.css('border', 'none');
                button.css('visibility', 'hidden');
              })
          },
          isTextArea: false,
          textArea: Em.TextArea.extend({
            didInsertElement: function () {
              var element = $(this.get('element'));
              element.width($(this.get('parentView').get('element')).width() - 10);
              element.height($(this.get('parentView').get('element')).height());
              element.select();
              element.css('resize', 'none');
            },
            readOnly: true,
            value: function () {
              return this.get('content');
            }.property('content')
          })
        })
      });
    },
    /**
     * check warnings from server and put it in parsing
      */
    rerunChecks: function(){
      var self = this;
      var currentProgress = 0;
      var interval = setInterval(function(){
        self.set('checksUpdateProgress', Math.ceil((++currentProgress/60)*100))
      }, 1000);
      setTimeout(function(){
        clearInterval(interval);
        App.ajax.send({
          name: 'wizard.step3.rerun_checks',
          sender: self,
          success: 'rerunChecksSuccessCallback',
          error: 'rerunChecksErrorCallback'
        });
      }, this.get('warningsTimeInterval'));

    },

    rerunChecksSuccessCallback: function (data) {
      this.set('checksUpdateProgress', 100);
      this.set('checksUpdateStatus', 'SUCCESS');
      this.parseWarnings(data);
    },

    rerunChecksErrorCallback: function () {
      this.set('checksUpdateProgress', 100);
      this.set('checksUpdateStatus', 'FAILED');
      console.log('INFO: Getting host information(last_agent_env) from the server failed');
    },

    warnings: [],
    warningsByHost: [],
    warningsTimeInterval: 60000,
    /**
     * check are hosts have any warnings
     */
    isHostHaveWarnings: function(){
      return this.get('warnings.length') > 0;
    }.property('warnings'),

    isWarningsBoxVisible: function(){
      return (App.testMode) ? true : this.get('allHostsComplete');
    }.property('allHostsComplete'),

    checksUpdateProgress:0,
    checksUpdateStatus: null,
    /**
     * filter data for warnings parse
     * is data from host in bootStrap
     * @param data
     * @return {Object}
     */
    filterBootHosts: function (data) {
      var bootHostNames = this.get('bootHosts').mapProperty('name');
      var filteredData = {
        href: data.href,
        items: []
      };
      data.items.forEach(function (host) {
        if (bootHostNames.contains(host.Hosts.host_name)) {
          filteredData.items.push(host);
        }
      });
      return filteredData;
    },
    /**
     * parse warnings data for each host and total
     * @param data
     */
    parseWarnings: function (data) {
      data = App.testMode ? data : this.filterBootHosts(data);
      var warnings = [];
      var warning;
      var hosts = [];
      data.items.sort(function (a, b) {
        if (a.Hosts.host_name > b.Hosts.host_name) {
          return 1;
        }
        if (a.Hosts.host_name < b.Hosts.host_name) {
          return -1;
        }
        return 0;
      });
      data.items.forEach(function (_host) {
        var host = {
          name: _host.Hosts.host_name,
          warnings: []
        }
        if (!_host.Hosts.last_agent_env) {
          // in some unusual circumstances when last_agent_env is not available from the _host,
          // skip the _host and proceed to process the rest of the hosts.
          console.log("last_agent_env is missing for " + _host.Hosts.host_name + ".  跳过 _host 检查.");
          return;
        }

        //parse all directories and files warnings for host

        //todo: to be removed after check in new API
        var stackFoldersAndFiles = _host.Hosts.last_agent_env.stackFoldersAndFiles || _host.Hosts.last_agent_env.paths;

        stackFoldersAndFiles.forEach(function (path) {
          warning = warnings.filterProperty('category', 'fileFolders').findProperty('name', path.name);
          if (warning) {
            warning.hosts.push(_host.Hosts.host_name);
            warning.onSingleHost = false;
          } else {
            warning = {
              name: path.name,
              hosts: [_host.Hosts.host_name],
              category: 'fileFolders',
              onSingleHost: true
            }
            warnings.push(warning);
          }
          host.warnings.push(warning);
        }, this);

        //parse all package warnings for host
        _host.Hosts.last_agent_env.rpms.forEach(function (_package) {

          if (_package.installed) {
            warning = warnings.filterProperty('category', 'packages').findProperty('name', _package.name);
            if (warning) {
              warning.hosts.push(_host.Hosts.host_name);
              warning.onSingleHost = false;
            } else {
              warning = {
                name: _package.name,
                hosts: [_host.Hosts.host_name],
                category: 'packages',
                onSingleHost: true
              }
              warnings.push(warning);
            }
            host.warnings.push(warning);
          }
        }, this);

        //parse all process warnings for host

        //todo: to be removed after check in new API
        var javaProcs = _host.Hosts.last_agent_env.hostHealth ? _host.Hosts.last_agent_env.hostHealth.activeJavaProcs : _host.Hosts.last_agent_env.javaProcs;

        javaProcs.forEach(function (process) {
          warning = warnings.filterProperty('category', 'processes').findProperty('pid', process.pid);
          if (warning) {
            warning.hosts.push(_host.Hosts.host_name);
            warning.onSingleHost = false;
          } else {
            warning = {
              name: (process.command.substr(0, 35) + '...'),
              hosts: [_host.Hosts.host_name],
              category: 'processes',
              user: process.user,
              pid: process.pid,
              command: '<table><tr><td style="word-break: break-all;">' +
                  ((process.command.length < 500) ? process.command : process.command.substr(0, 230) + '...' +
                      '<p style="text-align: center">................</p>' +
                      '...' + process.command.substr(-230)) + '</td></tr></table>',
              onSingleHost: true
            }
            warnings.push(warning);
          }
          host.warnings.push(warning);
        }, this);

        //parse all service warnings for host

        //todo: to be removed after check in new API
        if (_host.Hosts.last_agent_env.hostHealth && _host.Hosts.last_agent_env.hostHealth.liveServices) {

          _host.Hosts.last_agent_env.hostHealth.liveServices.forEach(function (service) {
            if (service.status === 'Unhealthy') {
              warning = warnings.filterProperty('category', 'services').findProperty('name', service.name);
              if (warning) {
                warning.hosts.push(_host.Hosts.host_name);
                warning.onSingleHost = false;
              } else {
                warning = {
                  name: service.name,
                  hosts: [_host.Hosts.host_name],
                  category: 'services',
                  onSingleHost: true
                }
                warnings.push(warning);
              }
              host.warnings.push(warning);
            }
          }, this);
        }
        //parse all user warnings for host

        //todo: to be removed after check in new API
        if (_host.Hosts.last_agent_env.existingUsers) {

          _host.Hosts.last_agent_env.existingUsers.forEach(function (user) {
            warning = warnings.filterProperty('category', 'users').findProperty('name', user.userName);
            if (warning) {
              warning.hosts.push(_host.Hosts.host_name);
              warning.onSingleHost = false;
            } else {
              warning = {
                name: user.userName,
                hosts: [_host.Hosts.host_name],
                category: 'users',
                onSingleHost: true
              }
              warnings.push(warning);
            }
            host.warnings.push(warning);
          }, this);
        }
        hosts.push(host);
      }, this);
      warnings.forEach(function (warn) {
        if (warn.hosts.length < 11) {
          warn.hostsList = warn.hosts.join('<br>')
        } else {
          warn.hostsList = warn.hosts.slice(0,10).join('<br>') + '<br> ' + Em.I18n.t('installer.step3.hostWarningsPopup.moreHosts').format(warn.hosts.length - 10);
        }
      });
      hosts.unshift({
        name: 'All Hosts',
        warnings: warnings
      });
      this.set('warnings', warnings);
      this.set('warningsByHost', hosts);
    },
    /**
     * open popup that contain hosts' warnings
     * @param event
     */
    hostWarningsPopup: function(event){
      var self = this;
      App.ModalPopup.show({

        header: Em.I18n.t('installer.step3.warnings.popup.header'),
        secondary: Em.I18n.t('installer.step3.hostWarningsPopup.rerunChecks'),
        primary: Em.I18n.t('common.close'),
        onPrimary: function () {
          self.set('checksUpdateStatus', null);
          this.hide();
        },
        onClose: function(){
          self.set('checksUpdateStatus', null);
          this.hide();
        },
        onSecondary: function() {
          self.rerunChecks();
        },
        didInsertElement: function () {
          this.fitHeight();
        },

        footerClass: Ember.View.extend({
          template: Ember.Handlebars.compile([
            '<div class="update-progress pull-left">',
            '{{#if view.isUpdateInProgress}}',
            '<div class="progress-info active progress">',
            '<div class="bar" {{bindAttr style="view.progressWidth"}}></div></div>',
            '{{else}}<label {{bindAttr class="view.updateStatusClass"}}>{{view.updateStatus}}</label>',
            '{{/if}}</div>',
            '{{#if view.parentView.secondary}}<button type="button" class="btn btn-info" {{bindAttr disabled="view.isUpdateInProgress"}} {{action onSecondary target="view.parentView"}}><i class="icon-repeat"></i>&nbsp;{{view.parentView.secondary}}</button>{{/if}}',
            '{{#if view.parentView.primary}}<button type="button" class="btn" {{action onPrimary target="view.parentView"}}>{{view.parentView.primary}}</button>{{/if}}'
          ].join('')),
          classNames: ['modal-footer', 'host-checks-update'],
          progressWidth: function(){
            return 'width:'+App.router.get('wizardStep3Controller.checksUpdateProgress')+'%';
          }.property('App.router.wizardStep3Controller.checksUpdateProgress'),
          isUpdateInProgress: function(){
            if((App.router.get('wizardStep3Controller.checksUpdateProgress') > 0) &&
               (App.router.get('wizardStep3Controller.checksUpdateProgress') < 100)){
              return true;
            }
          }.property('App.router.wizardStep3Controller.checksUpdateProgress'),
          updateStatusClass:function(){
            var status = App.router.get('wizardStep3Controller.checksUpdateStatus');
            if(status === 'SUCCESS'){
              return 'text-success';
            } else if(status === 'FAILED'){
              return 'text-error';
            } else {
              return null;
            }
          }.property('App.router.wizardStep3Controller.checksUpdateStatus'),
          updateStatus:function(){
            var status = App.router.get('wizardStep3Controller.checksUpdateStatus');
            if(status === 'SUCCESS'){
              return Em.I18n.t('installer.step3.warnings.updateChecks.success');
            } else if(status === 'FAILED'){
              return Em.I18n.t('installer.step3.warnings.updateChecks.failed');
            } else {
              return null;
            }
          }.property('App.router.wizardStep3Controller.checksUpdateStatus')
        }),

        bodyClass: Ember.View.extend({
          templateName: require('templates/wizard/step3_host_warnings_popup'),
          classNames: ['host-check'],
          didInsertElement: function () {
            Ember.run.next(this, function () {
              $(this.get('content').filterProperty('isCollapsed').map(function (cat) {
                return '#' + cat.category
              }).join(',')).hide();
              this.$("[rel='HostsListTooltip']").tooltip({html: true, placement: "right"});
              this.$('#process .warning-name').tooltip({html: true, placement: "top"});
            })
          }.observes('content'),
          warningsByHost: function () {
            return App.router.get('wizardStep3Controller.warningsByHost');
          }.property('App.router.wizardStep3Controller.warningsByHost'),
          warnings: function () {
            return App.router.get('wizardStep3Controller.warnings');
          }.property('App.router.wizardStep3Controller.warnings'),
          categories: function () {
            return this.get('warningsByHost').mapProperty('name');
          }.property('warningsByHost'),
          category: 'All Hosts',
          content: function () {
            var categoryWarnings = this.get('warningsByHost').findProperty('name', this.get('category')).warnings;
            return [
              Ember.Object.create({
                warnings: categoryWarnings.filterProperty('category', 'processes'),
                title: Em.I18n.t('installer.step3.hostWarningsPopup.process'),
                message: Em.I18n.t('installer.step3.hostWarningsPopup.processes.message'),
                type: Em.I18n.t('common.process'),
                emptyName: Em.I18n.t('installer.step3.hostWarningsPopup.empty.processes'),
                action: Em.I18n.t('installer.step3.hostWarningsPopup.action.running'),
                category: 'process',
                isCollapsed: true
              }),
               Ember.Object.create({
                warnings: categoryWarnings.filterProperty('category', 'packages'),
                title: Em.I18n.t('installer.step3.hostWarningsPopup.package'),
                message: Em.I18n.t('installer.step3.hostWarningsPopup.packages.message'),
                type: Em.I18n.t('common.package'),
                emptyName: Em.I18n.t('installer.step3.hostWarningsPopup.empty.packages'),
                action: Em.I18n.t('installer.step3.hostWarningsPopup.action.installed'),
                category: 'package',
                isCollapsed: true
              }),
               Ember.Object.create({
                warnings: categoryWarnings.filterProperty('category', 'fileFolders'),
                title: Em.I18n.t('installer.step3.hostWarningsPopup.fileAndFolder'),
                message: Em.I18n.t('installer.step3.hostWarningsPopup.fileFolders.message'),
                type: Em.I18n.t('common.path'),
                emptyName: Em.I18n.t('installer.step3.hostWarningsPopup.empty.filesAndFolders'),
                action: Em.I18n.t('installer.step3.hostWarningsPopup.action.exists'),
                category: 'fileFolders',
                isCollapsed: true
              }),
               Ember.Object.create({
                warnings: categoryWarnings.filterProperty('category', 'services'),
                title: Em.I18n.t('installer.step3.hostWarningsPopup.service'),
                message: Em.I18n.t('installer.step3.hostWarningsPopup.services.message'),
                type: Em.I18n.t('common.service'),
                emptyName: Em.I18n.t('installer.step3.hostWarningsPopup.empty.services'),
                action: Em.I18n.t('installer.step3.hostWarningsPopup.action.notRunning'),
                category: 'service',
                isCollapsed: true
              }),
               Ember.Object.create({
                warnings: categoryWarnings.filterProperty('category', 'users'),
                title: Em.I18n.t('installer.step3.hostWarningsPopup.user'),
                message: Em.I18n.t('installer.step3.hostWarningsPopup.users.message'),
                type: Em.I18n.t('common.user'),
                emptyName: Em.I18n.t('installer.step3.hostWarningsPopup.empty.users'),
                action: Em.I18n.t('installer.step3.hostWarningsPopup.action.exists'),
                category: 'user',
                isCollapsed: true
              })
            ]
          }.property('category', 'warningsByHost'),

          showHostsPopup: function (hosts) {
            $('.tooltip').hide();
            App.ModalPopup.show({
              header: Em.I18n.t('installer.step3.hostWarningsPopup.allHosts'),
              bodyClass: Ember.View.extend({
                hosts: hosts.context,
                template: Ember.Handlebars.compile('<ul>{{#each host in view.hosts}}<li>{{host}}</li>{{/each}}</ul>')
              }),
              onPrimary: function () {
                this.hide();
              },
              secondary: null
            });
          },

          onToggleBlock: function (category) {
            this.$('#' + category.context.category).toggle('blind', 500);
            category.context.set('isCollapsed', !category.context.isCollapsed);
          },
          warningsNotice: function () {
            var warnings = this.get('warnings');
            var warningsByHost = self.get('warningsByHost').slice();
            warningsByHost.shift();
            var issues = warnings.length + ' ' + (warnings.length === 1 ? Em.I18n.t('installer.step3.hostWarningsPopup.issue') : Em.I18n.t('installer.step3.hostWarningsPopup.issues'));
            var hostsNumber = warningsByHost.length - warningsByHost.filterProperty('warnings.length', 0).length;
            var hosts = hostsNumber + ' ' + (hostsNumber === 1 ? Em.I18n.t('installer.step3.hostWarningsPopup.host') : Em.I18n.t('installer.step3.hostWarningsPopup.hosts'));
            return Em.I18n.t('installer.step3.hostWarningsPopup.summary').format(issues, hosts);
          }.property('warnings', 'warningsByHost'),
          /**
           * generate detailed content to show it in new window
           */
          contentInDetails: function () {
            var content = this.get('content');
            var warningsByHost = this.get('warningsByHost').slice();
            warningsByHost.shift();
            var newContent = '';
            newContent += Em.I18n.t('installer.step3.hostWarningsPopup.report.header') + new Date;
            newContent += Em.I18n.t('installer.step3.hostWarningsPopup.report.hosts');
            newContent += warningsByHost.filterProperty('warnings.length').mapProperty('name').join(' ');
            if (content.findProperty('category', 'fileFolders').warnings.length) {
              newContent += Em.I18n.t('installer.step3.hostWarningsPopup.report.fileFolders');
              newContent += content.findProperty('category', 'fileFolders').warnings.mapProperty('name').join(' ') +  Em.I18n.t('installer.step3.hostWarningsPopup.report.folder');
            }
            if (content.findProperty('category', 'process').warnings.length) {
              newContent += Em.I18n.t('installer.step3.hostWarningsPopup.report.process');
              content.findProperty('category', 'process').warnings.forEach(function (process, i) {
                process.hosts.forEach(function (host, j) {
                  if (!!i || !!j) {
                    newContent += ',';
                  }
                  newContent += '(' + host + ',' + process.user + ',' + process.pid + ')';
                });
              });
            }
            if (content.findProperty('category', 'package').warnings.length) {
              newContent += Em.I18n.t('installer.step3.hostWarningsPopup.report.package');
              newContent += content.findProperty('category', 'package').warnings.mapProperty('name').join(' ');
            }
            if (content.findProperty('category', 'service').warnings.length) {
              newContent += Em.I18n.t('installer.step3.hostWarningsPopup.report.service');
              newContent += content.findProperty('category', 'service').warnings.mapProperty('name').join(' ');
            }
            if (content.findProperty('category', 'user').warnings.length) {
              newContent += Em.I18n.t('installer.step3.hostWarningsPopup.report.user');
              newContent += content.findProperty('category', 'user').warnings.mapProperty('name').join(' ');
            }
            newContent += '</p>';
            return newContent;
          }.property('content', 'warningsByHost'),
          /**
           * open new browser tab with detailed content
           */
          openWarningsInDialog: function(){
            var newWindow = window.open('');
            var newDocument = newWindow.document;
            newDocument.write(this.get('contentInDetails'));
            newWindow.focus();
          }
        })
      })
    },

    back: function () {
      if (this.get('isInstallInProgress')) {
        return;
      }
      App.router.send('back');
    }

  });

  
});
window.require.register("controllers/wizard/step4_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var stringUtils = require('utils/string_utils');

  App.WizardStep4Controller = Em.ArrayController.extend({

    name: 'wizardStep4Controller',
    content: [],

    isSubmitDisabled:function(){
      return this.filterProperty('isSelected', true).filterProperty('isInstalled', false).length === 0;
    }.property("@each.isSelected"),

    /**
     * Check whether all properties are selected
     */
    isAll: function () {
      return this.filterProperty('canBeSelected', true).everyProperty('isSelected', true);
    }.property('@each.isSelected'),

    /**
     * Check whether none properties(minimum) are selected
     */
    isMinimum: function () {
      return this.filterProperty('isDisabled', false).everyProperty('isSelected', false);
    }.property('@each.isSelected'),

    /**
     * Update hidden services. Make them to have the same status as master ones.
     */
    checkDependencies: function () {
      var hbase = this.findProperty('serviceName', 'HBASE');
      var zookeeper = this.findProperty('serviceName', 'ZOOKEEPER');
      var hive = this.findProperty('serviceName', 'HIVE');
      var hcatalog = this.findProperty('serviceName', 'HCATALOG');
      var webhcat = this.findProperty('serviceName', 'WEBHCAT');

      // prevent against getting error when not all elements have been loaded yet
      if (hbase && zookeeper && hive && hcatalog && webhcat) {
        if (stringUtils.compareVersions(App.get('currentStackVersionNumber'), "2.0") === -1) {
          zookeeper.set('isSelected', hbase.get('isSelected') || hive.get('isSelected'));
        }else{
          if (!zookeeper.get('isSelected')) {
            zookeeper.set('isSelected', hbase.get('isSelected'));
          }
        }
        hcatalog.set('isSelected', hive.get('isSelected'));
        webhcat.set('isSelected', hive.get('isSelected'));
      }
    }.observes('@each.isSelected'),

    /**
     * Onclick handler for <code>select all</code> link
     */
    selectAll: function () {
      this.filterProperty('canBeSelected', true).setEach('isSelected', true);
    },

    /**
     * onclick handler for <code>select minimum</code> link
     */
    selectMinimum: function () {
      this.filterProperty('isDisabled', false).setEach('isSelected', false);
    },

    /**
     * Check whether we should turn on <code>MapReduce</code> service
     * @return {Boolean}
     */
    needToAddMapReduce: function () {
      if (this.findProperty('serviceName', 'MAPREDUCE') && this.findProperty('serviceName', 'MAPREDUCE').get('isSelected') === false) {
        var mapreduceDependentServices = this.filter(function (item) {
          return ['PIG', 'OOZIE', 'HIVE'].contains(item.get('serviceName')) && item.get('isSelected', true);
        });
        return (mapreduceDependentServices.get('length') > 0);
      }

      return false;
    },

    /** 
     * Check whether we should turn on <code>HDFS or HCFS</code> service
     * @return {Boolean}
     */
    needToAddHDFS: function () {
      return (this.findProperty('serviceName', 'HDFS').get('isSelected') === false &&
      		(!this.findProperty('serviceName', 'HCFS') || this.findProperty('serviceName', 'HCFS').get('isSelected') === false));
    },

    /** 
     * Check if multiple distributed file systems were selected
     * @return {Boolean}
     */
    multipleDFSs: function () {
  	return (this.findProperty('serviceName', 'HDFS').get('isSelected') === true &&
  	    	(this.findProperty('serviceName', 'HCFS') && this.findProperty('serviceName', 'HCFS').get('isSelected') === true));
    },

    /**
     * Check do we have any monitoring service turned on
     * @return {Boolean}
     */
    gangliaOrNagiosNotSelected: function () {
      return (this.findProperty('serviceName', 'GANGLIA').get('isSelected') === false || this.findProperty('serviceName', 'NAGIOS').get('isSelected') === false);
    },

    /**
     * Check whether user turned on monitoring service and go to next step
     */
    validateMonitoring: function () {
      if (this.gangliaOrNagiosNotSelected()) {
        this.monitoringCheckPopup();
      } else {
        App.router.send('next');
      }
    },

    /**
     * Onclick handler for <code>Next</code> button
     */
    submit: function () {
      if(!this.get("isSubmitDisabled")){
        if (this.needToAddMapReduce()) {
          this.mapReduceCheckPopup();
        } else if (this.needToAddHDFS()) {
          this.needToAddHDFSPopup();
        } else if (this.multipleDFSs()) {
          this.multipleDFSPopup();        
        }
         else {
          this.validateMonitoring();
        }
      }
    },
    
    multipleDFSPopup: function() {
      var self = this;
      App.ModalPopup.show({
        header: Em.I18n.t('installer.step4.multipleDFS.popup.header'),
        body: Em.I18n.t('installer.step4.multipleDFS.popup.body'),
        onPrimary: function () {
          self.findProperty('serviceName', 'HDFS').set('isSelected', true);
          self.findProperty('serviceName', 'HCFS').set('isSelected', false);
          this.hide();
          self.validateMonitoring();
        },
        onSecondary: function () {
          this.hide();
        }
      });    
    },
    
    needToAddHDFSPopup: function() {
      var self = this;
      App.ModalPopup.show({
        header: Em.I18n.t('installer.step4.hdfsCheck.popup.header'),
        body: Em.I18n.t('installer.step4.hdfsCheck.popup.body'),
        onPrimary: function () {
        self.findProperty('serviceName', 'HDFS').set('isSelected', true);
        this.hide();
          self.validateMonitoring();
        },
        onSecondary: function () {
        this.hide();
        }
      });    
    },

    mapReduceCheckPopup: function () {
      var self = this;
      App.ModalPopup.show({
        header: Em.I18n.t('installer.step4.mapreduceCheck.popup.header'),
        body: Em.I18n.t('installer.step4.mapreduceCheck.popup.body'),
        onPrimary: function () {
          self.findProperty('serviceName', 'MAPREDUCE').set('isSelected', true);
          this.hide();
          self.validateMonitoring();
        },
        onSecondary: function () {
          this.hide();
        }
      });
    },

    monitoringCheckPopup: function () {
      App.ModalPopup.show({
        header: Em.I18n.t('installer.step4.monitoringCheck.popup.header'),
        body: Em.I18n.t('installer.step4.monitoringCheck.popup.body'),
        onPrimary: function () {
          this.hide();
          App.router.send('next');
        },
        onSecondary: function () {
          this.hide();
        }
      });
    }
  })
});
window.require.register("controllers/wizard/step5_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.WizardStep5Controller = Em.Controller.extend({

    name:"wizardStep5Controller",
    title: function () {
      if (this.get('content.controllerName') == 'reassignMasterController') {
        return Em.I18n.t('installer.step5.reassign.header');
      }
      return Em.I18n.t('installer.step5.header');
    }.property('content.controllerName'),

    isReassignWizard: function () {
      return this.get('content.controllerName') == 'reassignMasterController';
    }.property('content.controllerName'),

    isReassignHive: function () {
      return this.get('servicesMasters').objectAt(0) && this.get('servicesMasters').objectAt(0).component_name == 'HIVE_SERVER' && this.get('isReassignWizard');
    }.property('isReassignWizard', 'servicesMasters'),

    isSubmitDisabled: function () {
      if (!this.get('isReassignWizard')) {
        return false;
      }
      var reassigned = false;
      var arr1 = App.HostComponent.find().filterProperty('componentName', this.get('content.reassign.component_name')).mapProperty('host.hostName');
      var arr2 = this.get('servicesMasters').mapProperty('selectedHost');
      arr1.forEach(function (host) {
        if (!arr2.contains(host)) {
          reassigned = true;
        }
      }, this);
      return !reassigned;
    }.property('servicesMasters.@each.selectedHost'),

    hosts:[],

    servicesMasters:[],
    selectedServicesMasters:[],

    components:require('data/service_components'),

    clearStep:function () {
      this.set('hosts', []);
      this.set('selectedServicesMasters', []);
      this.set('servicesMasters', []);
    },

    loadStep:function () {
      console.log("WizardStep5Controller: Loading step5: Assign Masters");
      this.clearStep();
      this.renderHostInfo();
      this.renderComponents(this.loadComponents());

      this.updateComponent('ZOOKEEPER_SERVER');
      if(App.supports.multipleHBaseMasters){
        this.updateComponent('HBASE_MASTER');
      }

      if (!this.get("selectedServicesMasters").filterProperty('isInstalled', false).length) {
        console.log('no master components to add');
        App.router.send('next');
      }
    },

    /**
     * Used to set showAddControl flag for ZOOKEEPER_SERVER and HBASE_SERVER
     */
    updateComponent: function(componentName){
      var component = this.last(componentName);

      var services = this.get('content.services').filterProperty('isInstalled', true).mapProperty('serviceName');
      var currentService = componentName.split('_')[0];
      var showControl = !services.contains(currentService);

      if (component) {
        if(showControl){
          if (this.get("selectedServicesMasters").filterProperty("component_name", componentName).length < this.get("hosts.length") && !this.get('isReassignWizard')) {
            component.set('showAddControl', true);
          } else {
            component.set('showRemoveControl', false);
          }
        }
        this.rebalanceComponentHosts(componentName);
      }
    },

    /**
     * Load active host list to <code>hosts</code> variable
     */
    renderHostInfo:function () {

      var hostInfo = this.get('content.hosts');
      var result = [];

      for (var index in hostInfo) {
        var _host = hostInfo[index];
        if (_host.bootStatus === 'REGISTERED') {
          result.push(Ember.Object.create({
            host_name:_host.name,

            cpu:_host.cpu,
            memory:_host.memory,
            disk_info:_host.disk_info,
            host_info: Em.I18n.t('installer.step5.hostInfo').fmt(_host.name, (_host.memory * 1024).bytesToSize(1, 'parseFloat'), _host.cpu)
          }));
        }
      }
      this.set("hosts", result);
      this.sortHosts(this.get('hosts'));
    },

    sortHosts: function (hosts) {
      hosts.sort(function (a, b) {
        if (a.get('memory') == b.get('memory')) {
          if (a.get('cpu') == b.get('cpu')) {
            return a.get('host_name').localeCompare(b.get('host_name')); // hostname asc
          }
          return b.get('cpu') - a.get('cpu'); // cores desc
        }
        return b.get('memory') - a.get('memory'); // ram desc
      });
    },

    /**
     * Load services info to appropriate variable and return masterComponentHosts
     * @return Array
     */
    loadComponents:function () {

      var services = this.get('content.services')
        .filterProperty('isSelected', true).mapProperty('serviceName'); //list of shown services

      var masterComponents = this.get('components').filterProperty('isMaster', true); //get full list from mock data
      var masterHosts = this.get('content.masterComponentHosts'); //saved to local storage info

      var resultComponents = [];

      var servicesLength = services.length;
      for (var index = 0; index < servicesLength; index++) {
        var componentInfo = masterComponents.filterProperty('service_name', services[index]);

        componentInfo.forEach(function (_componentInfo) {
          if (_componentInfo.component_name == 'ZOOKEEPER_SERVER' || _componentInfo.component_name == 'HBASE_MASTER') {
            var savedComponents = masterHosts.filterProperty('component', _componentInfo.component_name);
            if (savedComponents.length) {

              savedComponents.forEach(function (item) {
                var zooKeeperHost = {};
                zooKeeperHost.display_name = _componentInfo.display_name;
                zooKeeperHost.component_name = _componentInfo.component_name;
                zooKeeperHost.selectedHost = item.hostName;
                zooKeeperHost.availableHosts = [];
                zooKeeperHost.serviceId = services[index];
                zooKeeperHost.isInstalled = item.isInstalled;
                zooKeeperHost.isHiveCoHost = false;
                resultComponents.push(zooKeeperHost);
              })

            } else {

              var zooHosts = this.selectHost(_componentInfo.component_name);
              zooHosts.forEach(function (_host) {
                var zooKeeperHost = {};
                zooKeeperHost.display_name = _componentInfo.display_name;
                zooKeeperHost.component_name = _componentInfo.component_name;
                zooKeeperHost.selectedHost = _host;
                zooKeeperHost.availableHosts = [];
                zooKeeperHost.serviceId = services[index];
                zooKeeperHost.isInstalled = false;
                zooKeeperHost.isHiveCoHost = false;
                resultComponents.push(zooKeeperHost);
              });

            }
          } else {
            var savedComponent = masterHosts.findProperty('component', _componentInfo.component_name);
            var componentObj = {};
            componentObj.component_name = _componentInfo.component_name;
            componentObj.display_name = _componentInfo.display_name;
            componentObj.selectedHost = savedComponent ? savedComponent.hostName : this.selectHost(_componentInfo.component_name);   // call the method that plays selectNode algorithm or fetches from server
            componentObj.isInstalled = savedComponent ? savedComponent.isInstalled : App.HostComponent.find().someProperty('componentName', _componentInfo.component_name);
            componentObj.serviceId = services[index];
            componentObj.availableHosts = [];
            componentObj.isHiveCoHost = ['HIVE_METASTORE', 'WEBHCAT_SERVER'].contains(_componentInfo.component_name) && !this.get('isReassignWizard');
            resultComponents.push(componentObj);
          }
        }, this);
      }

      return resultComponents;
    },

    /**
     * Put master components to <code>selectedServicesMasters</code>, which will be automatically rendered in template
     * @param masterComponents
     */
    renderComponents:function (masterComponents) {
      var services = this.get('content.services')
        .filterProperty('isInstalled', true).mapProperty('serviceName'); //list of shown services

      var showRemoveControlZk = !services.contains('ZOOKEEPER') && masterComponents.filterProperty('display_name', 'ZooKeeper').length > 1;
      var showRemoveControlHb = !services.contains('HBASE') && masterComponents.filterProperty('component_name', 'HBASE_MASTER').length > 1;
      var zid = 1;
      var hid = 1;
      var result = [];

      masterComponents.forEach(function (item) {

        var componentObj = Ember.Object.create(item);
        console.log("TRACE: render master component name is: " + item.component_name);

        if (item.display_name === "ZooKeeper") {
          componentObj.set('zId', zid++);
          componentObj.set("showRemoveControl", showRemoveControlZk);
        } else if (App.supports.multipleHBaseMasters && item.component_name === "HBASE_MASTER") {
          componentObj.set('zId', hid++);
          componentObj.set("showRemoveControl", showRemoveControlHb);
        }
        componentObj.set("availableHosts", this.get("hosts"));
        result.push(componentObj);
      }, this);

      this.set("selectedServicesMasters", result);
      if (this.get('isReassignWizard')) {
        var components = result.filterProperty('component_name', this.get('content.reassign.component_name'));
        components.setEach('isInstalled', false);
        this.set('servicesMasters', components);
      } else {
        this.set('servicesMasters', result);
      }
    },

    hasHiveServer: function () {
      return !!this.get('selectedServicesMasters').findProperty('component_name', 'HIVE_SERVER') && !this.get('isReassignWizard');
    }.property('selectedServicesMasters'),

    updateHiveCoHosts: function () {
      var hiveServer =  this.get('selectedServicesMasters').findProperty('component_name', 'HIVE_SERVER');
      var hiveMetastore = this.get('selectedServicesMasters').findProperty('component_name', 'HIVE_METASTORE');
      var webHCatServer = this.get('selectedServicesMasters').findProperty('component_name', 'WEBHCAT_SERVER');
      if (hiveServer && hiveMetastore && webHCatServer) {
        if (!this.get('isReassignHive') && this.get('servicesMasters').objectAt(0) && !(this.get('servicesMasters').objectAt(0).component_name == 'HIVE_METASTORE')) {
          this.get('selectedServicesMasters').findProperty('component_name', 'HIVE_METASTORE').set('selectedHost', hiveServer.get('selectedHost'))
        }
        this.get('selectedServicesMasters').findProperty('component_name', 'WEBHCAT_SERVER').set('selectedHost', hiveServer.get('selectedHost'));
      }
    }.observes('selectedServicesMasters.@each.selectedHost'),

    /**
     * select and return host for component by scheme
     * Scheme is an object that has keys which compared to number of hosts,
     * if key more that number of hosts, then return value of that key.
     * Value is index of host in hosts array.
     *
     * @param noOfHosts
     * @param selectionScheme
     * @return {*}
     */
    getHostForComponent: function(noOfHosts, selectionScheme){
      var hosts = this.get('hosts');
      if(hosts.length === 1 || $.isEmptyObject(selectionScheme)){
        return hosts[0];
      } else {
        for(var i in selectionScheme){
          if(window.isFinite(i)){
            if(noOfHosts < window.parseInt(i)){
              return hosts[selectionScheme[i]];
            }
          }
        }
        return hosts[selectionScheme['else']]
      }
    },

    getZooKeeperServer:function (noOfHosts) {
      var hosts = this.get('hosts');
      if (noOfHosts < 3) {
        return [hosts[0].host_name];
      } else {
        return [hosts[0].host_name, hosts[1].host_name, hosts[2].host_name];
      }
    },

    getGangliaServer:function (noOfHosts) {
      var hostNames = this.get('hosts').mapProperty('host_name');
      var hostExcAmbari = hostNames.without(location.hostname);
      if (noOfHosts > 1) {
        return hostExcAmbari[0];
      } else {
        return hostNames[0];
      }
    },

    getNagiosServer:function (noOfHosts) {
      return this.getGangliaServer(noOfHosts);
    },

    getHueServer:function (noOfHosts) {
      return this.getGangliaServer(noOfHosts);
    },
    /**
     * Return hostName of masterNode for specified service
     * @param componentName
     * @return {*}
     */
    selectHost:function (componentName) {
      var noOfHosts = this.get('hosts').length;
      switch (componentName) {
        case 'KERBEROS_SERVER':
          return this.getHostForComponent(noOfHosts, {
            "3" : 1,
            "6" : 1,
            "31" : 3,
            "else" : 5
          }).host_name;
        case 'NAMENODE':
          return this.getHostForComponent(noOfHosts, {
            "else" : 0
          }).host_name;
        case 'SECONDARY_NAMENODE':
          return this.getHostForComponent(noOfHosts, {
            "else" : 1
          }).host_name;
        case 'JOBTRACKER':
          return this.getHostForComponent(noOfHosts, {
            "3" : 1,
            "6" : 1,
            "31" : 1,
            "else" : 2
          }).host_name;
        case 'HISTORYSERVER':
          return this.getHostForComponent(noOfHosts, {
            "3" : 1,
            "6" : 1,
            "31" : 1,
            "else" : 2
          }).host_name;
        case 'RESOURCEMANAGER':
          return this.getHostForComponent(noOfHosts, {
            "3" : 1,
            "6" : 1,
            "31" : 1,
            "else" : 2
          }).host_name;
        case 'HBASE_MASTER':
          return [this.getHostForComponent(noOfHosts, {
            "3" : 0,
            "6" : 0,
            "31" : 2,
            "else" : 3
          }).host_name];
        case 'OOZIE_SERVER':
          return this.getHostForComponent(noOfHosts, {
            "3" : 1,
            "6" : 1,
            "31" : 2,
            "else" : 3
          }).host_name;
        case 'HIVE_SERVER':
          return this.getHostForComponent(noOfHosts, {
            "3" : 1,
            "6" : 1,
            "31" : 2,
            "else" : 4
          }).host_name;
        case 'HIVE_METASTORE':
          return this.getHostForComponent(noOfHosts, {
            "3" : 1,
            "6" : 1,
            "31" : 2,
            "else" : 4
          }).host_name;
        case 'WEBHCAT_SERVER':
          return this.getHostForComponent(noOfHosts, {
            "3" : 1,
            "6" : 1,
            "31" : 2,
            "else" : 4
          }).host_name;
        case 'ZOOKEEPER_SERVER':
          return this.getZooKeeperServer(noOfHosts);
        case 'GANGLIA_SERVER':
          return this.getGangliaServer(noOfHosts);
        case 'NAGIOS_SERVER':
          return this.getNagiosServer(noOfHosts);
        case 'HUE_SERVER':
          return this.getHueServer(noOfHosts);
      }
    },

    masterHostMapping:function () {
      var mapping = [], mappingObject, self = this, mappedHosts, hostObj, hostInfo;
      //get the unique assigned hosts and find the master services assigned to them

      mappedHosts = this.get("selectedServicesMasters").mapProperty("selectedHost").uniq();

      mappedHosts.forEach(function (item) {
        hostObj = self.get("hosts").findProperty("host_name", item);
        console.log("Name of the host is: " + hostObj.host_name);

        mappingObject = Ember.Object.create({
          host_name:item,
          hostInfo:hostObj.host_info,
          masterServices:self.get("selectedServicesMasters").filterProperty("selectedHost", item)
        });

        mapping.pushObject(mappingObject);
      }, this);

      mapping.sort(this.sortHostsByName);

      return mapping;

    }.property("selectedServicesMasters.@each.selectedHost"),

    remainingHosts:function () {
      return (this.get("hosts.length") - this.get("masterHostMapping.length"));
    }.property("selectedServicesMasters.@each.selectedHost"),

    //methods
    getAvailableHosts:function (componentName) {
      var selectedHosts = this.get("selectedServicesMasters").filterProperty("component_name", componentName).mapProperty("selectedHost").uniq();

      return this.get('hosts').filter(function(item){
        return !selectedHosts.contains(item.get("host_name"));
      });

    },

    /**
     * On change callback for selects
     * @param componentName
     * @param selectedHost
     * @param zId
     */
    assignHostToMaster:function (componentName, selectedHost, zId) {
      if (selectedHost && componentName) {
        if (zId) {
          this.get('selectedServicesMasters').filterProperty('component_name', componentName).findProperty("zId", zId).set("selectedHost", selectedHost);
          this.rebalanceComponentHosts(componentName);
        } else {
          this.get('selectedServicesMasters').findProperty("component_name", componentName).set("selectedHost", selectedHost);
        }

      }
    },

    /**
     * Returns last component of selected type
     * @param componentName
     * @return {*}
     */
    last: function(componentName){
      return this.get("selectedServicesMasters").filterProperty("component_name", componentName).get("lastObject");
    },

    /**
     * Add new component to ZooKeeper Server and Hbase master
     * @param componentName
     * @return {Boolean}
     */
    addComponent:function (componentName) {
      /*
       *Logic: If ZooKeeper service is selected then there can be
       * minimum 1 ZooKeeper master in total, and
       * maximum 1 ZooKeeper on every host
       */

      var maxNumZooKeepers = this.get("hosts.length"),
        currentZooKeepers = this.get("selectedServicesMasters").filterProperty("component_name", componentName),
        newZookeeper = null,
        zookeeperHosts = null,
        suggestedHost = null,
        i = 0,
        lastZoo = null;

      if (!currentZooKeepers.length) {
        console.log('ALERT: Zookeeper service was not selected');
        return false;
      }

      if (currentZooKeepers.get("length") < maxNumZooKeepers) {

        currentZooKeepers.set("lastObject.showAddControl", false);
        currentZooKeepers.set("lastObject.showRemoveControl", true);

        //create a new zookeeper based on an existing one
        newZookeeper = Ember.Object.create({});
        lastZoo = currentZooKeepers.get("lastObject");
        newZookeeper.set("display_name", lastZoo.get("display_name"));
        newZookeeper.set("component_name", lastZoo.get("component_name"));
        newZookeeper.set("selectedHost", lastZoo.get("selectedHost"));
        newZookeeper.set("availableHosts", this.getAvailableHosts(componentName));

        if (currentZooKeepers.get("length") === (maxNumZooKeepers - 1)) {
          newZookeeper.set("showAddControl", false);
        } else {
          newZookeeper.set("showAddControl", true);
        }
        newZookeeper.set("showRemoveControl", true);

        //get recommended host for the new Zookeeper server
        zookeeperHosts = currentZooKeepers.mapProperty("selectedHost").uniq();

        for (i = 0; i < this.get("hosts.length"); i++) {
          if (!(zookeeperHosts.contains(this.get("hosts")[i].get("host_name")))) {
            suggestedHost = this.get("hosts")[i].get("host_name");
            break;
          }
        }

        newZookeeper.set("selectedHost", suggestedHost);
        newZookeeper.set("zId", (currentZooKeepers.get("lastObject.zId") + 1));

        this.get("selectedServicesMasters").insertAt(this.get("selectedServicesMasters").indexOf(lastZoo) + 1, newZookeeper);

        if(componentName == 'ZOOKEEPER_SERVER' || componentName == 'HBASE_MASTER'){
          this.rebalanceComponentHosts(componentName);
        }

        return true;
      }
      return false;//if no more zookeepers can be added
    },

    /**
     * Remove component from ZooKeeper server or Hbase Master
     * @param componentName
     * @param zId
     * @return {Boolean}
     */
    removeComponent:function (componentName, zId) {
      var currentZooKeepers = this.get("selectedServicesMasters").filterProperty("component_name", componentName)

      //work only if the Zookeeper service is selected in previous step
      if (!currentZooKeepers.length) {
        return false;
      }

      if (currentZooKeepers.get("length") > 1) {
        this.get("selectedServicesMasters").removeAt(this.get("selectedServicesMasters").indexOf(currentZooKeepers.findProperty("zId", zId)));

        currentZooKeepers = this.get("selectedServicesMasters").filterProperty("component_name", componentName);
        if (currentZooKeepers.get("length") < this.get("hosts.length")) {
          currentZooKeepers.set("lastObject.showAddControl", true);
        }

        if (currentZooKeepers.get("length") === 1) {
          currentZooKeepers.set("lastObject.showRemoveControl", false);
        }
        if(componentName == 'ZOOKEEPER_SERVER' || componentName == 'HBASE_MASTER'){
          this.rebalanceComponentHosts(componentName);
        }

        return true;
      }

      return false;

    },

    rebalanceComponentHosts:function (componentName) {
      //for a zookeeper and hbase update the available hosts for the other zookeepers and hbases
      var currentComponents = this.get("selectedServicesMasters").filterProperty("component_name", componentName),
        componentHosts = currentComponents.mapProperty("selectedHost"),
        availableComponentHosts = [],
        preparedAvailableHosts = null;

      //get all hosts available for zookeepers
      this.get("hosts").forEach(function (item) {
        if (!componentHosts.contains(item.get("host_name"))) {
          availableComponentHosts.pushObject(item);
        }
      }, this);

      currentComponents.forEach(function (item) {
        preparedAvailableHosts = availableComponentHosts.slice(0);
        preparedAvailableHosts.pushObject(this.get("hosts").findProperty("host_name", item.get("selectedHost")))
        preparedAvailableHosts.sort(this.sortHostsByConfig, this);
        item.set("availableHosts", preparedAvailableHosts);
      }, this);
    },

    sortHostsByConfig:function (a, b) {
      //currently handling only total memory on the host
      if (a.memory < b.memory) {
        return 1;
      }
      else {
        return -1;
      }
    },

    sortHostsByName:function (a, b) {
      if (a.host_name > b.host_name) {
        return 1;
      }
      else {
        return -1;
      }
    },

    submit: function () {
      if (!this.get('isSubmitDisabled')){
        App.router.send('next');
      }
    }
  });



  
});
window.require.register("controllers/wizard/step6_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var db = require('utils/db');

  /**
   * By Step 6, we have the following information stored in App.db and set on this
   * controller by the router:
   *
   *   hosts: App.db.hosts (list of all hosts the user selected in Step 3)
   *   selectedServiceNames: App.db.selectedServiceNames (the services that the user selected in Step 4)
   *   masterComponentHosts: App.db.masterComponentHosts (master-components-to-hosts mapping the user selected in Step 5)
   *
   * Step 6 will set the following information in App.db:
   *   slaveComponentHosts: App.db.slaveComponentHosts (slave-components-to-hosts mapping the user selected in Step 6)
   *
   */
  App.WizardStep6Controller = Em.Controller.extend({

    hosts: [],

    headers: [],

    /**
     * true - assign ZK, HB
     * false - slaves and clients
     */
    isMasters: false,

    components: require('data/service_components'),

    isAddHostWizard: function () {
      return this.get('content.controllerName') === 'addHostController';
    }.property('content.controllerName'),

    isInstallerWizard: function () {
      return this.get('content.controllerName') === 'installerController';
    }.property('content.controllerName'),

    clearError: function () {
      var self = this;
      var isError = false;
      var err = true;
      var hosts = this.get('hosts');
      var headers = this.get('headers');
      headers.forEach(function (header) {
        var all_false = true;
        hosts.forEach(function (host) {
          var checkboxes = host.get('checkboxes');
          all_false &= !checkboxes.findProperty('title', header.get('label')).checked;
        });
        err &= all_false;
      });

      if (!err) {
        this.set('errorMessage', '');
      }

      if (this.get('isAddHostWizard')) {
        if (this.get('isMasters')) {
          this.set('errorMessage', '');
        }
        else {
          hosts.forEach(function (host) {
            isError = false;
            headers.forEach(function (header) {
              isError |= host.get('checkboxes').findProperty('title', header.get('label')).checked;
            });
            isError = !isError;
            if (isError) {
              return;
            }
            else {
              self.set('errorMessage', '');
            }
          });
        }
      }
    },

    /**
     * Check whether current host is currently selected as master
     * @param hostName
     * @return {Boolean}
     */
    hasMasterComponents: function (hostName) {
      return this.get('content.masterComponentHosts').someProperty('hostName', hostName);
    },

    clearStep: function () {
      this.set('hosts', []);
      this.set('headers', []);
      this.clearError();
    },

    /**
     * Enable some service for all hosts
     * @param event
     */
    selectAllNodes: function (event) {
      this.setAllNodes(event.context.label, true);
    },

    /**
     * Disable some services for all hosts
     * @param event
     */
    deselectAllNodes: function (event) {
      this.setAllNodes(event.context.label, false);
    },

    /**
     * Enable/disable some service for all hosts
     * @param {String} label - service name
     * @param {Boolean} checked - true - enable, false - disable
     */
    setAllNodes: function (label, checked) {
      this.get('hosts').forEach(function (host) {
        host.get('checkboxes').forEach(function (checkbox) {
          if (checkbox.get('title') === label) {
            checkbox.set('checked', checked);
          }
        });
      });
    },

    /**
     * Return whether service was selected or not
     * @param name serviceName
     * @return {*}
     */
    isServiceSelected: function (name) {
      return !!(this.get('content.services').findProperty('serviceName', name) &&
        this.get('content.services').findProperty('serviceName', name).get('isSelected'));
    },

    /**
     * Checkbox check callback
     * @param {String} title
     */
    checkCallback: function (title) {

      var header = this.get('headers').findProperty('label', title);
      var hosts = this.get('hosts');
      var allTrue = true;
      var allFalse = true;
      hosts.forEach(function (host) {
        host.get('checkboxes').forEach(function (cb) {
          if (cb.get('title') === title) {
            allTrue &= cb.get('checked');
            allFalse &= !cb.get('checked');
          }
        });
      });
      header.set('allChecked', allTrue);
      header.set('noChecked', allFalse);
      this.clearError();
    },

    getComponentDisplayName: function (componentName) {
      return this.get('components').findProperty('component_name', componentName).display_name
    },

    loadStep: function () {

      var self = this;

      console.log("WizardStep6Controller: Loading step6: Assign Slaves");
      this.clearStep();

      var headers = [];

      if (this.get('isMasters')) {
        if (this.isServiceSelected('HBASE') && App.supports.multipleHBaseMasters) {
          headers.pushObject(Em.Object.create({
            name: 'HBASE_MASTER',
            label: self.getComponentDisplayName('HBASE_MASTER')
          }));
        }
        if (this.isServiceSelected('ZOOKEEPER')) {
          headers.pushObject(Em.Object.create({
            name: 'ZOOKEEPER_SERVER',
            label: self.getComponentDisplayName('ZOOKEEPER_SERVER')
          }));
        }
      }
      else {
        if (this.isServiceSelected('HDFS')) {
          headers.pushObject(Ember.Object.create({
            name: 'DATANODE',
            label: self.getComponentDisplayName('DATANODE')
          }));
        }
        if (this.isServiceSelected('MAPREDUCE')) {
          headers.pushObject(Em.Object.create({
            name: 'TASKTRACKER',
            label: self.getComponentDisplayName('TASKTRACKER')
          }));
        }
        if (this.isServiceSelected('YARN')) {
          headers.pushObject(Em.Object.create({
            name: 'NODEMANAGER',
            label: self.getComponentDisplayName('NODEMANAGER')
          }));
        }
        if (this.isServiceSelected('HBASE')) {
          headers.pushObject(Em.Object.create({
            name: 'HBASE_REGIONSERVER',
            label: self.getComponentDisplayName('HBASE_REGIONSERVER')
          }));
        }
        headers.pushObject(Ember.Object.create({
          name: 'CLIENT',
          label: self.getComponentDisplayName('CLIENT')
        }));
      }

      headers.forEach(function (header) {
        header.setProperties({ allChecked: false, noChecked: true });
      });

      this.get('headers').pushObjects(headers);

      this.render();
      if (this.get('isMasters')) {
        if (this.get('content.skipMasterStep')) {
          App.router.send('next');
        }
      }
      else {
        if (this.get('content.skipSlavesStep')) {
          App.router.send('next');
        }
      }
    },

    /**
     * Get active host names
     * @return {Array}
     */
    getHostNames: function () {
      var hostInfo = this.get('content.hosts');
      var hostNames = [];
      for (var index in hostInfo) {
        if (hostInfo[index].bootStatus === 'REGISTERED') {
          hostNames.push(hostInfo[index].name);
        }
      }
      return hostNames;
    },

    /**
     * Load all data needed for this module. Then it automatically renders in template
     */
    render: function () {
      var hostsObj = Em.Set.create();
      var allHosts = this.getHostNames();

      var self = this;
      allHosts.forEach(function (_hostName) {

        var obj = Em.Object.create({
          hostName: _hostName,
          isMaster: false,
          checkboxes: []
        });

        self.get('headers').forEach(function (header) {
          obj.checkboxes.pushObject(Em.Object.create({
            title: header.label,
            checked: false,
            isInstalled: false
          }));
        });

        hostsObj.push(obj);
      });

      if (this.get('isMasters')) {
        hostsObj = this.renderMasters(hostsObj);
      }
      else {
        hostsObj = this.renderSlaves(hostsObj);
      }

      hostsObj.forEach(function (host) {
        this.get('hosts').pushObject(host);
      }, this);
      this.get('headers').forEach(function (header) {
        self.checkCallback(header.get('label'));
      });
    },

    /**
     *
     * @param hostsObj
     * @return {*}
     */
    renderSlaves: function (hostsObj) {
      var self = this;
      var allHosts = this.getHostNames();
      var headers = this.get('headers');
      var slaveComponents = this.get('content.slaveComponentHosts');
      if (!slaveComponents) { // we are at this page for the first time
        var client_is_set = false;
        hostsObj.forEach(function (host) {
          host.isMaster = self.hasMasterComponents(host.hostName);
          var checkboxes = host.get('checkboxes');
          checkboxes.setEach('checked', !host.isMaster);
          checkboxes.setEach('isInstalled', false);
          checkboxes.findProperty('title', headers.findProperty('name', 'CLIENT').get('label')).set('checked', false);
          // First not Master should have Client (only first!)
          if (!client_is_set) {
            if (self.isServiceSelected("HDFS")) {
              var checkboxDatanode = checkboxes.findProperty('title', headers.findProperty('name', 'DATANODE').get('label'));
              if (checkboxDatanode && checkboxDatanode.get('checked')) {
                checkboxes.findProperty('title', headers.findProperty('name', 'CLIENT').get('label')).set('checked', true);
                client_is_set = true;
              }
            }
          }
        });

        if (this.get('isInstallerWizard') && hostsObj.everyProperty('isMaster', true)) {
          var lastHost = hostsObj[hostsObj.length - 1];
          lastHost.get('checkboxes').setEach('checked', true);
        }
      }
      else {
        this.get('headers').forEach(function (header) {
          var nodes = slaveComponents.findProperty('componentName', header.get('name'));
          if (nodes) {
            nodes.hosts.forEach(function (_node) {
              var node = hostsObj.findProperty('hostName', _node.hostName);
              if (node) {
                node.get('checkboxes').findProperty('title', header.get('label')).set('checked', true);
                node.get('checkboxes').findProperty('title', header.get('label')).set('isInstalled', _node.isInstalled);
              }
            });
          }
        });
        allHosts.forEach(function (_hostname) {
          var host = hostsObj.findProperty('hostName', _hostname);
          if (host) {
            host.set('isMaster', this.hasMasterComponents(_hostname));
          }
        }, this);
      }
      return hostsObj;
    },

    /**
     *
     * @param hostsObj
     * @return {*}
     */
    renderMasters: function (hostsObj) {
      var self = this;
      var masterComponentHosts = this.get('content.masterComponentHosts');
      console.warn('masterComponentHosts', masterComponentHosts);

      if (masterComponentHosts) {
        masterComponentHosts.forEach(function (item) {
          var host = hostsObj.findProperty('hostName', item.hostName);
          if (host) {
            var checkbox = host.get('checkboxes').findProperty('title', item.display_name);
            if (checkbox) {
              checkbox.set('checked', true);
            }
          }
        });
      }

      return hostsObj;
    },

    /**
     * Return list of master components for specified <code>hostname</code>
     * @param hostName
     * @return {*}
     */
    getMasterComponentsForHost: function (hostName) {
      return this.get('content.masterComponentHosts').filterProperty('hostName', hostName).mapProperty('component');
    },


    /**
     * Validate form. Return do we have errors or not
     * @return {Boolean}
     */
    validate: function () {

      if (this.get('isAddHostWizard')) {
        return this.validateEachHost(Em.I18n.t('installer.step6.error.mustSelectOneForHost'));
      }
      else if (this.get('isInstallerWizard')) {
        //this.validateEachComponent() ? this.validateEachHost(Em.I18n.t('installer.step6.error.mustSelectOneForHost') ? return true : return false : return false;
       return this.validateEachComponent() && this.validateEachHost(Em.I18n.t('installer.step6.error.mustSelectOneForSlaveHost'));
      }
    },

    /**
     * Validate all components for each host. Return do we have errors or not
     * @return {Boolean}
     */
    validateEachHost: function (errorMsg) {

      var isError = false;
      var hosts = this.get('hosts');
      var headers = this.get('headers');
      for (var i = 0; i < hosts.length; i++) {
        if (this.get('isInstallerWizard') && this.get('content.masterComponentHosts').someProperty('hostName', hosts[i].hostName)) {
          continue;
        }
        var checkboxes = hosts[i].get('checkboxes');
        isError = false;
        headers.forEach(function (header) {
          isError |= checkboxes.findProperty('title', header.get('label')).checked;
        });
        isError = !isError;
        if (isError) {
          this.set('errorMessage', errorMsg);
          break;
        }
      }
      return !isError;
    },

    /**
     * Validate a component for all hosts. Return do we have errors or not
     * @return {Boolean}
     */
    validateEachComponent: function () {
      var isError = false;
      var hosts = this.get('hosts');
      var headers = this.get('headers');
      headers.forEach(function (header) {
        var all_false = true;
        hosts.forEach(function (host) {
          var checkboxes = host.get('checkboxes');
          all_false = all_false && !checkboxes.findProperty('title', header.get('label')).checked;
        });
        isError = isError || all_false;
      });
      if (isError) {
        this.set('errorMessage', Em.I18n.t('installer.step6.error.mustSelectOne'));
      }
      return !isError;
    }

  })
  ;
  
});
window.require.register("controllers/wizard/step7_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  /**
   * By Step 7, we have the following information stored in App.db and set on this
   * controller by the router.
   *
   *   selectedServices: App.db.selectedServices (the services that the user selected in Step 4)
   *   masterComponentHosts: App.db.masterComponentHosts (master-components-to-hosts mapping the user selected in Step 5)
   *   slaveComponentHosts: App.db.slaveComponentHosts (slave-components-to-hosts mapping the user selected in Step 6)
   *
   */

  App.WizardStep7Controller = Em.Controller.extend({

    name: 'wizardStep7Controller',

    stepConfigs: [], //contains all field properties that are viewed in this step

    selectedService: null,

    slaveHostToGroup: null,

    secureConfigs: require('data/secure_mapping'),

    miscModalVisible: false, //If miscConfigChange Modal is shown

    isSubmitDisabled: function () {
      return (!this.stepConfigs.filterProperty('showConfig', true).everyProperty('errorCount', 0) || this.get("miscModalVisible"));
    }.property('stepConfigs.@each.errorCount', 'miscModalVisible'),

    selectedServiceNames: function () {
      return this.get('content.services').filterProperty('isSelected', true).filterProperty('isInstalled', false).mapProperty('serviceName');
    }.property('content.services').cacheable(),

    allInstalledServiceNames: function () {
      return this.get('content.services').filterProperty('isSelected', true).mapProperty('serviceName');
    }.property('content.services').cacheable(),

    masterComponentHosts: function () {
      return this.get('content.masterComponentHosts');
    }.property('content.masterComponentHosts'),

    slaveComponentHosts: function () {
      return this.get('content.slaveGroupProperties');
    }.property('content.slaveGroupProperties', 'content.slaveComponentHosts'),

    customData: [],

    clearStep: function () {
      this.get('stepConfigs').clear();
    },

    /**
     * On load function
     */
    loadStep: function () {
      console.log("TRACE: Loading step7: Configure Services");
      this.clearStep();
      //STEP 1: Load advanced configs
      var advancedConfigs = this.get('content.advancedServiceConfig');
      //STEP 2: Load on-site configs by service from local DB
      var storedConfigs = this.get('content.serviceConfigProperties');
      //STEP 3: Merge pre-defined configs with loaded on-site configs
      var configs = App.config.mergePreDefinedWithStored(storedConfigs, advancedConfigs);
      //STEP 4: Add advanced configs
      App.config.addAdvancedConfigs(configs, advancedConfigs);
      //STEP 5: Add custom configs
      App.config.addCustomConfigs(configs);
      //STEP 6: Distribute configs by service and wrap each one in App.ServiceConfigProperty (configs -> serviceConfigs)
      var serviceConfigs = App.config.renderConfigs(configs, storedConfigs, this.get('allInstalledServiceNames'), this.get('selectedServiceNames'));
      this.set('stepConfigs', serviceConfigs);
      this.activateSpecialConfigs();
      this.set('selectedService', this.get('stepConfigs').filterProperty('showConfig', true).objectAt(0));
    },
    
     /**
     * make some configs visible depending on active services
     */
    activateSpecialConfigs: function () {
      var miscConfigs = this.get('stepConfigs').findProperty('serviceName', 'MISC').configs;
      miscConfigs = App.config.miscConfigVisibleProperty(miscConfigs, this.get('selectedServiceNames'));
    },

    /**
     * @param: An array of display names
     */
    setDisplayMessage: function (siteProperty, displayNames) {
      var displayMsg = null;
      if (displayNames && displayNames.length) {
        if (displayNames.length === 1) {
          displayMsg = siteProperty + ' ' + Em.I18n.t('as') + ' ' + displayNames[0];
        } else {
          var name = null;
          displayNames.forEach(function (_name, index) {
            if (index === 0) {
              name = _name;
            } else if (index === displayNames.length - 1) {
              name = name + ' ' + Em.I18n.t('and') + ' ' + _name;
            } else {
              name = name + ', ' + _name;
            }
          }, this);
          displayMsg = siteProperty + ' ' + Em.I18n.t('as') + ' ' + name;
        }
      } else {
        displayMsg = siteProperty;
      }
      return displayMsg;
    },

    /**
     * Set display names of the property tfrom he puppet/global names
     * @param displayNames: a field to be set with displayNames
     * @param names: array of property puppet/global names
     * @param configProperties: array of config properties of the respective service to the name param
     */
    setPropertyDisplayNames: function (displayNames, names, configProperties) {
      names.forEach(function (_name, index) {
        if (configProperties.someProperty('name', _name)) {
          displayNames.push(configProperties.findProperty('name', _name).displayName);
        }
      }, this);
    },

    /**
     * Display Error Message with service name, its custom configuration name and displaynames on the page
     * @param customConfig: array with custom configuration, serviceName and displayNames relative to custom configuration
     */
    showCustomConfigErrMsg: function (customConfig) {

      App.ModalPopup.show({
        header: Em.I18n.t('installer.step7.ConfigErrMsg.header'),
        primary: Em.I18n.t('ok'),
        secondary: null,
        onPrimary: function () {
          this.hide();
        },
        bodyClass: Ember.View.extend({
          message: Em.I18n.t('installer.step7.ConfigErrMsg.message'),
          siteProperties: customConfig,
          getDisplayMessage: function () {

          }.property('customConfig.@each.siteProperties.@each.siteProperty'),
          customConfig: customConfig,
          template: Ember.Handlebars.compile([
            '<h5>{{view.message}}</h5>',
            '<br/>',
            '<div class="pre-scrollable" style="max-height: 250px;">',
            '<ul>',
            '{{#each val in view.customConfig}}',
            '{{#if val.siteProperties}}',
            '<li>',
            '{{val.serviceName}}',
            '<ul>',
            '{{#each item in  val.siteProperties}}',
            '<li>',
            '{{item.displayMsg}}',
            '</li>',
            '{{/each}}',
            '</ul>',
            '</li>',
            '{{/if}}',
            '{{/each}}',
            '</ul>',
            '</div>'
          ].join('\n'))
        })
      });
    },

    submit: function () {
      if (!this.get('isSubmitDisabled')) {
        App.router.send('next');
      }
    }, 
    
    /**
     * Provides service component name and display-name information for 
     * the current selected service. 
     */
    getCurrentServiceComponents: function () {
      var selectedServiceName = this.get('selectedService.serviceName');
      var masterComponents = this.get('content.masterComponentHosts');
      var slaveComponents = this.get('content.slaveComponentHosts');
      var scMaps = require('data/service_components');
      
      var validComponents = Ember.A([]);
      var seenComponents = {};
      masterComponents.forEach(function(component){
        var cn = component.component
        var cdn = component.display_name;
        if(component.serviceId===selectedServiceName && !seenComponents[cn]){
          validComponents.pushObject(Ember.Object.create({
            componentName: cn,
            displayName: cdn,
            selected: false
          }));
          seenComponents[cn] = cn;
        }
      });
      slaveComponents.forEach(function(component){
        var cn = component.componentName
        var cdn = component.displayName;
        var componentDef = scMaps.findProperty('component_name', cn);
        if(componentDef!=null && selectedServiceName===componentDef.service_name && !seenComponents[cn]){
          validComponents.pushObject(Ember.Object.create({
            componentName: cn,
            displayName: cdn,
            selected: false
          }));
          seenComponents[cn] = cn;
        }
      });
      return validComponents;
    }.property('content'),
    

    getAllHosts: function () {
      // Load hosts
      var allHosts = Ember.A([]);
      var hostNameToHostMap = {};
      var hosts = this.get('content.hosts');
      for ( var hostName in hosts) {
        var host = hosts[hostName];
        hostNameToHostMap[hostName] = App.Host.createRecord({
          id: host.name,
          hostName: host.name,
          publicHostName: host.name,
          cpu: host.cpu,
          memory: host.memory
        });
        allHosts.pushObject(hostNameToHostMap[hostName]);
      }

      // Load host-components
      var masterComponents = this.get('content.masterComponentHosts');
      var slaveComponents = this.get('content.slaveComponentHosts');
      masterComponents.forEach(function (component) {
        var host = hostNameToHostMap[component.hostName];
        var hc = App.HostComponent.createRecord({
          componentName: component.component,
          host: host
        });
        if (host != null) {
          host.get('hostComponents').pushObject(hc);
        }
      });
      slaveComponents.forEach(function (component) {
        component.hosts.forEach(function (host) {
          var h = hostNameToHostMap[host.hostName];
          var hc = App.HostComponent.createRecord({
            componentName: component.componentName,
            host: h
          });
          if (h != null) {
            h.get('hostComponents').pushObject(hc);
          }
        });
      });
      return allHosts;
    }.property('content')

  });
  
});
window.require.register("controllers/wizard/step8_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var stringUtils = require('utils/string_utils');

  App.WizardStep8Controller = Em.Controller.extend({
    name: 'wizardStep8Controller',
    rawContent: require('data/review_configs'),
    totalHosts: [],
    clusterInfo: [],
    services: [],
    configs: [],
    globals: [],
    ajaxQueue: [],
    slaveComponentConfig: null,
    isSubmitDisabled: false,
    hasErrorOccurred: false,
    servicesInstalled: false,
    securityEnabled: false,
    /**
     * During page save time, we set the host overrides to the server.
     * The new host -> site:tag map is stored below. This will be
     * useful during save, to update the host's host components. Also,
     * it will be useful in deletion of overrides.
     *
     * Example:
     * {
     *  'hostname1': {
     *    'global': {
     *      'tagName': 'tag3187261938_hostname1',
     *      'map': {
     *        'hadoop_heapsize': '2048m'
     *      }
     *    }
     *  }
     * }
     *
     * @see loadedHostToOverrideSiteToTagMap
     */
    savedHostToOverrideSiteToTagMap: {},

    selectedServices: function () {
      return this.get('content.services').filterProperty('isSelected', true).filterProperty('isInstalled', false);
    }.property('content.services').cacheable(),

    configMapping: function() {
      return App.config.get('configMapping').all();
    }.property('App.config.configMapping'),

    clearStep: function () {
      this.get('services').clear();
      this.get('configs').clear();
      this.get('globals').clear();
      this.get('clusterInfo').clear();
      this.set('servicesInstalled', false);
    },

    loadStep: function () {
      console.log("TRACE: Loading step8: Review Page");
      if (this.get('content.controllerName') != 'installerController') {
        this.set('securityEnabled', App.router.get('mainAdminSecurityController').getUpdatedSecurityStatus());
      }
      this.clearStep();
      this.loadGlobals();
      this.loadConfigs();
      this.loadClusterInfo();
      this.loadServices();
      this.set('isSubmitDisabled', false);
    },

    loadGlobals: function () {
      var globals = this.get('content.serviceConfigProperties').filterProperty('id', 'puppet var');
      if (globals.someProperty('name', 'hive_database')) {
        var hiveDb = globals.findProperty('name', 'hive_database');
        var hiveDbType = {name: 'hive_database_type', value: 'mysql'};
        var hiveJdbcDriver = {name: 'hive_jdbc_driver'};

        if (hiveDb.value === 'New MySQL Database') {
          if (globals.someProperty('name', 'hive_ambari_host')) {
            globals.findProperty('name', 'hive_hostname').value = globals.findProperty('name', 'hive_ambari_host').value;
            hiveDbType.value = 'mysql';
            hiveJdbcDriver.value = 'com.mysql.jdbc.Driver';
          }
          globals = globals.without(globals.findProperty('name', 'hive_existing_mysql_host'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_mysql_database'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_oracle_host'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_oracle_database'));
        } else if (hiveDb.value === 'Existing MySQL Database'){
          globals.findProperty('name', 'hive_hostname').value = globals.findProperty('name', 'hive_existing_mysql_host').value;
          hiveDbType.value = 'mysql';
          hiveJdbcDriver.value = 'com.mysql.jdbc.Driver';
          globals = globals.without(globals.findProperty('name', 'hive_ambari_host'));
          globals = globals.without(globals.findProperty('name', 'hive_ambari_database'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_oracle_host'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_oracle_database'));
        } else { //existing oracle database
          globals.findProperty('name', 'hive_hostname').value = globals.findProperty('name', 'hive_existing_oracle_host').value;
          hiveDbType.value = 'oracle';
          hiveJdbcDriver.value = 'oracle.jdbc.driver.OracleDriver';
          globals = globals.without(globals.findProperty('name', 'hive_ambari_host'));
          globals = globals.without(globals.findProperty('name', 'hive_ambari_database'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_mysql_host'));
          globals = globals.without(globals.findProperty('name', 'hive_existing_mysql_database'));
        }
        globals.push(hiveDbType);
        globals.push(hiveJdbcDriver);
      }

      if (globals.someProperty('name', 'oozie_database')) {
        var oozieDb = globals.findProperty('name', 'oozie_database');
        var oozieDbType = {name:'oozie_database_type'};
        var oozieJdbcDriver = {name: 'oozie_jdbc_driver'};

        if (oozieDb.value === 'New Derby Database') {
          globals.findProperty('name', 'oozie_hostname').value = globals.findProperty('name', 'oozie_ambari_host').value;
          oozieDbType.value = 'derby';
          oozieJdbcDriver.value = 'org.apache.derby.jdbc.EmbeddedDriver';
          globals = globals.without(globals.findProperty('name', 'oozie_ambari_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_ambari_database'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_mysql_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_mysql_database'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_oracle_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_oracle_database'));
        } else if (oozieDb.value === 'Existing MySQL Database') {
          globals.findProperty('name', 'oozie_hostname').value = globals.findProperty('name', 'oozie_existing_mysql_host').value;
          oozieDbType.value = 'mysql';
          oozieJdbcDriver.value = 'com.mysql.jdbc.Driver';
          globals = globals.without(globals.findProperty('name', 'oozie_ambari_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_ambari_database'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_oracle_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_oracle_database'));
          globals = globals.without(globals.findProperty('name', 'oozie_derby_database'));
        } else { // existing oracle database
          globals.findProperty('name', 'oozie_hostname').value = globals.findProperty('name', 'oozie_existing_oracle_host').value;
          oozieDbType.value = 'oracle';
          oozieJdbcDriver.value = 'oracle.jdbc.driver.OracleDriver';
          globals = globals.without(globals.findProperty('name', 'oozie_ambari_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_ambari_database'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_mysql_host'));
          globals = globals.without(globals.findProperty('name', 'oozie_existing_mysql_database'));
          globals = globals.without(globals.findProperty('name', 'oozie_derby_database'));
        }
        globals.push(oozieDbType);
        globals.push(oozieJdbcDriver);
      }

      this.set('globals', globals);
    },

    loadConfigs: function () {
      //storedConfigs contains custom configs as well
      var serviceConfigProperties = this.get('content.serviceConfigProperties').filterProperty('id', 'site property');
      serviceConfigProperties.forEach(function(_config){
        _config.value = (typeof _config.value === "boolean") ? _config.value.toString() : _config.value;
      });
      var storedConfigs = serviceConfigProperties.filterProperty('value');
      var uiConfigs = this.loadUiSideConfigs();
      this.set('configs', storedConfigs.concat(uiConfigs));
    },

    loadUiSideConfigs: function () {
      var uiConfig = [];
      var configs = this.get('configMapping').filterProperty('foreignKey', null);
      this.addDynamicProperties(configs);
      configs.forEach(function (_config) {
        var valueWithOverrides = this.getGlobConfigValueWithOverrides(_config.templateName, _config.value, _config.name);
        uiConfig.pushObject({
          "id": "site property",
          "name": _config.name,
          "value": valueWithOverrides.value,
          "filename": _config.filename,
          "overrides": valueWithOverrides.overrides
        });
      }, this);
      var dependentConfig = this.get('configMapping').filterProperty('foreignKey');
      dependentConfig.forEach(function (_config) {
        App.config.setConfigValue(uiConfig, this.get('content.serviceConfigProperties'), _config, this.get('globals'));
        uiConfig.pushObject({
          "id": "site property",
          "name": _config._name || _config.name,
          "value": _config.value,
          "filename": _config.filename
        });
      }, this);
      return uiConfig;
    },

    addDynamicProperties: function(configs) {
      var templetonHiveProperty =  this.get('content.serviceConfigProperties').someProperty('name', 'templeton.hive.properties');
      if (!templetonHiveProperty) {
        configs.pushObject({
          "name": "templeton.hive.properties",
          "templateName": ["hivemetastore_host"],
          "foreignKey": null,
          "value": "hive.metastore.local=false,hive.metastore.uris=thrift://<templateName[0]>:9083,hive.metastore.sasl.enabled=yes,hive.metastore.execute.setugi=true,hive.metastore.warehouse.dir=/apps/hive/warehouse",
          "filename": "webhcat-site.xml"
        });
      }
    },

    getRegisteredHosts: function () {
      var allHosts = this.get('content.hosts');
      var hosts = [];
      for (var hostName in allHosts) {
        if (allHosts[hostName].bootStatus == 'REGISTERED') {
          allHosts[hostName].hostName = allHosts[hostName].name;
          hosts.pushObject(allHosts[hostName]);
        }
      }
      return hosts;
    },

    /**
     * Set all site property that are derived from other puppet-variable
     * @return {
     *   value: '...',
     *   overrides: {
     *    'value1': [h1, h2],
     *    'value2': [h3]
     *   }
     * }
     */

    getGlobConfigValueWithOverrides: function (templateName, expression, name) {
      var express = expression.match(/<(.*?)>/g);
      var value = expression;
      if (express == null) {
        return { value : expression, overrides: []};      // if site property do not map any global property then return the value
      }
      var overrideHostToValue = {};
      express.forEach(function (_express) {
        //console.log("The value of template is: " + _express);
        var index = parseInt(_express.match(/\[([\d]*)(?=\])/)[1]);
        if (this.get('globals').someProperty('name', templateName[index])) {
          //console.log("The name of the variable is: " + this.get('content.serviceConfigProperties').findProperty('name', templateName[index]).name);
          var globalObj = this.get('globals').findProperty('name', templateName[index]);
          var globValue = globalObj.value;
          // Hack for templeton.zookeeper.hosts
          var preReplaceValue = null;
          if (value !== null) {   // if the property depends on more than one template name like <templateName[0]>/<templateName[1]> then don't proceed to the next if the prior is null or not found in the global configs
            preReplaceValue = value;
            value = this._replaceConfigValues(name, _express, value, globValue);
          }
          if(globalObj.overrides!=null){
            globalObj.overrides.forEach(function(override){
              var ov = override.value;
              var hostsArray = override.hosts;
              hostsArray.forEach(function(host){
                if(!(host in overrideHostToValue)){
                  overrideHostToValue[host] = this._replaceConfigValues(name, _express, preReplaceValue, ov);
                }else{
                  overrideHostToValue[host] = this._replaceConfigValues(name, _express, overrideHostToValue[host], ov);
                }
              }, this);
            }, this);
          }
        } else {
          /*
           console.log("ERROR: The variable name is: " + templateName[index]);
           console.log("ERROR: mapped config from configMapping file has no corresponding variable in " +
           "content.serviceConfigProperties. Two possible reasons for the error could be: 1) The service is not selected. " +
           "and/OR 2) The service_config metadata file has no corresponding global var for the site property variable");
           */
          value = null;
        }
      }, this);

      var valueWithOverrides = {
          value: value,
          overrides: []
      };
      var overrideValueToHostMap = {};
      if(!jQuery.isEmptyObject(overrideHostToValue)){
        for(var host in overrideHostToValue){
          var hostVal = overrideHostToValue[host];
          if(!(hostVal in overrideValueToHostMap)){
            overrideValueToHostMap[hostVal] = [];
          }
          overrideValueToHostMap[hostVal].push(host);
        }
      }
      for(var val in overrideValueToHostMap){
        valueWithOverrides.overrides.push({
          value: val,
          hosts: overrideValueToHostMap[val]
        });
      }
      return valueWithOverrides;
    },

    _replaceConfigValues: function (name, express, value, globValue) {
      if (name === "templeton.zookeeper.hosts" || name === 'hbase.zookeeper.quorum') {
        // globValue is an array of ZooKeeper Server hosts
        var zooKeeperPort = '2181';
        if (name === "templeton.zookeeper.hosts") {
          var zooKeeperServers = globValue.map(function (item) {
            return item + ':' + zooKeeperPort;
          }).join(',');
          value = value.replace(express, zooKeeperServers);
        } else {
          value = value.replace(express, globValue.join(','));
        }
      } else {
        value = value.replace(express, globValue);
      }
      return value;
    },

    /**
     * Load all info about cluster to <code>clusterInfo</code> variable
     */
    loadClusterInfo: function () {

      //Admin name
      var admin = this.rawContent.findProperty('config_name', 'Admin');
      admin.config_value = App.db.getLoginName();
      console.log("STEP8: the value of content cluster name: " + App.db.getLoginName());
      if (admin.config_value) {
        this.get('clusterInfo').pushObject(Ember.Object.create(admin));
      }

      // cluster name
      var cluster = this.rawContent.findProperty('config_name', 'cluster');
      cluster.config_value = this.get('content.cluster.name');
      console.log("STEP8: the value of content cluster name: " + this.get('content.cluster.name'));
      this.get('clusterInfo').pushObject(Ember.Object.create(cluster));

      //hosts
      var masterHosts = this.get('content.masterComponentHosts').mapProperty('hostName').uniq();
      var slaveHosts = this.get('content.slaveComponentHosts');

      var hostObj = [];
      slaveHosts.forEach(function (_hosts) {
        hostObj = hostObj.concat(_hosts.hosts);
      }, this);

      slaveHosts = hostObj.mapProperty('hostName').uniq();

      var componentHosts = masterHosts.concat(slaveHosts).uniq();
      var totalHosts = App.Host.find().mapProperty('hostName').concat(componentHosts).uniq();
      var newHostsCount = totalHosts.length - App.Host.find().content.length;
      this.set('totalHosts', totalHosts);
      var totalHostsObj = this.rawContent.findProperty('config_name', 'hosts');
      totalHostsObj.config_value = totalHosts.length + ' (' + newHostsCount + ' new)';
      this.get('clusterInfo').pushObject(Ember.Object.create(totalHostsObj));

      //repo
      var repoOption = this.get('content.installOptions.localRepo');
      var repoObj = this.rawContent.findProperty('config_name', 'Repo');
      if (repoOption) {
        repoObj.config_value = 'Yes';
      } else {
        repoObj.config_value = 'No';
      }
      this.get('clusterInfo').pushObject(Ember.Object.create(repoObj));
    },


    /**
     * Load all info about services to <code>services</code> variable
     */
    loadServices: function () {
      var selectedServices = this.get('selectedServices');
      this.set('services', selectedServices.mapProperty('serviceName'));

      selectedServices.forEach(function (_service) {
        console.log('INFO: step8: Name of the service from getService function: ' + _service.serviceName);
        var reviewService = this.rawContent.findProperty('config_name', 'services');
        var serviceObj = reviewService.config_value.findProperty('service_name', _service.serviceName);

        if (serviceObj) {
          switch (serviceObj.service_name) {
            case 'HDFS':
              this.loadHDFS(serviceObj);
              break;
            case 'HCFS':
              this.loadHCFS(serviceObj);
              break;
            case 'MAPREDUCE':
              this.loadMapReduce(serviceObj);
              break;
            case 'MAPREDUCE2':
              this.loadMapReduce2(serviceObj);
              break;
            case 'YARN':
              this.loadYARN(serviceObj);
              break;
            case 'HIVE':
              this.loadHive(serviceObj);
              break;
            case 'HBASE':
              this.loadHbase(serviceObj);
              break;
            case 'ZOOKEEPER':
              this.loadZk(serviceObj);
              break;
            case 'OOZIE':
              this.loadOozie(serviceObj);
              break;
            case 'NAGIOS':
              this.loadNagios(serviceObj);
              break;
            case 'GANGLIA':
              this.loadGanglia(serviceObj);
              break;
            case 'HUE':
              this.loadHue(serviceObj);
              break;
            /* case 'TEZ':
             break;
             case 'PIG':
             this.loadPig(serviceObj);
             break;
             case 'SQOOP':
             this.loadSqoop(serviceObj);
             break;
             */
            case 'HCATALOG':
              break;
            default:
          }
        }
      }, this);
    },

    /**
     * load all info about HDFS service
     * @param hdfsObj
     */
    loadHDFS: function (hdfsObj) {
      hdfsObj.get('service_components').forEach(function (_component) {
        switch (_component.get('display_name')) {
          case 'NameNode':
            this.loadNnValue(_component);
            break;
          case 'SecondaryNameNode':
            this.loadSnnValue(_component);
            break;
          case 'DataNodes':
            this.loadDnValue(_component);
            break;
          default:
        }
      }, this);
      //var
      this.get('services').pushObject(hdfsObj);
    },
    
    /**
     * load all info about HCFS service
     * @param hcfsObj
     */
    loadHCFS: function (hcfsObj) {
      hcfsObj.get('service_components').forEach(function (_component) {
        switch (_component.get('display_name')) {
          case 'HCFS Client':
            this.loadHCFSClientValue(_component);
            break;
          default:
        }
      }, this);
      this.get('services').pushObject(hcfsObj);
    },
    
    loadHCFSClientValue: function (hcfsComponent) {
      var hcfsClientHosts = this.get('content.slaveComponentHosts').findProperty('displayName', 'Client');
      var totalHCFSHosts = hcfsClientHosts.hosts.length;
      hcfsComponent.set('component_value', totalHCFSHosts + ' hosts');  
    },

    loadNnValue: function (nnComponent) {
      var nnHostName = this.get('content.masterComponentHosts').findProperty('display_name', nnComponent.display_name);
      nnComponent.set('component_value', nnHostName.hostName);
    },

    loadSnnValue: function (snnComponent) {
      var snnHostName = this.get('content.masterComponentHosts').findProperty('display_name', 'SNameNode');
      snnComponent.set('component_value', snnHostName.hostName);
    },

    loadDnValue: function (dnComponent) {
      var dnHosts = this.get('content.slaveComponentHosts').findProperty('displayName', 'DataNode');
      var totalDnHosts = dnHosts.hosts.length;
      /* var totalGroups = this.get('slaveComponentConfig.components').findProperty('componentName', 'DATANODE').groups.length;
       var groupLabel;
       if (totalGroups == 1) {
       groupLabel = 'group';
       } else {
       groupLabel = 'groups';
       }
       */
      dnComponent.set('component_value', totalDnHosts + Em.I18n.t('installer.step8.hosts'));
    },


    /**
     * Load all info about mapReduce service
     * @param mrObj
     */
    loadMapReduce: function (mrObj) {
      mrObj.get('service_components').forEach(function (_component) {
        switch (_component.get('display_name')) {
          case 'JobTracker':
            this.loadJtValue(_component);
            break;
          case 'TaskTrackers':
            this.loadTtValue(_component);
            break;
          default:
        }
      }, this);
      this.get('services').pushObject(mrObj);
    },

    loadMapReduce2: function(mrObj){
      mrObj.get('service_components').forEach(function (_component) {
        switch (_component.get('display_name')) {
          case 'History Server':
            _component.set('component_value', this.get('content.masterComponentHosts').findProperty('component', 'HISTORYSERVER').hostName);
            break;
        }
      }, this);
      this.get('services').pushObject(mrObj);
    },

    loadYARN: function(mrObj){
      mrObj.get('service_components').forEach(function (_component) {
        switch (_component.get('display_name')) {
          case 'Node Manager':
            this.loadNMValue(_component);
            break;
          case 'Resource Manager':
            _component.set('component_value', this.get('content.masterComponentHosts').findProperty('component', 'RESOURCEMANAGER').hostName);
            break;
        }
      }, this);
      this.get('services').pushObject(mrObj);
    },

    loadNMValue: function (nmComponent) {
      var nmHosts = this.get('content.slaveComponentHosts').findProperty('componentName', 'NODEMANAGER');
      nmComponent.set('component_value', nmHosts.hosts.length + Em.I18n.t('installer.step8.hosts'));
    },

    loadJtValue: function (jtComponent) {
      var jtHostName = this.get('content.masterComponentHosts').findProperty('display_name', jtComponent.display_name);
      jtComponent.set('component_value', jtHostName.hostName);
    },

    loadTtValue: function (ttComponent) {
      var ttHosts = this.get('content.slaveComponentHosts').findProperty('displayName', 'TaskTracker');
      var totalTtHosts = ttHosts.hosts.length;
      /* var totalGroups = this.get('slaveComponentConfig.components').findProperty('componentName', 'TASKTRACKER').groups.length;
       var groupLabel;
       if (totalGroups == 1) {
       groupLabel = 'group';
       } else {
       groupLabel = 'groups';
       }
       */
      ttComponent.set('component_value', totalTtHosts + Em.I18n.t('installer.step8.hosts'));
    },

    /**
     * Load all info about Hive service
     * @param hiveObj
     */
    loadHive: function (hiveObj) {
      hiveObj.get('service_components').forEach(function (_component) {
        switch (_component.get('display_name')) {
          case 'Hive Metastore':
            this.loadHiveMetaStoreValue(_component);
            break;
          case 'Database':
            this.loadHiveDbValue(_component);
            break;
          default:
        }
      }, this);
      this.get('services').pushObject(hiveObj);

    },

    loadHiveMetaStoreValue: function (metaStoreComponent) {
      var hiveHostName = this.get('content.masterComponentHosts').findProperty('display_name', 'HiveServer2');
      metaStoreComponent.set('component_value', hiveHostName.hostName);
    },

    loadHiveDbValue: function (dbComponent) {
      var hiveDb = App.db.getServiceConfigProperties().findProperty('name', 'hive_database');
      if (hiveDb.value === 'New MySQL Database') {
        dbComponent.set('component_value', 'MySQL (New Database)');
      } else if(hiveDb.value === 'Existing MySQL Database'){
        var db = App.db.getServiceConfigProperties().findProperty('name', 'hive_existing_mysql_database');
        dbComponent.set('component_value', db.value + ' (' + hiveDb.value + ')');
      } else { // existing oracle database
        var db = App.db.getServiceConfigProperties().findProperty('name', 'hive_existing_oracle_database');
        dbComponent.set('component_value', db.value + ' (' + hiveDb.value + ')');
      }
    },

    /**
     * Load all info about Hbase
     * @param hbaseObj
     */
    loadHbase: function (hbaseObj) {
      hbaseObj.service_components.forEach(function (_component) {
        switch (_component.display_name) {
          case 'Master':
            this.loadMasterValue(_component);
            break;
          case 'RegionServers':
            this.loadRegionServerValue(_component);
            break;
          default:
        }
      }, this);
      this.get('services').pushObject(hbaseObj);
    },

    loadMasterValue: function (hbaseMaster) {
      var hbaseHostName = this.get('content.masterComponentHosts').filterProperty('display_name', 'HBase Master');
      if (hbaseHostName.length == 1) {
        hbaseMaster.set('component_value', hbaseHostName[0].hostName);
      } else {
        hbaseMaster.set('component_value', hbaseHostName[0].hostName + Em.I18n.t('installer.step8.other').format(hbaseHostName.length - 1));
      }
    },

    loadRegionServerValue: function (rsComponent) {
      var rsHosts = this.get('content.slaveComponentHosts').findProperty('displayName', 'RegionServer');
      var totalRsHosts = rsHosts.hosts.length;
      /* var totalGroups = this.get('slaveComponentConfig.components').findProperty('componentName', 'HBASE_REGIONSERVER').groups.length;
       var groupLabel;
       if (totalGroups == 1) {
       groupLabel = 'group';
       } else {
       groupLabel = 'groups';
       } */
      rsComponent.set('component_value', totalRsHosts + Em.I18n.t('installer.step8.hosts'));
    },

    /**
     * Load all info about ZooKeeper service
     * @param zkObj
     */
    loadZk: function (zkObj) {
      zkObj.get('service_components').forEach(function (_component) {
        switch (_component.get('display_name')) {
          case 'Servers':
            this.loadZkServerValue(_component);
            break;
          default:
        }
      }, this);
      this.get('services').pushObject(zkObj);
    },

    loadZkServerValue: function (serverComponent) {
      var zkHostNames = this.get('content.masterComponentHosts').filterProperty('display_name', 'ZooKeeper').length;
      var hostSuffix;
      if (zkHostNames === 1) {
        hostSuffix = Em.I18n.t('installer.step8.host');
      } else {
        hostSuffix = Em.I18n.t('installer.step8.hosts');
      }
      serverComponent.set('component_value', zkHostNames + ' ' + hostSuffix);
    },

    /**
     * Load all info about Hue services
     * @param hueObj
     */
    loadHue: function (hueObj) {
      hueObj.get('service_components').forEach(function (_component) {
        switch (_component.get('display_name')) {
          case 'Server':
            this.loadHueServerValue(_component);
            break;
          default:
        }
      }, this);
      this.get('services').pushObject(hueObj);
    },

    loadHueServerValue: function (hueServer) {
      var hueServerName = this.get('content.masterComponentHosts').findProperty('display_name', 'Hue Server');
      hueServer.set('component_value', hueServerName.hostName);
    },

    /**
     * Load all info about Oozie services
     * @param oozieObj
     */
    loadOozie: function (oozieObj) {
      oozieObj.get('service_components').forEach(function (_component) {
        switch (_component.get('display_name')) {
          case 'Server':
            this.loadOozieServerValue(_component);
            break;
          case 'Database':
            // TODO: uncomment when ready to integrate with Oozie Database other than Derby
            this.loadOozieDbValue(_component);
            break;
          default:
        }
      }, this);
      this.get('services').pushObject(oozieObj);
    },

    loadOozieServerValue: function (oozieServer) {
      var oozieServerName = this.get('content.masterComponentHosts').findProperty('display_name', 'Oozie Server');
      oozieServer.set('component_value', oozieServerName.hostName);
    },

    loadOozieDbValue: function (dbComponent) {
      var oozieDb = App.db.getServiceConfigProperties().findProperty('name', 'oozie_database');
      if (oozieDb.value === 'New Derby Database'){
        var db = App.db.getServiceConfigProperties().findProperty('name', 'oozie_derby_database');
        dbComponent.set('component_value', db.value + ' (' + oozieDb.value + ')');
      }/* else if (oozieDb.value === 'New MySQL Database') {
        dbComponent.set('component_value', 'MySQL (New Database)');
      } */else if(oozieDb.value === 'Existing MySQL Database'){
        var db = App.db.getServiceConfigProperties().findProperty('name', 'oozie_existing_mysql_database');
        dbComponent.set('component_value', db.value + ' (' + oozieDb.value + ')');
      } else { // existing oracle database
        var db = App.db.getServiceConfigProperties().findProperty('name', 'oozie_existing_oracle_database');
        dbComponent.set('component_value', db.value + ' (' + oozieDb.value + ')');
      }

    },


    /**
     * Load all info about Nagios service
     * @param nagiosObj
     */
    loadNagios: function (nagiosObj) {
      nagiosObj.service_components.forEach(function (_component) {
        switch (_component.display_name) {
          case 'Server':
            this.loadNagiosServerValue(_component);
            break;
          case 'Administrator':
            this.loadNagiosAdminValue(_component);
            break;
          default:
        }
      }, this);
      this.get('services').pushObject(nagiosObj);
    },

    loadNagiosServerValue: function (nagiosServer) {
      var nagiosServerName = this.get('content.masterComponentHosts').findProperty('display_name', 'Nagios Server');
      nagiosServer.set('component_value', nagiosServerName.hostName);
    },

    loadNagiosAdminValue: function (nagiosAdmin) {
      var config = this.get('content.serviceConfigProperties');
      var adminLoginName = config.findProperty('name', 'nagios_web_login');
      var adminEmail = config.findProperty('name', 'nagios_contact');
      nagiosAdmin.set('component_value', adminLoginName.value + ' / (' + adminEmail.value + ')');
    },

    /**
     * Load all info about ganglia
     * @param gangliaObj
     */
    loadGanglia: function (gangliaObj) {
      gangliaObj.get('service_components').forEach(function (_component) {
        switch (_component.get('display_name')) {
          case 'Server':
            this.loadGangliaServerValue(_component);
            break;
          default:
        }
      }, this);
      this.get('services').pushObject(gangliaObj);
    },

    loadGangliaServerValue: function (gangliaServer) {
      var gangliaServerName = this.get('content.masterComponentHosts').findProperty('display_name', 'Ganglia Collector');
      gangliaServer.set('component_value', gangliaServerName.hostName);
    },

    loadSqoop: function (sqoopObj) {
      this.get('services').pushObject(sqoopObj);
    },

    loadPig: function (pigObj) {
      this.get('services').pushObject(pigObj);
    },

    /**
     * Onclick handler for <code>next</code> button
     */
    submit: function () {
      if (this.get('isSubmitDisabled')) {
        return;
      }
      if ((this.get('content.controllerName') == 'addHostController') && this.get('securityEnabled')) {
        var self = this;
        App.showConfirmationPopup(function() {
          self.submitProceed();
        }, Em.I18n.t('installer.step8.securityConfirmationPopupBody'));
      }
      else {
        this.submitProceed();
      }
    },

    submitProceed: function() {
      this.set('isSubmitDisabled', true);

      // checkpoint the cluster status on the server so that the user can resume from where they left off
      switch (this.get('content.controllerName')) {
        case 'installerController':
          App.clusterStatus.setClusterStatus({
            clusterName: this.get('clusterName'),
            clusterState: 'CLUSTER_DEPLOY_PREP_2',
            wizardControllerName: this.get('content.controllerName'),
            localdb: App.db.data
          });
          break;
        case 'addHostController':
          App.clusterStatus.setClusterStatus({
            clusterName: this.get('clusterName'),
            clusterState: 'ADD_HOSTS_DEPLOY_PREP_2',
            wizardControllerName: this.get('content.controllerName'),
            localdb: App.db.data
          });
          break;
        case 'addServiceController':
          App.clusterStatus.setClusterStatus({
            clusterName: this.get('clusterName'),
            clusterState: 'ADD_SERVICES_DEPLOY_PREP_2',
            wizardControllerName: this.get('content.controllerName'),
            localdb: App.db.data
          });
          break;
        default:
          break;
      }
      // delete any existing clusters to start from a clean slate
      // before creating a new cluster in install wizard
      // TODO: modify for multi-cluster support
      if (this.get('content.controllerName') == 'installerController' && (!App.testMode)) {
        var clusterNames = this.getExistingClusterNames();
        this.deleteClusters(clusterNames);
      }
      this.setLocalRepositories();
      this.createCluster();
      this.createSelectedServices();
      this.createConfigurations();
      this.createComponents();
      this.registerHostsToCluster();
      this.createAllHostComponents();
      this.createHostOverrideConfigurations();

      this.ajaxQueueFinished = function () {
        console.log('everything is loaded');
        App.router.send('next');
      };
      this.doNextAjaxCall();
    },

    /**
     * Used in progress bar
     */
    ajaxQueueLength: function () {
      return this.get('ajaxQueue').length;
    }.property('ajaxQueue.length'),

    /**
     * Used in progress bar
     */
    ajaxQueueLeft: 0,

    setAmbariUIDb: function () {
      var dbContent = this.get('content.slaveGroupProperties');
      var slaveComponentConfig = this.get("slaveComponentConfig");
      this.persistKeyValues(slaveComponentConfig.version, dbContent);
      this.persistKeyValues('current_version', slaveComponentConfig.version);
    },

    persistKeyValues: function (key, value) {

      var str = "{ '" + key + "' : '" + JSON.stringify(value) + "'}";
      var obj = eval("(" + str + ")");

      this.ajax({
        type: "POST",
        url: App.apiPrefix + '/persist',
        data: JSON.stringify(obj),
        beforeSend: function () {
          console.log('BeforeSend: persistKeyValues', obj);
        }
      });
    },

    clusterName: function () {
      return this.get('content.cluster.name');
    }.property('content.cluster.name'),

    clusterNames: [],

    // returns an array of existing cluster names.
    // returns an empty array if there are no existing clusters.
    getExistingClusterNames: function () {
      var url = App.apiPrefix + '/clusters';

      App.ajax.send({
        name: 'wizard.step8.existing_cluster_names',
        sender: this,
        success: 'getExistingClusterNamesSuccessCallBack',
        error: 'getExistingClusterNamesErrorCallback'
      });

      return this.get('clusterNames');
    },

    getExistingClusterNamesSuccessCallBack: function (data) {
      var clusterNames = data.items.mapProperty('Clusters.cluster_name');
      console.log("Got existing cluster names: " + clusterNames);
      this.set('clusterNames', clusterNames);
    },

    getExistingClusterNamesErrorCallback: function () {
      console.log("Failed to get existing cluster names");
      this.set('clusterNames', []);
    },

    deleteClusters: function (clusterNames) {
      clusterNames.forEach(function (clusterName) {
        App.ajax.send({
          name: 'wizard.step8.delete_cluster',
          sender: this,
          data: {
            name: clusterName
          },
          success: 'deleteClustersSuccessCallback',
          error: 'deleteClustersErrorCallback'
        });
      }, this);
    },

    deleteClustersSuccessCallback: function(data, opt, params) {
      console.log('DELETE cluster ' + params.name + ' succeeded');
    },
    deleteClustersErrorCallback: function(request, ajaxOptions, error, opt) {
      console.log('DELETE cluster failed');
    },
    

    /**
     * Updates local repositories for the Ambari server.
     */
    setLocalRepositories: function () {
      if (this.get('content.controllerName') !== 'installerController' || !App.supports.localRepositories) {
        return false;
      }
      var self = this;
      var apiUrl = App.get('stack2VersionURL');
      var stacks = this.get('content.stacks');
      stacks.forEach(function (stack) {
        stack.operatingSystems.forEach(function (os) {
          if (os.baseUrl !== os.originalBaseUrl) {
            console.log("Updating local repository URL from " + os.originalBaseUrl + " -> " + os.baseUrl + ". ", os);
            var url = App.apiPrefix + apiUrl + "/operatingSystems/" + os.osType + "/repositories/" + stack.name;
            self.ajax({
              type: 'PUT',
              url: url,
              data: JSON.stringify({
                "Repositories": {
                  "base_url": os.baseUrl
                }
              }),
              beforeSend: function () {
                console.log("BeforeSend: setLocalRepositories PUT to ", url);
              }
            });
          }
        });
      });
    },


    /**
     *  The following create* functions are called upon submitting Step 8.
     */

    createCluster: function () {

      if (this.get('content.controllerName') !== 'installerController') {
        return false;
      }

      var clusterName = this.get('clusterName');
      var url = App.apiPrefix + '/clusters/' + clusterName;

      var stackVersion = (this.get('content.installOptions.localRepo')) ? App.defaultLocalStackVersion : App.currentStackVersion;

      this.ajax({
        type: 'POST',
        url: url,
        data: JSON.stringify({ "Clusters": {"version": stackVersion }}),
        beforeSend: function () {
          console.log("BeforeSend: createCluster for " + clusterName);
        }
      });

    },

    createSelectedServices: function () {

      var url = App.apiPrefix + '/clusters/' + this.get('clusterName') + '/services';
      var data = this.createServiceData();
      var httpMethod = 'POST';

      if (!data.length) {
        return;
      }

      this.ajax({
        type: httpMethod,
        url: url,
        data: JSON.stringify(data),
        beforeSend: function () {
          console.log('BeforeSend: createSelectedServices ', data);
        }
      });
    },

    createServiceData: function () {
      var services = this.get('selectedServices').mapProperty('serviceName');
      var data = [];
      services.forEach(function (_service) {
        data.pushObject({"ServiceInfo": { "service_name": _service }});
      }, this);
      return data;
    },

    createComponents: function () {

      var serviceComponents = require('data/service_components');
      var services = this.get('selectedServices').mapProperty('serviceName');
      services.forEach(function (_service) {
        var components = serviceComponents.filterProperty('service_name', _service);
        var componentsData = components.map(function (_component) {
          return { "ServiceComponentInfo": { "component_name": _component.component_name } };
        });

        // Service must be specified in terms of a query for creating multiple components at the same time.
        // See AMBARI-1018.
        var url = App.apiPrefix + '/clusters/' + this.get('clusterName') + '/services?ServiceInfo/service_name=' + _service;
        var data = {
          "components": componentsData
        }

        this.ajax({
          type: 'POST',
          url: url,
          data: JSON.stringify(data),
          beforeSend: function () {
            console.log('BeforeSend: createComponents for ' + _service, componentsData);
          }
        });
      }, this);

    },

    registerHostsToCluster: function () {

      var url = App.apiPrefix + '/clusters/' + this.get('clusterName') + '/hosts';
      var data = this.createRegisterHostData();

      if (data.length == 0) {
        return;
      }

      this.ajax({
        type: 'POST',
        url: url,
        data: JSON.stringify(data),
        beforeSend: function () {
          console.log('BeforeSend: registerHostsToCluster', data);
        }
      });
    },

    createRegisterHostData: function () {
      var hosts = this.getRegisteredHosts().filterProperty('isInstalled', false);
      if (!hosts.length) {
        return [];
      }
      return hosts.map(function (host) {
        return {"Hosts": { "host_name": host.hostName}};
      });
    },

    // TODO: review the code for add hosts / add services scenarios...
    createAllHostComponents: function () {

      var masterHosts = this.get('content.masterComponentHosts');
      var slaveHosts = this.get('content.slaveComponentHosts');
      var clients = this.get('content.clients');

      // note: masterHosts has 'component' vs slaveHosts has 'componentName'
      var masterComponents = masterHosts.mapProperty('component').uniq();

      masterComponents.forEach(function (component) {
        var hostNames = masterHosts.filterProperty('component', component).filterProperty('isInstalled', false).mapProperty('hostName');
        this.registerHostsToComponent(hostNames, component);
      }, this);

      slaveHosts.forEach(function (_slave) {
        if (_slave.componentName !== 'CLIENT') {
          var hostNames = _slave.hosts.filterProperty('isInstalled', false).mapProperty('hostName');
          this.registerHostsToComponent(hostNames, _slave.componentName);
        } else {
          clients.forEach(function (_client) {

            var hostNames = _slave.hosts.mapProperty('hostName');
            switch (_client.component_name) {
              case 'HDFS_CLIENT':
                // install HDFS_CLIENT on HBASE_MASTER, HBASE_REGIONSERVER, and WEBHCAT_SERVER hosts
                masterHosts.filterProperty('component', 'HBASE_MASTER').filterProperty('isInstalled', false).forEach(function (_masterHost) {
                  hostNames.pushObject(_masterHost.hostName);
                }, this);
                masterHosts.filterProperty('component', 'HBASE_REGIONSERVER').filterProperty('isInstalled', false).forEach(function (_masterHost) {
                  hostNames.pushObject(_masterHost.hostName);
                }, this);
                masterHosts.filterProperty('component', 'WEBHCAT_SERVER').filterProperty('isInstalled', false).forEach(function (_masterHost) {
                  hostNames.pushObject(_masterHost.hostName);
                }, this);
                break;
              case 'MAPREDUCE_CLIENT':
                // install MAPREDUCE_CLIENT on HIVE_SERVER, OOZIE_SERVER, NAGIOS_SERVER, and WEBHCAT_SERVER hosts
                masterHosts.filterProperty('component', 'HIVE_SERVER').filterProperty('isInstalled', false).forEach(function (_masterHost) {
                  hostNames.pushObject(_masterHost.hostName);
                }, this);
                masterHosts.filterProperty('component', 'OOZIE_SERVER').filterProperty('isInstalled', false).forEach(function (_masterHost) {
                  hostNames.pushObject(_masterHost.hostName);
                }, this);
                masterHosts.filterProperty('component', 'NAGIOS_SERVER').filterProperty('isInstalled', false).forEach(function (_masterHost) {
                  hostNames.pushObject(_masterHost.hostName);
                }, this);
                masterHosts.filterProperty('component', 'WEBHCAT_SERVER').filterProperty('isInstalled', false).forEach(function (_masterHost) {
                  hostNames.pushObject(_masterHost.hostName);
                }, this);
                break;
              case 'OOZIE_CLIENT':
                // install OOZIE_CLIENT on NAGIOS_SERVER host
                masterHosts.filterProperty('component', 'NAGIOS_SERVER').filterProperty('isInstalled', false).forEach(function (_masterHost) {
                  hostNames.pushObject(_masterHost.hostName);
                }, this);
                break;
              case 'ZOOKEEPER_CLIENT':
                // install ZOOKEEPER_CLIENT on WEBHCAT_SERVER host
                masterHosts.filterProperty('component', 'WEBHCAT_SERVER').filterProperty('isInstalled', false).forEach(function (_masterHost) {
                  hostNames.pushObject(_masterHost.hostName);
                }, this);
                break;

              case 'HIVE_CLIENT':
                //install HIVE client on NAGIOS_SERVER host
                masterHosts.filterProperty('component', 'NAGIOS_SERVER').filterProperty('isInstalled', false).forEach(function (_masterHost) {
                  hostNames.pushObject(_masterHost.hostName);
                }, this);
                masterHosts.filterProperty('component', 'HIVE_SERVER').filterProperty('isInstalled', false).forEach(function (_masterHost) {
                  hostNames.pushObject(_masterHost.hostName);
                }, this);
                break;

              case 'HCAT':
                // install HCAT (client) on NAGIOS_SERVER host
                masterHosts.filterProperty('component', 'NAGIOS_SERVER').filterProperty('isInstalled', false).forEach(function (_masterHost) {
                  hostNames.pushObject(_masterHost.hostName);
                }, this);
                break;
            }
            hostNames = hostNames.uniq();

            if (_client.isInstalled) {
              //check whether clients are already installed on selected master hosts!!!
              var installedHosts = _slave.hosts.filterProperty('isInstalled', true).mapProperty('hostName');
              installedHosts.forEach(function (host) {
                if (hostNames.contains(host)) {
                  hostNames.splice(hostNames.indexOf(host), 1);
                }
              }, this);
            }

            this.registerHostsToComponent(hostNames, _client.component_name);

          }, this);
        }
      }, this);

      // add Ganglia Monitor (Slave) to all hosts if Ganglia service is selected
      var gangliaService = this.get('content.services').filterProperty('isSelected', true).findProperty('serviceName', 'GANGLIA');
      if (gangliaService) {
        var hosts = this.getRegisteredHosts();
        if (gangliaService.get('isInstalled')) {
          hosts = hosts.filterProperty('isInstalled', false);
        }
        if (hosts.length) {
          this.registerHostsToComponent(hosts.mapProperty('hostName'), 'GANGLIA_MONITOR');
        }
      }
      // add MySQL Server if Hive is selected
      var hiveService = this.get('content.services').filterProperty('isSelected', true).filterProperty('isInstalled', false).findProperty('serviceName', 'HIVE');
      if (hiveService) {
        var hiveDb = this.get('content.serviceConfigProperties').findProperty('name', 'hive_database');
          if(hiveDb.value == "New MySQL Database") {
        this.registerHostsToComponent(masterHosts.filterProperty('component', 'HIVE_SERVER').mapProperty('hostName'), 'MYSQL_SERVER');
          }
      }
    },

    registerHostsToComponent: function (hostNames, componentName) {

      if (hostNames.length == 0) {
        return;
      }
      console.log('registering ' + componentName + ' to ' + JSON.stringify(hostNames));

      // currently we are specifying the predicate as a query string.
      // this can hit a ~4000-character limit in Jetty server.
      // chunk to multiple calls if needed
      // var hostsPredicate = hostNames.map(function (hostName) {
      //   return 'Hosts/host_name=' + hostName;
      // }).join('|');

      var queryStrArr = [];
      var queryStr = '';
      hostNames.forEach(function (hostName) {
        queryStr += 'Hosts/host_name=' + hostName + '|';
        if (queryStr.length > 3500) {
          queryStrArr.push(queryStr.slice(0, -1));
          queryStr = '';
        }
      });

      if (queryStr.length > 0) {
        queryStrArr.push(queryStr.slice(0, -1));
      }

      queryStrArr.forEach(function (queryStr) {
        // console.log('creating host components for ' + queryStr);
        var url = App.apiPrefix + '/clusters/' + this.get('clusterName') + '/hosts?' + queryStr;
        var data = {
          "host_components": [
            {
              "HostRoles": {
                "component_name": componentName
              }
            }
          ]
        };

        this.ajax({
          type: 'POST',
          url: url,
          data: JSON.stringify(data),
          beforeSend: function () {
            console.log('BeforeSend: registerHostsToComponent for ' + queryStr + ' and component ' + componentName);
          }
        });
      }, this);
    },

    createConfigurations: function () {
      var selectedServices = this.get('selectedServices');
      if (this.get('content.controllerName') == 'installerController') {
        this.applyConfigurationToSite(this.createGlobalSiteObj());
        this.applyConfigurationToSite(this.createCoreSiteObj());
        this.applyConfigurationToSite(this.createHdfsSiteObj());
      }
      if (selectedServices.someProperty('serviceName', 'MAPREDUCE')) {
        this.applyConfigurationToSite(this.createMrSiteObj());
        if (App.supports.capacitySchedulerUi) {
          this.applyConfigurationToSite(this.createCapacityScheduler());
          this.applyConfigurationToSite(this.createMapredQueueAcls());
        }
      }
      if (selectedServices.someProperty('serviceName', 'MAPREDUCE2')) {
        this.applyConfigurationToSite(this.createMrSiteObj());
        if (App.supports.capacitySchedulerUi) {
          this.applyConfigurationToSite(this.createMapredQueueAcls());
        }
      }
      if (selectedServices.someProperty('serviceName', 'YARN')) {
        this.applyConfigurationToSite(this.createYarnSiteObj());
        if (App.supports.capacitySchedulerUi) {
          this.applyConfigurationToSite(this.createCapacityScheduler());
        }
      }
      if (selectedServices.someProperty('serviceName', 'HBASE')) {
        this.applyConfigurationToSite(this.createHbaseSiteObj());
      }
      if (selectedServices.someProperty('serviceName', 'OOZIE')) {
        this.applyConfigurationToSite(this.createOozieSiteObj('OOZIE'));
      }
      if (selectedServices.someProperty('serviceName', 'HIVE')) {
        this.applyConfigurationToSite(this.createHiveSiteObj('HIVE'));
      }
      if (selectedServices.someProperty('serviceName', 'WEBHCAT')) {
        this.applyConfigurationToSite(this.createWebHCatSiteObj('WEBHCAT'));
      }
      if (selectedServices.someProperty('serviceName', 'HUE')) {
        this.applyConfigurationToSite(this.createHueSiteObj('HUE'));
      }
    },

    applyConfigurationToSite: function (data) {
      console.log("Inside applyConfigurationToSite");
      var clusterUrl = App.apiPrefix + '/clusters/' + this.get('clusterName');
      var clusterData = {
        Clusters: {
          desired_configs: data
        }
      };
      console.debug("applyConfigurationToSite(Step8): Applying to URL", clusterUrl, " Data:", clusterData);
      this.ajax({
        type: 'PUT',
        url: clusterUrl,
        data: JSON.stringify(clusterData),
        beforeSend: function () {
          console.log("BeforeSend: Updating cluster config for " + clusterData.type);
        }
      });
    },

    createGlobalSiteObj: function () {
      var globalSiteProperties = {};
      var globalSiteObj = this.get('globals');
      var isHCFSSelected = this.get('selectedServices').someProperty('serviceName', 'HCFS');
      
      // screen out the HCFS-specific global config entries when they are not required
      if (!isHCFSSelected) {
        globalSiteObj = globalSiteObj.filter(function(_config) {
          return _config.name.indexOf("fs_glusterfs") < 0;
        });
      }
      
      globalSiteObj.forEach(function (_globalSiteObj) {
        // do not pass any globals whose name ends with _host or _hosts
        if (!/_hosts?$/.test(_globalSiteObj.name)) {
          // append "m" to JVM memory options except for hadoop_heapsize
          if (/_heapsize|_newsize|_maxnewsize$/.test(_globalSiteObj.name) && _globalSiteObj.name !== 'hadoop_heapsize') {
            globalSiteProperties[_globalSiteObj.name] = _globalSiteObj.value + "m";
          } else {
            globalSiteProperties[_globalSiteObj.name] = _globalSiteObj.value;
          }
          console.log("STEP8: name of the global property is: " + _globalSiteObj.name);
          console.log("STEP8: value of the global property is: " + _globalSiteObj.value);
        }
        if (_globalSiteObj.name == 'java64_home') {
          globalSiteProperties['java64_home'] = this.get('content.installOptions.javaHome');
        }
        this._recordHostOverrideFromObj(_globalSiteObj, 'global', 'version1', this);
      }, this);
      // we don't expose gmond_user to the user; it needs to be the same as gmetad_user
      globalSiteProperties['gmond_user'] = globalSiteProperties['gmetad_user'];
      return {"type": "global", "tag": "version1", "properties": globalSiteProperties};
    },

    createCoreSiteObj: function () {
      var coreSiteObj = this.get('configs').filterProperty('filename', 'core-site.xml');
      var coreSiteProperties = {};
      // hadoop.proxyuser.oozie.hosts needs to be skipped if oozie is not selected
      var isOozieSelected = this.get('selectedServices').someProperty('serviceName', 'OOZIE');
      var oozieUser = this.get('globals').someProperty('name', 'oozie_user') ? this.get('globals').findProperty('name', 'oozie_user').value : null;
      var isHiveSelected = this.get('selectedServices').someProperty('serviceName', 'HIVE');
      var hiveUser = this.get('globals').someProperty('name', 'hive_user') ? this.get('globals').findProperty('name', 'hive_user').value : null;
      var isHcatSelected = this.get('selectedServices').someProperty('serviceName', 'WEBHCAT');
      var hcatUser = this.get('globals').someProperty('name', 'hcat_user') ? this.get('globals').findProperty('name', 'hcat_user').value : null;
      var isHCFSSelected = this.get('selectedServices').someProperty('serviceName', 'HCFS');
      
      // screen out the HCFS-specific core-site.xml entries when they are not needed
      if (!isHCFSSelected) {
         coreSiteObj = coreSiteObj.filter(function(_config) {
           return _config.name.indexOf("fs.glusterfs") < 0;
        });
      }
      coreSiteObj.forEach(function (_coreSiteObj) {
        if ((isOozieSelected || (_coreSiteObj.name != 'hadoop.proxyuser.' + oozieUser + '.hosts' && _coreSiteObj.name != 'hadoop.proxyuser.' + oozieUser + '.groups')) && (isHiveSelected || (_coreSiteObj.name != 'hadoop.proxyuser.' + hiveUser + '.hosts' && _coreSiteObj.name != 'hadoop.proxyuser.' + hiveUser + '.groups')) && (isHcatSelected || (_coreSiteObj.name != 'hadoop.proxyuser.' + hcatUser + '.hosts' && _coreSiteObj.name != 'hadoop.proxyuser.' + hcatUser + '.groups'))) {
          coreSiteProperties[_coreSiteObj.name] = _coreSiteObj.value;
          this._recordHostOverrideFromObj(_coreSiteObj, 'core-site', 'version1', this);
        }
        if (isHCFSSelected && _coreSiteObj.name == "fs.default.name") {
          coreSiteProperties[_coreSiteObj.name] = this.get('globals').someProperty('name', 'fs_glusterfs_default_name') ? this.get('globals').findProperty('name', 'fs_glusterfs_default_name').value : null;
        }
        console.log("STEP*: name of the property is: " + _coreSiteObj.name);
        console.log("STEP8: value of the property is: " + _coreSiteObj.value);
      }, this);
      return {"type": "core-site", "tag": "version1", "properties": coreSiteProperties};
    },

    createHdfsSiteObj: function () {
      var hdfsSiteObj = this.get('configs').filterProperty('filename', 'hdfs-site.xml');
      var hdfsProperties = {};
      hdfsSiteObj.forEach(function (_configProperty) {

        if (stringUtils.compareVersions(App.get('currentStackVersionNumber'), '2.0.0') === 1 ||
            stringUtils.compareVersions(App.get('currentStackVersionNumber'), '2.0.0') === 0) {
          // TODO Remove temporary hack. This was added to not set
          // dfs.hosts and dfs.hosts.exclude properties on HDP 2 stacks.
          if ("dfs.hosts"==_configProperty.name || "dfs.hosts.exclude"==_configProperty.name) {
            _configProperty.value = "";
          }
        }

        hdfsProperties[_configProperty.name] = _configProperty.value;
        this._recordHostOverrideFromObj(_configProperty, 'hdfs-site', 'version1', this);
        console.log("STEP*: name of the property is: " + _configProperty.name);
        console.log("STEP8: value of the property is: " + _configProperty.value);
      }, this);
      return {"type": "hdfs-site", "tag": "version1", "properties": hdfsProperties };
    },

    createHueSiteObj: function () {
      var hueSiteObj = this.get('configs').filterProperty('filename', 'hue-site.xml');
      var hueProperties = {};
      hueSiteObj.forEach(function (_configProperty) {
        hueProperties[_configProperty.name] = _configProperty.value;
        this._recordHostOverrideFromObj(_configProperty, 'hue-site', 'version1', this);
        console.log("STEP*: name of the property is: " + _configProperty.name);
        console.log("STEP8: value of the property is: " + _configProperty.value);
      }, this);
      return {"type": "hue-site", "tag": "version1", "properties": hueProperties };
    },

    createMrSiteObj: function () {
      var configs = this.get('configs').filterProperty('filename', 'mapred-site.xml');
      var mrProperties = {};
      configs.forEach(function (_configProperty) {
        mrProperties[_configProperty.name] = _configProperty.value;
        this._recordHostOverrideFromObj(_configProperty, 'mapred-site', 'version1', this);
        console.log("STEP*: name of the property is: " + _configProperty.name);
        console.log("STEP8: value of the property is: " + _configProperty.value);
      }, this);
      return {type: 'mapred-site', tag: 'version1', properties: mrProperties};
    },

    createYarnSiteObj: function () {
      var configs = this.get('configs').filterProperty('filename', 'yarn-site.xml');
      var mrProperties = {};
      configs.forEach(function (_configProperty) {
        mrProperties[_configProperty.name] = _configProperty.value;
        this._recordHostOverrideFromObj(_configProperty, 'yarn-site', 'version1', this);
        console.log("STEP*: name of the property is: " + _configProperty.name);
        console.log("STEP8: value of the property is: " + _configProperty.value);
      }, this);
      return {type: 'yarn-site', tag: 'version1', properties: mrProperties};
    },

    createCapacityScheduler: function () {
      var configs = this.get('configs').filterProperty('filename', 'capacity-scheduler.xml');
      var csProperties = {};
      configs.forEach(function (_configProperty) {
        csProperties[_configProperty.name] = _configProperty.value;
        this._recordHostOverrideFromObj(_configProperty, 'capacity-scheduler', 'version1', this);
        console.log("STEP*: name of the property is: " + _configProperty.name);
        console.log("STEP8: value of the property is: " + _configProperty.value);
      }, this);
      return {type: 'capacity-scheduler', tag: 'version1', properties: csProperties};
    },

    createMapredQueueAcls: function () {
      var configs = this.get('configs').filterProperty('filename', 'mapred-queue-acls.xml');
      var mqProperties = {};
      configs.forEach(function (_configProperty) {
       mqProperties[_configProperty.name] = _configProperty.value;
       this._recordHostOverrideFromObj(_configProperty, 'mapred-queue-acls', 'version1', this);
        console.log("STEP*: name of the property is: " + _configProperty.name);
        console.log("STEP8: value of the property is: " + _configProperty.value);
      }, this);
      return {type: 'mapred-queue-acls', tag: 'version1', properties: mqProperties};
    },

    createHbaseSiteObj: function () {
      var configs = this.get('configs').filterProperty('filename', 'hbase-site.xml');
      var hbaseProperties = {};
      configs.forEach(function (_configProperty) {
        hbaseProperties[_configProperty.name] = _configProperty.value;
        this._recordHostOverrideFromObj(_configProperty, 'hbase-site', 'version1', this);
      }, this);
      return {type: 'hbase-site', tag: 'version1', properties: hbaseProperties};
    },

    createOozieSiteObj: function (serviceName) {
      var configs = this.get('configs').filterProperty('filename', 'oozie-site.xml');
      var oozieProperties = {};
      configs.forEach(function (_configProperty) {
        oozieProperties[_configProperty.name] = _configProperty.value;
        this._recordHostOverrideFromObj(_configProperty, 'oozie-site', 'version1', this);
      }, this);
      var globals = this.get('content.serviceConfigProperties').filterProperty('id', 'puppet var');
      if (globals.someProperty('name', 'oozie_database')) {
        var oozieDb = globals.findProperty('name', 'oozie_database');
        var oozieHost = globals.findProperty('name', 'oozie_hostname').value;
        var oozieDbName = globals.findProperty('name', 'oozie_database_name').value;
        if (oozieDb.value === 'New Derby Database') {
          // oozieProperties["oozie.service.JPAService.jdbc.url"] = "jdbc:derby:${oozie.data.dir}/${oozie.db.schema.name}-db;create=true";
          oozieProperties["oozie.service.JPAService.jdbc.driver"] = "org.apache.derby.jdbc.EmbeddedDriver";
        } else if (oozieDb.value === 'Existing MySQL Database') {
          // oozieProperties["oozie.service.JPAService.jdbc.url"] = "jdbc:mysql://" + oozieHost + "/" + oozieDbName;
          oozieProperties["oozie.service.JPAService.jdbc.driver"] = "com.mysql.jdbc.Driver";
        } else { //existing oracle database
          // oozieProperties["oozie.service.JPAService.jdbc.url"] = "jdbc:oracle:thin:@//" + oozieHost + ":1521/" + oozieDbName;
          oozieProperties["oozie.service.JPAService.jdbc.driver"] = "oracle.jdbc.driver.OracleDriver";
        }
        //set oozie username and password
        oozieProperties["oozie.service.JPAService.jdbc.username"] = globals.findProperty('name', 'oozie_metastore_user_name').value;
        oozieProperties["oozie.service.JPAService.jdbc.password"] = globals.findProperty('name', 'oozie_metastore_user_passwd').value;
      }
      return {type: 'oozie-site', tag: 'version1', properties: oozieProperties};
    },

    createHiveSiteObj: function (serviceName) {
      var configs = this.get('configs').filterProperty('filename', 'hive-site.xml');
      var hiveProperties = {};
      configs.forEach(function (_configProperty) {
        hiveProperties[_configProperty.name] = _configProperty.value;
        this._recordHostOverrideFromObj(_configProperty, 'hive-site', 'version1', this);
      }, this);
      var globals = this.get('content.serviceConfigProperties').filterProperty('id', 'puppet var');
      if (globals.someProperty('name', 'hive_database')) {
        var hiveDb = globals.findProperty('name', 'hive_database');
        var hiveHost = globals.findProperty('name', 'hive_hostname').value;
        var hiveDbName = globals.findProperty('name', 'hive_database_name').value;
        if (hiveDb.value === 'New MySQL Database') {
          // hiveProperties["javax.jdo.option.ConnectionURL"] = "jdbc:mysql://"+ hiveHost + "/" + hiveDbName + "?createDatabaseIfNotExist=true";
          hiveProperties["javax.jdo.option.ConnectionDriverName"] = "com.mysql.jdbc.Driver";
        } else if (hiveDb.value === 'Existing MySQL Database'){
          // hiveProperties["javax.jdo.option.ConnectionURL"] = "jdbc:mysql://"+ hiveHost + "/" + hiveDbName + "?createDatabaseIfNotExist=true";
          hiveProperties["javax.jdo.option.ConnectionDriverName"] = "com.mysql.jdbc.Driver";
        } else { //existing oracle database
          // hiveProperties["javax.jdo.option.ConnectionURL"] = "jdbc:oracle:thin:@//"+ hiveHost + ":1521/" + hiveDbName;
          hiveProperties["javax.jdo.option.ConnectionDriverName"] = "oracle.jdbc.driver.OracleDriver";
        }
      }
      return {type: 'hive-site', tag: 'version1', properties: hiveProperties};
    },

    createWebHCatSiteObj: function (serviceName) {
      var configs = this.get('configs').filterProperty('filename', 'webhcat-site.xml');
      var webHCatProperties = {};
      configs.forEach(function (_configProperty) {
        webHCatProperties[_configProperty.name] = _configProperty.value;
        this._recordHostOverrideFromObj(_configProperty, 'webhcat-site', 'version1', this);
      }, this);
      return {type: 'webhcat-site', tag: 'version1', properties: webHCatProperties};
    },

    ajaxQueueFinished: function () {
      //do something
    },

    doNextAjaxCall: function () {

      if (this.get('ajaxBusy')) {
        return;
      }

      var queue = this.get('ajaxQueue');
      if (!queue.length) {
        this.ajaxQueueFinished();
        return;
      }

      var first = queue[0];
      this.set('ajaxQueue', queue.slice(1));
      this.set('ajaxQueueLeft', this.get('ajaxQueue').length);

      this.set('ajaxBusy', true);
      console.log('AJAX send ' + first.url);
      $.ajax(first);

    },

    /**
     * Records all the host overrides per site/tag
     */
    _recordHostOverrideFromObj: function(serviceConfigObj, siteName, tagName, self){
      var overrides = serviceConfigObj.overrides;
      if(overrides && overrides.length>0){
        overrides.forEach(function(override){
          override.hosts.forEach(function(host){
            if(!(host in self.savedHostToOverrideSiteToTagMap)){
              self.savedHostToOverrideSiteToTagMap[host] = {};
            }
            if(!(siteName in self.savedHostToOverrideSiteToTagMap[host])){
              self.savedHostToOverrideSiteToTagMap[host][siteName] = {};
              self.savedHostToOverrideSiteToTagMap[host][siteName].map = {};
            }
            var finalTag = tagName + '_' + host;
            console.log("recordHostOverride(): Saving host override for host="+host+", site="+siteName+", tag="+finalTag+", (key,value)=("+serviceConfigObj.name+","+override.value+")");
            self.savedHostToOverrideSiteToTagMap[host][siteName].tagName = finalTag;
            self.savedHostToOverrideSiteToTagMap[host][siteName].map[serviceConfigObj.name] = override.value;
          });
        });
      }
    },

    /**
     * Creates host level overrides for service configuration.
     *
     */
    createHostOverrideConfigurations: function () {
      var singlePUTHostData = [];
      var savedHostSiteArray = [];
      for ( var host in this.savedHostToOverrideSiteToTagMap) {
        for ( var siteName in this.savedHostToOverrideSiteToTagMap[host]) {
          var tagName = this.savedHostToOverrideSiteToTagMap[host][siteName].tagName;
          var map = this.savedHostToOverrideSiteToTagMap[host][siteName].map;
          savedHostSiteArray.push(host + "///" + siteName);
          singlePUTHostData.push({
            RequestInfo: {
              query: 'Hosts/host_name='+host
            },
            Body: {
              Hosts: {
                desired_config: {
                  type: siteName,
                  tag: tagName,
                  properties: map
                }
              }
            }
          });
        }
      }
      console.log("createHostOverrideConfigSites(): PUTting host-overrides. Data=", singlePUTHostData);
      if(singlePUTHostData.length>0){
        var url = App.apiPrefix + '/clusters/' + this.get('clusterName') + '/hosts';
        this.ajax({
          type: 'PUT',
          url: url,
          data: JSON.stringify(singlePUTHostData),
          dataType: 'text',
          beforeSend: function () {
            console.log("createHostOverrideConfigSites() PUT override=", singlePUTHostData);
          }
        });
      }
    },

    /**
     * We need to do a lot of ajax calls async in special order. To do this,
     * generate array of ajax objects and then send requests step by step. All
     * ajax objects are stored in <code>ajaxQueue</code>
     *
     * @param params
     */

    ajax: function (params) {
      if (App.testMode) return;

      var self = this;
      params = jQuery.extend({
        async: true,
        dataType: 'text',
        statusCode: require('data/statusCodes'),
        timeout: App.timeout,
        error: function (request, ajaxOptions, error) {
          console.log('Step8: In Error ');
          // console.log('Step8: Error message is: ' + request.responseText);
        },
        success: function (data) {
          var jsonData = jQuery.parseJSON(data);
          console.log("TRACE: STep8 -> In success function");
          console.log("TRACE: STep8 -> value of the url is: " + params.url);
          console.log("TRACE: STep8 -> value of the received data is: " + jsonData);
        }
      }, params);

      var success = params.success;
      var error = params.error;

      params.success = function () {
        if (success) {
          success();
        }

        self.set('ajaxBusy', false);
        self.doNextAjaxCall();
      }

      params.error = function (xhr, status, error) {
        var responseText = JSON.parse(xhr.responseText);
        var controller = App.router.get(App.clusterStatus.wizardControllerName);
        controller.registerErrPopup(Em.I18n.t('common.error'), responseText.message);
        self.set('hasErrorOccurred', true);
        // an error will break the ajax call chain and allow submission again
        self.set('isSubmitDisabled', false);
        self.get('ajaxQueue').clear();
        self.set('ajaxBusy', false);
      }
      this.get('ajaxQueue').pushObject(params);
    }

  });
  
});
window.require.register("controllers/wizard/step9_controller", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var App = require('app');

  App.WizardStep9Controller = Em.Controller.extend({
    name: 'wizardStep9Controller',
    hosts: [],
    progress: '0',

    isStepCompleted: false,

    isSubmitDisabled: function () {
      // return !this.get('isStepCompleted');
      var validStates = ['STARTED','START FAILED'];
      if (this.get('content.controllerName') == 'addHostController') {
        validStates.push('INSTALL FAILED');
      }
      return !validStates.contains(this.get('content.cluster.status'));
    }.property('content.cluster.status'),

    // links to previous steps are enabled iff install failed in installer
    togglePreviousSteps: function () {
      if ('INSTALL FAILED' === this.get('content.cluster.status') && this.get('content.controllerName') == 'installerController') {
        App.router.get('installerController').setStepsEnable();
      } else {
        App.router.get('installerController').setLowerStepsDisable(9);
      }
    }.observes('content.cluster.status', 'content.controllerName'),

    mockDataPrefix: '/data/wizard/deploy/5_hosts',
    pollDataCounter: 0,
    polledData: [],

    status: function () {
      if (this.hosts.someProperty('status', 'failed')) {
        return 'failed';
      }
      if (this.hosts.someProperty('status', 'warning')) {
        if (this.isStepFailed()) {
          return 'failed';
        } else {
          return 'warning';
        }
      }
      if(this.get('progress') == '100') {
        this.set('isStepCompleted', true);
        return 'success';
      }
      return 'info';
    }.property('hosts.@each.status', 'progress'),

    categoryObject: Em.Object.extend({
      hostsCount: function () {
        var category = this;
        var hosts = this.get('controller.hosts').filter(function(_host) {
          if(category.get('hostStatus') == 'inProgress'){   // queued, pending, in_progress map to inProgress
            return (_host.get('status') !== 'success' && _host.get('status') !== 'failed' && _host.get('status') !== 'warning');
          }
          return (_host.get('status') == category.get('hostStatus'));
        }, this);
        return hosts.get('length');
      }.property('controller.hosts.@each.status'),
      label: function () {
        return "%@ (%@)".fmt(this.get('value'), this.get('hostsCount'));
      }.property('value', 'hostsCount')
    }),
    getCategory: function(field, value){
      return this.get('categories').find(function(item){
        return item.get(field) == value;
      });
    },

    categories: function () {
      var self = this;
      self.categoryObject.reopen({
        controller: self,
        isActive: function(){
          return this.get('controller.category') == this;
        }.property('controller.category'),
        itemClass: function(){
          return this.get('isActive') ? 'active' : '';
        }.property('isActive')
      });

      var categories = [
        self.categoryObject.create({value: Em.I18n.t('common.all'), hostStatus:'all', hostsCount: function () {
          return this.get('controller.hosts.length');
        }.property('controller.hosts.length') }),
        self.categoryObject.create({value: Em.I18n.t('installer.step9.hosts.status.label.inProgress'), hostStatus: 'inProgress'}),
        self.categoryObject.create({value: Em.I18n.t('installer.step9.hosts.status.label.warning'), hostStatus: 'warning'}),
        self.categoryObject.create({value: Em.I18n.t('common.success'), hostStatus: 'success'}),
        self.categoryObject.create({value: Em.I18n.t('common.fail'), hostStatus: 'failed', last: true })
      ];

      this.set('category', categories.get('firstObject'));
      return categories;
    }.property(),

    category: false,
    visibleHosts: function(){
      var targetStatus = this.get('category.hostStatus');
      var visibleHosts =  this.get('hosts').filter(function(_host) {
        if (targetStatus == 'all') {
          return true;
        }
        if (targetStatus == 'inProgress') {   // queued, pending, in_progress map to inProgress
          return (_host.get('status') !== 'success' && _host.get('status') !== 'failed' && _host.get('status') !== 'warning');
        }
        return (_host.get('status') == targetStatus);
      }, this);
      return visibleHosts;
    }.property('category', 'hosts.@each.status'),

    selectCategory: function(event){
      this.set('category', event.context);
    },

    showRetry: function () {
      return this.get('content.cluster.status') == 'INSTALL FAILED';
    }.property('content.cluster.status'),

    // content.cluster.status can be:
    // PENDING: set upon successful transition from step 1 to step 2
    // INSTALLED: set upon successful completion of install phase as well as successful invocation of start services API
    // STARTED: set up on successful completion of start phase
    // INSTALL FAILED: set up upon encountering a failure in install phase
    // START FAILED: set upon unsuccessful invocation of start services API and also upon encountering a failure
    // during start phase

    // content.cluster.isCompleted
    // set to false upon successful transition from step 1 to step 2
    // set to true upon successful start of services in this step
    // note: looks like this is the same thing as checking content.cluster.status == 'STARTED'


    // navigateStep is called by App.WizardStep9View's didInsertElement and "retry" from router.
    navigateStep: function () {
      if (App.testMode) {
        // this is for repeatedly testing out installs in test mode
        this.set('content.cluster.status', 'PENDING');
        this.set('content.cluster.isCompleted', false);
        this.set('content.cluster.requestId',1);
      }
      var clusterStatus = this.get('content.cluster.status');
      console.log('navigateStep: clusterStatus = ' + clusterStatus);
      if (this.get('content.cluster.isCompleted') === false) {
        // the cluster has not yet successfully installed and started
        if (clusterStatus === 'INSTALL FAILED') {
          this.loadStep();
          this.loadLogData(this.get('content.cluster.requestId'));
          this.set('isStepCompleted', true);
        } else if (clusterStatus === 'START FAILED') {
          this.loadStep();
          this.loadLogData(this.get('content.cluster.requestId'));
          // this.hosts.setEach('status', 'info');
          this.set('isStepCompleted', true);
        } else {
          // handle PENDING, INSTALLED
          this.loadStep();
          this.loadLogData(this.get('content.cluster.requestId'));
          this.startPolling();
        }
      } else {
        // handle STARTED
        // the cluster has successfully installed and started
        this.loadStep();
        this.loadLogData(this.get('content.cluster.requestId'));
        this.set('isStepCompleted', true);
        this.set('progress', '100');
      }
    },
    clearStep: function () {
      this.hosts.clear();
      this.set('status', 'info');
      this.set('progress', '0');
      this.set('isStepCompleted', false);
      this.numPolls = 1;
    },

    loadStep: function () {
      console.log("TRACE: Loading step9: Install, Start and Test");
      this.clearStep();
      this.renderHosts(this.loadHosts());
    },
    /**
     * reset status and message of all hosts when retry install
     */
    resetHostsForRetry: function(){
      var hosts = this.get('content.hosts');
      for (var name in hosts) {
        hosts[name].status = "pending";
        hosts[name].message = 'Waiting';
      }
      this.set('content.hosts', hosts);
    },

    loadHosts: function () {
      var hostInfo = this.get('content.hosts');
      var hosts = new Ember.Set();
      for (var index in hostInfo) {
        var obj = Em.Object.create(hostInfo[index]);
        obj.message = (obj.message) ? obj.message : 'Waiting';
        obj.progress = 0;
        obj.status = (obj.status) ? obj.status : 'info';
        obj.tasks = [];
        obj.logTasks = [];
        hosts.add(obj);
        console.log("TRACE: host name is: " + hostInfo[index].name);
      }
      return hosts.filterProperty('bootStatus', 'REGISTERED');
    },

    // sets this.hosts, where each element corresponds to a status and progress info on a host
    renderHosts: function (hostsInfo) {
      hostsInfo.forEach(function (_hostInfo) {
        var hostInfo = App.HostInfo.create({
          name: _hostInfo.name,
          status: _hostInfo.status,
          tasks: _hostInfo.tasks,
          logTasks: _hostInfo.logTasks,
          message: _hostInfo.message,
          progress: _hostInfo.progress
        });
        console.log('pushing ' + hostInfo.name);
        this.hosts.pushObject(hostInfo);
      }, this);
    },

    replacePolledData: function (polledData) {
      this.polledData.clear();
      this.set('polledData', polledData);
    },

    displayMessage: function (task) {
      var role = App.format.role(task.role);
      console.log("In display message with task command value: " + task.command);
      switch (task.command) {
        case 'INSTALL':
          switch (task.status) {
            case 'PENDING':
              return Em.I18n.t('installer.step9.serviceStatus.install.pending') + role;
            case 'QUEUED' :
              return Em.I18n.t('installer.step9.serviceStatus.install.queued') + role;
            case 'IN_PROGRESS':
              return Em.I18n.t('installer.step9.serviceStatus.install.inProgress') + role;
            case 'COMPLETED' :
              return Em.I18n.t('installer.step9.serviceStatus.install.completed') + role;
            case 'FAILED':
              return Em.I18n.t('installer.step9.serviceStatus.install.failed') + role;
          }
        case 'UNINSTALL':
          switch (task.status) {
            case 'PENDING':
              return Em.I18n.t('installer.step9.serviceStatus.uninstall.pending') + role;
            case 'QUEUED' :
              return Em.I18n.t('installer.step9.serviceStatus.uninstall.queued') + role;
            case 'IN_PROGRESS':
              return Em.I18n.t('installer.step9.serviceStatus.uninstall.inProgress') + role;
            case 'COMPLETED' :
              return Em.I18n.t('installer.step9.serviceStatus.uninstall.completed') + role;
            case 'FAILED':
              return Em.I18n.t('installer.step9.serviceStatus.uninstall.failed') + role;
          }
        case 'START' :
          switch (task.status) {
            case 'PENDING':
              return Em.I18n.t('installer.step9.serviceStatus.start.pending') + role;
            case 'QUEUED' :
              return Em.I18n.t('installer.step9.serviceStatus.start.queued') + role;
            case 'IN_PROGRESS':
              return Em.I18n.t('installer.step9.serviceStatus.start.inProgress') + role;
            case 'COMPLETED' :
              return role + Em.I18n.t('installer.step9.serviceStatus.start.completed');
            case 'FAILED':
              return role + Em.I18n.t('installer.step9.serviceStatus.start.failed');
          }
        case 'STOP' :
          switch (task.status) {
            case 'PENDING':
              return Em.I18n.t('installer.step9.serviceStatus.stop.pending') + role;
            case 'QUEUED' :
              return Em.I18n.t('installer.step9.serviceStatus.stop.queued') + role;
            case 'IN_PROGRESS':
              return Em.I18n.t('installer.step9.serviceStatus.stop.inProgress') + role;
            case 'COMPLETED' :
              return role + Em.I18n.t('installer.step9.serviceStatus.stop.completed');
            case 'FAILED':
              return role + Em.I18n.t('installer.step9.serviceStatus.stop.failed');
          }
        case 'EXECUTE' :
          switch (task.status) {
            case 'PENDING':
              return Em.I18n.t('installer.step9.serviceStatus.execute.pending') + role;
            case 'QUEUED' :
              return Em.I18n.t('installer.step9.serviceStatus.execute.queued') + role;
            case 'IN_PROGRESS':
              return Em.I18n.t('installer.step9.serviceStatus.execute.inProgress') + role;
            case 'COMPLETED' :
              return role + Em.I18n.t('installer.step9.serviceStatus.execute.completed');
            case 'FAILED':
              return role + Em.I18n.t('installer.step9.serviceStatus.execute.failed');
          }
        case 'ABORT' :
          switch (task.status) {
            case 'PENDING':
              return Em.I18n.t('installer.step9.serviceStatus.abort.pending') + role;
            case 'QUEUED' :
              return Em.I18n.t('installer.step9.serviceStatus.abort.queued') + role;
            case 'IN_PROGRESS':
              return Em.I18n.t('installer.step9.serviceStatus.abort.inProgress') + role;
            case 'COMPLETED' :
              return role + Em.I18n.t('installer.step9.serviceStatus.abort.completed');
            case 'FAILED':
              return role + Em.I18n.t('installer.step9.serviceStatus.abort.failed');
          }
      }
    },

    /**
     * run start/check services after installation phase
     */
    launchStartServices: function () {
      var data = {
        "RequestInfo": {
          "context": Em.I18n.t("requestInfo.startServices")
        },
        "Body": {
          "ServiceInfo": { "state": "STARTED" }
        }
      };
      var name = 'wizard.step9.installer.launch_start_services';

      if (this.get('content.controllerName') === 'addHostController') {
        var hostnames = [];
        for (var hostname in App.db.getHosts()) {
          hostnames.push(hostname);
        }
        data = {
          "RequestInfo": {
            "context": Em.I18n.t("requestInfo.startHostComponents"),
            "query": "HostRoles/component_name.in(GANGLIA_MONITOR,HBASE_REGIONSERVER,DATANODE,TASKTRACKER)&HostRoles/state=INSTALLED&HostRoles/host_name.in(" + hostnames.join(',') + ")"
          },
          "Body": {
            "HostRoles": { "state": "STARTED" }
          }
        };
        name = 'wizard.step9.add_host.launch_start_services';
      }
      data = JSON.stringify(data);
      if (App.testMode) {
        this.numPolls = 6;
      }

      App.ajax.send({
        name: name,
        sender: this,
        data: {
          data: data,
          cluster: this.get('content.cluster.name')
        },
        success: 'launchStartServicesSuccessCallback',
        error: 'launchStartServicesErrorCallback'
      });
    },

    launchStartServicesSuccessCallback: function (jsonData) {
      console.log("TRACE: Step9 -> In success function for the startService call");
      console.log("TRACE: Step9 -> value of the received data is: " + jsonData);
      var requestId = jsonData.Requests.id;
      console.log('requestId is: ' + requestId);
      var clusterStatus = {
        status: 'INSTALLED',
        requestId: requestId,
        isStartError: false,
        isCompleted: false
      };

      App.router.get(this.get('content.controllerName')).saveClusterStatus(clusterStatus);

      // We need to do recovery if there is a browser crash
      App.clusterStatus.setClusterStatus({
        clusterState: 'SERVICE_STARTING_3',
        localdb: App.db.data
      });

      this.startPolling();
    },

    launchStartServicesErrorCallback: function () {
      console.log("ERROR");
      var clusterStatus = {
        status: 'START FAILED',
        isStartError: true,
        isCompleted: false
      };
      App.router.get(this.get('content.controllerName')).saveClusterStatus(clusterStatus);
    },

    // marks a host's status as "success" if all tasks are in COMPLETED state
    onSuccessPerHost: function (actions, contentHost) {
      if (actions.everyProperty('Tasks.status', 'COMPLETED') && this.get('content.cluster.status') === 'INSTALLED') {
        contentHost.set('status', 'success');
      }
    },

    // marks a host's status as "warning" if at least one of the tasks is FAILED, ABORTED, or TIMEDOUT and marks host's status as "failed" if at least one master component install task is FAILED.
    // note that if the master failed to install because of ABORTED or TIMEDOUT, we don't mark it as failed, because this would mark all hosts as "failed" and makes it difficult for the user
    // to find which host FAILED occurred on, if any
    onErrorPerHost: function (actions, contentHost) {
      if (actions.someProperty('Tasks.status', 'FAILED') || actions.someProperty('Tasks.status', 'ABORTED') || actions.someProperty('Tasks.status', 'TIMEDOUT')) {
        contentHost.set('status', 'warning');
      }
      if ((this.get('content.cluster.status') === 'PENDING' && actions.someProperty('Tasks.status', 'FAILED')) || (this.isMasterFailed(actions))) {
        contentHost.set('status', 'failed');
      }
    },
    //return true if there is at least one FAILED task of master component install
    isMasterFailed: function(polledData) {
      var result = false;
      polledData.filterProperty('Tasks.command', 'INSTALL').filterProperty('Tasks.status', 'FAILED').mapProperty('Tasks.role').forEach (
        function (task) {
          if (!['DATANODE', 'TASKTRACKER', 'HBASE_REGIONSERVER', 'GANGLIA_MONITOR'].contains(task)) {
            result = true;
          }
        }
      );
      return result;
    },

    onInProgressPerHost: function (tasks, contentHost) {
      var runningAction = tasks.findProperty('Tasks.status', 'IN_PROGRESS');
      if (runningAction === undefined || runningAction === null) {
        runningAction = tasks.findProperty('Tasks.status', 'QUEUED');
      }
      if (runningAction === undefined || runningAction === null) {
        runningAction = tasks.findProperty('Tasks.status', 'PENDING');
      }
      if (runningAction !== null && runningAction !== undefined) {
        contentHost.set('message', this.displayMessage(runningAction.Tasks));
      }
    },

    /**
     * calculate progress of tasks per host
     * @param actions
     * @param contentHost
     * @return {Number}
     */
    progressPerHost: function (actions, contentHost) {
      var progress = 0;
      var actionsPerHost = actions.length;
      // TODO: consolidate to a single filter function for better performance
      var completedActions = actions.filterProperty('Tasks.status', 'COMPLETED').length
        + actions.filterProperty('Tasks.status', 'FAILED').length
        + actions.filterProperty('Tasks.status', 'ABORTED').length
        + actions.filterProperty('Tasks.status', 'TIMEDOUT').length;
      var queuedActions = actions.filterProperty('Tasks.status', 'QUEUED').length;
      var inProgressActions = actions.filterProperty('Tasks.status', 'IN_PROGRESS').length;
      /** for the install phase (PENDING), % completed per host goes up to 33%; floor(100 / 3)
       * for the start phase (INSTALLED), % completed starts from 34%
       * when task in queued state means it's completed on 9%
       * in progress - 35%
       * completed - 100%
       */
      switch (this.get('content.cluster.status')) {
        case 'PENDING':
          progress = Math.ceil(((queuedActions * 0.09) + (inProgressActions * 0.35) + completedActions ) / actionsPerHost * 33);
          break;
        case 'INSTALLED':
          progress = 34 + Math.ceil(((queuedActions * 0.09) + (inProgressActions * 0.35) + completedActions ) / actionsPerHost * 66);
          break;
        default:
          progress = 100;
          break;
      }
      console.log('INFO: progressPerHost is: ' + progress);
      contentHost.set('progress', progress.toString());
      return progress;
    },

    isSuccess: function (polledData) {
      return polledData.everyProperty('Tasks.status', 'COMPLETED');
    },

    /**
     * return true if:
     *  1. any of the master/client components failed to install
     *  OR
     *  2. at least 50% of the slave host components for the particular service component fails to install
     */
    isStepFailed: function () {
      var failed = false;
      var polledData = this.get('polledData');
      polledData.filterProperty('Tasks.command', 'INSTALL').mapProperty('Tasks.role').uniq().forEach(function (role) {
        if (failed) {
          return;
        }
        var actionsPerRole = polledData.filterProperty('Tasks.role', role);
        if (['DATANODE', 'TASKTRACKER', 'HBASE_REGIONSERVER', 'GANGLIA_MONITOR'].contains(role)) {
          // check slave components for success factor.
          // partial failure for slave components are allowed.
          var actionsFailed = actionsPerRole.filterProperty('Tasks.status', 'FAILED');
          var actionsAborted = actionsPerRole.filterProperty('Tasks.status', 'ABORTED');
          var actionsTimedOut = actionsPerRole.filterProperty('Tasks.status', 'TIMEDOUT');
          if ((((actionsFailed.length + actionsAborted.length + actionsTimedOut.length) / actionsPerRole.length) * 100) > 50) {
            failed = true;
          }
        } else if (actionsPerRole.someProperty('Tasks.status', 'FAILED') || actionsPerRole.someProperty('Tasks.status', 'ABORTED') ||
          actionsPerRole.someProperty('Tasks.status', 'TIMEDOUT')) {
          // check non-salve components (i.e., masters and clients).  all of these must be successfully installed.
          failed = true;
        }
      }, this);
      return failed;
    },

    // makes a state transition
    // PENDING -> INSTALLED
    // PENDING -> INSTALL FAILED
    // INSTALLED -> STARTED
    // INSTALLED -> START_FAILED
    // returns true if polling should stop; false otherwise
    // polling from ui stops only when no action has 'PENDING', 'QUEUED' or 'IN_PROGRESS' status
    finishState: function (polledData) {
      var clusterStatus = {};
      var requestId = this.get('content.cluster.requestId');
      if (this.get('content.cluster.status') === 'INSTALLED') {
        if (!polledData.someProperty('Tasks.status', 'PENDING') && !polledData.someProperty('Tasks.status', 'QUEUED') && !polledData.someProperty('Tasks.status', 'IN_PROGRESS')) {
          this.set('progress', '100');
          clusterStatus = {
            status: 'INSTALLED',
            requestId: requestId,
            isCompleted: true
          };
          if (this.isSuccess(polledData)) {
            clusterStatus.status = 'STARTED';
            var serviceStartTime = new Date().getTime();
            var timeToStart = ((parseInt(serviceStartTime) - parseInt(this.get('content.cluster.installStartTime'))) / 60000).toFixed(2);
            clusterStatus.installTime = timeToStart;
          } else {
              clusterStatus.status = 'START FAILED'; // 'START FAILED' implies to step10 that installation was successful but start failed
          }
          App.router.get(this.get('content.controllerName')).saveClusterStatus(clusterStatus);
          this.set('isStepCompleted', true);
          this.setTasksPerHost();
          App.router.get(this.get('content.controllerName')).saveInstalledHosts(this);
          return true;
        }
      } else if (this.get('content.cluster.status') === 'PENDING') {
        if (!polledData.someProperty('Tasks.status', 'PENDING') && !polledData.someProperty('Tasks.status', 'QUEUED') && !polledData.someProperty('Tasks.status', 'IN_PROGRESS')) {
          clusterStatus = {
            status: 'PENDING',
            requestId: requestId,
            isCompleted: false
          };
          if (this.get('status') === 'failed') {
            clusterStatus.status = 'INSTALL FAILED';
            this.set('progress', '100');
            this.get('hosts').setEach('progress', '100');
            App.router.get(this.get('content.controllerName')).saveClusterStatus(clusterStatus);
            this.set('isStepCompleted', true);
          } else {
            clusterStatus.status = 'INSTALLED';
            this.set('progress', '34');
            this.launchStartServices();
          }
          this.setTasksPerHost();
          App.router.get(this.get('content.controllerName')).saveInstalledHosts(this);
          return true;
        }
      } else if (this.get('content.cluster.status') === 'INSTALL FAILED' || this.get('content.cluster.status') === 'START FAILED' || this.get('content.cluster.status') === 'STARTED') {
        this.set('progress', '100');
        return true;
      }
      return false;
    },

    setTasksPerHost: function () {
      var tasksData = this.get('polledData');
      this.get('hosts').forEach(function (_host) {
        var tasksPerHost = tasksData.filterProperty('Tasks.host_name', _host.name); // retrieved from polled Data
        if (tasksPerHost.length === 0) {
          //alert('For testing with mockData follow the sequence: hit referesh,"mockData btn", "pollData btn", again "pollData btn"');
          //exit();
        }
        if (tasksPerHost !== null && tasksPerHost !== undefined && tasksPerHost.length !== 0) {
          tasksPerHost.forEach(function (_taskPerHost) {
            console.log('In step9 _taskPerHost function.');
            //if (_taskPerHost.Tasks.status !== 'PENDING' && _taskPerHost.Tasks.status !== 'QUEUED' &&  _taskPerHost.Tasks.status !== 'IN_PROGRESS') {
            _host.tasks.pushObject(_taskPerHost);
            //}
          }, this);
        }
      }, this);
    },

    logTasksChangesCounter: 0,

    // This is done at HostRole level.
    setLogTasksStatePerHost: function (tasksPerHost, host) {
      console.log('In step9 setTasksStatePerHost function.');
      tasksPerHost.forEach(function (_task) {
        console.log('In step9 _taskPerHost function.');
        //if (_task.Tasks.status !== 'PENDING' && _task.Tasks.status !== 'QUEUED') {
        var task = host.logTasks.findProperty('Tasks.id', _task.Tasks.id);
        if (task) {
          host.logTasks.removeObject(task);
        }
        host.logTasks.pushObject(_task);
        //}
      }, this);
      this.set('logTasksChangesCounter', this.get('logTasksChangesCounter') + 1);
    },

    parseHostInfo: function (polledData) {
      console.log('TRACE: Entering host info function');
      var self = this;
      var totalProgress = 0;
      var tasksData = polledData.tasks;
      console.log("The value of tasksData is: ", tasksData);
      if (!tasksData) {
        console.log("Step9: ERROR: NO tasks available to process");
      }
      var requestId = this.get('content.cluster.requestId');
      if(polledData.Requests && polledData.Requests.id && polledData.Requests.id!=requestId){
        // We dont want to use non-current requestId's tasks data to
        // determine the current install status.
        // Also, we dont want to keep polling if it is not the
        // current requestId.
        return false;
      }
      this.replacePolledData(tasksData);
      this.hosts.forEach(function (_host) {
        var actionsPerHost = tasksData.filterProperty('Tasks.host_name', _host.name); // retrieved from polled Data
        if (actionsPerHost.length === 0) {
          _host.set('message', this.t('installer.step9.host.status.nothingToInstall'));
          console.log("INFO: No task is hosted on the host");
        }
        if (actionsPerHost !== null && actionsPerHost !== undefined && actionsPerHost.length !== 0) {
          this.setLogTasksStatePerHost(actionsPerHost, _host);
          this.onSuccessPerHost(actionsPerHost, _host);     // every action should be a success
          this.onErrorPerHost(actionsPerHost, _host);     // any action should be a failure
          this.onInProgressPerHost(actionsPerHost, _host);  // current running action for a host
          totalProgress += self.progressPerHost(actionsPerHost, _host);
        }
      }, this);
      totalProgress = Math.floor(totalProgress / this.hosts.length);
      this.set('progress', totalProgress.toString());
      console.log("INFO: right now the progress is: " + this.get('progress'));
      return this.finishState(tasksData);
    },

    startPolling: function () {
      this.set('isSubmitDisabled', true);
      this.doPolling();
    },

    numPolls: 1,

    getUrl: function (requestId) {
      var clusterName = this.get('content.cluster.name');
      var requestId = requestId || this.get('content.cluster.requestId');
      var url = App.apiPrefix + '/clusters/' + clusterName + '/requests/' + requestId + '?fields=tasks/*';
      console.log("URL for step9 is: " + url);
      return url;
    },

    POLL_INTERVAL: 4000,

    loadLogData: function(requestId) {
      var url = this.getUrl(requestId);
      var requestsId = App.db.getCluster().oldRequestsId;
      if (App.testMode) {
        this.POLL_INTERVAL = 1;
      }

      requestsId.forEach(function(requestId) {
        url = this.getUrl(requestId);
        if (App.testMode) {
          this.POLL_INTERVAL = 1;
          url = this.get('mockDataPrefix') + '/poll_' + this.numPolls + '.json';
        }
        this.getLogsByRequest(url, false);
      }, this);
    },

    // polling: whether to continue polling for status or not
    getLogsByRequest: function(url, polling){
      var self = this;
      $.ajax({
        type: 'GET',
        url: url,
        async: true,
        timeout: App.timeout,
        dataType: 'text',
        success: function (data) {
          console.log("TRACE: In success function for the GET logs data");
          console.log("TRACE: STep9 -> The value is: ", jQuery.parseJSON(data));
          var result = self.parseHostInfo(jQuery.parseJSON(data));
          if (!polling) {
            return;
          }
          if (result !== true) {
            window.setTimeout(function () {
              self.doPolling();
            }, self.POLL_INTERVAL);
          } else {
            self.stopPolling();
          }
        },

        error: function (request, ajaxOptions, error) {
          console.log("TRACE: STep9 -> In error function for the GET logs data");
          console.log("TRACE: STep9 -> value of the url is: " + url);
          console.log("TRACE: STep9 -> error code status is: " + request.status);
          self.stopPolling();
        },

        statusCode: require('data/statusCodes')
      }).retry({times: App.maxRetries, timeout: App.timeout}).then(null,
        function () {
          App.showReloadPopup();
          console.log('Install services all retries failed');
        }
      );
    },

    doPolling: function () {
      var url = this.getUrl();

      if (App.testMode) {
        this.numPolls++;
        url = this.get('mockDataPrefix') + '/poll_' + this.get('numPolls') + '.json';

      }
      this.getLogsByRequest(url, true);
    },

    stopPolling: function () {
      //TODO: uncomment following line after the hook up with the API call
      // this.set('isStepCompleted',true);
    },

    submit: function () {
      if (!this.get('isSubmitDisabled')) {
        App.router.send('next');
      }
    },

    back: function () {
      if (!this.get('isSubmitDisabled')) {
        App.router.send('back');
      }
    }
  });
  
});
window.require.register("data/HDP2/config_mapping", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var configs = [
    /**********************************************core-site***************************************/
    {
      "name": "fs.default.name",
      "templateName": ["namenode_host"],
      "foreignKey": null,
      "value": "hdfs://<templateName[0]>:8020",
      "filename": "core-site.xml"
    },
    {
      "name": "fs.checkpoint.dir",
      "templateName": ["fs_checkpoint_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "core-site.xml"
    },
    {
      "name": "fs.checkpoint.period",
      "templateName": ["fs_checkpoint_period"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "core-site.xml"
    },
    {
      "name": "fs.checkpoint.size",
      "templateName": ["fs_checkpoint_size"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "core-site.xml"
    },
    {
      "name": "fs.checkpoint.edits.dir",
      "templateName": ["fs_checkpoint_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "core-site.xml"
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.groups",
      "templateName": ["proxyuser_group"],
      "foreignKey": ["hive_user"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "isOverridable" : true
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.hosts",
      "templateName": ["hivemetastore_host"],
      "foreignKey": ["hive_user"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "isOverridable" : true
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.groups",
      "templateName": ["proxyuser_group"],
      "foreignKey": ["oozie_user"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "isOverridable" : true
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.hosts",
      "templateName": ["oozieserver_host"],
      "foreignKey": ["oozie_user"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "isOverridable" : true
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.groups",
      "templateName": ["proxyuser_group"],
      "foreignKey": ["webhcat_user"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "isOverridable" : true
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.hosts",
      "templateName": ["hivemetastore_host"],
      "foreignKey": ["webhcat_user"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "isOverridable" : true
    },
    /**********************************************hdfs-site***************************************/
    {
      "name": "dfs.name.dir",
      "templateName": ["dfs_name_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.webhdfs.enabled",
      "templateName": ["dfs_webhdfs_enabled"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.datanode.failed.volumes.tolerated",
      "templateName": ["dfs_datanode_failed_volume_tolerated"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.block.local-path-access.user",
      "templateName": ["dfs_block_local_path_access_user"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.data.dir",
      "templateName": ["dfs_data_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.hosts.exclude",
      "templateName": ["hadoop_conf_dir", "dfs_exclude"],
      "foreignKey": null,
      "value": "<templateName[0]>\/<templateName[1]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.hosts",
      "templateName": ["hadoop_conf_dir", "dfs_include"],
      "foreignKey": null,
      "value": "<templateName[0]>\/<templateName[1]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.replication",
      "templateName": ["dfs_replication"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.datanode.address",
      "templateName": ["dfs_datanode_address"],
      "foreignKey": null,
      "value": "0.0.0.0:<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.datanode.http.address",
      "templateName": ["dfs_datanode_http_address"],
      "foreignKey": null,
      "value": "0.0.0.0:<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.http.address",
      "templateName": ["namenode_host"],
      "foreignKey": null,
      "value": "<templateName[0]>:50070",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.datanode.du.reserved",
      "templateName": ["datanode_du_reserved"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },

    {
      "name": "dfs.secondary.http.address",
      "templateName": ["snamenode_host"],
      "foreignKey": null,
      "value": "<templateName[0]>:50090",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.https.address",
      "templateName": ["namenode_host"],
      "foreignKey": null,
      "value": "<templateName[0]>:50470",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.datanode.data.dir.perm",
      "templateName": ["dfs_datanode_data_dir_perm"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    /**********************************************oozie-site***************************************/
    {
      "name": "oozie.base.url",
      "templateName": ["oozieserver_host"],
      "foreignKey": null,
      "value": "http://<templateName[0]>:11000/oozie",
      "filename": "oozie-site.xml"
    },
    /**********************************************hive-site***************************************/
    {
      "name": "javax.jdo.option.ConnectionUserName",
      "templateName": ["hive_metastore_user_name"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hive-site.xml"
    },
    {
      "name": "javax.jdo.option.ConnectionPassword",
      "templateName": ["hive_metastore_user_passwd"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hive-site.xml"
    },

    {
      "name": "hive.metastore.uris",
      "templateName": ["hivemetastore_host"],
      "foreignKey": null,
      "value": "thrift://<templateName[0]>:9083",
      "filename": "hive-site.xml"
    },
  /**********************************************yarn-site***************************************/
    {
      "name": "yarn.resourcemanager.resource-tracker.address",
      "templateName": ["rm_host"],
      "foreignKey": null,
      "value": "hdfs://<templateName[0]>:8025",
      "filename": "yarn-site.xml"
    },
    {
      "name": "yarn.resourcemanager.scheduler.address",
      "templateName": ["rm_host"],
      "foreignKey": null,
      "value": "hdfs://<templateName[0]>:8030",
      "filename": "yarn-site.xml"
    },
    {
      "name": "yarn.resourcemanager.address",
      "templateName": ["rm_host"],
      "foreignKey": null,
      "value": "hdfs://<templateName[0]>:8050",
      "filename": "yarn-site.xml"
    },
    {
      "name": "yarn.resourcemanager.admin.address",
      "templateName": ["rm_host"],
      "foreignKey": null,
      "value": "hdfs://<templateName[0]>:8041",
      "filename": "yarn-site.xml"
    },
  /**********************************************mapred-site***************************************/
    {
      "name": "mapreduce.jobhistory.webapp.address",
      "templateName": ["hs_host"],
      "foreignKey": null,
      "value": "hdfs://<templateName[0]>:19888",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapreduce.jobhistory.address",
      "templateName": ["hs_host"],
      "foreignKey": null,
      "value": "hdfs://<templateName[0]>:10020",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapreduce.map.memory.mb",
      "templateName": ["mapred_job_map_mem_mb"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapreduce.reduce.memory.mb",
      "templateName": ["mapred_job_red_mem_mb"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    //io.sort.mb -> mapreduce.task.io.sort.mb
    {
      "name": "mapreduce.task.io.sort.mb",
      "templateName": ["mapreduce_task_io_sort_mb"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.system.dir",
      "templateName": ["mapred_system_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.cluster.reduce.memory.mb",
      "templateName": ["mapred_cluster_red_mem_mb"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.hosts",
      "templateName": ["hadoop_conf_dir", "mapred_hosts_include"],
      "foreignKey": null,
      "value": "<templateName[0]>/<templateName[1]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.jobtracker.maxtasks.per.job",
      "templateName": ["maxtasks_per_job"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.userlog.retain.hours",
      "templateName": ["mapreduce_userlog_retainhours"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.local.dir",
      "templateName": ["mapred_local_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.task.tracker.task-controller",
      "templateName": ["task_controller"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.tasktracker.map.tasks.maximum",
      "templateName": ["mapred_map_tasks_max"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.hosts.exclude",
      "templateName": ["hadoop_conf_dir", "mapred_hosts_exclude"],
      "foreignKey": null,
      "value": "<templateName[0]>/<templateName[1]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.cluster.max.map.memory.mb",
      "templateName": ["mapred_cluster_max_map_mem_mb"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.cluster.max.reduce.memory.mb",
      "templateName": ["mapred_cluster_max_red_mem_mb"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.jobtracker.taskScheduler",
      "templateName": ["scheduler_name"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.healthChecker.script.path",
      "templateName": ["mapred_jobstatus_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.cluster.map.memory.mb",
      "templateName": ["mapred_cluster_map_mem_mb"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    /**********************************************hbase-site***************************************/
    {
      "name": "hbase.rootdir",
      "templateName": ["namenode_host", "hbase_hdfs_root_dir"],
      "foreignKey": null,
      "value": "hdfs://<templateName[0]>:8020<templateName[1]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.tmp.dir",
      "templateName": ["hbase_tmp_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.regionserver.global.memstore.upperLimit",
      "templateName": ["regionserver_memstore_upperlimit"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.hstore.blockingStoreFiles",
      "templateName": ["hstore_blockingstorefiles"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.hstore.compactionThreshold",
      "templateName": ["hstore_compactionthreshold"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hfile.block.cache.size",
      "templateName": ["hfile_blockcache_size"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.hregion.max.filesize",
      "templateName": ["hstorefile_maxsize"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.regionserver.handler.count",
      "templateName": ["regionserver_handlers"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.hregion.majorcompaction",
      "templateName": ["hregion_majorcompaction"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.regionserver.global.memstore.lowerLimit",
      "templateName": ["regionserver_memstore_lowerlimit"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.hregion.memstore.block.multiplier",
      "templateName": ["hregion_blockmultiplier"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.hregion.memstore.mslab.enabled",
      "templateName": ["regionserver_memstore_lab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.hregion.memstore.flush.size",
      "templateName": ["hregion_memstoreflushsize"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.client.scanner.caching",
      "templateName": ["client_scannercaching"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.client.scanner.caching",
      "templateName": ["client_scannercaching"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.cluster.distributed",
      "templateName": [],
      "foreignKey": null,
      "value": "true",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.zookeeper.property.clientPort",
      "templateName": [],
      "foreignKey": null,
      "value": "2181",
      "filename": "hbase-site.xml"
    },
    {
      "name": "zookeeper.session.timeout",
      "templateName": ["zookeeper_sessiontimeout"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.client.keyvalue.maxsize",
      "templateName": ["hfile_max_keyvalue_size"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "dfs.support.append",
      "templateName": ["hdfs_support_append"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "dfs.client.read.shortcircuit",
      "templateName": ["hdfs_enable_shortcircuit_read"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.security.authentication",
      "templateName": [],
      "foreignKey": null,
      "value": "simple",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.rpc.engine",
      "templateName": [],
      "foreignKey": null,
      "value": "org.apache.hadoop.hbase.ipc.WritableRpcEngine",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.security.authorization",
      "templateName": [],
      "foreignKey": null,
      "value": "false",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.zookeeper.quorum",
      "templateName": ["zookeeperserver_hosts"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "zookeeper.znode.parent",
      "templateName": [],
      "foreignKey": null,
      "value": "/hbase-unsecure",
      "filename": "hbase-site.xml"
    },
    /**********************************************webhcat-site***************************************/
    {
      "name": "templeton.hive.properties",
      "templateName": ["hivemetastore_host"],
      "foreignKey": null,
      "value": "hive.metastore.local=false,hive.metastore.uris=thrift://<templateName[0]>:9083,hive.metastore.sasl.enabled=yes,hive.metastore.execute.setugi=true",
      "filename": "webhcat-site.xml"
    },
    {
      "name": "templeton.zookeeper.hosts",
      "templateName": ["zookeeperserver_hosts"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "webhcat-site.xml"
    }
  ];

  /**
   * Configs consists of 2 types: Computed values, which cannot be modified by user
   * and overridable values, which user can modify. We provide interface how to get all of this
   * configs separately
   * @type {Object}
   */
  module.exports = {
    all : function(){
      return configs.slice(0);
    },
    overridable: function(){
      return configs.filterProperty('foreignKey');
    },
    computed: function(){
      return configs.filterProperty('foreignKey', null);
    }
  };
  
});
window.require.register("data/HDP2/config_properties", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * Defines service configuration properties.
   *   name:
   *     The name of the config property that is understood by Ambari server and agent.
   *     E.g., "datanode_du_reserved"
   *
   *   displayName:
   *     The human-friendly display name of the config property.
   *     E.g., "Reserved space for HDFS"
   *
   *   description:
   *     The description of the config property.
   *     E.g., "Reserved space in GB per volume"
   *
   *   defaultValue:
   *     The default value of the config property.
   *     E.g., "1"
   *
   *   isReconfigurable:
   *     Whether the config property can be reconfigured after it has been initially set and deployed.
   *     If this is unspecified, true is assumed.
   *     E.g., true, false
   *
   *   isOverridable:
   *     Whether the config property can be overridden by hosts.
   *     If this is unspecified, true is assumed.
   *
   *   isRequired:
   *     Whether the config property is required or not.
   *     If this is unspecified, true is assumed.
   *     E.g., true, false
   *
   *   displayType:
   *     How the config property is to be rendered for user input.
   *     If this is left unspecified, "string" is assumed
   *     E.g., "string", "int", "float", "checkbox", "directories", "custom", "email", "masterHost", "slaveHosts"
   *
   *   unit
   *     The unit for the config property.
   *     E.g., "ms", "MB", "bytes"
   *
   *   serviceName:
   *     The service that the config property belongs to.
   *     E.g., "HDFS", "MAPREDUCE2", "ZOOKEEPER", etc.
   *
   *   category: the category that the config property belongs to (used for grouping config properties in the UI).
   *     if unspecified, "General" is assumed.
   *     E.g., "General", "Advanced", "NameNode", "DataNode"
   *
   *   index: the sequence number in category, that point to place where config located regarding all rest in category.
   *     if unspecified, push to the end of array.
   *     E.g., 0, 1, '2'
   */

  var App = require('app');
  require('config');

  module.exports =
  {
    "configProperties": [
      /**********************************************HDFS***************************************/
      {
        "id": "puppet var",
        "name": "namenode_host",
        "displayName": "NameNode host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run NameNode/",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "NameNode",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "dfs_name_dir",
        "displayName": "NameNode directories",
        "description": "NameNode directories for HDFS to store the file system image",
        "defaultValue": "",
        "defaultDirectory": "/hadoop/hdfs/namenode",
        "displayType": "directories",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "NameNode",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "namenode_heapsize",
        "displayName": "NameNode Java heap size",
        "description": "Initial and maximum Java heap size for NameNode (Java options -Xms and -Xmx)",
        "defaultValue": "1024",
        "displayType": "int",
        "unit": "MB",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "NameNode",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "namenode_opt_newsize",
        "displayName": "NameNode new generation size",
        "description": "Default size of Java new generation for NameNode (Java option -XX:NewSize)",
        "defaultValue": "200",
        "displayType": "int",
        "unit": "MB",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "NameNode",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "snamenode_host",
        "displayName": "SNameNode host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run SecondaryNameNode",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "SNameNode",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "fs_checkpoint_dir",
        "displayName": "SecondaryNameNode Checkpoint directory",
        "description": "Directory on the local filesystem where the Secondary NameNode should store the temporary images to merge",
        "defaultValue": "",
        "defaultDirectory": "/hadoop/hdfs/namesecondary",
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "SNameNode",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "datanode_hosts", //not in the schema. For UI purpose
        "displayName": "DataNode hosts",
        "value": "",
        "defaultValue": "",
        "description": "The hosts that have been assigned to run DataNode",
        "displayType": "slaveHosts",
        "isRequired": false,
        "isOverridable": false,
        "isVisible": true,
        "domain": "datanode-global",
        "serviceName": "HDFS",
        "category": "DataNode",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "dfs_data_dir",
        "displayName": "DataNode directories",
        "description": "DataNode directories for HDFS to store the data blocks",
        "defaultValue": "",
        "defaultDirectory": "/hadoop/hdfs/data",
        "displayType": "directories",
        "isVisible": true,
        "domain": "datanode-global",
        "serviceName": "HDFS",
        "category": "DataNode",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "dtnode_heapsize",
        "displayName": "DataNode maximum Java heap size",
        "description": "Maximum Java heap size for DataNode (Java option -Xmx)",
        "defaultValue": "1024",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "datanode-global",
        "serviceName": "HDFS",
        "category": "DataNode",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "dfs_datanode_failed_volume_tolerated",
        "displayName": "DataNode volumes failure toleration",
        "description": "The number of volumes that are allowed to fail before a DataNode stops offering service",
        "defaultValue": "0",
        "displayType": "int",
        "isVisible": true,
        "domain": "datanode-global",
        "serviceName": "HDFS",
        "category": "DataNode",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "dfs_webhdfs_enabled",
        "displayName": "WebHDFS enabled",
        "description": "Whether to enable WebHDFS feature",
        "defaultValue": true,
        "displayType": "checkbox",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "hadoop_heapsize",
        "displayName": "Hadoop maximum Java heap size",
        "description": "Maximum Java heap size for daemons such as Balancer (Java option -Xmx)",
        "defaultValue": "1024",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "datanode_du_reserved",
        "displayName": "Reserved space for HDFS",
        "description": "Reserved space in GB per volume",
        "defaultValue": "1",
        "displayType": "int",
        "unit": "GB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "fs_checkpoint_period",
        "displayName": "HDFS Maximum Checkpoint Delay",
        "description": "Maximum delay between two consecutive checkpoints for HDFS",
        "defaultValue": "21600",
        "displayType": "int",
        "unit": "seconds",
        "isVisible": true,
        "domain": "global",
        "filename": "core-site.xml",
        "serviceName": "HDFS",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "fs_checkpoint_size",
        "displayName": "HDFS Maximum Edit Log Size for Checkpointing",
        "description": "Maximum size of the edits log file that forces an urgent checkpoint even if the maximum checkpoint delay is not reached",
        "defaultValue": "0.5",
        "displayType": "float",
        "unit": "GB",
        "isVisible": true,
        "domain": "global",
        "filename": "core-site.xml",
        "serviceName": "HDFS",
        "index": 4
      },
      {
        "id": "puppet var",
        "name": "hdfs_log_dir_prefix",
        "displayName": "Hadoop Log Dir Prefix",
        "description": "The parent directory for Hadoop log files.  The HDFS log directory will be ${hadoop_log_dir_prefix} / ${hdfs_user} and the MapReduce log directory will be ${hadoop_log_dir_prefix} / ${mapred_user}.",
        "defaultValue": "/var/log/hadoop",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hadoop_pid_dir_prefix",
        "displayName": "Hadoop PID Dir Prefix",
        "description": "The parent directory in which the PID files for Hadoop processes will be created.  The HDFS PID directory will be ${hadoop_pid_dir_prefix} / ${hdfs_user} and the MapReduce PID directory will be ${hadoop_pid_dir_prefix} / ${mapred_user}.",
        "defaultValue": "/var/run/hadoop",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "namenode_opt_maxnewsize",
        "displayName": "NameNode maximum new generation size",
        "description": "",
        "defaultValue": "640",
        "displayType": "int",
        "unit": "MB",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "NameNode"
      },
      {
        "id": "puppet var",
        "name": "dfs_exclude",
        "displayName": "Exclude hosts",
        "description": "Names a file that contains a list of hosts that are not permitted to connect to the namenode.  This file will be placed inside the Hadoop conf directory.",
        "defaultValue": "dfs.exclude",
        "displayType": "advanced",
        "isVisible": true,
        "filename": "hdfs-site.xml",
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "dfs_include",
        "displayName": "Include hosts",
        "description": "Names a file that contains a list of hosts that are permitted to connect to the namenode.  This file will be placed inside the Hadoop conf directory.",
        "defaultValue": "dfs.include",
        "displayType": "advanced",
        "isVisible": true,
        "filename": "hdfs-site.xml",
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "dfs_replication",
        "displayName": "Block replication",
        "description": "Default block replication.",
        "displayType": "int",
        "defaultValue": "3",
        "isVisible": true,
        "filename": "hdfs-site.xml",
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "dfs_block_local_path_access_user",
        "displayName": "dfs.block.local-path-access.user",
        "description": "the user who is allowed to perform short circuit reads",
        "displayType": "advanced",
        "defaultValue": "hbase",
        "isVisible": true,
        "filename": "hdfs-site.xml",
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "dfs_datanode_data_dir_perm",
        "displayName": "dfs_datanode_data_dir_perm",
        "description": "",
        "defaultValue": "750",
        "isReconfigurable": true,
        "displayType": "int",
        "isVisible": false,
        "filename": "hdfs-site.xml",
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "security_enabled",
        "displayName": "Hadoop Security",
        "description": "Enable hadoop security",
        "defaultValue": 'false',
        "isRequired": false,
        "displayType": "checkbox",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "namenode_formatted_mark_dir",
        "displayName": "Hadoop formatted mark directory",
        "description": "",
        "defaultValue": "/var/run/hadoop/hdfs/namenode/formatted/",
        "isRequired": false,
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "NameNode"
      },
      {
        "id": "puppet var",
        "name": "hcat_conf_dir",
        "displayName": "HCat conf directory",
        "description": "",
        "defaultValue": "",
        "isRequired": false,
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },

    /**********************************************MAPREDUCE2***************************************/
      {
        "id": "puppet var",
        "name": "hs_host",
        "displayName": "History Server",
        "description": "History Server",
        "defaultValue": "",
        "isOverridable": false,
        "displayType": "masterHost",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE2",
        "category": "HistoryServer",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "mapred_local_dir",
        "displayName": "MapReduce local directories",
        "description": "Directories for MapReduce to store intermediate data files",
        "defaultValue": "",
        "defaultDirectory": "/hadoop/mapred",
        "displayType": "directories",
        "isReconfigurable": true,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE2"
      },
      {
        "id": "puppet var",
        "name": "mapred_cluster_red_mem_mb",
        "displayName": "Cluster's Reduce slot size (virtual memory)",
        "description": "The virtual memory size of a single Reduce slot in the MapReduce framework",
        "defaultValue": "2048",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE2"
      },
      {
        "id": "puppet var",
        "name": "mapred_map_tasks_max",
        "displayName": "Number of Map slots per node",
        "description": "Number of slots that Map tasks that run simultaneously can occupy on a TaskTracker",
        "defaultValue": "4",
        "displayType": "int",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE2"
      },
      {
        "id": "puppet var",
        "name": "mapred_job_map_mem_mb",
        "displayName": "Default virtual memory for a job's map-task",
        "description": "Virtual memory for single Map task",
        "defaultValue": "1536",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE2"
      },
      {
        "id": "puppet var",
        "name": "mapred_job_red_mem_mb",
        "displayName": "Default virtual memory for a job's reduce-task",
        "description": "Virtual memory for single Reduce task",
        "defaultValue": "2048",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE2"
      },
      {
        "id": "puppet var",
        "name": "mapreduce_task_io_sort_mb",
        "displayName": "Map-side sort buffer memory",
        "description": "The total amount of Map-side buffer memory to use while sorting files (Expert-only configuration)",
        "defaultValue": "200",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE2"
      },
      {
        "id": "puppet var",
        "name": "mapreduce_userlog_retainhours",
        "displayName": "Job log retention (hours)",
        "description": "The maximum time, in hours, for which the user-logs are to be retained after the job completion.",
        "defaultValue": "24",
        "displayType": "int",
        "unit": "hours",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE2"
      },
      {
        "id": "puppet var",
        "name": "maxtasks_per_job",
        "displayName": "Maximum number tasks for a Job",
        "description": "Maximum number of tasks for a single Job",
        "defaultValue": "-1",
        "displayType": "int",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE2"
      },
      {
        "id": "puppet var",
        "name": "mapred_cluster_max_map_mem_mb",
        "displayName": "Upper limit on virtual memory for single Map task",
        "description": "Upper limit on virtual memory size for a single Map task of any MapReduce job",
        "defaultValue": "6144",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE2"
      },
      {
        "id": "puppet var",
        "name": "mapred_cluster_max_red_mem_mb",
        "displayName": "Upper limit on virtual memory for single Reduce task",
        "description": "Upper limit on virtual memory size for a single Reduce task of any MapReduce job",
        "defaultValue": "4096",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE2"
      },
      {
        "id": "puppet var",
        "name": "scheduler_name",
        "displayName": "MapReduce Capacity Scheduler",
        "description": "The scheduler to use for scheduling of MapReduce jobs",
        "defaultValue": "org.apache.hadoop.mapred.CapacityTaskScheduler",
        "displayType": "advanced",
        "isOverridable": false,
        "isVisible": true,
        "serviceName": "MAPREDUCE2"
      },
      {
        "id": "puppet var",
        "name": "mapred_cluster_map_mem_mb",
        "displayName": "Cluster's Map slot size (virtual memory)",
        "description": "The virtual memory size of a single Map slot in the MapReduce framework",
        "defaultValue": "1536",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE2"
      },
      {
        "id": "puppet var",
        "name": "mapred_system_dir",
        "displayName": "MapReduce system directories",
        "description": "",
        "defaultValue": "/mapred/system",
        "displayType": "directories",
        "isReconfigurable": true,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE2",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "mapred_hosts_include",
        "displayName": "Include hosts",
        "description": "Include enetered hosts",
        "defaultValue": "mapred.include",
        "displayType": "directories",
        "isVisible": false,
        "serviceName": "MAPREDUCE2",
        "domain": "global",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "task_controller",
        "displayName": "task_controller",
        "description": "",
        "defaultValue": "org.apache.hadoop.mapred.DefaultTaskController",
        "displayType": "advanced",
        "isVisible": false,
        "serviceName": "MAPREDUCE2",
        "domain": "global",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "mapred_hosts_exclude",
        "displayName": "Exclude hosts",
        "description": "Exclude entered hosts",
        "defaultValue": "mapred.exclude",
        "displayType": "directories",
        "isVisible": false,
        "serviceName": "MAPREDUCE2",
        "domain": "global",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "mapred_jobstatus_dir",
        "displayName": "Job Status directory",
        "description": "Directory path to view job status",
        "defaultValue": "file:////mapred/jobstatus",
        "displayType": "advanced",
        "isVisible": false,
        "serviceName": "MAPREDUCE2",
        "domain": "global",
        "category": "Advanced"
      },
    /**********************************************YARN***************************************/
      {
        "id": "puppet var",
        "name": "rm_host",
        "displayName": "Resource Manager",
        "description": "Resource Manager",
        "defaultValue": "",
        "isOverridable": false,
        "displayType": "masterHost",
        "isVisible": true,
        "domain": "global",
        "serviceName": "YARN",
        "category": "ResourceManager",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "nm_hosts",
        "displayName": "Node Manager",
        "description": "List of Node Manager Hosts.",
        "defaultValue": "",
        "isOverridable": false,
        "displayType": "slaveHosts",
        "isVisible": true,
        "domain": "global",
        "serviceName": "YARN",
        "category": "NodeManager",
        "index": 0
      },
    /**********************************************HBASE***************************************/
      {
        "id": "puppet var",
        "name": "hbasemaster_host",
        "displayName": "HBase Master hosts",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run HBase Master",
        "displayType": "masterHosts",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "HBase Master",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "hbase_master_heapsize",
        "displayName": "HBase Master Maximum Java heap size",
        "description": "Maximum Java heap size for HBase master (Java option -Xmx)",
        "defaultValue": "1024",
        "displayType": "int",
        "unit": "MB",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "HBase Master",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "regionserver_hosts",
        "displayName": "RegionServer hosts",
        "value": "",
        "defaultValue": "",
        "description": "The hosts that have been assigned to run RegionServer",
        "displayType": "slaveHosts",
        "isOverridable": false,
        "isVisible": true,
        "isRequired": false,
        "domain": "regionserver-global",
        "serviceName": "HBASE",
        "category": "RegionServer",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "hbase_regionserver_heapsize",
        "displayName": "HBase RegionServers maximum Java heap size",
        "description": "Maximum Java heap size for HBase RegionServers (Java option -Xmx)",
        "defaultValue": "1024",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "regionserver-global",
        "serviceName": "HBASE",
        "category": "RegionServer",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "regionserver_handlers",
        "displayName": "HBase RegionServer Handler",
        "description": "Count of RPC Listener instances spun up on RegionServers",
        "defaultValue": "60",
        "displayType": "int",
        "isVisible": true,
        "domain": "regionserver-global",
        "serviceName": "HBASE",
        "category": "RegionServer",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "hregion_majorcompaction",
        "displayName": "HBase Region Major Compaction",
        "description": "The time between major compactions of all HStoreFiles in a region. Set to 0 to disable automated major compactions.",
        "defaultValue": "86400000",
        "displayType": "int",
        "unit": "ms",
        "isVisible": true,
        "domain": "regionserver-global",
        "serviceName": "HBASE",
        "category": "RegionServer",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "hregion_blockmultiplier",
        "displayName": "HBase Region Block Multiplier",
        "description": "Block updates if memstore has \"Multiplier * HBase Region Memstore Flush Size\" bytes. Useful preventing runaway memstore during spikes in update traffic",
        "defaultValue": "2",
        "displayType": "int",
        "isVisible": true,
        "domain": "regionserver-global",
        "serviceName": "HBASE",
        "category": "RegionServer",
        "index": 4
      },
      {
        "id": "puppet var",
        "name": "hregion_memstoreflushsize",
        "displayName": "HBase Region Memstore Flush Size",
        "description": "Memstore will be flushed to disk if size of the memstore exceeds this number of bytes.",
        "defaultValue": "134217728",
        "displayType": "int",
        "unit": "bytes",
        "isVisible": true,
        "domain": "regionserver-global",
        "serviceName": "HBASE",
        "category": "RegionServer",
        "index": 5
      },
      {
        "id": "puppet var",
        "name": "hstore_compactionthreshold",
        "displayName": "HBase HStore compaction threshold",
        "description": "If more than this number of HStoreFiles in any one HStore then a compaction is run to rewrite all HStoreFiles files as one.",
        "defaultValue": "3",
        "displayType": "int",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "hfile_blockcache_size",
        "displayName": "HFile block cache size ",
        "description": "Percentage of maximum heap (-Xmx setting) to allocate to block cache used by HFile/StoreFile. Set to 0 to disable but it's not recommended.",
        "defaultValue": "0.40",
        "displayType": "float",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "hstorefile_maxsize",
        "displayName": "Maximum HStoreFile Size",
        "description": "If any one of a column families' HStoreFiles has grown to exceed this value, the hosting HRegion is split in two.",
        "defaultValue": "10737418240",
        "displayType": "int",
        "unit": "bytes",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "client_scannercaching",
        "displayName": "HBase Client Scanner Caching",
        "description": "Number of rows that will be fetched when calling next on a scanner if it is not served from (local, client) memory. Do not set this value such that the time between invocations is greater than the scanner timeout",
        "defaultValue": "100",
        "displayType": "int",
        "unit": "rows",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "zookeeper_sessiontimeout",
        "displayName": "Zookeeper timeout for HBase Session",
        "description": "HBase passes this to the zk quorum as suggested maximum time for a session",
        "defaultValue": "60000",
        "displayType": "int",
        "unit": "ms",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "index": 4
      },
      {
        "id": "puppet var",
        "name": "hfile_max_keyvalue_size",
        "displayName": "HBase Client Maximum key-value Size",
        "description": "Specifies the combined maximum allowed size of a KeyValue instance. It should be set to a fraction of the maximum region size.",
        "defaultValue": "10485760",
        "displayType": "int",
        "unit": "bytes",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "index": 5
      },
      {
        "id": "puppet var",
        "name": "hbase_log_dir",
        "displayName": "HBase Log Dir",
        "description": "Directory for HBase logs",
        "defaultValue": "/var/log/hbase",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hbase_pid_dir",
        "displayName": "HBase PID Dir",
        "description": "Directory in which the pid files for HBase processes will be created",
        "defaultValue": "/var/run/hbase",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hbase_hdfs_root_dir",
        "displayName": "Hbase relative path to HDFS",
        "description": "Hbase relative directory to HDFS",
        "defaultValue": "/apps/hbase/data",
        "isRequired": true,
        "displayType": "advanced",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hbase_tmp_dir",
        "displayName": "Hbase temp directory",
        "description": "",
        "defaultValue": "/var/log/hbase",
        "isRequired": false,
        "displayType": "advanced",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hdfs_enable_shortcircuit_read",
        "displayName": "HDFS Short-circuit read",
        "description": "",
        "defaultValue": true,
        "isRequired": false,
        "displayType": "checkbox",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hdfs_support_append",
        "displayName": "HDFS append support",
        "description": "HDFS append support",
        "defaultValue": true,
        "isRequired": false,
        "displayType": "checkbox",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hstore_blockingstorefiles",
        "displayName": "hstore blocking storefiles",
        "description": "If more than this number of StoreFiles in any one Store (one StoreFile is written per flush of " +
          "MemStore) then updates are blocked for this HRegion until a compaction is completed, or until " +
          "hbase.hstore.blockingWaitTime has been exceeded.",
        "defaultValue": 7,
        "isRequired": true,
        "displayType": "init",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "regionserver_memstore_lab",
        "displayName": "regionserver_memstore_lab",
        "description": "",
        "defaultValue": true,
        "isRequired": false,
        "displayType": "checkbox",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "regionserver_memstore_lowerlimit",
        "displayName": "regionserver_memstore_lowerlimit",
        "description": "",
        "defaultValue": "0.38",
        "isRequired": false,
        "displayType": "float",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "regionserver_memstore_upperlimit",
        "displayName": "regionserver_memstore_upperlimit",
        "description": "",
        "defaultValue": "0.4",
        "isRequired": true,
        "displayType": "float",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
    /**********************************************HIVE***************************************/
      {
        "id": "puppet var",
        "name": "hivemetastore_host",
        "displayName": "Hive Metastore host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run Hive Metastore",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 0
      },
      // for existing MySQL
      {
        "id": "puppet var",
        "name": "hive_existing_mysql_database",
        "displayName": "Database Type",
        "value": "",
        "defaultValue": "MySQL",
        "description": "Using an existing MySQL database for Hive Metastore",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": false,
        "isReconfigurable": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 1
      },
      // for existing Oracle
      {
        "id": "puppet var",
        "name": "hive_existing_oracle_database",
        "displayName": "Database Type",
        "value": "",
        "defaultValue": "Oracle",
        "description": "Using an existing Oracle database for Hive Metastore",
        "displayType": "masterHost",
        "isVisible": false,
        "isOverridable": false,
        "isReconfigurable": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 1
      },
      // for new MySQL
      {
        "id": "puppet var",
        "name": "hive_ambari_database",
        "displayName": "Database Type",
        "value": "",
        "defaultValue": "MySQL",
        "description": "MySQL will be installed by Ambari",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "hive_database",
        "displayName": "Hive Database",
        "value": "",
        "defaultValue": "New MySQL Database",
        "options": [
          {
            displayName: 'New MySQL Database',
            foreignKeys: ['hive_ambari_database', 'hive_ambari_host']
          },
          {
            displayName: 'Existing MySQL Database',
            foreignKeys: ['hive_existing_mysql_database', 'hive_existing_mysql_host']
          },
          {
            displayName: 'Existing Oracle Database',
            foreignKeys: ['hive_existing_oracle_database', 'hive_existing_oracle_host'],
            hidden: !App.supports.hiveOozieExtraDatabases
          }
        ],
        "description": "MySQL will be installed by Ambari",
        "displayType": "radio button",
        "isReconfigurable": false,
        "radioName": "hive-database",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "hive_existing_mysql_host",
        "displayName": "Database Host",
        "description": "Specify the host on which the existing database is hosted",
        "defaultValue": "",
        "isReconfigurable": false,
        "displayType": "host",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "hive_existing_oracle_host",
        "displayName": "Database Host",
        "description": "Specify the host on which the existing database is hosted",
        "defaultValue": "",
        "isReconfigurable": false,
        "displayType": "host",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "hive_ambari_host",
        "value": "",
        "defaultValue": "",
        "displayName": "Database Host",
        "description": "Host on which the database will be created by Ambari",
        "isReconfigurable": false,
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "hive_database_name",
        "displayName": "Database Name",
        "description": "Database name used as the Hive Metastore",
        "defaultValue": "hive",
        "isReconfigurable": false,
        "displayType": "host",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 4
      },
      {
        "id": "puppet var",
        "name": "hive_metastore_user_name",
        "displayName": "Database Username",
        "description": "Database user name to use to connect to the database",
        "defaultValue": "hive",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 5
      },
      {
        "id": "puppet var",
        "name": "hive_metastore_user_passwd",
        "displayName": "Database Password",
        "description": "Database password to use to connect to the PostgreSQL database",
        "defaultValue": "",
        "isReconfigurable": false,
        "displayType": "password",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 6
      },
      {
        "id": "puppet var",
        "name": "hive_metastore_port",
        "displayName": "Hive metastore port",
        "description": "",
        "defaultValue": "9083",
        "isReconfigurable": false,
        "displayType": "int",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hive_lib",
        "displayName": "Hive library",
        "description": "",
        "defaultValue": "/usr/lib/hive/lib/",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hive_conf_dir",
        "displayName": "Hive conf directory",
        "description": "",
        "defaultValue": "/etc/hive/conf",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hive_dbroot",
        "displayName": "Hive db directory",
        "description": "",
        "defaultValue": "/usr/lib/hive/lib",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hive_log_dir",
        "displayName": "Hive Log Dir",
        "description": "Directory for Hive log files",
        "defaultValue": "/var/log/hive",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hive_pid_dir",
        "displayName": "Hive PID Dir",
        "description": "Directory in which the PID files for Hive processes will be created",
        "defaultValue": "/var/run/hive",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "mysql_connector_url",
        "displayName": "MySQL connector url",
        "description": "",
        "defaultValue": "${download_url}/mysql-connector-java-5.1.18.zip",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hive_aux_jars_path",
        "displayName": "Hive auxilary jar path",
        "description": "",
        "defaultValue": "/usr/lib/hcatalog/share/hcatalog/hcatalog-core.jar",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
    /**********************************************WEBHCAT***************************************/
      {
        "id": "puppet var",
        "name": "webhcatserver_host",
        "displayName": "WebHCat Server host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run WebHCat Server",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "WEBHCAT",
        "category": "WebHCat Server"
      },
      {
        "id": "puppet var",
        "name": "hcat_log_dir",
        "displayName": "WebHCat Log Dir",
        "description": "Directory for WebHCat log files",
        "defaultValue": "/var/log/webhcat",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "WEBHCAT",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hcat_pid_dir",
        "displayName": "WebHCat PID Dir",
        "description": "Directory in which the PID files for WebHCat processes will be created",
        "defaultValue": "/var/run/webhcat",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "WEBHCAT",
        "category": "Advanced"
      },
    /**********************************************OOZIE***************************************/
      {
        "id": "puppet var",
        "name": "oozieserver_host",
        "displayName": "Oozie Server host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run Oozie Server",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 0
      },
      // for existing Oracle
      {
        "id": "puppet var",
        "name": "oozie_existing_oracle_database",
        "displayName": "Database Type",
        "value": "",
        "defaultValue": "Oracle",
        "description": "Using an existing Oracle database for Oozie Metastore",
        "displayType": "masterHost",
        "isVisible": false,
        "isReconfigurable": false,
        "isOverridable": false,
        //"domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 1
      },
      // for new MySQL
      {
        "id": "puppet var",
        "name": "oozie_ambari_database",
        "displayName": "Database Type",
        "value": "",
        "defaultValue": "MySQL",
        "description": "MySQL will be installed by Ambari",
        "displayType": "masterHost",
        "isVisible": false,
        "isOverridable": false,
        // "domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 1
      },
      // for current derby
      {
        "id": "puppet var",
        "name": "oozie_derby_database",
        "displayName": "Database Type",
        "value": "",
        "defaultValue": "Derby",
        "description": "Using current Derby database for Oozie Metastore",
        "displayType": "masterHost",
        "isVisible": false,
        "isReconfigurable": false,
        "isOverridable": false,
        // "domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 1
      },
      // for existing MySQL oozie
      {
        "id": "puppet var",
        "name": "oozie_existing_mysql_database",
        "displayName": "Database Type",
        "value": "",
        "defaultValue": "MySQL",
        "description": "Using an existing MySQL database for Oozie Metastore",
        "displayType": "masterHost",
        "isVisible": false,
        "isReconfigurable": false,
        "isOverridable": false,
        //"domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "oozie_database",
        "displayName": "Oozie Database",
        "value": "",
        "defaultValue": "New Derby Database",
        "options": [
          {
            displayName: 'New Derby Database',
            foreignKeys: ['oozie_derby_database']
          },
          {
            displayName: 'New MySQL Database',
            foreignKeys: ['oozie_ambari_database', 'oozie_ambari_host'],
            hidden: !App.supports.hiveOozieExtraDatabases
          },
          {
            displayName: 'Existing MySQL Database',
            foreignKeys: ['oozie_existing_mysql_database', 'oozie_existing_mysql_host'],
            hidden: !App.supports.hiveOozieExtraDatabases
          },
          {
            displayName: 'Existing Oracle Database',
            foreignKeys: ['oozie_existing_oracle_database', 'oozie_existing_oracle_host'],
            hidden: !App.supports.hiveOozieExtraDatabases
          }
        ],
        "description": "Current Derby Database will be installed by Ambari",
        "displayType": "radio button",
        "isReconfigurable": false,
        "isOverridable": false,
        "radioName": "oozie-database",
        "isVisible": true,
        "domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "oozie_database_name",
        "displayName": "Database Name",
        "description": "Database name used for the Oozie",
        "defaultValue": "oozie",
        "isReconfigurable": false,
        "isOverridable": false,
        "displayType": "host",
        "isVisible": true,
        //"domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "oozie_metastore_user_name",
        "displayName": "Database Username",
        "description": "Database user name to use to connect to the database",
        "defaultValue": "oozie",
        "isReconfigurable": false,
        "isOverridable": false,
        "displayType": "user",
        "isVisible": true,
        //"domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 4
      },
      {
        "id": "puppet var",
        "name": "oozie_metastore_user_passwd",
        "displayName": "Database Password",
        "description": "Database password to use to connect to the database",
        "defaultValue": "",
        "isReconfigurable": false,
        "isOverridable": false,
        "displayType": "password",
        "isVisible": true,
        //"domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 5
      },
      {
        "id": "puppet var",
        "name": "oozie_data_dir",
        "displayName": "Oozie Data Dir",
        "description": "Data directory in which the Oozie DB exists",
        "defaultValue": "",
        "defaultDirectory": "/hadoop/oozie/data",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "isRequired": false,
        "domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 6
      },
      {
        "id": "puppet var",
        "name": "oozie_existing_mysql_host",
        "displayName": "Database Host",
        "description": "Specify the host on which the existing database is hosted",
        "defaultValue": "",
        "isReconfigurable": false,
        "isOverridable": false,
        "displayType": "host",
        "isVisible": false,
        //"domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server"
      },
      {
        "id": "puppet var",
        "name": "oozie_existing_oracle_host",
        "displayName": "Database Host",
        "description": "Specify the host on which the existing database is hosted",
        "defaultValue": "",
        "isReconfigurable": false,
        "isOverridable": false,
        "displayType": "host",
        "isVisible": false,
        //"domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server"
      },
      {
        "id": "puppet var",
        "name": "oozie_ambari_host",
        "value": "",
        "defaultValue": "",
        "displayName": "Database Host",
        "description": "Host on which the database will be created by Ambari",
        "isReconfigurable": false,
        "isOverridable": false,
        "displayType": "masterHost",
        "isVisible": false,
        //"domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server"
      },
      {
        "id": "puppet var",
        "name": "oozie_log_dir",
        "displayName": "Oozie Log Dir",
        "description": "Directory for oozie logs",
        "defaultValue": "/var/log/oozie",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "OOZIE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "oozie_pid_dir",
        "displayName": "Oozie PID Dir",
        "description": "Directory in which the pid files for oozie processes will be created",
        "defaultValue": "/var/run/oozie",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "OOZIE",
        "category": "Advanced"
      },
    /**********************************************NAGIOS***************************************/
      {
        "id": "puppet var",
        "name": "nagios_web_login",
        "displayName": "Nagios Admin username",
        "description": "Nagios Web UI Admin username",
        "defaultValue": "nagiosadmin",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "domain": "global",
        "isVisible": true,
        "serviceName": "NAGIOS",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "nagios_web_password",
        "displayName": "Nagios Admin password",
        "description": "Nagios Web UI Admin password",
        "defaultValue": "",
        "isReconfigurable": false,
        "displayType": "password",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "NAGIOS",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "nagios_contact",
        "displayName": "Hadoop Admin email",
        "description": "Hadoop Administrator email for alert notification",
        "defaultValue": "",
        "displayType": "email",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "NAGIOS",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "nagios_group",
        "displayName": "Nagios Group",
        "description": "Nagios Group",
        "defaultValue": "nagios",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "domain": "global",
        "isVisible": false,
        "serviceName": "NAGIOS"
      },
    /**********************************************ZOOKEEPER***************************************/
      {
        "id": "puppet var",
        "name": "zookeeperserver_hosts",
        "displayName": "ZooKeeper Server hosts",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run ZooKeeper Server",
        "displayType": "masterHosts",
        "isVisible": true,
        "isOverridable": false,
        "isRequired": false,
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "zk_data_dir",
        "displayName": "ZooKeeper directory",
        "description": "Data directory for ZooKeeper",
        "defaultValue": "",
        "defaultDirectory": "/hadoop/zookeeper",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": true,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "tickTime",
        "displayName": "Length of single Tick",
        "description": "The length of a single tick in milliseconds, which is the basic time unit used by ZooKeeper",
        "defaultValue": "2000",
        "displayType": "int",
        "unit": "ms",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "initLimit",
        "displayName": "Ticks to allow for sync at Init",
        "description": "Amount of time, in ticks to allow followers to connect and sync to a leader",
        "defaultValue": "10",
        "displayType": "int",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "syncLimit",
        "displayName": "Ticks to allow for sync at Runtime",
        "description": "Amount of time, in ticks to allow followers to connect",
        "defaultValue": "5",
        "displayType": "int",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server",
        "index": 4
      },
      {
        "id": "puppet var",
        "name": "clientPort",
        "displayName": "Port for running ZK Server",
        "description": "Port for running ZooKeeper server",
        "defaultValue": "2181",
        "displayType": "int",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server",
        "index": 5
      },
      {
        "id": "puppet var",
        "name": "zk_log_dir",
        "displayName": "ZooKeeper Log Dir",
        "description": "Directory for ZooKeeper log files",
        "defaultValue": "/var/log/zookeeper",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "Advanced",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "zk_pid_dir",
        "displayName": "ZooKeeper PID Dir",
        "description": "Directory in which the pid files for zookeeper processes will be created",
        "defaultValue": "/var/run/zookeeper",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "Advanced",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "zk_pid_file",
        "displayName": "ZooKeeper PID File",
        "description": "",
        "defaultValue": "/var/run/zookeeper/zookeeper_server.pid",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "Advanced"
      },
    /**********************************************HUE***************************************/
      {
        "id": "puppet var",
        "name": "hueserver_host",
        "displayName": "Hue Server host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run Hue Server",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HUE",
        "category": "Hue Server"
      },
      {
        "id": "puppet var",
        "name": "hue_log_dir",
        "displayName": "HUE Log Dir",
        "description": "Directory for HUE logs",
        "defaultValue": "/var/log/hue",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HUE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hue_pid_dir",
        "displayName": "HUE Pid Dir",
        "description": "Directory in which the pid files for HUE processes will be created",
        "defaultValue": "/var/run/hue",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HUE",
        "category": "Advanced"
      },
    /**********************************************GANGLIA***************************************/
      {
        "id": "puppet var",
        "name": "ganglia_conf_dir",
        "displayName": "Ganglia conf directory",
        "description": "",
        "defaultValue": "/etc/ganglia/hdp",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "GANGLIA",
        "category": "Advanced"
      },
    /**********************************************MISC***************************************/
      {
        "id": "puppet var",
        "name": "hbase_conf_dir",
        "displayName": "HBase conf dir",
        "description": "",
        "defaultValue": "/etc/hbase",
        "isRequired": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "proxyuser_group",
        "displayName": "Proxy group for Hive, WebHCat, and Oozie",
        "description": "",
        "defaultValue": "users",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "filename": "core-site.xml",
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["HIVE","WEBHCAT","OOZIE"]
      },
      {
        "id": "puppet var",
        "name": "dfs_datanode_address",
        "displayName": "dfs_datanode_address",
        "description": "",
        "defaultValue": "50010",
        "isReconfigurable": true,
        "displayType": "int",
        "isVisible": true,
        "filename": "hdfs-site.xml",
        "domain": "global",
        "serviceName": "MISC",
        "category": "Advanced",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "dfs_datanode_http_address",
        "displayName": "dfs_datanode_http_address",
        "description": "",
        "defaultValue": "50075",
        "isReconfigurable": true,
        "displayType": "int",
        "isVisible": true,
        "filename": "hdfs-site.xml",
        "domain": "global",
        "serviceName": "MISC",
        "category": "Advanced",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "gpl_artifacts_download_url",
        "displayName": "gpl artifact download url",
        "description": "",
        "defaultValue": "",
        "isReconfigurable": false,
        "displayType": "advanced",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "apache_artifacts_download_url",
        "displayName": "apache artifact download url",
        "description": "",
        "defaultValue": "",
        "isReconfigurable": false,
        "displayType": "advanced",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "ganglia_runtime_dir",
        "displayName": "Ganglia runtime directory",
        "description": "",
        "defaultValue": "/var/run/ganglia/hdp",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "java64_home",
        "displayName": "Path to 64-bit JAVA_HOME",
        "description": "Path to 64-bit JAVA_HOME.  /usr/jdk/jdk1.6.0_31 is the default used by Ambari.  You can override this to a specific path that contains the JDK.  Note that the path must be valid on ALL hosts in your cluster.",
        "defaultValue": "/usr/jdk64/jdk1.6.0_31",
        "isRequired": true,
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "run_dir",
        "displayName": "Hadoop run directory",
        "description": "",
        "defaultValue": "/var/run/hadoop",
        "isRequired": false,
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Advanced",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "hadoop_conf_dir",
        "displayName": "Hadoop conf directory",
        "description": "",
        "defaultValue": "/etc/hadoop",
        "isRequired": false,
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Advanced",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "hdfs_user",
        "displayName": "HDFS User",
        "description": "User to run HDFS as",
        "defaultValue": "hdfs",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "serviceName": "MISC",
        "domain": "global",
        "category": "Users and Groups",
        "belongsToService":["HDFS"]
      },
      {
        "id": "puppet var",
        "name": "mapred_user",
        "displayName": "MapReduce User",
        "description": "User to run MapReduce as",
        "defaultValue": "mapred",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["MAPREDUCE"]
      },
      {
        "id": "puppet var",
        "name": "hbase_user",
        "displayName": "HBase User",
        "description": "User to run HBase as",
        "defaultValue": "hbase",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["HBASE"]
      },
      {
        "id": "puppet var",
        "name": "hive_user",
        "displayName": "Hive User",
        "description": "User to run Hive as",
        "defaultValue": "hive",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["HIVE"]
      },
      {
        "id": "puppet var",
        "name": "hcat_user",
        "displayName": "HCat User",
        "description": "User to run HCatalog as",
        "defaultValue": "hcat",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["HCATALOG"]
      },
      {
        "id": "puppet var",
        "name": "webhcat_user",
        "displayName": "WebHCat User",
        "description": "User to run WebHCat as",
        "defaultValue": "hcat",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["WEBHCAT"]
      },
      {
        "id": "puppet var",
        "name": "oozie_user",
        "displayName": "Oozie User",
        "description": "User to run Oozie as",
        "defaultValue": "oozie",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["OOZIE"]
      },
      {
        "id": "puppet var",
        "name": "zk_user",
        "displayName": "ZooKeeper User",
        "description": "User to run ZooKeeper as",
        "defaultValue": "zookeeper",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["ZOOKEEPER"]
      },
      {
        "id": "puppet var",
        "name": "gmetad_user",
        "displayName": "Ganglia User",
        "description": "The user used to run Ganglia",
        "defaultValue": "nobody",
        "isReconfigurable": false,
        "displayType": "advanced",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["GANGLIA"]
      },
      {
        "id": "puppet var",
        "name": "gmond_user",
        "displayName": "Gmond User",
        "description": "The user used to run gmond for Ganglia",
        "defaultValue": "nobody",
        "isReconfigurable": false,
        "displayType": "advanced",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName":"MISC",
        "category": "Users and Groups",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "nagios_user",
        "displayName": "Nagios User",
        "description": "User to run Nagios as",
        "defaultValue": "nagios",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "domain": "global",
        "isVisible": true,
        "serviceName":"MISC",
        "category": "Users and Groups",
        "belongsToService":["NAGIOS"]
      },
      {
        "id": "puppet var",
        "name": "smokeuser",
        "displayName": "Smoke Test User",
        "description": "The user used to run service smoke tests",
        "defaultValue": "ambari-qa",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": App.supports.customizeSmokeTestUser,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["HDFS"]
      },
      {
        "id": "puppet var",
        "name": "user_group",
        "displayName": "Group",
        "description": "Group that the users specified above belong to",
        "defaultValue": "hadoop",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["HDFS"]
      },
      {
        "id": "puppet var",
        "name": "rrdcached_base_dir",
        "displayName": "Ganglia rrd cached base directory",
        "description": "Default directory for saving the rrd files on ganglia server",
        "defaultValue": "/var/lib/ganglia/rrds",
        "displayType": "directory",
        "isOverridable": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General",
        "belongsToService":["GANGLIA"]
      }
    ]
  };
  
});
window.require.register("data/config_mapping", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var configs = [
    {
      "name": "fs.default.name",
      "templateName": ["namenode_host"],
      "foreignKey": null,
      "value": "hdfs://<templateName[0]>:8020",
      "filename": "core-site.xml"
    },
    {
      "name": "fs.checkpoint.dir",
      "templateName": ["fs_checkpoint_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "core-site.xml"
    },
    {
      "name": "fs.checkpoint.period",
      "templateName": ["fs_checkpoint_period"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "core-site.xml"
    },
    {
      "name": "fs.checkpoint.size",
      "templateName": ["fs_checkpoint_size"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "core-site.xml"
    },
    {
      "name": "fs.checkpoint.edits.dir",
      "templateName": ["fs_checkpoint_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "core-site.xml"
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.groups",
      "templateName": ["proxyuser_group"],
      "foreignKey": ["hive_user"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "isOverridable" : true
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.hosts",
      "templateName": ["hivemetastore_host"],
      "foreignKey": ["hive_user"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "isOverridable" : true
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.groups",
      "templateName": ["proxyuser_group"],
      "foreignKey": ["oozie_user"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "isOverridable" : true
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.hosts",
      "templateName": ["oozieserver_host"],
      "foreignKey": ["oozie_user"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "isOverridable" : true
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.groups",
      "templateName": ["proxyuser_group"],
      "foreignKey": ["webhcat_user"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "isOverridable" : true
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.hosts",
      "templateName": ["hivemetastore_host"],
      "foreignKey": ["webhcat_user"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "isOverridable" : true
    },
    {
      "name": "dfs.name.dir",
      "templateName": ["dfs_name_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    /*
    {
      "name": "dfs.support.append",
      "templateName": ["dfs_support_append"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    */
    {
      "name": "dfs.webhdfs.enabled",
      "templateName": ["dfs_webhdfs_enabled"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.datanode.failed.volumes.tolerated",
      "templateName": ["dfs_datanode_failed_volume_tolerated"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.block.local-path-access.user",
      "templateName": ["dfs_block_local_path_access_user"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.data.dir",
      "templateName": ["dfs_data_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.hosts.exclude",
      "templateName": ["hadoop_conf_dir", "dfs_exclude"],
      "foreignKey": null,
      "value": "<templateName[0]>\/<templateName[1]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.hosts",
      "templateName": ["hadoop_conf_dir", "dfs_include"],
      "foreignKey": null,
      "value": "<templateName[0]>\/<templateName[1]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.replication",
      "templateName": ["dfs_replication"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.datanode.address",
      "templateName": ["dfs_datanode_address"],
      "foreignKey": null,
      "value": "0.0.0.0:<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.datanode.http.address",
      "templateName": ["dfs_datanode_http_address"],
      "foreignKey": null,
      "value": "0.0.0.0:<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.http.address",
      "templateName": ["namenode_host"],
      "foreignKey": null,
      "value": "<templateName[0]>:50070",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.datanode.du.reserved",
      "templateName": ["datanode_du_reserved"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.secondary.http.address",
      "templateName": ["snamenode_host"],
      "foreignKey": null,
      "value": "<templateName[0]>:50090",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.https.address",
      "templateName": ["namenode_host"],
      "foreignKey": null,
      "value": "<templateName[0]>:50470",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.datanode.data.dir.perm",
      "templateName": ["dfs_datanode_data_dir_perm"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "mapred.local.dir",
      "templateName": ["mapred_local_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "oozie.base.url",
      "templateName": ["oozieserver_host"],
      "foreignKey": null,
      "value": "http://<templateName[0]>:11000/oozie",
      "filename": "oozie-site.xml"
    },
    {
      "name": "oozie.service.JPAService.create.db.schema",
      "templateName": [],
      "foreignKey": null,
      "value": "false",  // this is always false
      "filename": "oozie-site.xml"
    },
    {
      "name": "oozie.db.schema.name",
      "templateName": ['oozie_database_name'],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "oozie-site.xml"
    },
    {
      "name": "oozie.service.JPAService.jdbc.driver",
      "templateName": [],
      "foreignKey": null,
      "value": "org.apache.derby.jdbc.EmbeddedDriver",  // this value is overwritten in code
      "filename": "oozie-site.xml"
    },
    {
      "name": "oozie.service.JPAService.jdbc.username",
      "templateName": ['oozie_metastore_user_name'],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "oozie-site.xml"
    },
    {
      "name": "oozie.service.JPAService.jdbc.password",
      "templateName": ['oozie_metastore_user_passwd'],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "oozie-site.xml"
    },
    {
      "name": "oozie.service.JPAService.jdbc.url",
      "templateName": ["oozie_jdbc_connection_url"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "oozie-site.xml"
    },
    {
      "name": "javax.jdo.option.ConnectionDriverName",
      "templateName": [],
      "foreignKey": null,
      "value": "com.mysql.jdbc.Driver",  // this value is overwritten in code
      "filename": "hive-site.xml"
    },
    {
      "name": "javax.jdo.option.ConnectionUserName",
      "templateName": ["hive_metastore_user_name"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hive-site.xml"
    },
    {
      "name": "javax.jdo.option.ConnectionPassword",
      "templateName": ["hive_metastore_user_passwd"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hive-site.xml"
    },
    {
      "name": "javax.jdo.option.ConnectionURL",
      "templateName": ["hive_jdbc_connection_url"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hive-site.xml"
    },
    {
      "name": "hive.metastore.uris",
      "templateName": ["hivemetastore_host"],
      "foreignKey": null,
      "value": "thrift://<templateName[0]>:9083",
      "filename": "hive-site.xml"
    },
    {
      "name": "mapred.jobtracker.taskScheduler",
      "templateName": ["scheduler_name"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.tasktracker.map.tasks.maximum",
      "templateName": ["mapred_map_tasks_max"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.tasktracker.reduce.tasks.maximum",
      "templateName": ["mapred_red_tasks_max"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.cluster.reduce.memory.mb",
      "templateName": ["mapred_cluster_red_mem_mb"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.job.map.memory.mb",
      "templateName": ["mapred_job_map_mem_mb"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.cluster.max.map.memory.mb",
      "templateName": ["mapred_cluster_max_map_mem_mb"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.cluster.max.reduce.memory.mb",
      "templateName": ["mapred_cluster_max_red_mem_mb"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.job.reduce.memory.mb",
      "templateName": ["mapred_job_red_mem_mb"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.hosts",
      "templateName": ["hadoop_conf_dir", "mapred_hosts_include"],
      "foreignKey": null,
      "value": "<templateName[0]>/<templateName[1]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.hosts.exclude",
      "templateName": ["hadoop_conf_dir", "mapred_hosts_exclude"],
      "foreignKey": null,
      "value": "<templateName[0]>/<templateName[1]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.healthChecker.script.path",
      "templateName": ["mapred_jobstatus_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.job.tracker.persist.jobstatus.dir",
      "templateName": ["hadoop_conf_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>/health_check",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.child.java.opts",
      "templateName": ["mapred_child_java_opts_sz"],
      "foreignKey": null,
      "value": "-server -Xmx<templateName[0]>m -Djava.net.preferIPv4Stack=true",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.cluster.map.memory.mb",
      "templateName": ["mapred_cluster_map_mem_mb"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "io.sort.mb",
      "templateName": ["io_sort_mb"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "io.sort.spill.percent",
      "templateName": ["io_sort_spill_percent"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.system.dir",
      "templateName": ["mapred_system_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.job.tracker",
      "templateName": ["jobtracker_host"],
      "foreignKey": null,
      "value": "<templateName[0]>:50300",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.job.tracker.http.address",
      "templateName": ["jobtracker_host"],
      "foreignKey": null,
      "value": "<templateName[0]>:50030",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.userlog.retain.hours",
      "templateName": ["mapreduce_userlog_retainhours"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapred.jobtracker.maxtasks.per.job",
      "templateName": ["maxtasks_per_job"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapreduce.history.server.embedded",
      "templateName": [],
      "foreignKey": null,
      "value": "false",
      "filename": "mapred-site.xml"
    },
    {
      "name": "mapreduce.history.server.http.address",
      "templateName": ["jobtracker_host"],
      "foreignKey": null,
      "value": "<templateName[0]>:51111",
      "filename": "mapred-site.xml"
    },
    {
      "name": "hbase.rootdir",
      "templateName": ["namenode_host", "hbase_hdfs_root_dir"],
      "foreignKey": null,
      "value": "hdfs://<templateName[0]>:8020<templateName[1]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.tmp.dir",
      "templateName": ["hbase_tmp_dir"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    /*
     {
     "name": "hbase.master.info.bindAddress",
     "templateName": ["hbasemaster.host"],
     "foreignKey": null,
     "value": "<templateName[0]>",
     "filename": "hbase-site.xml"
     },
     */
    {
      "name": "hbase.regionserver.global.memstore.upperLimit",
      "templateName": ["regionserver_memstore_upperlimit"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.hstore.blockingStoreFiles",
      "templateName": ["hstore_blockingstorefiles"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.hstore.compactionThreshold",
      "templateName": ["hstore_compactionthreshold"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hfile.block.cache.size",
      "templateName": ["hfile_blockcache_size"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.hregion.max.filesize",
      "templateName": ["hstorefile_maxsize"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.regionserver.handler.count",
      "templateName": ["regionserver_handlers"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.hregion.majorcompaction",
      "templateName": ["hregion_majorcompaction"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.regionserver.global.memstore.lowerLimit",
      "templateName": ["regionserver_memstore_lowerlimit"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.hregion.memstore.block.multiplier",
      "templateName": ["hregion_blockmultiplier"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.hregion.memstore.mslab.enabled",
      "templateName": ["regionserver_memstore_lab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.hregion.memstore.flush.size",
      "templateName": ["hregion_memstoreflushsize"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.client.scanner.caching",
      "templateName": ["client_scannercaching"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.client.scanner.caching",
      "templateName": ["client_scannercaching"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.cluster.distributed",
      "templateName": [],
      "foreignKey": null,
      "value": "true",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.zookeeper.property.clientPort",
      "templateName": [],
      "foreignKey": null,
      "value": "2181",
      "filename": "hbase-site.xml"
    },
    {
      "name": "zookeeper.session.timeout",
      "templateName": ["zookeeper_sessiontimeout"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "hbase.client.keyvalue.maxsize",
      "templateName": ["hfile_max_keyvalue_size"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "dfs.support.append",
      "templateName": ["hdfs_support_append"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },

    {
      "name": "dfs.client.read.shortcircuit",
      "templateName": ["hdfs_enable_shortcircuit_read"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "templeton.zookeeper.hosts",
      "templateName": ["zookeeperserver_hosts"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "webhcat-site.xml"
    },
    {
      "name": "hbase.zookeeper.quorum",
      "templateName": ["zookeeperserver_hosts"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml"
    },
    {
      "name": "fs.glusterfs.impl",
      "templateName": ["fs_glusterfs_impl"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "core-site.xml"
    },
    {
      "name": "fs.glusterfs.volname",
      "templateName": ["fs_glusterfs_volname"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "core-site.xml"
    },
    {
      "name": "fs.glusterfs.mount",
      "templateName": ["fs_glusterfs_mount"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "core-site.xml"
    },
    {
      "name": "fs.glusterfs.server",
      "templateName": ["fs_glusterfs_server"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "core-site.xml"
    },
    {
      "name": "fs.glusterfs.automount",
      "templateName": ["fs_glusterfs_automount"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "core-site.xml"
    },
    {
      "name": "fs.glusterfs.getfattrcmd",
      "templateName": ["fs_glusterfs_getfattrcmd"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "core-site.xml"
    }
  ];

  /**
   * Configs consists of 2 types: Computed values, which cannot be modified by user
   * and overridable values, which user can modify. We provide interface how to get all of this
   * configs separately
   * @type {Object}
   */
  module.exports = {
    all : function(){
      return configs.slice(0);
    },
    overridable: function(){
      return configs.filterProperty('foreignKey');
    },
    computed: function(){
      return configs.filterProperty('foreignKey', null);
    }
  };
  
});
window.require.register("data/config_properties", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /**
   * Defines service configuration properties.
   *   name:
   *     The name of the config property that is understood by Ambari server and agent.
   *     E.g., "datanode_du_reserved"
   *
   *   displayName:
   *     The human-friendly display name of the config property.
   *     E.g., "Reserved space for HDFS"
   *
   *   description:
   *     The description of the config property.
   *     E.g., "Reserved space in GB per volume"
   *
   *   defaultValue:
   *     The default value of the config property.
   *     E.g., "1"
   *
   *   isReconfigurable:
   *     Whether the config property can be reconfigured after it has been initially set and deployed.
   *     If this is unspecified, true is assumed.
   *     E.g., true, false
   *
   *   isOverridable:
   *     Whether the config property can be overridden by hosts.
   *     If this is unspecified, true is assumed.
   *
   *   isRequired:
   *     Whether the config property is required or not.
   *     If this is unspecified, true is assumed.
   *     E.g., true, false
   *
   *   displayType:
   *     How the config property is to be rendered for user input.
   *     If this is left unspecified, "string" is assumed
   *     E.g., "string", "int", "float", "checkbox", "directories", "custom", "email", "masterHost", "slaveHosts"
   *
   *   unit
   *     The unit for the config property.
   *     E.g., "ms", "MB", "bytes"
   *
   *   serviceName:
   *     The service that the config property belongs to.
   *     E.g., "HDFS", "MAPREDUCE", "ZOOKEEPER", etc.
   *
   *   category: the category that the config property belongs to (used for grouping config properties in the UI).
   *     if unspecified, "General" is assumed.
   *     E.g., "General", "Advanced", "NameNode", "DataNode"
   *
   *   index: the sequence number in category, that point to place where config located regarding all rest in category.
   *     if unspecified, push to the end of array.
   *     E.g., 0, 1, '2'
   */

  var App = require('app');
  require('config');

  module.exports =
  {
    "configProperties": [
      /**********************************************HDFS***************************************/
      {
        "id": "puppet var",
        "displayName": "NameNode host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run NameNode",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "NameNode",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "dfs_name_dir",
        "displayName": "NameNode directories",
        "description": "NameNode directories for HDFS to store the file system image",
        "defaultValue": "",
        "defaultDirectory": "/hadoop/hdfs/namenode",
        "displayType": "directories",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "NameNode",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "namenode_heapsize",
        "displayName": "NameNode Java heap size",
        "description": "Initial and maximum Java heap size for NameNode (Java options -Xms and -Xmx)",
        "defaultValue": "1024",
        "displayType": "int",
        "unit": "MB",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "NameNode",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "namenode_opt_newsize",
        "displayName": "NameNode new generation size",
        "description": "Default size of Java new generation for NameNode (Java option -XX:NewSize)",
        "defaultValue": "200",
        "displayType": "int",
        "unit": "MB",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "NameNode",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "snamenode_host",
        "displayName": "SNameNode host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run SecondaryNameNode",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "SNameNode",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "fs_checkpoint_dir",
        "displayName": "SecondaryNameNode Checkpoint directory",
        "description": "Directory on the local filesystem where the Secondary NameNode should store the temporary images to merge",
        "defaultValue": "",
        "defaultDirectory": "/hadoop/hdfs/namesecondary",
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "SNameNode",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "datanode_hosts", //not in the schema. For UI purpose
        "displayName": "DataNode hosts",
        "value": "",
        "defaultValue": "",
        "description": "The hosts that have been assigned to run DataNode",
        "displayType": "slaveHosts",
        "isRequired": false,
        "isOverridable": false,
        "isVisible": true,
        "domain": "datanode-global",
        "serviceName": "HDFS",
        "category": "DataNode",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "dfs_data_dir",
        "displayName": "DataNode directories",
        "description": "DataNode directories for HDFS to store the data blocks",
        "defaultValue": "",
        "defaultDirectory": "/hadoop/hdfs/data",
        "displayType": "directories",
        "isVisible": true,
        "domain": "datanode-global",
        "serviceName": "HDFS",
        "category": "DataNode",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "dtnode_heapsize",
        "displayName": "DataNode maximum Java heap size",
        "description": "Maximum Java heap size for DataNode (Java option -Xmx)",
        "defaultValue": "1024",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "datanode-global",
        "serviceName": "HDFS",
        "category": "DataNode",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "dfs_datanode_failed_volume_tolerated",
        "displayName": "DataNode volumes failure toleration",
        "description": "The number of volumes that are allowed to fail before a DataNode stops offering service",
        "defaultValue": "0",
        "displayType": "int",
        "isVisible": true,
        "domain": "datanode-global",
        "serviceName": "HDFS",
        "category": "DataNode",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "dfs_webhdfs_enabled",
        "displayName": "WebHDFS enabled",
        "description": "Whether to enable WebHDFS feature",
        "defaultValue": true,
        "displayType": "checkbox",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "hadoop_heapsize",
        "displayName": "Hadoop maximum Java heap size",
        "description": "Maximum Java heap size for daemons such as Balancer (Java option -Xmx)",
        "defaultValue": "1024",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "datanode_du_reserved",
        "displayName": "Reserved space for HDFS",
        "description": "Reserved space in bytes per volume. Always leave this much space free for non dfs use.",
        "defaultValue": "0",
        "displayType": "int",
        "unit": "bytes",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "fs_checkpoint_period",
        "displayName": "HDFS Maximum Checkpoint Delay",
        "description": "Maximum delay between two consecutive checkpoints for HDFS",
        "defaultValue": "21600",
        "displayType": "int",
        "unit": "seconds",
        "isVisible": true,
        "domain": "global",
        "filename": "core-site.xml",
        "serviceName": "HDFS",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "fs_checkpoint_size",
        "displayName": "HDFS Maximum Edit Log Size for Checkpointing",
        "description": "Maximum size of the edits log file that forces an urgent checkpoint even if the maximum checkpoint delay is not reached",
        "defaultValue": "67108864",
        "displayType": "float",
        "unit": "bytes",
        "isVisible": true,
        "domain": "global",
        "filename": "core-site.xml",
        "serviceName": "HDFS",
        "index": 4
      },
      {
        "id": "puppet var",
        "name": "hdfs_log_dir_prefix",
        "displayName": "Hadoop Log Dir Prefix",
        "description": "The parent directory for Hadoop log files.  The HDFS log directory will be ${hadoop_log_dir_prefix} / ${hdfs_user} and the MapReduce log directory will be ${hadoop_log_dir_prefix} / ${mapred_user}.",
        "defaultValue": "/var/log/hadoop",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hadoop_pid_dir_prefix",
        "displayName": "Hadoop PID Dir Prefix",
        "description": "The parent directory in which the PID files for Hadoop processes will be created.  The HDFS PID directory will be ${hadoop_pid_dir_prefix} / ${hdfs_user} and the MapReduce PID directory will be ${hadoop_pid_dir_prefix} / ${mapred_user}.",
        "defaultValue": "/var/run/hadoop",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      /*
       {
       "id": "puppet var",
       "name": "dfs_support_append",
       "displayName": "Append enabled",
       "description": "Whether to enable HDFS Append feature",
       "defaultValue": true,
       "displayType": "checkbox",
       "isVisible": true,
       "domain": "global",
       "serviceName": "HDFS"
       },
       */
      {
        "id": "puppet var",
        "name": "namenode_opt_maxnewsize",
        "displayName": "NameNode maximum new generation size",
        "description": "",
        "defaultValue": "200",
        "displayType": "int",
        "unit": "MB",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "NameNode"
      },
      {
        "id": "puppet var",
        "name": "dfs_exclude",
        "displayName": "Exclude hosts",
        "description": "Names a file that contains a list of hosts that are not permitted to connect to the namenode.  This file will be placed inside the Hadoop conf directory.",
        "defaultValue": "dfs.exclude",
        "displayType": "advanced",
        "isVisible": true,
        "filename": "hdfs-site.xml",
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "dfs_include",
        "displayName": "Include hosts",
        "description": "Names a file that contains a list of hosts that are permitted to connect to the namenode.  This file will be placed inside the Hadoop conf directory.",
        "defaultValue": "dfs.include",
        "displayType": "advanced",
        "isVisible": true,
        "filename": "hdfs-site.xml",
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "dfs_replication",
        "displayName": "Block replication",
        "description": "Default block replication.",
        "displayType": "int",
        "defaultValue": "3",
        "isVisible": true,
        "filename": "hdfs-site.xml",
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "dfs_block_local_path_access_user",
        "displayName": "dfs.block.local-path-access.user",
        "description": "the user who is allowed to perform short circuit reads",
        "displayType": "advanced",
        "defaultValue": "hbase",
        "isVisible": true,
        "filename": "hdfs-site.xml",
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "dfs_datanode_data_dir_perm",
        "displayName": "dfs_datanode_data_dir_perm",
        "description": "",
        "defaultValue": "750",
        "isReconfigurable": true,
        "displayType": "int",
        "isVisible": false,
        "filename": "hdfs-site.xml",
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "security_enabled",
        "displayName": "Hadoop Security",
        "description": "Enable hadoop security",
        "defaultValue": 'false',
        "isRequired": false,
        "displayType": "checkbox",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "namenode_formatted_mark_dir",
        "displayName": "Hadoop formatted mark directory",
        "description": "",
        "defaultValue": "/var/run/hadoop/hdfs/namenode/formatted/",
        "isRequired": false,
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "NameNode"
      },
      {
        "id": "puppet var",
        "name": "hcat_conf_dir",
        "displayName": "HCat conf directory",
        "description": "",
        "defaultValue": "",
        "isRequired": false,
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HDFS",
        "category": "Advanced"
      },
      /**********************************************HCFS***************************************/    
      {
        "id": "puppet var",
        "name": "fs_glusterfs_server",
        "displayName": "Gluster server",
        "description": "Gluster server (Slave FQDN)",
        "defaultValue": "{firstHost}",
        "displayType": "string",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HCFS",
        "category": "General"
      },
      {
        "id": "puppet var",
        "name": "fs_glusterfs_default_name",
        "displayName": "Gluster default fs name",
        "description": "Gluster default filesystem name (glusterfs://{MasterFQDN}:9000)",
        "defaultValue": "glusterfs://{firstHost}:9000",
        "displayType": "string",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HCFS",
        "category": "General"
      },
      {
        "id": "puppet var",
        "name": "fs_glusterfs_volname",
        "displayName": "Gluster volume name",
        "description": "Gluster volume name",
        "defaultValue": "HadoopVol",
        "displayType": "string",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HCFS",
        "category": "General"
      },
      {
        "id": "puppet var",
        "name": "fs_glusterfs_mount",
        "displayName": "Gluster mount point",
        "description": "Gluster mount point",
        "defaultValue": "/mnt/glusterfs",
        "displayType": "string",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HCFS",
        "category": "General"
      },
      {
        "id": "puppet var",
        "name": "fs_glusterfs_automount",
        "displayName": "Automount HCFS",
        "description": "Automount the HCFS Volume",
        "defaultValue": "false",
        "displayType": "string",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HCFS",
        "category": "General"
      },
      {
        "id": "puppet var",
        "name": "fs_glusterfs_impl",
        "displayName": "Gluster fs impl",
        "description": "Gluster fs impl",
        "defaultValue": "org.apache.hadoop.fs.glusterfs.GlusterFileSystem",
        "displayType": "string",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HCFS",
        "category": "General"
      },
      {
        "id": "puppet var",
        "name": "fs_glusterfs_getfattrcmd",
        "displayName": "Gluster getfattr command",
        "description": "Gluster getfattr command",
        "defaultValue": "sudo getfattr -m . -n trusted.glusterfs.pathinfo",
        "displayType": "string",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HCFS",
        "category": "General"
      },
    /**********************************************MAPREDUCE***************************************/
      {
        "id": "puppet var",
        "name": "jobtracker_host",
        "displayName": "JobTracker host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run JobTracker",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "category": "JobTracker",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "jtnode_opt_newsize",
        "displayName": "JobTracker new generation size",
        "description": "Default size of Java new generation size for JobTracker in MB (Java option -XX:NewSize)",
        "defaultValue": "200",
        "displayType": "int",
        "unit": "MB",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "category": "JobTracker",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "jtnode_opt_maxnewsize",
        "displayName": "JobTracker maximum new generation size",
        "description": "Maximum size of Java new generation for JobTracker in MB (Java option -XX:MaxNewSize)",
        "defaultValue": "200",
        "displayType": "int",
        "unit": "MB",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "category": "JobTracker",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "jtnode_heapsize",
        "displayName": "JobTracker maximum Java heap size",
        "description": "Maximum Java heap size for JobTracker in MB (Java option -Xmx)",
        "defaultValue": "1024",
        "displayType": "int",
        "unit": "MB",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "category": "JobTracker",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "tasktracker_hosts",
        "displayName": "TaskTracker hosts",
        "value": "",
        "defaultValue": "",
        "description": "The hosts that have been assigned to run TaskTracker",
        "displayType": "slaveHosts",
        "isOverridable": false,
        "isVisible": true,
        "isRequired": false,
        "domain": "tasktracker-global",
        "serviceName": "MAPREDUCE",
        "category": "TaskTracker",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "mapred_local_dir",
        "displayName": "MapReduce local directories",
        "description": "Directories for MapReduce to store intermediate data files",
        "defaultValue": "",
        "defaultDirectory": "/hadoop/mapred",
        "displayType": "directories",
        "isReconfigurable": true,
        "isVisible": true,
        "domain": "tasktracker-global",
        "serviceName": "MAPREDUCE",
        "category": "TaskTracker",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "mapred_map_tasks_max",
        "displayName": "Number of Map slots per node",
        "description": "Number of slots that Map tasks that run simultaneously can occupy on a TaskTracker",
        "defaultValue": "4",
        "displayType": "int",
        "isVisible": true,
        "domain": "tasktracker-global",
        "serviceName": "MAPREDUCE",
        "category": "TaskTracker",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "mapred_red_tasks_max",
        "displayName": "Number of Reduce slots per node",
        "description": "Number of slots that Reduce tasks that run simultaneously can occupy on a TaskTracker.",
        "defaultValue": "2",
        "displayType": "int",
        "isVisible": true,
        "isRequired": false,
        "domain": "tasktracker-global",
        "serviceName": "MAPREDUCE",
        "category": "TaskTracker",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "mapred_child_java_opts_sz",
        "displayName": "Java options for MapReduce tasks",
        "description": "Java options for the TaskTracker child processes.",
        "defaultValue": "768",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "tasktracker-global",
        "serviceName": "MAPREDUCE",
        "category": "TaskTracker",
        "index": 4
      },
      {
        "id": "puppet var",
        "name": "scheduler_name",
        "displayName": "MapReduce Capacity Scheduler",
        "description": "The scheduler to use for scheduling of MapReduce jobs",
        "defaultValue": "org.apache.hadoop.mapred.CapacityTaskScheduler",
        "displayType": "advanced",
        "isOverridable": false,
        "isVisible": true,
        "serviceName": "MAPREDUCE",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "mapred_cluster_map_mem_mb",
        "displayName": "Cluster's Map slot size (virtual memory)",
        "description": "The virtual memory size of a single Map slot in the MapReduce framework",
        "defaultValue": "1536",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "mapred_cluster_red_mem_mb",
        "displayName": "Cluster's Reduce slot size (virtual memory)",
        "description": "The virtual memory size of a single Reduce slot in the MapReduce framework",
        "defaultValue": "2048",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "mapred_cluster_max_map_mem_mb",
        "displayName": "Upper limit on virtual memory for single Map task",
        "description": "Upper limit on virtual memory size for a single Map task of any MapReduce job",
        "defaultValue": "6144",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "mapred_cluster_max_red_mem_mb",
        "displayName": "Upper limit on virtual memory for single Reduce task",
        "description": "Upper limit on virtual memory size for a single Reduce task of any MapReduce job",
        "defaultValue": "4096",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "index": 4
      },
      {
        "id": "puppet var",
        "name": "mapred_job_map_mem_mb",
        "displayName": "Default virtual memory for a job's map-task",
        "description": "Virtual memory for single Map task",
        "defaultValue": "1536",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "index": 5
      },
      {
        "id": "puppet var",
        "name": "mapred_job_red_mem_mb",
        "displayName": "Default virtual memory for a job's reduce-task",
        "description": "Virtual memory for single Reduce task",
        "defaultValue": "2048",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "index": 6
      },
      {
        "id": "puppet var",
        "name": "io_sort_mb",
        "displayName": "Map-side sort buffer memory",
        "description": "The total amount of Map-side buffer memory to use while sorting files (Expert-only configuration)",
        "defaultValue": "200",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "index": 7
      },
      {
        "id": "puppet var",
        "name": "io_sort_spill_percent",
        "displayName": "Limit on buffer",
        "description": "Percentage of sort buffer used for record collection (Expert-only configuration)",
        "defaultValue": "0.9",
        "displayType": "float",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "index": 8
      },
      {
        "id": "puppet var",
        "name": "mapreduce_userlog_retainhours",
        "displayName": "Job log retention (hours)",
        "description": "The maximum time, in hours, for which the user-logs are to be retained after the job completion.",
        "defaultValue": "24",
        "displayType": "int",
        "unit": "hours",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "index": 9
      },
      {
        "id": "puppet var",
        "name": "maxtasks_per_job",
        "displayName": "Maximum number tasks for a Job",
        "description": "Maximum number of tasks for a single Job",
        "defaultValue": "-1",
        "displayType": "int",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "index": 10
      },
      {
        "id": "puppet var",
        "name": "lzo_enabled",
        "displayName": "LZO compression",
        "description": "LZO compression enabled",
        "defaultValue": true,
        "displayType": "checkbox",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "index": 11
      },
      {
        "id": "puppet var",
        "name": "snappy_enabled",
        "displayName": "Snappy compression",
        "description": "Snappy compression enabled",
        "defaultValue": true,
        "isReconfigurable": false,
        "displayType": "checkbox",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "index": 12
      },
      {
        "id": "puppet var",
        "name": "rca_enabled",
        "displayName": "Enable Job Diagnostics",
        "description": "Tools for tracing the path and troubleshooting the performance of MapReduce jobs",
        "defaultValue": true,
        "isReconfigurable": true,
        "isOverridable": false,
        "displayType": "checkbox",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "index": 13
      },
      {
        "id": "puppet var",
        "name": "mapred_system_dir",
        "displayName": "MapReduce system directories",
        "description": "",
        "defaultValue": "/mapred/system",
        "displayType": "directories",
        "isReconfigurable": true,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MAPREDUCE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "mapred_hosts_exclude",
        "displayName": "Exclude hosts",
        "description": "Exclude entered hosts",
        "defaultValue": "mapred.exclude",
        "displayType": "directories",
        "isVisible": false,
        "serviceName": "MAPREDUCE",
        "domain": "global",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "mapred_hosts_include",
        "displayName": "Include hosts",
        "description": "Include enetered hosts",
        "defaultValue": "mapred.include",
        "displayType": "directories",
        "isVisible": false,
        "serviceName": "MAPREDUCE",
        "domain": "global",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "mapred_jobstatus_dir",
        "displayName": "Job Status directory",
        "description": "Directory path to view job status",
        "defaultValue": "file:////mapred/jobstatus",
        "displayType": "advanced",
        "isVisible": false,
        "serviceName": "MAPREDUCE",
        "domain": "global",
        "category": "Advanced"
      },
      {
        "id": "site property",
        "name": "mapred.capacity-scheduler.maximum-system-jobs",
        "displayName": "Max system jobs",
        "displayType": "int",
        "value": '3000',
        "defaultValue": '3000',
        "description": "Maximum number of jobs in the system which can be initialized, concurrently, by the " +
          "CapacityScheduler. Individual queue limits on initialized jobs are directly proportional to their queue " +
          "capacities.",
        "isVisible": true,
        "isRequired": true,
        "serviceName": "MAPREDUCE",
        "category": "CapacityScheduler",
        "filename": "capacity-scheduler.xml"
      },
    /**********************************************HBASE***************************************/
      {
        "id": "puppet var",
        "name": "hbasemaster_host",
        "displayName": "HBase Master hosts",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run HBase Master",
        "displayType": "masterHosts",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "HBase Master",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "hbase_master_heapsize",
        "displayName": "HBase Master Maximum Java heap size",
        "description": "Maximum Java heap size for HBase master (Java option -Xmx)",
        "defaultValue": "1024",
        "displayType": "int",
        "unit": "MB",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "HBase Master",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "regionserver_hosts",
        "displayName": "RegionServer hosts",
        "value": "",
        "defaultValue": "",
        "description": "The hosts that have been assigned to run RegionServer",
        "displayType": "slaveHosts",
        "isOverridable": false,
        "isVisible": true,
        "isRequired": false,
        "domain": "regionserver-global",
        "serviceName": "HBASE",
        "category": "RegionServer",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "hbase_regionserver_heapsize",
        "displayName": "HBase RegionServers maximum Java heap size",
        "description": "Maximum Java heap size for HBase RegionServers (Java option -Xmx)",
        "defaultValue": "1024",
        "displayType": "int",
        "unit": "MB",
        "isVisible": true,
        "domain": "regionserver-global",
        "serviceName": "HBASE",
        "category": "RegionServer",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "regionserver_handlers",
        "displayName": "HBase RegionServer Handler",
        "description": "Count of RPC Listener instances spun up on RegionServers",
        "defaultValue": "60",
        "displayType": "int",
        "isVisible": true,
        "domain": "regionserver-global",
        "serviceName": "HBASE",
        "category": "RegionServer",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "hregion_majorcompaction",
        "displayName": "HBase Region Major Compaction",
        "description": "The time between major compactions of all HStoreFiles in a region. Set to 0 to disable automated major compactions.",
        "defaultValue": "86400000",
        "displayType": "int",
        "unit": "ms",
        "isVisible": true,
        "domain": "regionserver-global",
        "serviceName": "HBASE",
        "category": "RegionServer",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "hregion_blockmultiplier",
        "displayName": "HBase Region Block Multiplier",
        "description": "Block updates if memstore has \"Multiplier * HBase Region Memstore Flush Size\" bytes. Useful preventing runaway memstore during spikes in update traffic",
        "defaultValue": "2",
        "displayType": "int",
        "isVisible": true,
        "domain": "regionserver-global",
        "serviceName": "HBASE",
        "category": "RegionServer",
        "index": 4
      },
      {
        "id": "puppet var",
        "name": "hregion_memstoreflushsize",
        "displayName": "HBase Region Memstore Flush Size",
        "description": "Memstore will be flushed to disk if size of the memstore exceeds this number of bytes.",
        "defaultValue": "134217728",
        "displayType": "int",
        "unit": "bytes",
        "isVisible": true,
        "domain": "regionserver-global",
        "serviceName": "HBASE",
        "category": "RegionServer",
        "index": 5
      },
      {
        "id": "puppet var",
        "name": "hstore_compactionthreshold",
        "displayName": "HBase HStore compaction threshold",
        "description": "If more than this number of HStoreFiles in any one HStore then a compaction is run to rewrite all HStoreFiles files as one.",
        "defaultValue": "3",
        "displayType": "int",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "hfile_blockcache_size",
        "displayName": "HFile block cache size ",
        "description": "Percentage of maximum heap (-Xmx setting) to allocate to block cache used by HFile/StoreFile. Set to 0 to disable but it's not recommended.",
        "defaultValue": "0.40",
        "displayType": "float",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "hstorefile_maxsize",
        "displayName": "Maximum HStoreFile Size",
        "description": "If any one of a column families' HStoreFiles has grown to exceed this value, the hosting HRegion is split in two.",
        "defaultValue": "10737418240",
        "displayType": "int",
        "unit": "bytes",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "client_scannercaching",
        "displayName": "HBase Client Scanner Caching",
        "description": "Number of rows that will be fetched when calling next on a scanner if it is not served from (local, client) memory. Do not set this value such that the time between invocations is greater than the scanner timeout",
        "defaultValue": "100",
        "displayType": "int",
        "unit": "rows",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "zookeeper_sessiontimeout",
        "displayName": "Zookeeper timeout for HBase Session",
        "description": "HBase passes this to the zk quorum as suggested maximum time for a session",
        "defaultValue": "60000",
        "displayType": "int",
        "unit": "ms",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "index": 4
      },
      {
        "id": "puppet var",
        "name": "hfile_max_keyvalue_size",
        "displayName": "HBase Client Maximum key-value Size",
        "description": "Specifies the combined maximum allowed size of a KeyValue instance. It should be set to a fraction of the maximum region size.",
        "defaultValue": "10485760",
        "displayType": "int",
        "unit": "bytes",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "index": 5
      },
      {
        "id": "puppet var",
        "name": "hbase_log_dir",
        "displayName": "HBase Log Dir",
        "description": "Directory for HBase logs",
        "defaultValue": "/var/log/hbase",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hbase_pid_dir",
        "displayName": "HBase PID Dir",
        "description": "Directory in which the pid files for HBase processes will be created",
        "defaultValue": "/var/run/hbase",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hbase_hdfs_root_dir",
        "displayName": "Hbase relative path to HDFS",
        "description": "Hbase relative directory to HDFS",
        "defaultValue": "/apps/hbase/data",
        "isRequired": true,
        "displayType": "advanced",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hbase_tmp_dir",
        "displayName": "Hbase temp directory",
        "description": "",
        "defaultValue": "/var/log/hbase",
        "isRequired": false,
        "displayType": "advanced",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hdfs_enable_shortcircuit_read",
        "displayName": "HDFS Short-circuit read",
        "description": "",
        "defaultValue": true,
        "isRequired": false,
        "displayType": "checkbox",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hdfs_support_append",
        "displayName": "HDFS append support",
        "description": "HDFS append support",
        "defaultValue": true,
        "isRequired": false,
        "displayType": "checkbox",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hstore_blockingstorefiles",
        "displayName": "hstore blocking storefiles",
        "description": "If more than this number of StoreFiles in any one Store (one StoreFile is written per flush of " +
          "MemStore) then updates are blocked for this HRegion until a compaction is completed, or until " +
          "hbase.hstore.blockingWaitTime has been exceeded.",
        "defaultValue": 7,
        "isRequired": true,
        "displayType": "init",
        "isVisible": true,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "regionserver_memstore_lab",
        "displayName": "regionserver_memstore_lab",
        "description": "",
        "defaultValue": true,
        "isRequired": false,
        "displayType": "checkbox",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "regionserver_memstore_lowerlimit",
        "displayName": "regionserver_memstore_lowerlimit",
        "description": "",
        "defaultValue": "0.38",
        "isRequired": false,
        "displayType": "float",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "regionserver_memstore_upperlimit",
        "displayName": "regionserver_memstore_upperlimit",
        "description": "",
        "defaultValue": "0.4",
        "isRequired": true,
        "displayType": "float",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HBASE",
        "category": "Advanced"
      },
    /**********************************************HIVE***************************************/
      {
        "id": "puppet var",
        "name": "hivemetastore_host",
        "displayName": "Hive Metastore host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run Hive Metastore",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "isObserved": true,
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 0
      },
      // for existing MySQL
      {
        "id": "puppet var",
        "name": "hive_existing_mysql_database",
        "displayName": "Database Type",
        "value": "",
        "defaultValue": "MySQL",
        "description": "Using an existing MySQL database for Hive Metastore",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": false,
        "isReconfigurable": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 1
      },
      // for existing Oracle
      {
        "id": "puppet var",
        "name": "hive_existing_oracle_database",
        "displayName": "Database Type",
        "value": "",
        "defaultValue": "Oracle",
        "description": "Using an existing Oracle database for Hive Metastore",
        "displayType": "masterHost",
        "isVisible": false,
        "isOverridable": false,
        "isReconfigurable": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 1
      },
      // for new MySQL
      {
        "id": "puppet var",
        "name": "hive_ambari_database",
        "displayName": "Database Type",
        "value": "",
        "defaultValue": "MySQL",
        "description": "MySQL will be installed by Ambari",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "hive_database",
        "displayName": "Hive Database",
        "value": "",
        "defaultValue": "New MySQL Database",
        "options": [
          {
            displayName: 'New MySQL Database',
            foreignKeys: ['hive_ambari_database', 'hive_ambari_host']
          },
          {
            displayName: 'Existing MySQL Database',
            foreignKeys: ['hive_existing_mysql_database', 'hive_existing_mysql_host']
          },
          {
            displayName: 'Existing Oracle Database',
            foreignKeys: ['hive_existing_oracle_database', 'hive_existing_oracle_host'],
            hidden: !App.supports.hiveOozieExtraDatabases
          }
        ],
        "description": "MySQL will be installed by Ambari",
        "displayType": "radio button",
        "isReconfigurable": false,
        "radioName": "hive-database",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "hive_hostname",
        "displayName": "Database Host",
        "description": "Specify the host on which the database is hosted",
        "defaultValue": "",
        "isReconfigurable": true,
        "displayType": "host",
        "isOverridable": false,
        "isVisible": false,
        "isObserved": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "hive_existing_mysql_host",
        "displayName": "Database Host",
        "description": "Specify the host on which the existing database is hosted",
        "defaultValue": "",
        "isReconfigurable": false,
        "displayType": "host",
        "isOverridable": false,
        "isVisible": false,
        "isObserved": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "hive_existing_oracle_host",
        "displayName": "Database Host",
        "description": "Specify the host on which the existing database is hosted",
        "defaultValue": "",
        "isReconfigurable": false,
        "displayType": "host",
        "isOverridable": false,
        "isVisible": false,
        "isObserved": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "hive_ambari_host",
        "value": "",
        "defaultValue": "",
        "displayName": "Database Host",
        "description": "The host where Hive Metastore database is located",
        "isReconfigurable": false,
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "hive_database_name",
        "displayName": "Database Name",
        "description": "Database name used as the Hive Metastore",
        "defaultValue": "hive",
        "isReconfigurable": true,
        "displayType": "host",
        "isOverridable": false,
        "isVisible": true,
        "isObserved": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 4
      },
      {
        "id": "puppet var",
        "name": "hive_metastore_user_name",
        "displayName": "Database Username",
        "description": "Database user name to use to connect to the database",
        "defaultValue": "hive",
        "isReconfigurable": true,
        "displayType": "host",  // don't apply user validation
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 5
      },
      {
        "id": "puppet var",
        "name": "hive_metastore_user_passwd",
        "displayName": "Database Password",
        "description": "Database password to use to connect to the PostgreSQL database",
        "defaultValue": "",
        "isReconfigurable": true,
        "displayType": "password",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 6
      },
      {
        "id": "puppet var",
        "name": "hive_jdbc_connection_url",
        "displayName": "Database URL",
        "value": "",
        "defaultValue": " ", // set to a space to not include this in initial error count
        "description": "The JDBC connection URL to the database",
        "displayType": "advanced",
        "isOverridable": false,
        "isVisible": true,
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "index": 7
      },
      {
        "id": "puppet var",
        "name": "hive_metastore_port",
        "displayName": "Hive metastore port",
        "description": "",
        "defaultValue": "9083",
        "isReconfigurable": false,
        "displayType": "int",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hive_lib",
        "displayName": "Hive library",
        "description": "",
        "defaultValue": "/usr/lib/hive/lib/",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hive_conf_dir",
        "displayName": "Hive conf directory",
        "description": "",
        "defaultValue": "/etc/hive/conf",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hive_dbroot",
        "displayName": "Hive db directory",
        "description": "",
        "defaultValue": "/usr/lib/hive/lib",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hive_log_dir",
        "displayName": "Hive Log Dir",
        "description": "Directory for Hive log files",
        "defaultValue": "/var/log/hive",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hive_pid_dir",
        "displayName": "Hive PID Dir",
        "description": "Directory in which the PID files for Hive processes will be created",
        "defaultValue": "/var/run/hive",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "mysql_connector_url",
        "displayName": "MySQL connector url",
        "description": "",
        "defaultValue": "${download_url}/mysql-connector-java-5.1.18.zip",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hive_aux_jars_path",
        "displayName": "Hive auxilary jar path",
        "description": "",
        "defaultValue": "/usr/lib/hcatalog/share/hcatalog/hcatalog-core.jar",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "HIVE",
        "category": "Advanced"
      },
    /**********************************************WEBHCAT***************************************/
      {
        "id": "puppet var",
        "name": "webhcatserver_host",
        "displayName": "WebHCat Server host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run WebHCat Server",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "WEBHCAT",
        "category": "WebHCat Server"
      },
      {
        "id": "puppet var",
        "name": "hcat_log_dir",
        "displayName": "WebHCat Log Dir",
        "description": "Directory for WebHCat log files",
        "defaultValue": "/var/log/webhcat",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "WEBHCAT",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hcat_pid_dir",
        "displayName": "WebHCat PID Dir",
        "description": "Directory in which the PID files for WebHCat processes will be created",
        "defaultValue": "/var/run/webhcat",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "WEBHCAT",
        "category": "Advanced"
      },
    /**********************************************OOZIE***************************************/
      {
        "id": "puppet var",
        "name": "oozieserver_host",
        "displayName": "Oozie Server host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run Oozie Server",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 0
      },
      // for existing Oracle
      {
        "id": "puppet var",
        "name": "oozie_existing_oracle_database",
        "displayName": "Database Type",
        "value": "",
        "defaultValue": "Oracle",
        "description": "Using an existing Oracle database for Oozie Metastore",
        "displayType": "masterHost",
        "isVisible": false,
        "isObserved": true,
        "isReconfigurable": false,
        "isOverridable": false,
        //"domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 1
      },
      // for new MySQL
      /*{
        "id": "puppet var",
        "name": "oozie_ambari_database",
        "displayName": "Database Type",
        "value": "",
        "defaultValue": "MySQL",
        "description": "MySQL will be installed by Ambari",
        "displayType": "masterHost",
        "isVisible": false,
        "isOverridable": false,
        // "domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 1
      },*/
      // for current derby
      {
        "id": "puppet var",
        "name": "oozie_derby_database",
        "displayName": "Database Type",
        "value": "",
        "defaultValue": "Derby",
        "description": "Using current Derby database for Oozie Metastore",
        "displayType": "masterHost",
        "isVisible": false,
        "isReconfigurable": false,
        "isOverridable": false,
        // "domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 1
      },
      // for existing MySQL oozie
      {
        "id": "puppet var",
        "name": "oozie_existing_mysql_database",
        "displayName": "Database Type",
        "value": "",
        "defaultValue": "MySQL",
        "description": "Using an existing MySQL database for Oozie Metastore",
        "displayType": "masterHost",
        "isVisible": false,
        "isReconfigurable": false,
        "isOverridable": false,
        //"domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "oozie_database",
        "displayName": "Oozie Database",
        "value": "",
        "defaultValue": "New Derby Database",
        "options": [
          {
            displayName: 'New Derby Database',
            foreignKeys: ['oozie_derby_database','oozie_ambari_host']
          },
           /*{
            displayName: 'New MySQL Database',
            foreignKeys: ['oozie_ambari_database', 'oozie_ambari_host'],
            hidden: !App.supports.hiveOozieExtraDatabases
          },*/
          {
            displayName: 'Existing MySQL Database',
            foreignKeys: ['oozie_existing_mysql_database', 'oozie_existing_mysql_host'],
            hidden: !App.supports.hiveOozieExtraDatabases
          },
          {
            displayName: 'Existing Oracle Database',
            foreignKeys: ['oozie_existing_oracle_database', 'oozie_existing_oracle_host'],
            hidden: !App.supports.hiveOozieExtraDatabases
          }
        ],
        "description": "Current Derby Database will be installed by Ambari",
        "displayType": "radio button",
        "isReconfigurable": false,
        "isOverridable": false,
        "radioName": "oozie-database",
        "isVisible": true,
        "domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "oozie_hostname",
        "defaultValue": "",
        "displayName": "Database Host",
        "description": "The host where the Oozie database is located",
        "isReconfigurable": true,
        "isOverridable": false,
        "displayType": "host",
        "isVisible": false,
        "domain": "global",
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 3
      },
        {
            "id": "puppet var",
            "name": "oozie_existing_mysql_host",
            "displayName": "Database Host",
            "description": "Specify the host on which the existing database is hosted",
            "defaultValue": "",
            "isReconfigurable": false,
            "isOverridable": false,
            "displayType": "host",
            "isVisible": false,
            "isObserved": true,
            "domain": "global",
            "serviceName": "OOZIE",
            "category": "Oozie Server",
            "index": 3
        },
        {
            "id": "puppet var",
            "name": "oozie_existing_oracle_host",
            "displayName": "Database Host",
            "description": "Specify the host on which the existing database is hosted",
            "defaultValue": "",
            "isReconfigurable": false,
            "isOverridable": false,
            "displayType": "host",
            "isVisible": false,
            "isObserved": true,
            "domain": "global",
            "serviceName": "OOZIE",
            "category": "Oozie Server",
            "index": 3
        },
        {
            "id": "puppet var",
            "name": "oozie_ambari_host",
            "value": "",
            "defaultValue": "",
            "displayName": "Database Host",
            "description": "Host on which the database will be created by Ambari",
            "isReconfigurable": false,
            "isOverridable": false,
            "displayType": "masterHost",
            "isVisible": false,
            "domain": "global",
            "serviceName": "OOZIE",
            "category": "Oozie Server",
            "index": 3
        },
        {
            "id": "puppet var",
            "name": "oozie_database_name",
            "displayName": "Database Name",
            "description": "Database name used for the Oozie",
            "defaultValue": "oozie",
            "isReconfigurable": true,
            "isOverridable": false,
            "displayType": "host",
            "isVisible": true,
            "isObserved": true,
            //"domain": "global",
            "serviceName": "OOZIE",
            "category": "Oozie Server",
            "index": 4
        },
        {
            "id": "puppet var",
            "name": "oozie_metastore_user_name",
            "displayName": "Database Username",
            "description": "Database user name to use to connect to the database",
            "defaultValue": "oozie",
            "isReconfigurable": true,
            "isOverridable": false,
            "displayType": "host",  // don't apply user validation
            "isVisible": true,
            //"domain": "global",
            "serviceName": "OOZIE",
            "category": "Oozie Server",
            "index": 5
        },
        {
            "id": "puppet var",
            "name": "oozie_metastore_user_passwd",
            "displayName": "Database Password",
            "description": "Database password to use to connect to the database",
            "defaultValue": "",
            "isReconfigurable": true,
            "isOverridable": false,
            "displayType": "password",
            "isVisible": true,
            //"domain": "global",
            "serviceName": "OOZIE",
            "category": "Oozie Server",
            "index": 6
        },
      {
        "id": "puppet var",
        "name": "oozie_jdbc_connection_url",
        "displayName": "Database URL",
        "description": "The JDBC connection URL to the database",
        "defaultValue": " ",  // set to a space to not include this in initial error count
        "isReconfigurable": true,
        "isOverridable": false,
        "displayType": "advanced",
        "isVisible": true,
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "index": 7
      },
      {
            "id": "puppet var",
            "name": "oozie_data_dir",
            "displayName": "Oozie Data Dir",
            "description": "Data directory in which the Oozie DB exists",
            "defaultValue": "",
            "defaultDirectory": "/hadoop/oozie/data",
            "isReconfigurable": false,
            "displayType": "directory",
            "isOverridable": false,
            "isVisible": true,
            "isRequired": false,
            "domain": "global",
            "serviceName": "OOZIE",
            "category": "Oozie Server",
            "index": 8
        },

      {
        "id": "puppet var",
        "name": "oozie_log_dir",
        "displayName": "Oozie Log Dir",
        "description": "Directory for oozie logs",
        "defaultValue": "/var/log/oozie",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "OOZIE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "oozie_pid_dir",
        "displayName": "Oozie PID Dir",
        "description": "Directory in which the pid files for oozie processes will be created",
        "defaultValue": "/var/run/oozie",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "OOZIE",
        "category": "Advanced"
      },
      /*  {
       "id": "puppet var",
       "name": "oozie_database",
       "displayName": "Oozie Database",
       "value": "",
       "defaultValue": "New PostgreSQL Database",
       "options": [
       {
       displayName: 'New PostgreSQL Database',
       foreignKeys: ['oozie_ambari_database', 'oozie_ambari_host']
       },
       {
       displayName: 'Existing Database',
       foreignKeys: ['oozie_existing_database', 'oozie_existing_host']
       }
       ],
       "description": "PostgreSQL will be installed by ambari. Any other database will have to be installed by the user.",
       "displayType": "radio button",
       "radioName": "oozie-database",
       "isVisible": true,
       "serviceName": "OOZIE",
       "category": "Oozie Server"
       },
       {
       "id": "puppet var",
       "name": "oozie_existing_database",
       "displayName": "Oozie Database",
       "value": "",
       "defaultValue": "MySQL",
       "description": "Select the database, if you already have existing one for Oozie.",
       "displayType": "combobox",
       "isVisible": false,
       "options": ['MySQL', 'PostgreSQL'],
       "serviceName": "OOZIE",
       "category": "Oozie Server"
       },
       {
       "id": "puppet var",
       "name": "oozie_existing_host",
       "displayName": "Database Host",
       "description": "Select the host on which the existing database is hosted.",
       "defaultValue": "",
       "isReconfigurable": false,
       "displayType": "host",
       "isVisible": false,
       "serviceName": "OOZIE",
       "category": "Oozie Server"
       },
       {
       "id": "puppet var",
       "name": "oozie_ambari_database",
       "displayName": "Oozie Database",
       "value": "",
       "defaultValue": "PostgreSQL",
       "description": "PostgreSQL will be installed by ambari.",
       "displayType": "masterHost",
       "isVisible": true,
       "serviceName": "OOZIE",
       "category": "Oozie Server"
       },
       {
       "id": "puppet var",
       "name": "oozie_ambari_host",
       "value": "",
       "defaultValue": "",
       "displayName": "PostgreSQL host",
       "description": "Host  on which the PostgreSQL database will be created by ambari. ",
       "isReconfigurable": false,
       "displayType": "masterHost",
       "isVisible": true,
       "serviceName": "OOZIE",
       "category": "Oozie Server"
       },
       */
    /**********************************************NAGIOS***************************************/
      {
        "id": "puppet var",
        "name": "nagios_web_login",
        "displayName": "Nagios Admin username",
        "description": "Nagios Web UI Admin username",
        "defaultValue": "nagiosadmin",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "domain": "global",
        "isVisible": true,
        "serviceName": "NAGIOS",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "nagios_web_password",
        "displayName": "Nagios Admin password",
        "description": "Nagios Web UI Admin password",
        "defaultValue": "",
        "isReconfigurable": false,
        "displayType": "password",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "NAGIOS",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "nagios_contact",
        "displayName": "Hadoop Admin email",
        "description": "Hadoop Administrator email for alert notification",
        "defaultValue": "",
        "displayType": "email",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "NAGIOS",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "nagios_group",
        "displayName": "Nagios Group",
        "description": "Nagios Group",
        "defaultValue": "nagios",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "domain": "global",
        "isVisible": false,
        "serviceName": "NAGIOS"
      },
    /**********************************************ZOOKEEPER***************************************/
      {
        "id": "puppet var",
        "name": "zookeeperserver_hosts",
        "displayName": "ZooKeeper Server hosts",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run ZooKeeper Server",
        "displayType": "masterHosts",
        "isVisible": true,
        "isOverridable": false,
        "isRequired": false,
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "zk_data_dir",
        "displayName": "ZooKeeper directory",
        "description": "Data directory for ZooKeeper",
        "defaultValue": "",
        "defaultDirectory": "/hadoop/zookeeper",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": true,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "tickTime",
        "displayName": "Length of single Tick",
        "description": "The length of a single tick in milliseconds, which is the basic time unit used by ZooKeeper",
        "defaultValue": "2000",
        "displayType": "int",
        "unit": "ms",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server",
        "index": 2
      },
      {
        "id": "puppet var",
        "name": "initLimit",
        "displayName": "Ticks to allow for sync at Init",
        "description": "Amount of time, in ticks to allow followers to connect and sync to a leader",
        "defaultValue": "10",
        "displayType": "int",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server",
        "index": 3
      },
      {
        "id": "puppet var",
        "name": "syncLimit",
        "displayName": "Ticks to allow for sync at Runtime",
        "description": "Amount of time, in ticks to allow followers to connect",
        "defaultValue": "5",
        "displayType": "int",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server",
        "index": 4
      },
      {
        "id": "puppet var",
        "name": "clientPort",
        "displayName": "Port for running ZK Server",
        "description": "Port for running ZooKeeper server",
        "defaultValue": "2181",
        "displayType": "int",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server",
        "index": 5
      },
      {
        "id": "puppet var",
        "name": "zk_log_dir",
        "displayName": "ZooKeeper Log Dir",
        "description": "Directory for ZooKeeper log files",
        "defaultValue": "/var/log/zookeeper",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "Advanced",
        "index": 0
      },
      {
        "id": "puppet var",
        "name": "zk_pid_dir",
        "displayName": "ZooKeeper PID Dir",
        "description": "Directory in which the pid files for zookeeper processes will be created",
        "defaultValue": "/var/run/zookeeper",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "Advanced",
        "index": 1
      },
      {
        "id": "puppet var",
        "name": "zk_pid_file",
        "displayName": "ZooKeeper PID File",
        "description": "",
        "defaultValue": "/var/run/zookeeper/zookeeper_server.pid",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "ZOOKEEPER",
        "category": "Advanced"
      },
    /**********************************************HUE***************************************/
      {
        "id": "puppet var",
        "name": "hueserver_host",
        "displayName": "Hue Server host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run Hue Server",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HUE",
        "category": "Hue Server"
      },
      {
        "id": "puppet var",
        "name": "hue_log_dir",
        "displayName": "HUE Log Dir",
        "description": "Directory for HUE logs",
        "defaultValue": "/var/log/hue",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HUE",
        "category": "Advanced"
      },
      {
        "id": "puppet var",
        "name": "hue_pid_dir",
        "displayName": "HUE Pid Dir",
        "description": "Directory in which the pid files for HUE processes will be created",
        "defaultValue": "/var/run/hue",
        "isReconfigurable": false,
        "displayType": "directory",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "HUE",
        "category": "Advanced"
      },
    /**********************************************GANGLIA***************************************/
      {
        "id": "puppet var",
        "name": "ganglia_conf_dir",
        "displayName": "Ganglia conf directory",
        "description": "",
        "defaultValue": "/etc/ganglia/hdp",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "GANGLIA",
        "category": "Advanced"
      },
    /**********************************************MISC***************************************/
      {
        "id": "puppet var",
        "name": "hbase_conf_dir",
        "displayName": "HBase conf dir",
        "description": "",
        "defaultValue": "/etc/hbase",
        "isRequired": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "proxyuser_group",
        "displayName": "Proxy group for Hive, WebHCat, and Oozie",
        "description": "",
        "defaultValue": "users",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "filename": "core-site.xml",
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["HIVE","WEBHCAT","OOZIE"]
      },
      {
        "id": "puppet var",
        "name": "dfs_datanode_address",
        "displayName": "dfs_datanode_address",
        "description": "",
        "defaultValue": "50010",
        "isReconfigurable": true,
        "displayType": "int",
        "isVisible": true,
        "filename": "hdfs-site.xml",
        "domain": "global",
        "serviceName": "MISC",
        "category": "Advanced",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "dfs_datanode_http_address",
        "displayName": "dfs_datanode_http_address",
        "description": "",
        "defaultValue": "50075",
        "isReconfigurable": true,
        "displayType": "int",
        "isVisible": true,
        "filename": "hdfs-site.xml",
        "domain": "global",
        "serviceName": "MISC",
        "category": "Advanced",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "gpl_artifacts_download_url",
        "displayName": "gpl artifact download url",
        "description": "",
        "defaultValue": "",
        "isReconfigurable": false,
        "displayType": "advanced",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "apache_artifacts_download_url",
        "displayName": "apache artifact download url",
        "description": "",
        "defaultValue": "",
        "isReconfigurable": false,
        "displayType": "advanced",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "ganglia_runtime_dir",
        "displayName": "Ganglia runtime directory",
        "description": "",
        "defaultValue": "/var/run/ganglia/hdp",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General",
        "belongsToService":[]
      },
      /*
      {
        "id": "puppet var",
        "name": "ganglia_shell_cmds_dir",
        "displayName": "ganglia_shell_cmds_dir",
        "description": "",
        "defaultValue": "/usr/libexec/hdp/ganglia",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General"
      },
      {
        "id": "puppet var",
        "name": "webserver_group",
        "displayName": "ganglia_shell_cmds_dir",
        "description": "",
        "defaultValue": "apache",
        "isReconfigurable": false,
        "displayType": "advanced",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General"
      },
      */
      /*
      {
        "id": "puppet var",
        "name": "jdk_location",
        "displayName": "URL to download 64-bit JDK",
        "description": "URL from where the 64-bit JDK binary can be downloaded",
        "defaultValue": "",
        "isRequired": false,
        "isReconfigurable": false,
        "displayType": "url",
        "isVisible": true,
        "serviceName": "MISC"
      },
      */
      {
        "id": "puppet var",
        "name": "java64_home",
        "displayName": "Path to 64-bit JAVA_HOME",
        "description": "Path to 64-bit JAVA_HOME.  /usr/jdk/jdk1.6.0_31 is the default used by Ambari.  You can override this to a specific path that contains the JDK.  Note that the path must be valid on ALL hosts in your cluster.",
        "defaultValue": "/usr/jdk64/jdk1.6.0_31",
        "isRequired": true,
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "run_dir",
        "displayName": "Hadoop run directory",
        "description": "",
        "defaultValue": "/var/run/hadoop",
        "isRequired": false,
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Advanced",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "hadoop_conf_dir",
        "displayName": "Hadoop conf directory",
        "description": "",
        "defaultValue": "/etc/hadoop",
        "isRequired": false,
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Advanced",
        "belongsToService":[]
      },
      /*
      {
        "id": "puppet var",
        "name": "hcat_metastore_port",
        "displayName": "hcat_metastore_port",
        "description": "",
        "defaultValue": "/usr/lib/hcatalog/share/hcatalog",
        "isRequired": true,
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC"
      },
      {
        "id": "puppet var",
        "name": "hcat_lib",
        "displayName": "hcat_lib",
        "description": "",
        "defaultValue": "/usr/lib/hcatalog/share/hcatalog",
        "isRequired": true,
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC"
      },

      {
        "id": "puppet var",
        "name": "hcat_dbroot",
        "displayName": "hcat_dbroot",
        "description": "",
        "defaultValue": "/usr/lib/hcatalog/share/hcatalog",
        "isRequired": true,
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC"
      },
      {
        "id": "puppet var",
        "name": "hcat_dbroot",
        "displayName": "hcat_dbroot",
        "description": "",
        "defaultValue": "/usr/lib/hcatalog/share/hcatalog",
        "isRequired": true,
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC"
      },

       {
       "id": "puppet var",
       "name": "hadoop_log_dir",
       "displayName": "Hadoop Log Dir",
       "description": "Directory for Hadoop log files",
       "defaultValue": "/var/log/hadoop",
       "isReconfigurable": false,
       "displayType": "directory",
       "isVisible":  true, "serviceName": "MISC",
       "category": "Advanced"
       },
       {
       "id": "puppet var",
       "name": "hadoop_pid_dir",
       "displayName": "Hadoop PID Dir",
       "description": "Directory in which the pid files for Hadoop processes will be created",
       "defaultValue": "/var/run/hadoop",
       "isReconfigurable": false,
       "displayType": "directory",
       "isVisible":  true, "serviceName": "MISC",
       "category": "Advanced"
       },
      {
        "id": "puppet var",
        "name": "using_local_repo",
        "displayName": "Whether a local repo is being used",
        "description": "Whether a local repo is being used",
        "defaultValue": false,
        "isReconfigurable": false,
        "displayType": "checkbox",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC"
      },
      {
        "id": "puppet var",
        "name": "yum_repo_file",
        "displayName": "Path to local repo file",
        "description": "Path to local repository file that configures from where to download software packages",
        "defaultValue": "/etc/yum.repos.d/hdp.repo",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC"
      },
      */
      {
        "id": "puppet var",
        "name": "hdfs_user",
        "displayName": "HDFS User",
        "description": "User to run HDFS as",
        "defaultValue": "hdfs",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "serviceName": "MISC",
        "domain": "global",
        "category": "Users and Groups",
        "belongsToService":["HDFS"]
      },
      {
        "id": "puppet var",
        "name": "mapred_user",
        "displayName": "MapReduce User",
        "description": "User to run MapReduce as",
        "defaultValue": "mapred",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["MAPREDUCE"]
      },
      {
        "id": "puppet var",
        "name": "hbase_user",
        "displayName": "HBase User",
        "description": "User to run HBase as",
        "defaultValue": "hbase",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["HBASE"]
      },
      {
        "id": "puppet var",
        "name": "hive_user",
        "displayName": "Hive User",
        "description": "User to run Hive as",
        "defaultValue": "hive",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["HIVE"]
      },
      {
        "id": "puppet var",
        "name": "hcat_user",
        "displayName": "HCat User",
        "description": "User to run HCatalog as",
        "defaultValue": "hcat",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["HCATALOG"]
      },
      {
        "id": "puppet var",
        "name": "webhcat_user",
        "displayName": "WebHCat User",
        "description": "User to run WebHCat as",
        "defaultValue": "hcat",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["WEBHCAT"]
      },
      {
        "id": "puppet var",
        "name": "oozie_user",
        "displayName": "Oozie User",
        "description": "User to run Oozie as",
        "defaultValue": "oozie",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["OOZIE"]
      },
      /*
      {
        "id": "puppet var",
        "name": "oozie_conf_dir",
        "displayName": "Oozie conf dir",
        "description": "",
        "defaultValue": "/etc/oozie",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General"
      },

      {
        "id": "puppet var",
        "name": "pig_conf_dir",
        "displayName": "Pig conf dir",
        "description": "",
        "defaultValue": "/etc/pig",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General"
      },
      */
      /*
      {
        "id": "puppet var",
        "name": "sqoop_conf_dir",
        "displayName": "sqoop conf dir",
        "description": "",
        "defaultValue": "/etc/sqoop",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General"
      },
      {
        "id": "puppet var",
        "name": "sqoop_lib",
        "displayName": "sqoop conf dir",
        "description": "",
        "defaultValue": "/usr/lib/sqoop/lib/",
        "isReconfigurable": false,
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General"
      },
      */
      {
        "id": "puppet var",
        "name": "zk_user",
        "displayName": "ZooKeeper User",
        "description": "User to run ZooKeeper as",
        "defaultValue": "zookeeper",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["ZOOKEEPER"]
      },
      {
        "id": "puppet var",
        "name": "gmetad_user",
        "displayName": "Ganglia User",
        "description": "The user used to run Ganglia",
        "defaultValue": "nobody",
        "isReconfigurable": false,
        "displayType": "advanced",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["GANGLIA"]
      },
      {
        "id": "puppet var",
        "name": "gmond_user",
        "displayName": "Gmond User",
        "description": "The user used to run gmond for Ganglia",
        "defaultValue": "nobody",
        "isReconfigurable": false,
        "displayType": "advanced",
        "isOverridable": false,
        "isVisible": false,
        "domain": "global",
        "serviceName":"MISC",
        "category": "Users and Groups",
        "belongsToService":[]
      },
      {
        "id": "puppet var",
        "name": "nagios_user",
        "displayName": "Nagios User",
        "description": "User to run Nagios as",
        "defaultValue": "nagios",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "domain": "global",
        "isVisible": true,
        "serviceName":"MISC",
        "category": "Users and Groups",
        "belongsToService":["NAGIOS"]
      },
      {
        "id": "puppet var",
        "name": "smokeuser",
        "displayName": "Smoke Test User",
        "description": "The user used to run service smoke tests",
        "defaultValue": "ambari-qa",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": App.supports.customizeSmokeTestUser,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["HDFS"]
      },
      {
        "id": "puppet var",
        "name": "user_group",
        "displayName": "Group",
        "description": "Group that the users specified above belong to",
        "defaultValue": "hadoop",
        "isReconfigurable": false,
        "displayType": "user",
        "isOverridable": false,
        "isVisible": true,
        "domain": "global",
        "serviceName": "MISC",
        "category": "Users and Groups",
        "belongsToService":["HDFS"]
      },
      /*
      {
        "id": "puppet var",
        "name": "zk_conf_dir",
        "displayName": "zk_conf_dir",
        "description": "",
        "defaultValue": "/etc/conf/",
        "displayType": "directory",
        "isVisible": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General"
      },
      */
      {
        "id": "puppet var",
        "name": "rrdcached_base_dir",
        "displayName": "Ganglia rrd cached base directory",
        "description": "Default directory for saving the rrd files on ganglia server",
        "defaultValue": "/var/lib/ganglia/rrds",
        "displayType": "directory",
        "isOverridable": false,
        "domain": "global",
        "serviceName": "MISC",
        "category": "General",
        "belongsToService":["GANGLIA"]
      }
    ]
  };
  
});
window.require.register("data/custom_configs", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  module.exports =
    [
      {
        "id": "site property",
        "name": "mapred.capacity-scheduler.queue.<queue-name>.capacity",
        "displayName": "Capacity",
        "value": '',
        "defaultValue": '',
        "description": "Percentage of the number of slots in the cluster that are made to be available for jobs in this queue. The sum of capacities for all queues should be less than or equal 100.",
        "isVisible": true,
        "isRequired": true,
        "serviceName": "MAPREDUCE",
        "category": "CapacityScheduler",
        "unit": "%",
        "isQueue": true,
        "filename": 'capacity-scheduler.xml',
        "index": 1
      },
      {
        "id": "site property",
        "name": "mapred.capacity-scheduler.queue.<queue-name>.maximum-capacity",
        "displayName": "Max Capacity",
        "value": '',
        "defaultValue": 100,
        "displayType": "int",
        "description": "Defines a limit beyond which a queue cannot use the capacity of the cluster." +
          "This provides a means to limit how much excess capacity a queue can use. By default, there is no limit." +
          "The Max Capacity of a queue can only be greater than or equal to its minimum capacity. " +
          "This property could be to curtail certain jobs which are long running in nature from occupying more than a certain " +
          "percentage of the cluster, which in the absence of pre-emption, could lead to capacity guarantees of other queues being affected. " +
          "One important thing to note is that maximum-capacity is a percentage , so based on the cluster's capacity it would change. " +
          "So if large no of nodes or racks get added to the cluster, Max Capacity in absolute terms would increase accordingly. ",
        "isVisible": true,
        "isRequired": true,
        "serviceName": "MAPREDUCE",
        "category": "CapacityScheduler",
        "unit": "%",
        "valueRange": [0, 100],
        "isQueue": true,
        "filename": 'capacity-scheduler.xml',
        "index": 2
      },
      {
        "id": "site property",
        "name": "mapred.capacity-scheduler.queue.<queue-name>.minimum-user-limit-percent",
        "displayName": "Min User Limit",
        "value": '',
        "defaultValue": 100,
        "displayType": "int",
        "description": "Each queue enforces a limit on the percentage of resources allocated to a user at any given time, " +
          "if there is competition for them. This user limit can vary between a minimum and maximum value. " +
          "The former depends on the number of users who have submitted jobs, and the latter is set to this property value. " +
          "For example, suppose the value of this property is 25. If two users have submitted jobs to a queue, no single user " +
          "can use more than 50% of the queue resources. If a third user submits a job, no single user can use more than 33% of " +
          "the queue resources. With 4 or more users, no user can use more than 25% of the queue's resources. " +
          "A value of 100 implies no user limits are imposed.",
        "isVisible": true,
        "isRequired": true,
        "serviceName": "MAPREDUCE",
        "category": "CapacityScheduler",
        "unit": "%",
        "valueRange": [1, 100],
        "isQueue": true,
        "filename": 'capacity-scheduler.xml',
        "index": 9
      },
      {
        "id": "site property",
        "name": "mapred.capacity-scheduler.queue.<queue-name>.user-limit-factor",
        "displayName": "User Limit Factor",
        "value": '',
        "defaultValue": 1,
        "displayType": "int",
        "description": "The multiple of the queue capacity which can be configured to allow a single user to acquire more slots. " +
          "By default this is set to 1 which ensure that a single user can never take more than the queue's configured capacity " +
          "irrespective of how idle the cluster is.",
        "isVisible": true,
        "isRequired": true,
        "serviceName": "MAPREDUCE",
        "category": "CapacityScheduler",
        "isQueue": true,
        "filename": 'capacity-scheduler.xml',
        "index": 8
      },
      {
        "id": "site property",
        "name": "mapred.capacity-scheduler.queue.<queue-name>.supports-priority",
        "displayName": "Supports Priority",
        "value": 'false',
        "defaultValue": false,
        "displayType": "checkbox",
        "description": "If true, priorities of jobs will be taken into account in scheduling decisions.",
        "isVisible": true,
        "isRequired": true,
        "serviceName": "MAPREDUCE",
        "category": "CapacityScheduler",
        "isQueue": true,
        "filename": 'capacity-scheduler.xml',
        "index": 7
      },
      {
        "id": "site property",
        "name": "mapred.queue.<queue-name>.acl-submit-job",
        "displayName": "",
        "value": '',
        "defaultValue": '',
        "description": "",
        "isVisible": false,
        "isRequired": true,
        "serviceName": "MAPREDUCE",
        "category": "CapacityScheduler",
        "isQueue": true,
        "filename": 'mapred-queue-acls.xml',
        "index": 13
      },
      {
        "id": "site property",
        "name": "mapred.queue.<queue-name>.acl-administer-jobs",
        "displayName": "",
        "value": '',
        "defaultValue": '',
        "description": "",
        "isVisible": false,
        "isRequired": true,
        "serviceName": "MAPREDUCE",
        "category": "CapacityScheduler",
        "isQueue": true,
        "filename": 'mapred-queue-acls.xml',
        "index": 14
      },
      {
        "id": "site property",
        "name": "mapred.capacity-scheduler.queue.<queue-name>.maximum-initialized-active-tasks",
        "displayName": "Max initialized active tasks",
        "value": '',
        "defaultValue": 200000,
        "displayType": "int",
        "description": "The maximum number of tasks, across all jobs in the queue, which can be initialized concurrently. " +
          "Once the queue's jobs exceed this limit they will be queued on disk.",
        "isVisible": true,
        "isRequired": true,
        "serviceName": "MAPREDUCE",
        "category": "CapacityScheduler",
        "isQueue": true,
        "filename": 'capacity-scheduler.xml',
        "index": 10
      },
      {
        "id": "site property",
        "name": "mapred.capacity-scheduler.queue.<queue-name>.maximum-initialized-active-tasks-per-user",
        "displayName": "Max initialized active tasks per user",
        "value": '',
        "defaultValue": 100000,
        "displayType": "int",
        "description": "The maximum number of tasks per-user, across all the of the user's jobs in the queue, which " +
          "can be initialized concurrently. Once the user's jobs exceed this limit they will be queued on disk.",
        "isVisible": true,
        "isRequired": true,
        "serviceName": "MAPREDUCE",
        "category": "CapacityScheduler",
        "isQueue": true,
        "filename": 'capacity-scheduler.xml',
        "index": 11
      },
      {
        "id": "site property",
        "name": "mapred.capacity-scheduler.queue.<queue-name>.init-accept-jobs-factor",
        "displayName": "Init accept jobs factor",
        "value": '',
        "defaultValue": 10,
        "displayType": "int",
        "description": "The multiple of (maximum-system-jobs * queue-capacity) used to determine the number of " +
          "jobs which are accepted by the scheduler. The default value is 10. If number of jobs submitted to " +
          "the queue exceeds this limit, job submission are rejected.",
        "isVisible": true,
        "isRequired": true,
        "serviceName": "MAPREDUCE",
        "category": "CapacityScheduler",
        "isQueue": true,
        "filename": 'capacity-scheduler.xml',
        "index": 12
      }
    ]
});
window.require.register("data/review_configs", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  module.exports = [

    {
      config_name: 'Admin',
      display_name: 'Admin Name',
      config_value: ''
    },
    {
      config_name: 'cluster',
      display_name: 'Cluster Name',
      config_value: ''
    },
    {
      config_name: 'hosts',
      display_name: 'Total Hosts',
      config_value: ''
    },
    {
      config_name: 'Repo',
      display_name: 'Local Repository',
      config_value: ''
    },
    {
      config_name: 'services',
      display_name: 'Services',
      config_value: [
        Ember.Object.create({
          service_name: 'HDFS',
          display_name: 'HDFS',
          service_components: [
            Ember.Object.create({
              display_name: 'NameNode',
              component_value: ''
            }),
            Ember.Object.create({
              display_name: 'SecondaryNameNode',
              component_value: ''
            }),
            Ember.Object.create({
              display_name: 'DataNodes',
              component_value: ''
            })
          ]
        }),
        Ember.Object.create({
          service_name: 'HCFS',
          display_name: 'HCFS',
          service_components: [
            Ember.Object.create({
              display_name: 'HCFS Client',
              component_value: ''
            })
          ]
        }),
        Ember.Object.create({
          service_name: 'MAPREDUCE',
          display_name: 'MapReduce',
          service_components: [
            Ember.Object.create({
              display_name: 'JobTracker',
              component_value: ''
            }),
            Ember.Object.create({
              display_name: 'TaskTrackers',
              component_value: ''
            })
          ]
        }),
        Ember.Object.create({
          service_name: 'MAPREDUCE2',
          display_name: 'MapReduce 2',
          service_components: [
            Ember.Object.create({
              display_name: 'History Server',
              component_value: ''
            })
          ]
        }),
        Ember.Object.create({
          service_name: 'YARN',
          display_name: 'YARN',
          service_components: [
            Ember.Object.create({
              display_name: 'Node Manager',
              component_value: ''
            }),
            Ember.Object.create({
              display_name: 'Resource Manager',
              component_value: ''
            })
          ]
        }),
        Ember.Object.create({
          service_name: 'HIVE',
          display_name: 'Hive + HCatalog',
          service_components: [
            Ember.Object.create({
              display_name: 'Hive Metastore',
              component_value: ''
            }),
            Ember.Object.create({
              display_name: 'Database',
              component_value: ''
            })
          ]
        }),
        Ember.Object.create({
          service_name: 'HBASE',
          display_name: 'HBase',
          service_components: [
            Ember.Object.create({
              display_name: 'Master',
              component_value: ''
            }),
            Ember.Object.create({
              display_name: 'RegionServers',
              component_value: ''
            })
          ]
        }),
        Ember.Object.create({
          service_name: 'ZOOKEEPER',
          display_name: 'ZooKeeper',
          service_components: [
            Ember.Object.create({
              display_name: 'Servers',
              component_value: ''
            })
          ]
        }),
        Ember.Object.create({
          service_name: 'OOZIE',
          display_name: 'Oozie',
          service_components: [
            Ember.Object.create({
              display_name: 'Server',
              component_value: ''
            }),
            // TODO: uncomment when ready to integrate with database other than Derby
            Ember.Object.create({
               display_name: 'Database',
               component_value: ''
            })
          ]
        }),
        Ember.Object.create({
          service_name: 'NAGIOS',
          display_name: 'Nagios',
          service_components: [
            Ember.Object.create({
              display_name: 'Server',
              component_value: ''
            }),
            Ember.Object.create({
              display_name: 'Administrator',
              component_value: ''
            })
          ]
        }),
        Ember.Object.create({
          service_name: 'GANGLIA',
          display_name: 'Ganglia',
          service_components: [
            Ember.Object.create({
              display_name: 'Server',
              component_value: ''
            })
          ]
        }),
        Ember.Object.create({
          service_name: 'TEZ',
          display_name: 'TEZ',
          service_components: []
        }),
        Ember.Object.create({
          service_name: 'PIG',
          display_name: 'Pig',
          service_components: []
        }),
        Ember.Object.create({
          service_name: 'SQOOP',
          display_name: 'Sqoop',
          service_components: []
        }),
        Ember.Object.create({
          service_name: 'HCATALOG',
          display_name: 'HCatalog',
          service_components: [
            Ember.Object.create({

            })
          ]
        }),
        Ember.Object.create({
          service_name: 'HUE',
          display_name: 'Hue',
          service_components: [
            Ember.Object.create({
              display_name: 'Server',
              component_value: ''
            })
          ]
        })

      ]
    }
  ];
});
window.require.register("data/secure_configs", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var App = require('app');
  require('models/service_config');
  App.SecureConfigProperties = Ember.ArrayProxy.extend({
    content: require('data/secure_properties').configProperties
  });

  var configProperties = App.SecureConfigProperties.create();

  module.exports = [
    {
      serviceName: 'GENERAL',
      displayName: 'General',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'KERBEROS', displayName: 'Kerberos'}),
        App.ServiceConfigCategory.create({ name: 'AMBARI', displayName: 'Ambari'})
      ],
      sites: ['global'],
      configs: configProperties.filterProperty('serviceName', 'GENERAL')
    },
    {
      serviceName: 'HDFS',
      displayName: 'HDFS',
      filename: 'hdfs-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'General', displayName: 'General'}),
        App.ServiceConfigCategory.create({ name: 'NameNode', displayName: 'NameNode'}),
        App.ServiceConfigCategory.create({ name: 'SNameNode', displayName: 'Secondary NameNode'}),
        App.ServiceConfigCategory.create({ name: 'DataNode', displayName: 'DataNode'})
      ],
      sites: ['core-site', 'hdfs-site'],
      configs: configProperties.filterProperty('serviceName', 'HDFS')
    },

    {
      serviceName: 'MAPREDUCE',
      displayName: 'MapReduce',
      filename: 'mapred-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'JobTracker', displayName: 'JobTracker and Job History Server'}),
        App.ServiceConfigCategory.create({ name: 'TaskTracker', displayName: 'TaskTracker'})
      ],
      sites: ['mapred-site'],
      configs: configProperties.filterProperty('serviceName', 'MAPREDUCE')
    },

    {
      serviceName: 'HIVE',
      displayName: 'Hive',
      filename: 'hive-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'Hive Metastore', displayName: 'Hive Metastore and Hive Server 2'})
      ],
      sites: ['hive-site'],
      configs: configProperties.filterProperty('serviceName', 'HIVE')
    },
    {
      serviceName: 'WEBHCAT',
      displayName: 'WebHCat',
      filename: 'webhcat-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'WebHCat Server', displayName : 'WebHCat Server'})
      ],
      sites: ['webhcat-site'],
      configs: configProperties.filterProperty('serviceName', 'WEBHCAT')
    },
    {
      serviceName: 'HBASE',
      displayName: 'HBase',
      filename: 'hbase-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'HBase Master', displayName : 'HBase Master'}),
        App.ServiceConfigCategory.create({ name: 'RegionServer', displayName : 'RegionServer'})
      ],
      sites: ['hbase-site'],
      configs: configProperties.filterProperty('serviceName', 'HBASE')
    },
    {
      serviceName: 'ZOOKEEPER',
      displayName: 'ZooKeeper',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'ZooKeeper Server', displayName: 'ZooKeeper Server'})
      ],
      configs: configProperties.filterProperty('serviceName', 'ZOOKEEPER')

    },
    {
      serviceName: 'OOZIE',
      displayName: 'Oozie',
      filename: 'oozie-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'Oozie Server', displayName:  'Oozie Server'})
      ],
      sites: ['oozie-site'],
      configs: configProperties.filterProperty('serviceName', 'OOZIE')
    },
    {
      serviceName: 'NAGIOS',
      displayName: 'Nagios',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'Nagios Server', displayName:  'Nagios Server'})
      ],
      configs: configProperties.filterProperty('serviceName', 'NAGIOS')
    }

  ];
  
});
window.require.register("data/secure_mapping", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  module.exports = [
    {
      "name": "hadoop.security.authentication",
      "templateName": [],
      "foreignKey": null,
      "value": "kerberos",
      "filename": "core-site.xml",
      "serviceName": "HDFS"
    },
    {
      "name": "hadoop.security.authorization",
      "templateName": [],
      "foreignKey": null,
      "value": "true",
      "filename": "core-site.xml",
      "serviceName": "HDFS"
    },

    {
      "name": "hadoop.security.auth_to_local",
      "templateName": ["jobtracker_primary_name", "kerberos_domain", "mapred_user", "tasktracker_primary_name", "namenode_primary_name", "hdfs_user", "datanode_primary_name", "hbase_master_primary_name", "hbase_user","hbase_regionserver_primary_name","oozie_primary_name","oozie_user"],
      "foreignKey": null,
      "value": "RULE:[2:$1@$0](<templateName[0]>@.*<templateName[1]>)s/.*/<templateName[2]>/\nRULE:[2:$1@$0](<templateName[3]>@.*<templateName[1]>)s/.*/<templateName[2]>/\nRULE:[2:$1@$0](<templateName[4]>@.*<templateName[1]>)s/.*/<templateName[5]>/\nRULE:[2:$1@$0](<templateName[6]>@.*<templateName[1]>)s/.*/<templateName[5]>/\nRULE:[2:$1@$0](<templateName[7]>@.*<templateName[1]>)s/.*/<templateName[8]>/\nRULE:[2:$1@$0](<templateName[9]>@.*<templateName[1]>)s/.*/<templateName[8]>/\nRULE:[2:$1@$0](<templateName[10]>@.*<templateName[1]>)s/.*/<templateName[11]>/\nDEFAULT",
      "filename": "core-site.xml",
      "serviceName": "HDFS",
      "dependedServiceName": [{name: "HBASE", replace: "\nRULE:[2:$1@$0](<templateName[7]>@.*<templateName[1]>)s/.*/<templateName[8]>/\nRULE:[2:$1@$0](<templateName[9]>@.*<templateName[1]>)s/.*/<templateName[8]>/"},{name: "OOZIE",replace: "\nRULE:[2:$1@$0](<templateName[10]>@.*<templateName[1]>)s/.*/<templateName[11]>/"}]
    },
    {
      "name": "dfs.namenode.kerberos.principal",
      "templateName": ["namenode_principal_name", "kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>@<templateName[1]>",
      "filename": "hdfs-site.xml",
      "serviceName": "HDFS"
    },
    {
      "name": "dfs.namenode.keytab.file",
      "templateName": ["namenode_keytab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml",
      "serviceName": "HDFS"
    },
    {
      "name": "dfs.secondary.namenode.kerberos.principal",
      "templateName": ["snamenode_principal_name", "kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>@<templateName[1]>",
      "filename": "hdfs-site.xml"
    },
    {
      "name": "dfs.secondary.namenode.keytab.file",
      "templateName": ["snamenode_keytab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml",
      "serviceName": "HDFS"
    },
    {
      "name": "dfs.web.authentication.kerberos.principal",
      "templateName": ["hadoop_http_principal_name", "kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>@<templateName[1]>",
      "filename": "hdfs-site.xml",
      "serviceName": "HDFS"
    },
    {
      "name": "dfs.web.authentication.kerberos.keytab",
      "templateName": ["hadoop_http_keytab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml",
      "serviceName": "HDFS"
    },
    {
      "name": "dfs.datanode.kerberos.principal",
      "templateName": ["datanode_principal_name", "kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>@<templateName[1]>",
      "filename": "hdfs-site.xml",
      "serviceName": "HDFS"
    },
    {
      "name": "dfs.datanode.keytab.file",
      "templateName": ["datanode_keytab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hdfs-site.xml",
      "serviceName": "HDFS"
    },
    {
      "name": "dfs.namenode.kerberos.internal.spnego.principal",
      "templateName": [],
      "foreignKey": null,
      "value": "${dfs.web.authentication.kerberos.principal}",
      "filename": "hdfs-site.xml",
      "serviceName": "HDFS"
    },
    {
      "name": "dfs.secondary.namenode.kerberos.internal.spnego.principal",
      "templateName": [],
      "foreignKey": null,
      "value": "${dfs.web.authentication.kerberos.principal}",
      "filename": "hdfs-site.xml",
      "serviceName": "HDFS"
    },
    {
      "name": "dfs.datanode.address",
      "templateName": ["dfs_datanode_address"],
      "foreignKey": null,
      "value": "0.0.0.0:<templateName[0]>",
      "filename": "hdfs-site.xml",
      "serviceName": "HDFS"
    },
    {
      "name": "dfs.datanode.http.address",
      "templateName": ["dfs_datanode_http_address"],
      "foreignKey": null,
      "value": "0.0.0.0:<templateName[0]>",
      "filename": "hdfs-site.xml",
      "serviceName": "HDFS"
    },
    {
      "name": "mapreduce.jobtracker.kerberos.principal",
      "templateName": ["jobtracker_principal_name", "kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>@<templateName[1]>",
      "filename": "mapred-site.xml",
      "serviceName": "MAPREDUCE"
    },
    {
      "name": "mapreduce.jobtracker.keytab.file",
      "templateName": ["jobtracker_keytab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml",
      "serviceName": "MAPREDUCE"
    },
    {
      "name": "mapreduce.jobhistory.kerberos.principal",
      "templateName": ["jobtracker_principal_name", "kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>@<templateName[1]>",
      "filename": "mapred-site.xml",
      "serviceName": "MAPREDUCE"
    },
    {
      "name": "mapreduce.jobhistory.keytab.file",
      "templateName": ["jobtracker_keytab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml",
      "serviceName": "MAPREDUCE"
    },
    {
      "name": "mapreduce.tasktracker.kerberos.principal",
      "templateName": ["tasktracker_principal_name", "kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>@<templateName[1]>",
      "filename": "mapred-site.xml",
      "serviceName": "MAPREDUCE"
    },
    {
      "name": "mapreduce.tasktracker.keytab.file",
      "templateName": ["tasktracker_keytab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml",
      "serviceName": "MAPREDUCE"
    },
    {
      "name": "mapred.task.tracker.task-controller",
      "templateName": ["tasktracker_task_controller"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "mapred-site.xml",
      "serviceName": "MAPREDUCE"
    },
    {
      "name": "hbase.master.kerberos.principal",
      "templateName": ["hbase_master_principal_name", "kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>@<templateName[1]>",
      "filename": "hbase-site.xml",
      "serviceName": "HBASE"
    },
    {
      "name": "hbase.master.keytab.file",
      "templateName": ["hbase_master_keytab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml",
      "serviceName": "HBASE"
    },
    {
      "name": "hbase.regionserver.kerberos.principal",
      "templateName": ["hbase_regionserver_principal_name", "kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>@<templateName[1]>",
      "filename": "hbase-site.xml",
      "serviceName": "HBASE"
    },
    {
      "name": "hbase.regionserver.keytab.file",
      "templateName": ["hbase_regionserver_keytab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hbase-site.xml",
      "serviceName": "HBASE"
    },
    {
      "name": "hive.metastore.sasl.enabled",
      "templateName": [],
      "foreignKey": null,
      "value": "true",
      "filename": "hive-site.xml",
      "serviceName": "HIVE"
    },
    {
      "name": "hive.server2.authentication",
      "templateName": [],
      "foreignKey": null,
      "value": "KERBEROS",
      "filename": "hive-site.xml",
      "serviceName": "HIVE"
    },
    {
      "name": "hive.metastore.kerberos.principal",
      "templateName": ["hive_metastore_principal_name", "kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>@<templateName[1]>",
      "filename": "hive-site.xml",
      "serviceName": "HIVE"
    },
    {
      "name": "hive.metastore.kerberos.keytab.file",
      "templateName": ["hive_metastore_keytab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hive-site.xml",
      "serviceName": "HIVE"
    },
    {
      "name": "hive.server2.authentication.kerberos.principal",
      "templateName": ["hive_metastore_principal_name", "kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>@<templateName[1]>",
      "filename": "hive-site.xml",
      "serviceName": "HIVE"
    },
    {
      "name": "hive.server2.authentication.kerberos.keytab",
      "templateName": ["hive_metastore_keytab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "hive-site.xml",
      "serviceName": "HIVE"
    },
    {
      "name": "oozie.service.AuthorizationService.authorization.enabled",
      "templateName": [],
      "foreignKey": null,
      "value": "true",
      "filename": "oozie-site.xml",
      "serviceName": "OOZIE"
    },
    {
      "name": "oozie.service.HadoopAccessorService.kerberos.enabled",
      "templateName": [],
      "foreignKey": null,
      "value": "true",
      "filename": "oozie-site.xml",
      "serviceName": "OOZIE"
    },
    {
      "name": "local.realm",
      "templateName": ["kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "oozie-site.xml",
      "serviceName": "OOZIE"
    },
    {
      "name": "oozie.service.HadoopAccessorService.keytab.file",
      "templateName": ["oozie_keytab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "oozie-site.xml",
      "serviceName": "OOZIE"
    },
    {
      "name": "oozie.service.HadoopAccessorService.kerberos.principal",
      "templateName": ["oozie_principal_name", "kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>@<templateName[1]>",
      "filename": "oozie-site.xml",
      "serviceName": "OOZIE"
    },
    {
      "name": "oozie.authentication.type",
      "templateName": [],
      "foreignKey": null,
      "value": "kerberos",
      "filename": "oozie-site.xml",
      "serviceName": "OOZIE"
    },
    {
      "name": "oozie.authentication.kerberos.principal",
      "templateName": ["oozie_http_principal_name", "kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>@<templateName[1]>",
      "filename": "oozie-site.xml",
      "serviceName": "OOZIE"
    },
    {
      "name": "oozie.authentication.kerberos.keytab",
      "templateName": ["oozie_http_keytab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "oozie-site.xml",
      "serviceName": "OOZIE"
    },
    {
      "name": "oozie.authentication.kerberos.name.rules",
      "templateName": ["jobtracker_primary_name", "kerberos_domain", "mapred_user", "tasktracker_primary_name", "namenode_primary_name", "hdfs_user", "datanode_primary_name", "hbase_master_primary_name", "hbase_user","hbase_regionserver_primary_name"],
      "foreignKey": null,
      "value": "RULE:[2:$1@$0](<templateName[0]>@.*<templateName[1]>)s/.*/<templateName[2]>/\nRULE:[2:$1@$0](<templateName[3]>@.*<templateName[1]>)s/.*/<templateName[2]>/\nRULE:[2:$1@$0](<templateName[4]>@.*<templateName[1]>)s/.*/<templateName[5]>/\nRULE:[2:$1@$0](<templateName[6]>@.*<templateName[1]>)s/.*/<templateName[5]>/\nRULE:[2:$1@$0](<templateName[7]>@.*<templateName[1]>)s/.*/<templateName[8]>/\nRULE:[2:$1@$0](<templateName[9]>@.*<templateName[1]>)s/.*/<templateName[8]>/\nDEFAULT",
      "filename": "oozie-site.xml",
      "serviceName": "OOZIE",
      "dependedServiceName": [{name: "HBASE", replace: "\nRULE:[2:$1@$0](<templateName[7]>@.*<templateName[1]>)s/.*/<templateName[8]>/\nRULE:[2:$1@$0](<templateName[9]>@.*<templateName[1]>)s/.*/<templateName[8]>/"}]
    },
    {
      "name": "templeton.kerberos.principal",
      "templateName": ["webHCat_http_principal_name", "kerberos_domain"],
      "foreignKey": null,
      "value": "<templateName[0]>@<templateName[1]>",
      "filename": "webhcat-site.xml",
      "serviceName": "WEBHCAT"
    },
    {
      "name": "templeton.kerberos.keytab",
      "templateName": ["webhcat_http_keytab"],
      "foreignKey": null,
      "value": "<templateName[0]>",
      "filename": "webhcat-site.xml",
      "serviceName": "WEBHCAT"
    },
    {
      "name": "templeton.kerberos.secret",
      "templateName": [""],
      "foreignKey": null,
      "value": "secret",
      "filename": "webhcat-site.xml",
      "serviceName": "WEBHCAT"
    },
    {
      "name": "templeton.hive.properties",
      "templateName": ["hivemetastore_host","hive_metastore_principal_name","kerberos_domain"],
      "foreignKey": null,
      "value": "hive.metastore.local=false,hive.metastore.uris=thrift://<templateName[0]>:9083,hive." +
        "metastore.sasl.enabled=true,hive.metastore.execute.setugi=true,hive.metastore.warehouse.dir=/apps/hive/warehouse,hive.exec.mode.local.auto=false,hive.metastore.kerberos.principal=<templateName[1]>@<templateName[2]>",
      "filename": "webhcat-site.xml",
      "serviceName": "WEBHCAT"
    },
    {
      "name": "hbase.coprocessor.master.classes",
      "templateName": [],
      "foreignKey": null,
      "value": "org.apache.hadoop.hbase.security.access.AccessController",
      "filename": "hbase-site.xml",
      "serviceName": "HBASE"
    },
    {
      "name": "hbase.coprocessor.region.classes",
      "templateName": [],
      "foreignKey": null,
      "value": "org.apache.hadoop.hbase.security.token.TokenProvider,org.apache.hadoop.hbase.security.access.SecureBulkLoadEndpoint,org.apache.hadoop.hbase.security.access.AccessController",
      "filename": "hbase-site.xml",
      "serviceName": "HBASE"
    },
    {
      "name": "hbase.security.authentication",
      "templateName": [],
      "foreignKey": null,
      "value": "kerberos",
      "filename": "hbase-site.xml",
      "serviceName": "HBASE"
    },
    {
      "name": "hbase.rpc.engine",
      "templateName": [],
      "foreignKey": null,
      "value": "org.apache.hadoop.hbase.ipc.SecureRpcEngine",
      "filename": "hbase-site.xml",
      "serviceName": "HBASE"
    },
    {
      "name": "hbase.security.authorization",
      "templateName": [],
      "foreignKey": null,
      "value": "true",
      "filename": "hbase-site.xml",
      "serviceName": "HBASE"
    },
    {
      "name": "hbase.bulkload.staging.dir",
      "templateName": [],
      "foreignKey": null,
      "value": "/apps/hbase/staging",
      "filename": "hbase-site.xml",
      "serviceName": "HBASE"
    },
    {
      "name": "zookeeper.znode.parent",
      "templateName": [],
      "foreignKey": null,
      "value": "/hbase-secure",
      "filename": "hbase-site.xml",
      "serviceName": "HBASE"
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.groups",
      "templateName": ["proxyuser_group"],
      "foreignKey": ["hive_metastore_primary_name"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "serviceName": "HIVE"
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.hosts",
      "templateName": ["hivemetastore_host"],
      "foreignKey": ["hive_metastore_primary_name"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "serviceName": "HIVE"
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.groups",
      "templateName": ["proxyuser_group"],
      "foreignKey": ["oozie_primary_name"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "serviceName": "OOZIE"
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.hosts",
      "templateName": ["oozieserver_host"],
      "foreignKey": ["oozie_primary_name"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "serviceName": "OOZIE"
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.groups",
      "templateName": ["proxyuser_group"],
      "foreignKey": ["webHCat_http_primary_name"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "serviceName": "WEBHCAT"
    },
    {
      "name": "hadoop.proxyuser.<foreignKey[0]>.hosts",
      "templateName": ["webhcat_server"],
      "foreignKey": ["webHCat_http_primary_name"],
      "value": "<templateName[0]>",
      "filename": "core-site.xml",
      "serviceName": "WEBHCAT"
    }
  ];

  
});
window.require.register("data/secure_properties", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  module.exports =
  {
    "configProperties": [
      {
        "id": "puppet var",
        "name": "security_enabled",
        "displayName": "Enable security",
        "value": "",
        "defaultValue": 'true',
        "description": "Enable kerberos security for the cluster",
        "isVisible": false,
        "isOverridable": false,
        "serviceName": "GENERAL",
        "category": "KERBEROS"
      },
      {
        "id": "puppet var",
        "name": "kerberos_install_type",
        "displayName": "Type of security",
        "value": "",
        "defaultValue": "MANUALLY_SET_KERBEROS",
        "description": "Type of kerberos security for the cluster",
        "isVisible": false,
        "isOverridable": false,
        "serviceName": "GENERAL",
        "category": "KERBEROS"
      },
      {
        "id": "puppet var",
        "name": "keytab_path",
        "displayName": "Path to keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs",
        "description": "Type of kerberos security for the cluster",
        "displayType": "principal",
        "isVisible": false,
        "isOverridable": false,
        "serviceName": "GENERAL",
        "category": "AMBARI"
      },
      {
        "id": "puppet var",
        "name": "kerberos_domain",
        "displayName": "Realm name",
        "value": "",
        "defaultValue": "EXAMPLE.COM",
        "description": "Realm name to be used for all principal names",
        "displayType": "advanced",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "GENERAL",
        "category": "KERBEROS"
      },
      {
        "id": "puppet var",
        "name": "kinit_path_local",
        "displayName": "Kerberos tool path",
        "value": "",
        "defaultValue": "/usr/bin",
        "description": "Directoy path to installed kerberos tools like kinit, kdestroy etc. This can have multiple comma delimited paths",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "GENERAL",
        "category": "KERBEROS"
      },
      {
        "id": "puppet var",
        "name": "smokeuser_principal_name",
        "displayName": "Smoke test user Principal",
        "value": "",
        "defaultValue": "ambari-qa",
        "description": "This is the principal name for Smoke test user",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "isReconfigurable": false,
        "serviceName": "GENERAL",
        "category": "AMBARI"
      },
      {
        "id": "puppet var",
        "name": "smokeuser_keytab",
        "displayName": "Path to smoke test user keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/smokeuser.headless.keytab",
        "description": "Path to keytab file for smoke test user",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "GENERAL",
        "category": "AMBARI"
      },
      {
        "id": "puppet var",
        "name": "hdfs_principal_name",
        "displayName": "HDFS User Principal",
        "value": "",
        "defaultValue": "hdfs",
        "description": "This is the principal name for HDFS user",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "isReconfigurable": false,
        "serviceName": "GENERAL",
        "category": "AMBARI"
      },
      {
        "id": "puppet var",
        "name": "hdfs_user_keytab",
        "displayName": "Path to HDFS user keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/hdfs.headless.keytab",
        "description": "Path to keytab file for HDFS user",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "GENERAL",
        "category": "AMBARI"
      },
      {
        "id": "puppet var",
        "name": "hbase_principal_name",
        "displayName": "HBase User Principal",
        "value": "",
        "defaultValue": "hbase",
        "description": "This is the principal name for HBase user",
        "displayType": "principal",
        "isVisible": false,
        "isOverridable": false,
        "isReconfigurable": false,
        "serviceName": "GENERAL",
        "category": "AMBARI"
      },
      {
        "id": "puppet var",
        "name": "hbase_user_keytab",
        "displayName": "Path to HBase user keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/hbase.headless.keytab",
        "description": "Path to keytab file for Hbase user",
        "displayType": "directory",
        "isVisible": false,
        "isOverridable": false,
        "serviceName": "GENERAL",
        "category": "AMBARI"
      },

      //HDFS
      {
        "id": "puppet var",
        "name": "namenode_host",
        "displayName": "NameNode host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run NameNode",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "serviceName": "HDFS",
        "category": "NameNode"
      },
      {
        "id": "puppet var",
        "name": "namenode_principal_name",
        "displayName": "Principal name",
        "value": "",
        "defaultValue": "nn/_HOST",
        "description": "Principal name for NameNode. _HOST will get automatically replaced with actual hostname at an instance of NameNode",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HDFS",
        "category": "NameNode",
        "components": ["NAMENODE"]
      },
      {
        "id": "puppet var",
        "name": "namenode_keytab",
        "displayName": "Path to Keytab File",
        "value": "",
        "defaultValue": "/etc/security/keytabs/nn.service.keytab",
        "description": "Path to NameNode keytab file",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HDFS",
        "category": "NameNode",
        "components": ["NAMENODE"]
      },
      {
        "id": "puppet var",
        "name": "snamenode_host",
        "displayName": "SNameNode host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run SecondaryNameNode",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "serviceName": "HDFS",
        "category": "SNameNode"
      },
      {
        "id": "puppet var",
        "name": "snamenode_principal_name",
        "displayName": "Principal name",
        "value": "",
        "defaultValue": "nn/_HOST",
        "description": "Principal name for SNameNode. _HOST will get automatically replaced with actual hostname at an instance of SNameNode",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HDFS",
        "category": "SNameNode",
        "components": ["SECONDARY_NAMENODE"]
      },
      {
        "id": "puppet var",
        "name": "snamenode_keytab",
        "displayName": "Path to Keytab File",
        "value": "",
        "defaultValue": "/etc/security/keytabs/nn.service.keytab",
        "description": "Path to SNameNode keytab file",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HDFS",
        "category": "SNameNode",
        "components": ["SECONDARY_NAMENODE"]
      },
      {
        "id": "puppet var",
        "name": "datanode_hosts", //not in the schema. For UI purpose
        "displayName": "DataNode hosts",
        "value": "",
        "defaultValue": "",
        "description": "The hosts that have been assigned to run DataNode",
        "displayType": "slaveHosts",
        "isOverridable": false,
        "isVisible": true,
        "serviceName": "HDFS",
        "category": "DataNode"
      },
      {
        "id": "puppet var",
        "name": "dfs_datanode_address",
        "displayName": "Datanode address",
        "value": "",
        "defaultValue": "1019",
        "description": "Address for DataNode",
        "displayType": "principal",
        "isVisible": false,
        "isOverridable": false,
        "serviceName": "HDFS",
        "category": "DataNode"
      },
      {
        "id": "puppet var",
        "name": "dfs_datanode_http_address",
        "displayName": "Datanode HTTP address",
        "value": "",
        "defaultValue": "1022",
        "description": "Address for DataNode",
        "displayType": "principal",
        "isVisible": false,
        "isOverridable": false,
        "serviceName": "HDFS",
        "category": "DataNode"
      },
      {
        "id": "puppet var",
        "name": "datanode_principal_name",
        "displayName": "Principal name",
        "value": "",
        "defaultValue": "dn/_HOST",
        "description": "Principal name for DataNode. _HOST will get automatically replaced with actual hostname at every instance of DataNode",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HDFS",
        "category": "DataNode",
        "component": "DATANODE"
      },
      {
        "id": "puppet var",
        "name": "datanode_keytab",
        "displayName": "Path to Keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/dn.service.keytab",
        "description": "Path to DataNode keytab file",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HDFS",
        "category": "DataNode",
        "component": "DATANODE"
      },
      {
        "id": "puppet var",
        "name": "hadoop_http_principal_name",
        "displayName": "DFS Web Principal name",
        "value": "",
        "defaultValue": "HTTP/_HOST",
        "description": "Principal name for spnego access for NameNode and SNameNode. _HOST will get automatically replaced with actual hostname at instance of NameNode and SNameNode",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HDFS",
        "category": "General"
      },
      {
        "id": "puppet var",
        "name": "hadoop_http_keytab",
        "displayName": "Path to spnego keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/spnego.service.keytab",
        "description": "Path to spnego keytab file for NameNode and SNameNode",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HDFS",
        "category": "General"
      },
      //MAPREDUCE
      {
        "id": "puppet var",
        "name": "jobtracker_host",
        "displayName": "JobTracker host",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run JobTracker",
        "displayType": "masterHost",
        "isOverridable": false,
        "isVisible": true,
        "serviceName": "MAPREDUCE",
        "category": "JobTracker"
      },
      {
        "id": "puppet var",
        "name": "jobtracker_principal_name",
        "displayName": "Principal name",
        "value": "",
        "defaultValue": "jt/_HOST",
        "description": "Principal name for JobTracker and Job History Server. _HOST will get automatically replaced with actual hostname at instance of JobTracker and Job History Server",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "MAPREDUCE",
        "category": "JobTracker",
        "component": "JOBTRACKER"
      },
      {
        "id": "puppet var",
        "name": "jobtracker_keytab",
        "displayName": "Path to keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/jt.service.keytab",
        "description": "Path to JobTracker and Job History Server keytab file",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "MAPREDUCE",
        "category": "JobTracker",
        "component": "JOBTRACKER"
      },
      {
        "id": "puppet var",
        "name": "tasktracker_hosts",
        "displayName": "TaskTracker hosts",
        "value": "",
        "defaultValue": "",
        "description": "The hosts that have been assigned to run TaskTracker",
        "displayType": "slaveHosts",
        "isOverridable": false,
        "isVisible": true,
        "serviceName": "MAPREDUCE",
        "category": "TaskTracker"
      },
      {
        "id": "puppet var",
        "name": "tasktracker_principal_name",
        "displayName": "Principal name",
        "value": "",
        "defaultValue": "tt/_HOST",
        "description": "Principal name for TaskTracker. _HOST will get automatically replaced with actual hostname at every instance of TaskTracker",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "MAPREDUCE",
        "category": "TaskTracker",
        "component": "TASKTRACKER"
      },
      {
        "id": "puppet var",
        "name": "tasktracker_keytab",
        "displayName": "Path to keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/tt.service.keytab",
        "description": "Path to TaskTracker keytab file",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "MAPREDUCE",
        "category": "TaskTracker",
        "component": "TASKTRACKER"
      },
      {
        "id": "puppet var",
        "name": "tasktracker_task_controller",
        "displayName": "TaskController",
        "value": "",
        "defaultValue": "org.apache.hadoop.mapred.LinuxTaskController",
        "description": "TaskController which is used to launch and manage task execution. This sets property mapred.task.tracker.task-controller",
        "displayType": "advanced",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "MAPREDUCE",
        "category": "TaskTracker",
        "component": "TASKTRACKER"
      },

      //WEBHCAT
      {
        "id": "puppet var",
        "name": "webhcatserver_host",
        "displayName": "WebHCat Server host",
        "value": "",
        "defaultValue": "localhost",
        "description": "The host that has been assigned to run WebHCat Server",
        "displayType": "masterHost",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "WEBHCAT",
        "category": "WebHCat Server"
      },
      {
        "id": "puppet var",
        "name": "webHCat_http_principal_name",
        "displayName": "Principal name",
        "value": "",
        "defaultValue": "HTTP/_HOST",
        "description": "Principal name for spnego access for WebHCat",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "WEBHCAT",
        "category": "WebHCat Server"
      },
      {
        "id": "puppet var",
        "name": "webhcat_http_keytab",
        "displayName": "Path to keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/spnego.service.keytab",
        "description": "Path to spnego keytab file for WebHCat",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "WEBHCAT",
        "category": "WebHCat Server"
      },
      //HBASE
      {
        "id": "puppet var",
        "name": "hbasemaster_host",
        "displayName": "HBase Master hosts",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run HBase Master",
        "displayType": "masterHosts",
        "isOverridable": false,
        "isVisible": true,
        "serviceName": "HBASE",
        "category": "HBase Master"
      },
      {
        "id": "puppet var",
        "name": "hbase_master_principal_name",
        "displayName": "Principal name",
        "value": "",
        "defaultValue": "hbase/_HOST",
        "description": "Principal name for HBase master. _HOST will get automatically replaced with actual hostname at an instance of HBase Master",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HBASE",
        "category": "HBase Master",
        "components": ["HBASE_MASTER"]
      },
      {
        "id": "puppet var",
        "name": "hbase_master_keytab",
        "displayName": "Path to Keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/hbase.service.keytab",
        "description": "Path to HBase master keytab file",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HBASE",
        "category": "HBase Master",
        "components": ["HBASE_MASTER"]
      },
      {
        "id": "puppet var",
        "name": "regionserver_hosts",
        "displayName": "RegionServer hosts",
        "value": "",
        "defaultValue": "",
        "description": "The hosts that have been assigned to run RegionServer",
        "displayType": "slaveHosts",
        "isOverridable": false,
        "isVisible": true,
        "serviceName": "HBASE",
        "category": "RegionServer"
      },
      {
        "id": "puppet var",
        "name": "hbase_regionserver_principal_name",
        "displayName": "Principal name",
        "value": "",
        "defaultValue": "hbase/_HOST",
        "description": "Principal name for HBase RegionServer. _HOST will get automatically replaced with actual hostname at every instance of RegionServer",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HBASE",
        "category": "RegionServer",
        "components": ["HBASE_REGIONSERVER"]
      },
      {
        "id": "puppet var",
        "name": "hbase_regionserver_keytab",
        "displayName": "Path to Keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/hbase.service.keytab",
        "description": "Path to HBase RegionServer keytab file",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HBASE",
        "category": "RegionServer",
        "components": ["HBASE_REGIONSERVER"]
      },

      //HIVE
      {
        "id": "puppet var",
        "name": "hive_metastore",
        "displayName": "Hive Metastore host",
        "value": "",
        "defaultValue": "localhost",
        "description": "The host that has been assigned to run Hive Metastore and HiveServer2",
        "displayType": "masterHost",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HIVE",
        "category": "Hive Metastore"
      },
      {
        "id": "puppet var",
        "name": "hive_metastore_principal_name",
        "displayName": "Principal name",
        "value": "",
        "defaultValue": "hive/_HOST",
        "description": "Principal name for Hive Metastore and HiveServer2. _HOST will get automatically replaced with actual hostname at an instance of Hive Metastore and HiveServer2",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "component": "HIVE_SERVER"
      },
      {
        "id": "puppet var",
        "name": "hive_metastore_keytab",
        "displayName": "Path to Keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/hive.service.keytab",
        "description": "Path to Hive Metastore and HiveServer2 keytab file",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "HIVE",
        "category": "Hive Metastore",
        "component": "HIVE_SERVER"
      },

      //OOZIE
      {
        "id": "puppet var",
        "name": "oozie_servername",
        "displayName": "Oozie Server host",
        "value": "",
        "defaultValue": "localhost",
        "description": "Oozie server host name",
        "displayType": "masterHost",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "OOZIE",
        "category": "Oozie Server"
      },
      {
        "id": "puppet var",
        "name": "oozie_principal_name",
        "displayName": "Principal name",
        "value": "",
        "defaultValue": "oozie/_HOST",
        "description": "Principal name for Oozie server",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "component": "OOZIE_SERVER"
      },
      {
        "id": "puppet var",
        "name": "oozie_keytab",
        "displayName": "Path to keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/oozie.service.keytab",
        "description": "Path to Oozie server keytab file",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "OOZIE",
        "category": "Oozie Server",
        "component": "OOZIE_SERVER"
      },
      {
        "id": "puppet var",
        "name": "oozie_http_principal_name",
        "displayName": "Oozie Web Principal name",
        "value": "",
        "defaultValue": "HTTP/_HOST",
        "description": "Principal name for spnego access for Oozie",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "OOZIE",
        "category": "Oozie Server"
      },
      {
        "id": "puppet var",
        "name": "oozie_http_keytab",
        "displayName": "Path to spnego keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/spnego.service.keytab",
        "description": "Path to spnego keytab file for oozie",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "OOZIE",
        "category": "Oozie Server"
      },

      //ZooKeeper
      {
        "id": "puppet var",
        "name": "zookeeperserver_hosts",
        "displayName": "ZooKeeper Server hosts",
        "value": "",
        "defaultValue": "",
        "description": "The host that has been assigned to run ZooKeeper Server",
        "displayType": "masterHosts",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server"
      },
      {
        "id": "puppet var",
        "name": "zookeeper_principal_name",
        "displayName": "Principal name",
        "value": "",
        "defaultValue": "zookeeper/_HOST",
        "description": "Principal name for ZooKeeper. _HOST will get automatically replaced with actual hostname at every instance of zookeeper server",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server",
        "component": "ZOOKEEPER_SERVER"
      },
      {
        "id": "puppet var",
        "name": "zookeeper_keytab_path",
        "displayName": "Path to keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/zk.service.keytab",
        "description": "Path to ZooKeeper keytab file",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "ZOOKEEPER",
        "category": "ZooKeeper Server",
        "component": "ZOOKEEPER_SERVER"
      },
      //NAGIOS
      {
        "id": "puppet var",
        "name": "nagios_server",
        "displayName": "Nagios Server host",
        "value": "",
        "defaultValue": "localhost",
        "description": "Nagios server host",
        "displayType": "masterHost",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "NAGIOS",
        "category": "Nagios Server"
      },
      {
        "id": "puppet var",
        "name": "nagios_principal_name",
        "displayName": "Principal name",
        "value": "",
        "defaultValue": "nagios",
        "description": "Primary name for Nagios server",
        "displayType": "principal",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "NAGIOS",
        "category": "Nagios Server",
        "component": "NAGIOS_SERVER"
      },
      {
        "id": "puppet var",
        "name": "nagios_keytab_path",
        "displayName": " Path to keytab file",
        "value": "",
        "defaultValue": "/etc/security/keytabs/nagios.service.keytab",
        "description": "Path to the Nagios server keytab file",
        "displayType": "directory",
        "isVisible": true,
        "isOverridable": false,
        "serviceName": "NAGIOS",
        "category": "Nagios Server",
        "component": "NAGIOS_SERVER"
      }

    ]
  };
});
window.require.register("data/service_components", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  module.exports = new Ember.Set([

    {
      service_name: 'HDFS',
      component_name: 'NAMENODE',
      display_name: 'NameNode',
      isMaster: true,
      isClient: false,
      description: 'Master server that manages the file system namespace and regulates access to files by clients'
    },
    {
      service_name: 'HDFS',
      component_name: 'SECONDARY_NAMENODE',
      display_name: 'SNameNode',
      isMaster: true,
      isClient: false,
      description: 'Helper to the primary NameNode that is responsible for supporting periodic checkpoints of the HDFS metadata'
    },
    {
      service_name: 'HDFS',
      component_name: 'DATANODE',
      display_name: 'DataNode',
      isMaster: false,
      isClient: false,
      description: 'The slave for HDFS'
    },
    {
      service_name: 'HDFS',
      component_name: 'HDFS_CLIENT',
      display_name: 'HDFS Client',
      isMaster: false,
      isClient: true,
      description: 'Client component for HDFS'
    },
    {
      service_name: 'MAPREDUCE',
      component_name: 'JOBTRACKER',
      display_name: 'JobTracker',
      isMaster: true,
      isClient: false,
      description: 'Central Master service that pushes work (MR tasks) out to available TaskTracker nodes in the cluster'
    },
    {
      service_name: 'MAPREDUCE',
      component_name: 'TASKTRACKER',
      display_name: 'TaskTracker',
      isMaster: false,
      isClient: false,
      description: 'The slave for MapReduce'
    },
    {
      service_name: 'MAPREDUCE',
      component_name: 'MAPREDUCE_CLIENT',
      display_name: 'MapReduce Client',
      isMaster: false,
      isClient: true,
      description: 'Client component for MapReduce'
    },
    {
      service_name: 'MAPREDUCE2',
      component_name: 'MAPREDUCE2_CLIENT',
      display_name: 'MapReduce 2 Client',
      isMaster: false,
      isClient: true,
      description: ''
    },
    {
      service_name: 'MAPREDUCE2',
      component_name: 'HISTORYSERVER',
      display_name: 'History Server',
      isMaster: true,
      isClient: false,
      description: ''
    },
    {
      service_name: 'TEZ',
      component_name: 'TEZ_CLIENT',
      display_name: 'TEZ Client',
      isMaster: false,
      isClient: true,
      description: ''
    },
    {
      service_name: 'YARN',
      component_name: 'RESOURCEMANAGER',
      display_name: 'Resource Manager',
      isMaster: true,
      isClient: false,
      description: ''
    },
    {
      service_name: 'YARN',
      component_name: 'YARN_CLIENT',
      display_name: 'YARN Client',
      isMaster: false,
      isClient: true,
      description: ''
    },
    {
      service_name: 'YARN',
      component_name: 'NODEMANAGER',
      display_name: 'Node Manager',
      isMaster: false,
      isClient: false,
      description: ''
    },
    {
      service_name: 'ZOOKEEPER',
      component_name: 'ZOOKEEPER_SERVER',
      display_name: 'ZooKeeper',
      isMaster: true,
      isClient: false,
      description: ''
    },
    {
      service_name: 'ZOOKEEPER',
      component_name: 'ZOOKEEPER_CLIENT',
      display_name: 'ZooKeeper Client',
      isMaster: false,
      isClient: true,
      description: ''
    },
    {
      service_name: 'HBASE',
      component_name: 'HBASE_MASTER',
      display_name: 'HBase Master',
      isMaster: true,
      isClient: false,
      description: ''
    },
    {
      service_name: 'HBASE',
      component_name: 'HBASE_REGIONSERVER',
      display_name: 'RegionServer',
      isMaster: false,
      isClient: false,
      description: 'The slave for HBase'
    },
    {
      service_name: 'HBASE',
      component_name: 'HBASE_CLIENT',
      display_name: 'HBase Client',
      isMaster: false,
      isClient: true,
      description: 'The slave for HBase'
    },
    {
      service_name: 'PIG',
      component_name: 'PIG',
      display_name: 'Pig',
      isMaster: false,
      isClient: true,
      description: ''
    },
    {
      service_name: 'SQOOP',
      component_name: 'SQOOP',
      display_name: 'Sqoop',
      isMaster: false,
      isClient: true,
      description: ''
    },
    {
      service_name: 'OOZIE',
      component_name: 'OOZIE_SERVER',
      display_name: 'Oozie Server',
      isMaster: true,
      isClient: false,
      description: ''
    },
    {
      service_name: 'OOZIE',
      component_name: 'OOZIE_CLIENT',
      display_name: 'Oozie Client',
      isMaster: false,
      isClient: true,
      description: ''
    },
    {
      service_name: 'HIVE',
      component_name: 'HIVE_SERVER',
      display_name: 'HiveServer2',
      isMaster: true,
      isClient: false,
      description: ''
    },
    {
      service_name: 'HIVE',
      component_name: 'HIVE_METASTORE',
      display_name: 'Hive Metastore',
      isMaster: true,
      isClient: false,
      description: ''
    },
    {
      service_name: 'HIVE',
      component_name: 'HIVE_CLIENT',
      display_name: 'Hive Client',
      isMaster: false,
      isClient: true,
      description: ''
    },
    {
      service_name: 'HIVE',
      component_name: 'MYSQL_SERVER',
      display_name: 'MySQL Server for Hive',
      isMaster: false,
      isClient: false,
      description: ''
    },
    {
      service_name: 'HCATALOG',
      component_name: 'HCAT',
      display_name: 'HCat Client',
      isMaster: false,
      isClient: true,
      description: ''
    },
    {
      service_name: 'WEBHCAT',
      component_name: 'WEBHCAT_SERVER',
      display_name: 'WebHCat Server',
      isMaster: true,
      isClient: false,
      description: ''
    },
    {
      service_name: 'DASHBOARD',
      component_name: 'DASHBOARD',
      display_name: 'Monitoring Dashboard',
      isMaster: false,
      isClient: false,
      description: ''
    },
    {
      service_name: 'NAGIOS',
      component_name: 'NAGIOS_SERVER',
      display_name: 'Nagios Server',
      isMaster: true,
      isClient: false,
      description: ''
    },
    {
      service_name: 'GANGLIA',
      component_name: 'GANGLIA_SERVER',
      display_name: 'Ganglia Collector',
      isMaster: true,
      isClient: false,
      description: ''
    },
    {
      service_name: 'GANGLIA',
      component_name: 'GANGLIA_MONITOR',
      display_name: 'Ganglia Slave',
      isMaster: false,
      isClient: false,
      description: ''
    },
    {
      service_name: 'KERBEROS',
      component_name: 'KERBEROS_SERVER',
      display_name: 'Kerberos Server',
      isMaster: true,
      isClient: false,
      description: ''
    },
    {
      service_name: 'KERBEROS',
      component_name: 'KERBEROS_ADMIN_CLIENT',
      display_name: 'Kerberos Admin Client',
      isMaster: false,
      isClient: true,
      description: ''
    },
    {
      service_name: 'KERBEROS',
      component_name: 'KERBEROS_CLIENT',
      display_name: 'Kerberos Client',
      isMaster: false,
      isClient: true,
      description: ''
    },
    {
      service_name: 'CLIENT',
      component_name: 'CLIENT',
      display_name: 'Client',
      isMaster: false,
      isClient: true,
      description: ''
    },
    {
      service_name: 'HUE',
      component_name: 'HUE_SERVER',
      display_name: 'Hue Server',
      isMaster: true,
      isClient: false,
      description: ''
    },
    { 
      service_name: 'HCFS',
      component_name: 'HCFS_CLIENT',
      display_name: 'HCFS Client', 
      isMaster: false, 
      isClient: true, 
      description: 'Client component for HCFS'
    }
  ]);
});
window.require.register("data/service_configs", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  require('models/service_config');


  module.exports = [
    {
      serviceName: 'HDFS',
      displayName: 'HDFS',
      filename: 'hdfs-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'NameNode', displayName : 'NameNode', hostComponentNames : ['NAMENODE']}),
        App.ServiceConfigCategory.create({ name: 'SNameNode', displayName : 'Secondary Name Node', hostComponentNames : ['SECONDARY_NAMENODE']}),
        App.ServiceConfigCategory.create({ name: 'DataNode', displayName : 'DataNode', hostComponentNames : ['DATANODE']}),
        App.ServiceConfigCategory.create({ name: 'General', displayName : 'General'}),
        App.ServiceConfigCategory.create({ name: 'Advanced', displayName : 'Advanced'}),
        App.ServiceConfigCategory.create({ name: 'AdvancedCoreSite', displayName : 'Custom core-site.xml', siteFileName: 'core-site.xml', canAddProperty: true}),
        App.ServiceConfigCategory.create({ name: 'AdvancedHDFSSite', displayName : 'Custom hdfs-site.xml', siteFileName: 'hdfs-site.xml', canAddProperty: true})
      ],
      sites: ['global', 'core-site', 'hdfs-site'],
      configs: []
    },
    {
      serviceName: 'HCFS',
      displayName: 'HCFS',
      filename: 'core-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'General', displayName : 'General'})      
      ],
      sites: ['core-site'],
      configs: []
    },  
    {
      serviceName: 'MAPREDUCE',
      displayName: 'MapReduce',
      filename: 'mapred-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'JobTracker', displayName : 'JobTracker', hostComponentNames : ['JOBTRACKER']}),
        App.ServiceConfigCategory.create({ name: 'TaskTracker', displayName : 'TaskTracker', hostComponentNames : ['TASKTRACKER']}),
        App.ServiceConfigCategory.create({ name: 'General', displayName : 'General'}),
        App.ServiceConfigCategory.create({ name: 'Advanced', displayName : 'Advanced'}),
        App.ServiceConfigCategory.create({ name: 'CapacityScheduler', displayName : 'Capacity Scheduler', isCapacityScheduler : true, isCustomView: true, siteFileName: 'capacity-scheduler.xml', siteFileNames: ['capacity-scheduler.xml', 'mapred-queue-acls.xml'], canAddProperty: true}),
        App.ServiceConfigCategory.create({ name: 'AdvancedMapredSite', displayName : 'Custom mapred-site.xml', siteFileName: 'mapred-site.xml', canAddProperty: true})
      ],
      sites: ['global', 'core-site', 'mapred-site', 'capacity-scheduler', 'mapred-queue-acls'],
      configs: []
    },

    {
      serviceName: 'MAPREDUCE2',
      displayName: 'MapReduce 2',
      filename: 'mapred-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'HistoryServer', displayName : 'History Server', hostComponentNames : ['HISTORYSERVER']}),
        App.ServiceConfigCategory.create({ name: 'General', displayName : 'General'}),
        App.ServiceConfigCategory.create({ name: 'Advanced', displayName : 'Advanced'}),
        App.ServiceConfigCategory.create({ name: 'AdvancedMapredSite', displayName : 'Custom mapred-site.xml', siteFileName: 'mapred-site.xml', canAddProperty: true})
      ],
      sites: ['core-site', 'mapred-site', 'mapred-queue-acls'],
      configs: []
    },

    {
      serviceName: 'YARN',
      displayName: 'YARN',
      filename: 'yarn-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'ResourceManager', displayName : 'Resource Manager', hostComponentNames : ['RESOURCEMANAGER']}),
        App.ServiceConfigCategory.create({ name: 'NodeManager', displayName : 'Node Manager', hostComponentNames : ['NODEMANAGER']}),
        App.ServiceConfigCategory.create({ name: 'General', displayName : 'General'}),
        App.ServiceConfigCategory.create({ name: 'CapacityScheduler', displayName : 'Capacity Scheduler', isCapacityScheduler : true, isCustomView: true, siteFileName: 'capacity-scheduler.xml', siteFileNames: ['capacity-scheduler.xml', 'mapred-queue-acls.xml'], canAddProperty: true}),
        App.ServiceConfigCategory.create({ name: 'Advanced', displayName : 'Advanced'}),
        App.ServiceConfigCategory.create({ name: 'AdvancedYARNSite', displayName : 'Custom yarn-site.xml', siteFileName: 'yarn-site.xml', canAddProperty: true})
      ],
      sites: ['core-site', 'yarn-site', 'capacity-scheduler', 'mapred-queue-acls'],
      configs: []
    },

    {
      serviceName: 'HIVE',
      displayName: 'Hive',
      filename: 'hive-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'Hive Metastore', displayName : 'Hive Metastore'}),
        App.ServiceConfigCategory.create({ name: 'Advanced', displayName : 'Advanced'}),
        App.ServiceConfigCategory.create({ name: 'AdvancedHiveSite', displayName : 'Custom hive-site.xml', siteFileName: 'hive-site.xml', canAddProperty: true})
      ],
      sites: ['global', 'hive-site'],
      configs: []
    },

    {
      serviceName: 'WEBHCAT',
      displayName: 'WebHCat',
      filename: 'webhcat-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'WebHCat Server', displayName : 'WebHCat Server'}),
        App.ServiceConfigCategory.create({ name: 'Advanced', displayName : 'Advanced'}),
        App.ServiceConfigCategory.create({ name: 'AdvancedWebHCatSite', displayName : 'Custom webhcat-site.xml', siteFileName: 'webhcat-site.xml', canAddProperty: true})
      ],
      sites: ['global', 'webhcat-site'],
      configs: []
    },

    {
      serviceName: 'HBASE',
      displayName: 'HBase',
      filename: 'hbase-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'HBase Master', displayName : 'HBase Master'}),
        App.ServiceConfigCategory.create({ name: 'RegionServer', displayName : 'RegionServer'}),
        App.ServiceConfigCategory.create({ name: 'General', displayName : 'General'}),
        App.ServiceConfigCategory.create({ name: 'Advanced', displayName : 'Advanced'}),
        App.ServiceConfigCategory.create({ name: 'AdvancedHbaseSite', displayName : 'Custom hbase-site.xml', siteFileName: 'hbase-site.xml', canAddProperty: true})
      ],
      sites: ['global', 'hbase-site'],
      configs: []
    },

    {
      serviceName: 'ZOOKEEPER',
      displayName: 'ZooKeeper',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'ZooKeeper Server', displayName : 'ZooKeeper Server'}),
        App.ServiceConfigCategory.create({ name: 'Advanced', displayName : 'Advanced'})
      ],
      sites: ['global'],
      configs: []
    },

    {
      serviceName: 'OOZIE',
      displayName: 'Oozie',
      filename: 'oozie-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'Oozie Server', displayName : 'Oozie Server'}),
        App.ServiceConfigCategory.create({ name: 'Advanced', displayName : 'Advanced'}),
        App.ServiceConfigCategory.create({ name: 'AdvancedOozieSite', displayName : 'Custom oozie-site.xml', siteFileName: 'oozie-site.xml', canAddProperty: true})
      ],
      sites: ['global', 'oozie-site'],
      configs: []
    },

    {
      serviceName: 'NAGIOS',
      displayName: 'Nagios',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'General', displayName : 'General'})
      ],
      sites: ['global'],
      configs: []
    },

    {
      serviceName: 'HUE',
      displayName: 'Hue',
      filename: 'hue-site',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'Hue Server', displayName : 'Hue Server'}),
        App.ServiceConfigCategory.create({ name: 'Advanced', displayName : 'Advanced'})
      ],
      sites: ['hue-site'],
      configs: []
    },

    {
      serviceName: 'MISC',
      displayName: 'Misc',
      configCategories: [
        App.ServiceConfigCategory.create({ name: 'General', displayName : 'General'}),
        App.ServiceConfigCategory.create({ name: 'Users and Groups', displayName : 'Users and Groups'})
      ],
      sites: ['global'],
      configs: []
    }

  ];
  
});
window.require.register("data/services", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  module.exports = [
    {
      serviceName: 'HDFS',
      displayName: 'HDFS1',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      description: Em.I18n.t('services.hdfs.description')
    },
    {
      serviceName: 'HCFS',
      displayName: 'HCFS',
      isDisabled: false,
      isSelected: false,
      canBeSelected: true,
      description: Em.I18n.t('services.hcfs.description')
    },
    {
      serviceName: 'MAPREDUCE',
      displayName: 'MapReduce',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      description: Em.I18n.t('services.mapreduce.description')
    },
    {
      serviceName: 'MAPREDUCE2',
      displayName: 'MapReduce 2',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      description: Em.I18n.t('services.mapreduce2.description')
    },
    {
      serviceName: 'YARN',
      displayName: 'YARN',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      description: Em.I18n.t('services.yarn.description')
    },
    {
      serviceName: 'TEZ',
      displayName: 'TEZ',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      description: Em.I18n.t('services.tez.description')
    },
    {
      serviceName: 'NAGIOS',
      displayName: 'Nagios',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      description: Em.I18n.t('services.nagios.description')
    },
    {
      serviceName: 'GANGLIA',
      displayName: 'Ganglia',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      description: Em.I18n.t('services.ganglia.description')
    },
    {
      serviceName: 'HIVE',
      displayName: 'Hive + HCat',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      description: Em.I18n.t('services.hive.description')
    },
    {
      serviceName: 'HCATALOG',
      displayName: 'HCatalog',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      isHidden: true
    },
    {
      serviceName: 'WEBHCAT',
      displayName: 'WebHCat',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      isHidden: true
    },
    {
      serviceName: 'HBASE',
      displayName: 'HBase',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      description: Em.I18n.t('services.hbase.description')
    },
    {
      serviceName: 'PIG',
      displayName: 'Pig',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      description: Em.I18n.t('services.pig.description')
    },
    {
      serviceName: 'SQOOP',
      displayName: 'Sqoop',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      description: Em.I18n.t('services.sqoop.description')
    },
    {
      serviceName: 'OOZIE',
      displayName: 'Oozie',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      description: Em.I18n.t('services.oozie.description')
    },
    {
      serviceName: 'ZOOKEEPER',
  	  displayName: 'ZooKeeper',
      isDisabled: false,
      isSelected: true,
      canBeSelected: true,
      description: Em.I18n.t('services.zookeeper.description')
    },
    {
      serviceName: 'HUE',
      displayName: 'Hue',
      isDisabled: false,
      isSelected: App.supports.hue,
      canBeSelected: App.supports.hue,
      isHidden: !App.supports.hue
    }
  ]
});
window.require.register("data/statusCodes", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  module.exports = {
  	200: function () {
  		console.log("Status code 200: Success.");
    },
    202: function () {
      console.log("Status code 202: Success for creation.");
    },
  	400: function () {
  		console.log("Error code 400: Bad Request.");
  	},
  	401: function () {
  		console.log("Error code 401: Unauthorized.");
  	},
  	402: function () {
  		console.log("Error code 402: Payment Required.");
  	},
  	403: function () {
  		console.log("Error code 403: Forbidden.");
      App.router.logOff();
  	},
  	404: function () {
  		console.log("Error code 404: URI not found.");
  	},
  	500: function () {
  		console.log("Error code 500: Internal Error on server side.");
  	},
  	501: function () {
  		console.log("Error code 501: Not implemented yet.");
  	},
  	502: function () {
  		console.log("Error code 502: Services temporarily overloaded.");
  	},
  	503: function () {
  		console.log("Error code 503: Gateway timeout.");
  	}
  }
  
});
window.require.register("ember", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  module.exports=Ember;
});
window.require.register("initialize", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  window.App = require('app');

  require('config');

  require('messages');
  require('utils/base64');
  require('utils/db');
  require('utils/helper');
  require('utils/config')
  require('models');
  require('controllers');
  require('templates');
  require('views');
  require('router');

  require('utils/ajax');
  require('utils/updater');;

  require('mappers/server_data_mapper');
  require('mappers/status_mapper');
  require('mappers/hosts_mapper');
  require('mappers/cluster_mapper');
  require('mappers/jobs_mapper');
  require('mappers/runs_mapper');
  require('mappers/racks_mapper');
  require('mappers/alerts_mapper');
  require('mappers/users_mapper');
  require('mappers/service_mapper');
  require('mappers/target_cluster_mapper');
  require('mappers/dataset_mapper');
  require('utils/http_client');
  require('utils/host_progress_popup');

  App.initialize();

  console.log('after initialize');
  console.log('TRACE: app.js-> localStorage:Ambari.authenticated=' + localStorage.getItem('Ambari' + 'authenticated'));
  console.log('TRACE: app.js-> localStorage:currentStep=' + localStorage.getItem(App.get('router').getLoginName() + 'Installer' + 'currentStep'));
  console.log('TRACE: app.js-> router.authenticated=' + App.get('router.loggedIn'));
  
});
window.require.register("mappers/alerts_mapper", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  App.alertsMapper = App.QuickDataMapper.create({
    model: App.Alert,
    config:{
      $alert_id:'' ,
      title: "service_description",
      service_type: "service_type",
      date: "last_hard_state_change",
      status: "current_state",
      message: "plugin_output",
      host_name: "host_name",
      current_attempt: "current_attempt",
      last_hard_state_change: "last_hard_state_change",
      last_hard_state: "last_hard_state",
      last_time_ok: "last_time_ok",
      last_time_warning: "last_time_warning",
      last_time_unknown: "last_time_unknown",
      last_time_critical: "last_time_critical",
      is_flapping: "is_flapping",
      last_check: "last_check"
    },
    map: function (json) {
      if (!this.get('model')) {
        return;
      }
      if (json && json.items && json.items.length>0 && json.items[0].HostRoles && json.items[0].HostRoles.nagios_alerts) {
        var alerts = json.items[0].HostRoles.nagios_alerts.alerts;
        if (App.Alert.find().content.length > 0) {
          this.update(alerts);
        } else {
          var result = [];
          alerts.forEach(function(item){
            var applyConfig = jQuery.extend({}, this.config);
            if (item.current_state && item.last_hard_state && item.current_state != item.last_hard_state) {
              switch (item.current_state) {
                case "0":
                  applyConfig['date'] = 'last_time_ok';
                  break;
                case "1":
                  applyConfig['date'] = 'last_time_warning';
                  break;
                case "2":
                  applyConfig['date'] = 'last_time_critical';
                  break;
                case "3":
                  applyConfig['date'] = 'last_time_unknown';
                  break;
              }
            }
            result.push(this.parseIt(item, applyConfig));
          }, this);
          App.store.loadMany(this.get('model'), result);
        }
      }
    },
    update: function(alerts){
      var alertsList = App.Alert.find();
      var titleToAlertMap = {};
      alertsList.forEach(function(alert){
        titleToAlertMap[alert.get('serviceType') + alert.get('title') + alert.get('hostName')] = alert;
      });
      var newRecords = [];
      alerts.forEach(function(item){
        var existAlert = titleToAlertMap[item.service_type + item.service_description + item.host_name];
        if (existAlert == null) {
          var applyConfig = jQuery.extend({}, this.config);
          if (item.current_state && item.last_hard_state && item.current_state != item.last_hard_state) {
            switch (item.current_state) {
              case "0":
                applyConfig['date'] = 'last_time_ok';
                break;
              case "1":
                applyConfig['date'] = 'last_time_warning';
                break;
              case "2":
                applyConfig['date'] = 'last_time_critical';
                break;
              case "3":
                applyConfig['date'] = 'last_time_unknown';
                break;
            }
          }
          newRecords.push(this.parseIt(item, applyConfig));
        } else {
          // update record
          existAlert.set('serviceType', item.service_type);
          if (item.current_state && item.last_hard_state && item.current_state != item.last_hard_state) {
            switch (item.current_state) {
              case "0":
                existAlert.set('date', DS.attr.transforms.date.from(item.last_time_ok));
                break;
              case "1":
                existAlert.set('date', DS.attr.transforms.date.from(item.last_time_warning));
                break;
              case "2":
                existAlert.set('date', DS.attr.transforms.date.from(item.last_time_critical));
                break;
              case "3":
                existAlert.set('date', DS.attr.transforms.date.from(item.last_time_unknown));
                break;
              default:
                existAlert.set('date', DS.attr.transforms.date.from(item.last_hard_state_change));
                break;
            }
          }else{
            existAlert.set('date', DS.attr.transforms.date.from(item.last_hard_state_change));
          }
          existAlert.set('status', item.current_state);
          existAlert.set('message', item.plugin_output);
          existAlert.set('lastHardStateChange', item.last_hard_state_change);
          existAlert.set('lastHardState', item.last_hard_state);
          existAlert.set('lastTimeOk', item.last_time_ok);
          existAlert.set('lastTimeWarning', item.last_time_warning);
          existAlert.set('lastTimeUnknown', item.last_time_unknown);
          existAlert.set('lastTimeCritical', item.last_time_critical);
          existAlert.set('lastCheck', item.last_check);
          existAlert.set('isFlapping', item.is_flapping);
          delete titleToAlertMap[item.service_type + item.service_description + item.host_name];
        }
      }, this);
      for ( var e in titleToAlertMap) {
        titleToAlertMap[e].deleteRecord();
      }
      if (newRecords.length > 0) {
        App.store.loadMany(this.get('model'), newRecords); // Add new records
      }
    }
  });
  
});
window.require.register("mappers/cluster_mapper", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  App.clusterMapper = App.QuickDataMapper.create({
      model : App.Cluster,
      map:function(json){
        if(!this.get('model')) {return;}
        if(json){
          var result = json;
          result = this.parseIt(result, this.config);
          App.store.load(this.get('model'), result);
          
          var cluster = App.Cluster.find(result.id);
          var clusterDesiredConfigs = [];
          // Create desired_configs_array
          if(json.Clusters.desired_configs){
            for(var site in json.Clusters.desired_configs){
              var tag = json.Clusters.desired_configs[site].tag;
              var configObj = App.ConfigSiteTag.create({
                site: site,
                tag: tag,
                hostOverrides: {}
              });
              if(json.Clusters.desired_configs[site].host_overrides!=null){
                var hostOverridesArray = {};
                json.Clusters.desired_configs[site].host_overrides.forEach(function(override){
                  var hostname = override.host_name;
                  var tag = override.tag;
                  hostOverridesArray[hostname] = tag;
                });
                configObj.set('hostOverrides', hostOverridesArray);
              }
              clusterDesiredConfigs.push(configObj);
            }
          }
          cluster.set('desiredConfigs', clusterDesiredConfigs);
        }
      },
      config : {
        id:'Clusters.cluster_id',
        cluster_name: 'Clusters.cluster_name',
        stack_name: 'Clusters.stack_name',
        version: 'Clusters.version',
        //$hosts: [1, 2, 3, 4],
        $racks: [1],
        max_hosts_per_rack: 'Clusters.max_hosts_per_rack'
      }
  });
  
});
window.require.register("mappers/dataset_mapper", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.dataSetMapper = App.QuickDataMapper.create({
    model: App.Dataset,
    Jobs_model: App.DataSetJob,
    config: {
      id: 'id', // approach 2 : to be calculated (TBC1)
      name: 'Feeds.name', // from json
      status: 'Feeds.status', // from json
      source_cluster_name: 'Feeds.clusters.cluster[0].name', // approach1 : from json
      $target_cluster: 'none', // will be loaded outside parser ( TBC2 ),
      source_dir: 'Feeds.locations.location.path',
      $schedule_id: 'none', // will be loaded outside parser
      dataset_jobs: 'dataset_jobs', // TBC3 ( set of ids will be added )

      // all below are unknown at present and may be blank
      last_failed_date: 'last_failed_date', // TBC4
      last_succeeded_date: 'last_succeeded_date', // TBC5
      last_duration: 'last_duration', // TBC6
      avg_data: 'avg_data', // TBC7
      created_date: 'created_date', // TBC8
      target_dir: 'target_dir'

    },
    jobs_config: {
      $dataset_id: 'none', // will be loaded outside parser
      id: 'Instances.id',
      status : 'Instances.status',
      start_date: 'start_date',
      end_date: 'end_date',
      duration: 'duration'
      //data: 'Instances.details'
    },

    schedule_config: {
      $dataset_id: 'none', // will be loaded outside parser
      id: 'id',
      start_date : 'start_date',
      end_date :  'end_date',
      start_time : 'start_time',
      end_time : 'end_time',
      timezone : 'timezone',
      frequency : 'frequency'
    },

    loadSchedule: function (datasetItemFromJson) {
      App.store.load(App.Dataset.Schedule, this.parseSchedule(datasetItemFromJson));
    },

    parseSchedule: function(datasetItemFromJson) {
      var schedule = {};
      schedule.id = datasetItemFromJson.id;
      var source_cluster = datasetItemFromJson.Feeds.clusters.cluster.findProperty("type", "source");
      var start_date = new Date(source_cluster.validity.start);
      var end_date = new Date(source_cluster.validity.end);

      var d = new Date();
      var start_mm = start_date.getMonth() + 1; // In future may consider using getUTCMonth()
      var start_dd = start_date.getDay();
      var start_yyyy = start_date.getFullYear();
      var end_mm = end_date.getMonth() + 1;
      var end_dd = end_date.getDay();
      var end_yyyy = end_date.getFullYear();

      schedule.start_date = start_mm + "/" + start_dd + "/" + start_yyyy;
      schedule.end_date = end_mm + "/" + end_dd + "/" + end_yyyy;

      var start_hh = start_date.getHours();
      var start_mi = start_date.getMinutes();
      var start_ampm = (start_hh < 12 ? 'AM' : 'PM');
      var end_hh = end_date.getHours();
      var end_mi = end_date.getMinutes();
      var end_ampm = (end_hh < 12 ? 'AM' : 'PM');

      if (start_hh) {
        start_hh %= 12;
      }

      if (end_hh) {
        end_hh %= 12;
      }

      schedule.start_time = start_hh + ":" + start_mi + ":" + start_ampm;
      schedule.end_time = end_hh + ":" + end_mi + ":" + end_ampm;

      schedule.frequency = datasetItemFromJson.Feeds.frequency;
      schedule.timezone = datasetItemFromJson.Feeds.timezone;
      schedule.dataset_id = datasetItemFromJson.id;
      return schedule;
    },

    map: function (json) {
      if (!this.get('model')) {
        return;
      }
      if (json && json.items && json.items.length > 0) {
        var dataset_results = [];
        json.items.forEach(function (item) {

          try {
            // TBC1
            item.id = this.getId(item.Feeds.name);

            // TBC3
            item.dataset_jobs = [];

            var last_failed_date = null;
            var last_succeeded_date = null;
            var last_end_date = null;
            item.instances.forEach(function (job) {
              var end_date = new Date(job.Instances.end);

              if (!last_end_date) {
                last_end_date = end_date;
                item.last_job = job;
              }
              else if (end_date > last_end_date) {
                last_end_date = end_date;
                item.last_job = job;
              }
              if (job.Instances.status === 'FAILED') {
                if (last_failed_date == null || last_failed_date < end_date) {
                  item.last_failed_date = end_date.getTime();
                  last_failed_date = end_date;
                }
              }
              else if (job.Instances.status === 'SUCCESSFUL') {
                if (last_succeeded_date == null || last_succeeded_date < end_date) {
                  item.last_succeeded_date = end_date.getTime();
                  last_succeeded_date = end_date;
                }
              }

              item.dataset_jobs.push(job.Instances.id);
            });

            // calculate last_duration

            var last_end_date = new Date(item.last_job.Instances.end);
            var last_start_date = new Date(item.last_job.Instances.start);
            item.last_duration = last_end_date - last_start_date;


            item.avg_data = '';
            item.created_date = '';
            item.target_dir = '';

            var newitem = this.parseIt(item, this.config);

            // TBC2 - but shd be loaded after parsing
            var target_cluster_name = (item.Feeds.clusters.cluster.findProperty("type", "target")).name;
            var target_cluster_id = (item.Feeds.clusters.cluster.findProperty("type", "target")).name;

            newitem.target_cluster_id = this.getId(target_cluster_id);

            newitem.schedule_id = newitem.id;

            this.loadSchedule(item);

            dataset_results.push(newitem);
          } catch (ex) {
            console.debug('Exception occured : ' + ex);
          }
        }, this);

        console.debug('Before load: App.Dataset.find().content : ' + App.Dataset.find().content);
        App.store.loadMany(this.get('model'), dataset_results);
        console.debug('After load: App.Dataset.find().content : ' + App.Dataset.find().content);

        try {
          // Child records
          var dataset_job_results = [];
          json.items.forEach(function (item) {
            item.instances.forEach(function (instance) {
              instance.Instances.start = new Date(instance.Instances.start); // neeed to be calulated end -start
              instance.Instances.end = new Date(instance.Instances.end); // neeed to be calulated end -start
              instance.duration = instance.Instances.end - instance.Instances.start;
              instance.start_date = instance.Instances.start;
              instance.end_date = instance.Instances.end;

              var result = this.parseIt(instance, this.jobs_config);
              result.dataset_id = item.id;
              dataset_job_results.push(result);


            }, this)
          }, this);

          console.debug('Before load: App.DataSetJob.find().content : ' + App.DataSetJob.find().content);
          App.store.loadMany(this.get('Jobs_model'), dataset_job_results);
          console.debug('After load: App.DataSetJob.find().content : ' + App.DataSetJob.find().content);
        }
        catch (ex) {
          console.debug('Exception occured : ' + ex);
        }
      }
    },

    getId: function(n) {
      var re = new RegExp(" ", "g");
      return n.replace(re, "_");
    }

  });
  
});
window.require.register("mappers/hosts_mapper", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.hostsMapper = App.QuickDataMapper.create({

    model: App.Host,
    config: {
      id: 'Hosts.host_name',
      host_name: 'Hosts.host_name',
      public_host_name: 'Hosts.public_host_name',
      cluster_id: 'Hosts.cluster_name',// 1
      rack: 'Hosts.rack_info',
      host_components_key: 'host_components',
      host_components_type: 'array',
      host_components: {
        item: 'id'
      },
      cpu: 'Hosts.cpu_count',
      memory: 'Hosts.total_mem',
      disk_info: 'Hosts.disk_info',
      disk_total: 'metrics.disk.disk_total',
      disk_free: 'metrics.disk.disk_free',
      health_status: 'Hosts.host_status',
      load_one: 'metrics.load.load_one',
      load_five: 'metrics.load.load_five',
      load_fifteen: 'metrics.load.load_fifteen',
      cpu_usage: 'cpu_usage',
      memory_usage: 'memory_usage',
      last_heart_beat_time: "Hosts.last_heartbeat_time",
      os_arch: 'Hosts.os_arch',
      os_type: 'Hosts.os_type',
      ip: 'Hosts.ip',
      disk_usage: 'disk_usage'
    },
    map: function (json) {
      if (json.items) {
        var result = this.parse(json.items);
        App.store.loadMany(this.get('model'), result);
      }
    },

    parse: function(items) {
      var result = [];
      items.forEach(function (item) {

        // Disk Usage
        if (item.metrics && item.metrics.disk && item.metrics.disk.disk_total && item.metrics.disk.disk_free) {
          var diskUsed = item.metrics.disk.disk_total - item.metrics.disk.disk_free;
          var diskUsedPercent = (100 * diskUsed) / item.metrics.disk.disk_total;
          item.disk_usage = diskUsedPercent.toFixed(1);
        }
        // CPU Usage
        if (item.metrics && item.metrics.cpu && item.metrics.cpu.cpu_system && item.metrics.cpu.cpu_user) {
          var cpuUsedPercent = item.metrics.cpu.cpu_system + item.metrics.cpu.cpu_user;
          item.cpu_usage = cpuUsedPercent.toFixed(1);
        }
        // Memory Usage
        if (item.metrics && item.metrics.memory && item.metrics.memory.mem_free && item.metrics.memory.mem_total) {
          var memUsed = item.metrics.memory.mem_total - item.metrics.memory.mem_free;
          var memUsedPercent = (100 * memUsed) / item.metrics.memory.mem_total;
          item.memory_usage = memUsedPercent.toFixed(1);
        }

        item.host_components.forEach(function (host_component) {
          host_component.id = host_component.HostRoles.component_name + "_" + host_component.HostRoles.host_name;
        }, this);
        result.push(this.parseIt(item, this.config));

      }, this);
      result = this.sortByPublicHostName(result);
      return result;
    },
    /**
     * Default data sorting by public_host_name field
     * @param data
     * @return {Array}
     */
    sortByPublicHostName: function(data) {
      data.sort(function(a, b) {
        var ap = a.public_host_name;
        var bp = b.public_host_name;
        if (ap > bp) return 1;
        if (ap < bp) return -1;
        return 0;
      });
      return data;
    }

  });
  
});
window.require.register("mappers/jobs_mapper", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.jobsMapper = App.QuickDataMapper.create({
    model:App.Job,
    map:function (json) {
      if (!this.get('model')) {
        return;
      }
      if (json.jobs) {
        var result = [];
        json.jobs.forEach(function (item) {
          result.push(this.parseIt(item, this.config));
        }, this);

        var r = Ember.ArrayProxy.create({"content":[]});
        result.forEach(function(item){
          r.content.push(App.Job2.create(item));
        });

        this.set('controller.content.jobs', r.content);
      }
    },
    config:{
      id:'jobId',
      run_id:'workflowId',
      job_name:'jobName',
      workflow_entity_name:'workflowEntityName',
      user_name:'userName',
      submit_time:'submitTime',
      maps:'maps',
      reduces:'reduces',
      status:'status',
      input:'inputBytes',
      output:'outputBytes',
      elapsed_time:'elapsedTime'
    }
  });

  App.jobTimeLineMapper = App.QuickDataMapper.create({
    model: null, //model will be set outside of mapper
    config:{
      map:'map',
      shuffle:'shuffle',
      reduce:'reduce'
    },
    map:function (json) {
      var job = this.get('model'); // @model App.MainAppsItemBarView
      var parseResult = this.parseIt(json, this.config);
      var self = this;
      $.each(parseResult, function (field, value) {
        var d = self.coordinatesModify(value);
        d.reverse();
        d = self.coordinatesModify(d);
        d.reverse();
        job.set(field, d);
      });
    },

    coordinatesModify: function(data) {
      var d = this.zeroAdding(data);
      d.reverse();
      d = this.zeroAdding(d);
      d.reverse();
      return d;
    },

    zeroAdding: function(data) {
      var d = [];
      var last_y = 0;
      data.forEach(function(coordinates) {
        if (coordinates.y != 0 && last_y == 0) {
          d.push({x: coordinates.x, y: 0});
        }
        d.push(coordinates);
        last_y = coordinates.y;
      });
      return d;
    }
  });

  App.taskTimeLineMapper = App.QuickDataMapper.create({
    model: null, //model will be set outside of mapper
    config:{
      allmap:'map',
      allshuffle:'shuffle',
      allreduce:'reduce'
    },
    map:function (json) {
      var job = this.get('model'); // @model App.MainAppsItemBarView
      var parseResult = this.parseIt(json, this.config);

      $.each(parseResult, function (field, value) {
        job.set(field, value);
      });
    }
  });

  App.jobTasksMapper = App.QuickDataMapper.create({
    model: null, //model will be set outside of mapper
    config:{
      mapNodeLocal:'mapNodeLocal',
      mapRackLocal:'mapRackLocal',
      mapOffSwitch:'mapOffSwitch',
      reduceOffSwitch:'reduceOffSwitch',
      submit:'submitTime',
      finish:'finishTime'
    },
    map:function (json) {
      var job = this.get('model'); // @model App.MainAppsItemBarView
      var parseResult = this.parseIt(json, this.config);
      $.each(parseResult, function (field, value) {
        job.set(field, value);
      });
    }
  });
  
});
window.require.register("mappers/racks_mapper", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */


  App.racksMapper = App.QuickDataMapper.create({
    model: App.Rack,
    config: {
      id: "Racks.id",
      name: "Racks.name"
      //$hosts: ["host01", "host06", "host05"],
      //status: "Racks.status",
      //live_hosts_count: "Racks.live_hosts_count",
      //critical_hosts_count: "Racks.critical_hosts_count",
      //dead_hosts_count: "Racks.dead_hosts_count"
    }
  });
  
});
window.require.register("mappers/runs_mapper", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.runsMapper = App.QuickDataMapper.create({
    model : App.Run,
    map : function(json) {
      if(!this.get('model')) {
        return;
      }
      if(json && json.aaData) {
        var result = [];

        var pagination_info={
          iTotalDisplayRecords :json.iTotalDisplayRecords ,
          iTotalRecords:json.iTotalRecords,
          startIndex:parseInt(json.startIndex)+1,
          endIndex:parseInt(json.endIndex)+1
        }

        json.aaData.forEach(function(item, index) {
          result.push(this.generateWorkflow(item, index));
        }, this);

        var r = [];
        result.forEach(function(item){
          r.push(App.Run2.create(item));
        });

        App.router.get('mainAppsController').set('content', r);
        App.router.get('mainAppsController').set('serverData', json.summary);
        App.router.get('mainAppsController').set('paginationObject', pagination_info);
      }


    },

    generateWorkflow: function(item, index) {
      var o = this.parseIt(item, this.config);

      var r = '{dag: {';
      item.workflowContext.workflowDag.entries.forEach(function(item) {
        r += '"' + item.source + '": [';
        // if a standalone MapReduce job, there won't be any targets
        if (item.targets) {
          item.targets.forEach(function(target) {
            r += '"' + target + '",';
          });
          if(item.targets.length){
            r = r.substr(0, r.length - 1);
          }
        }
        else {
          r += item.source;
        }
        r += '],';
      });
      r = r.substr(0, r.length - 1);
      r += '}}';
      o.workflowContext = r;
      o.index = index + 1;
      return o;
    },

    config : {
      id: 'workflowId',
      appName: 'workflowName',
      numJobsTotal: 'numJobsTotal',
      numJobsCompleted: 'numJobsCompleted',
      userName:'userName',
      startTime: 'startTime',
      elapsedTime: 'elapsedTime',
      input: 'inputBytes',
      output: 'outputBytes'
    }
  });
  
});
window.require.register("mappers/server_data_mapper", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.ServerDataMapper = Em.Object.extend({
    jsonKey: false,
    map: function (json) {
      if (json) {
        var model = this.get('model');
        var jsonKey = this.get('jsonKey');

        if (jsonKey && json[jsonKey]) { // if data come as { hdfs: {...} }
          json = json[jsonKey];
        }

        $.each(json, function (field, value) {
          model.set(field, value);
        })
      }
    }
  });


  App.QuickDataMapper = App.ServerDataMapper.extend({
    config: {},
    model: null,
    map: function (json) {
      if (!this.get('model')) {
        return;
      }

      if (json.items) {
        var result = [];

        json.items.forEach(function (item) {
          result.push(this.parseIt(item, this.config));
        }, this);

        App.store.loadMany(this.get('model'), result);
      }
    },

    parseIt: function (data, config) {
      var result = {};
      for ( var i in config) {
        if (i.substr(0, 1) === '$') {
          i = i.substr(1, i.length);
          result[i] = config['$' + i];
        } else {
          var isSpecial = false;
          if (i.substr(-5) == '_type') {
            var prefix = i.substr(0, i.length - 5);
            isSpecial = config[prefix + '_key'] != null;
          } else if (i.substr(-4) == '_key') {
            var prefix = i.substr(0, i.length - 4);
            isSpecial = config[prefix + '_type'] != null;
          }
          if (!isSpecial && typeof config[i] == 'string') {
            result[i] = this.getJsonProperty(data, config[i]);
          } else if (typeof config[i] == 'object') {
            result[i] = [];
            var _data = this.getJsonProperty(data, config[i + '_key']);
            var _type = config[i + '_type'];
            var l = _data.length;
            for ( var index = 0; index < l; index++) {
              if (_type == 'array') {
                result[i].push(this.getJsonProperty(_data[index], config[i].item));
              } else {
                result[i].push(this.parseIt(_data[index], config[i]));
              }
            }
            if(_type == 'array'){
              result[i] = result[i].sort();
            }
          }
        }
      }
      return result;
    },

    getJsonProperty: function (json, path) {
      var pathArr = path.split('.');
      var current = json;
      while (pathArr.length && current) {
        if (pathArr[0].substr(-1) == ']') {
          var index = parseInt(pathArr[0].substr(-2, 1));
          var attr = pathArr[0].substr(0, pathArr[0].length - 3);
          if (attr in current) {
            current = current[attr][index];
          }
        } else {
          current = current[pathArr[0]];
        }
        pathArr.splice(0, 1);
      }
      return current;
    },

    calculateState: function (json) {
  //    var stateEqual = (json.desired_status != json.work_status);
  //    if (stateEqual) {
  //      if (json.desired_status == 'STARTED' && json.work_status == 'INSTALLED') {
  //        json.work_status = 'STARTING';
  //      } else if (json.desired_status == 'INSTALLED' && json.work_status == 'STARTED') {
  //        json.work_status = 'STOPPING';
  //      }
  //    }
      return json;
    }
  });
  
});
window.require.register("mappers/service_mapper", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.servicesMapper = App.QuickDataMapper.create({
    servicesSortOrder: [
      'HDFS',
      'YARN',
      'MAPREDUCE',
      'MAPREDUCE2',
      'TEZ',
      'HBASE',
      'HIVE',
      'HCATALOG',
      'WEBHCAT',
      'FLUME',
      'OOZIE',
      'GANGLIA',
      'NAGIOS',
      'ZOOKEEPER',
      'PIG',
      'SQOOP',
      'HUE'
    ],
    sortByOrder: function (sortOrder, array) {
      var sorted = [];
      for (var i = 0; i < sortOrder.length; i++)
        for (var j = 0; j < array.length; j++) {
          if (sortOrder[i] == array[j].id) {
            sorted.push(array[j]);
          }
        }
      return sorted;
    },

    model: App.Service,
    config: {
      id: 'ServiceInfo.service_name',
      service_name: 'ServiceInfo.service_name',
      work_status: 'ServiceInfo.state',
      $rand: Math.random(),
      $alerts: [ 1, 2, 3 ],
      host_components: 'host_components'
    },
    hdfsConfig: {
      version: 'nameNodeComponent.ServiceComponentInfo.Version',
      name_node_id: 'nameNodeComponent.host_components[0].HostRoles.host_name',
      sname_node_id: 'snameNodeComponent.host_components[0].HostRoles.host_name',
      data_nodes: 'data_nodes',
      name_node_start_time: 'nameNodeComponent.ServiceComponentInfo.StartTime',
      jvm_memory_heap_used: 'nameNodeComponent.host_components[0].metrics.jvm.memHeapUsedM',
      jvm_memory_heap_committed: 'nameNodeComponent.host_components[0].metrics.jvm.memHeapCommittedM',
      live_data_nodes: 'live_data_nodes',
      dead_data_nodes: 'dead_data_nodes',
      decommission_data_nodes: 'decommission_data_nodes',
      capacity_used: 'nameNodeComponent.ServiceComponentInfo.CapacityUsed',
      capacity_total: 'nameNodeComponent.ServiceComponentInfo.CapacityTotal',
      capacity_remaining: 'nameNodeComponent.ServiceComponentInfo.CapacityRemaining',
      dfs_total_blocks: 'nameNodeComponent.ServiceComponentInfo.BlocksTotal',
      dfs_corrupt_blocks: 'nameNodeComponent.ServiceComponentInfo.CorruptBlocks',
      dfs_missing_blocks: 'nameNodeComponent.ServiceComponentInfo.MissingBlocks',
      dfs_under_replicated_blocks: 'nameNodeComponent.ServiceComponentInfo.UnderReplicatedBlocks',
      dfs_total_files: 'nameNodeComponent.ServiceComponentInfo.TotalFiles',
      upgrade_status: 'nameNodeComponent.ServiceComponentInfo.UpgradeFinalized',
      safe_mode_status: 'nameNodeComponent.ServiceComponentInfo.Safemode',

      name_node_cpu: 'nameNodeComponent.host_components[0].metrics.cpu.cpu_wio',
      name_node_rpc: 'nameNodeComponent.host_components[0].metrics.rpc.RpcQueueTime_avg_time'
    },
    mapReduceConfig: {
      version: 'jobTrackerComponent.ServiceComponentInfo.Version',
      job_tracker_id: 'jobTrackerComponent.host_components[0].HostRoles.host_name',
      task_trackers: 'task_trackers',
      job_tracker_start_time: 'jobTrackerComponent.ServiceComponentInfo.StartTime',
      job_tracker_heap_used: 'jobTrackerComponent.ServiceComponentInfo.HeapMemoryUsed',
      job_tracker_heap_max: 'jobTrackerComponent.ServiceComponentInfo.HeapMemoryMax',
      alive_trackers: 'alive_trackers',
      black_list_trackers: 'black_list_trackers',
      gray_list_trackers: 'gray_list_trackers',
      map_slots: 'map_slots',
      reduce_slots: 'reduce_slots',
      jobs_submitted: 'jobTrackerComponent.ServiceComponentInfo.jobtracker.jobs_submitted',
      jobs_completed: 'jobTrackerComponent.ServiceComponentInfo.jobtracker.jobs_completed',
      map_slots_occupied: 'jobTrackerComponent.ServiceComponentInfo.jobtracker.occupied_map_slots',
      map_slots_reserved: 'jobTrackerComponent.ServiceComponentInfo.jobtracker.reserved_map_slots',
      reduce_slots_occupied: 'jobTrackerComponent.ServiceComponentInfo.jobtracker.occupied_reduce_slots',
      reduce_slots_reserved: 'jobTrackerComponent.ServiceComponentInfo.jobtracker.reserved_reduce_slots',
      maps_running: 'jobTrackerComponent.ServiceComponentInfo.jobtracker.running_maps',
      maps_waiting: 'jobTrackerComponent.ServiceComponentInfo.jobtracker.waiting_maps',
      reduces_running: 'jobTrackerComponent.ServiceComponentInfo.jobtracker.running_reduces',
      reduces_waiting: 'jobTrackerComponent.ServiceComponentInfo.jobtracker.waiting_reduces',
      trackers_decommissioned: 'jobTrackerComponent.host_components[0].metrics.mapred.jobtracker.trackers_decommissioned',

      job_tracker_cpu: 'jobTrackerComponent.host_components[0].metrics.cpu.cpu_wio',
      job_tracker_rpc: 'jobTrackerComponent.host_components[0].metrics.rpc.RpcQueueTime_avg_time'
    },
    hbaseConfig: {
      version: 'masterComponent.ServiceComponentInfo.Version',
      master_id: 'masterComponent.host_components[0].HostRoles.host_name',
      region_servers: 'region_servers',
      master_start_time: 'masterComponent.ServiceComponentInfo.MasterStartTime',
      master_active_time: 'masterComponent.ServiceComponentInfo.MasterActiveTime',
      average_load: 'masterComponent.ServiceComponentInfo.AverageLoad',
      regions_in_transition: 'regions_in_transition',
      revision: 'masterComponent.ServiceComponentInfo.Revision',
      heap_memory_used: 'masterComponent.ServiceComponentInfo.HeapMemoryUsed',
      heap_memory_max: 'masterComponent.ServiceComponentInfo.HeapMemoryMax'
    },

    model3: App.HostComponent,
    config3: {
      id: 'id',
      work_status: 'HostRoles.state',
      desired_status: 'HostRoles.desired_state',
      component_name: 'HostRoles.component_name',
      ha_status: 'HostRoles.ha_status',
      host_id: 'HostRoles.host_name',
      $service_id: 'none' /* will be set outside of parse function */
    },

    map: function (json) {
      if (!this.get('model')) {
        return;
      }

      var start = new Date().getTime();
      console.log('in service mapper');

      if (json.items) {
        var result = [];
        json.items.forEach(function (item) {
          var finalConfig = jQuery.extend({}, this.config);
          var finalJson = [];
          item.host_components = [];
          item.components.forEach(function (component) {
            component.host_components.forEach(function (host_component) {
              host_component.id = host_component.HostRoles.component_name + "_" + host_component.HostRoles.host_name;
              item.host_components.push(host_component.id);
            }, this);
          }, this);
          item.host_components.sort();

          if (item && item.ServiceInfo && item.ServiceInfo.service_name == "HDFS") {
            finalJson = this.hdfsMapper(item);
            finalJson.rand = Math.random();
            result.push(finalJson);
            App.store.load(App.HDFSService, finalJson);
          }else if (item && item.ServiceInfo && item.ServiceInfo.service_name == "MAPREDUCE") {
            finalJson = this.mapreduceMapper(item);
            finalJson.rand = Math.random();
            result.push(finalJson);
            App.store.load(App.MapReduceService, finalJson);
          }else if (item && item.ServiceInfo && item.ServiceInfo.service_name == "HBASE") {
            finalJson = this.hbaseMapper(item);
            finalJson.rand = Math.random();
            result.push(finalJson);
            App.store.load(App.HBaseService, finalJson);
          }else if (item && item.ServiceInfo && item.ServiceInfo.service_name == "FLUME") {
            finalJson = this.flumeMapper(item);
            finalJson.rand = Math.random();
            result.push(finalJson);
            if(finalJson.nodeObjs){
              finalJson.nodeObjs.forEach(function(no){
                App.store.load(App.FlumeNode, no);
              });
            }
            App.store.load(App.FlumeService, finalJson);
          }else {
            finalJson = this.parseIt(item, this.config);
            finalJson.rand = Math.random();
            this.mapQuickLinks(finalJson, item);
            result.push(finalJson);
          }
        }, this);


        result = this.sortByOrder(this.get('servicesSortOrder'), result);
        App.store.loadMany(this.get('model'), result);

        // Host components
        result = [];
        var hostComponentToActualConfigsMap = {};
        json.items.forEach(function(item){
          item.components.forEach(function(component){
            var service = component.ServiceComponentInfo.service_name;
            component.host_components.forEach(function(host_component){
              hostComponentToActualConfigsMap[host_component.id] = host_component.HostRoles.actual_configs;
              var comp = this.parseIt(host_component, this.config3);
              comp.service_id = service;
              result.push(comp);
            }, this)
          }, this)
        }, this);

        result.forEach(function(hcJson){
          this.calculateState(hcJson);
        }, this);

        var oldHostComponents = App.HostComponent.find();
        var item;
        var currentHCWithComponentNames = {};
        var currentComponentNameHostNames = {};
        for ( var i = 0; i < oldHostComponents.content.length; i++) {
          item = oldHostComponents.objectAt(i);
          if (item && !result.findProperty('id', item.get('id'))) {
            item.deleteRecord();
          } else {
            var componentName = item.get('componentName');
            if (componentName) {
              currentHCWithComponentNames[item.get('id')] = item.get('id');
            }
            if (!currentComponentNameHostNames[componentName]) {
              currentComponentNameHostNames[componentName] = [];
            }
            currentComponentNameHostNames[componentName].pushObject(item.get('host.hostName'));
          }
        }
        result.forEach(function (item) {
          if (currentHCWithComponentNames[item.id] != null && 
              !currentComponentNameHostNames[item.component_name].contains(item.host_id)) {
            item.id = (new Date).getTime();
          }
        });
        
        App.store.loadMany(this.get('model3'), result);
        for(var hostComponentId in hostComponentToActualConfigsMap){
          var hostComponentObj = App.HostComponent.find(hostComponentId);
          var actualConfigs = [];
          // Create actual_configs
          for(var site in hostComponentToActualConfigsMap[hostComponentId]){
            var tag = hostComponentToActualConfigsMap[hostComponentId][site].tag;
            var configObj = App.ConfigSiteTag.create({
              site: site,
              tag: tag,
              hostOverrides: {}
            });
            var overrides = hostComponentToActualConfigsMap[hostComponentId][site].host_overrides;
            if(overrides!=null){
              var hostOverridesArray = {};
              overrides.forEach(function(override){
                var hostname = override.host_name;
                var tag = override.tag;
                hostOverridesArray[hostname] = tag;
              });
              configObj.set('hostOverrides', hostOverridesArray);
            }
            actualConfigs.push(configObj);
          }
          hostComponentObj.set('actualConfigs', actualConfigs);
        }
      }
      console.log('out service mapper.  Took ' + (new Date().getTime() - start) + 'ms');
    },

    /**
     * Map quick links to services:OOZIE,GANGLIA,NAGIOS,HUE
     * @param finalJson
     * @param item
     */
    mapQuickLinks: function (finalJson, item){
      if(item && item.ServiceInfo && item.ServiceInfo.service_name == "OOZIE"){
        finalJson.quick_links = [19];
      }else if(item && item.ServiceInfo && item.ServiceInfo.service_name == "GANGLIA"){
        finalJson.quick_links = [20];
      }else if(item && item.ServiceInfo && item.ServiceInfo.service_name == "NAGIOS"){
        finalJson.quick_links = [21];
      }else if(item && item.ServiceInfo && item.ServiceInfo.service_name == "HUE"){
        finalJson.quick_links = [22];
      }
    },

    hdfsMapper: function (item) {
      var finalConfig = jQuery.extend({}, this.config);
      // Change the JSON so that it is easy to map
      var hdfsConfig = this.hdfsConfig;
      item.components.forEach(function (component) {
        if (component.ServiceComponentInfo && component.ServiceComponentInfo.component_name == "NAMENODE") {
          item.nameNodeComponent = component;
          finalConfig = jQuery.extend(finalConfig, hdfsConfig);
          // Get the live, dead & decommission nodes from string json
          var liveNodesJson = App.parseJSON(component.ServiceComponentInfo.LiveNodes);
          var deadNodesJson = App.parseJSON(component.ServiceComponentInfo.DeadNodes);
          var decommissionNodesJson = App.parseJSON(component.ServiceComponentInfo.DecomNodes);
          item.live_data_nodes = [];
          item.dead_data_nodes = [];
          item.decommission_data_nodes = [];
          for (var ln in liveNodesJson) {
            item.live_data_nodes.push(ln);
          }
          for (var dn in deadNodesJson) {
            item.dead_data_nodes.push(dn);
          }
          for (var dcn in decommissionNodesJson) {
            item.decommission_data_nodes.push(dcn);
          }
        }
        if (component.ServiceComponentInfo && component.ServiceComponentInfo.component_name == "SECONDARY_NAMENODE") {
          item.snameNodeComponent = component;
        }
        if (component.ServiceComponentInfo && component.ServiceComponentInfo.component_name == "DATANODE") {
          if (!item.data_nodes) {
            item.data_nodes = [];
          }
          if (component.host_components) {
            component.host_components.forEach(function (hc) {
              item.data_nodes.push(hc.HostRoles.host_name);
            });
          }
        }
      });
      // Map
      var finalJson = this.parseIt(item, finalConfig);
      finalJson.quick_links = [1, 2, 3, 4];

      return finalJson;
    },
    mapreduceMapper: function (item) {
      // Change the JSON so that it is easy to map
      var result = [];
      var finalConfig = jQuery.extend({}, this.config);
      var mapReduceConfig = this.mapReduceConfig;
      item.components.forEach(function (component) {
        if (component.ServiceComponentInfo && component.ServiceComponentInfo.component_name == "JOBTRACKER") {
          item.jobTrackerComponent = component;
          finalConfig = jQuery.extend(finalConfig, mapReduceConfig);
          // Get the live, gray & black nodes from string json
          item.map_slots = 0;
          item.reduce_slots = 0;
          var liveNodesJson = App.parseJSON(component.ServiceComponentInfo.AliveNodes);
          var grayNodesJson = App.parseJSON(component.ServiceComponentInfo.GrayListedNodes);
          var blackNodesJson = App.parseJSON(component.ServiceComponentInfo.BlackListedNodes);
          item.alive_trackers = [];
          item.gray_list_trackers = [];
          item.black_list_trackers = [];
          if (liveNodesJson != null) {
            liveNodesJson.forEach(function (nj) {
              item.alive_trackers.push(nj.hostname);
              if (nj.slots && nj.slots.map_slots)
                item.map_slots += nj.slots.map_slots;
              if (nj.slots && nj.slots.map_slots_used)
                item.map_slots_used += nj.slots.map_slots_used;
              if (nj.slots && nj.slots.reduce_slots)
                item.reduce_slots += nj.slots.reduce_slots;
              if (nj.slots && nj.slots.reduce_slots_used)
                item.reduce_slots_used += nj.slots.reduce_slots_used;
            });
          }
          if (grayNodesJson != null) {
            grayNodesJson.forEach(function (nj) {
              item.gray_list_trackers.push(nj.hostname);
            });
          }
          if (blackNodesJson != null) {
            blackNodesJson.forEach(function (nj) {
              item.black_list_trackers.push(nj.hostname);
            });
          }
        }
        if (component.ServiceComponentInfo && component.ServiceComponentInfo.component_name == "TASKTRACKER") {
          if (!item.task_trackers) {
            item.task_trackers = [];
          }
          if (component.host_components) {
            component.host_components.forEach(function (hc) {
              item.task_trackers.push(hc.HostRoles.host_name);
            });
          }
        }
      });
      // Map
      finalJson = this.parseIt(item, finalConfig);
      finalJson.quick_links = [5, 6, 7, 8, 9, 10, 11, 12];
      return finalJson;
    },
    hbaseMapper: function (item) {
      // Change the JSON so that it is easy to map
      var finalConfig = jQuery.extend({}, this.config);
      var hbaseConfig = this.hbaseConfig;
      item.components.forEach(function (component) {
        if (component.ServiceComponentInfo && component.ServiceComponentInfo.component_name == "HBASE_MASTER") {
          item.masterComponent = component;
          finalConfig = jQuery.extend(finalConfig, hbaseConfig);
          var regionsArray = App.parseJSON(component.ServiceComponentInfo.RegionsInTransition);
          item.regions_in_transition = regionsArray == null ? 0 : regionsArray.length;
        }
        if (component.ServiceComponentInfo && component.ServiceComponentInfo.component_name == "HBASE_REGIONSERVER") {
          if (!item.region_servers) {
            item.region_servers = [];
          }
          if (component.host_components) {
            component.host_components.forEach(function (hc) {
              item.region_servers.push(hc.HostRoles.host_name);
            });
          }
        }
      });
      // Map
      finalJson = this.parseIt(item, finalConfig);
      finalJson.quick_links = [13, 14, 15, 16, 17, 18];
      return finalJson;
    },
    
    /**
     * Flume is different from other services, in that the important
     * data is in customizeable channels. Hence we directly transfer 
     * data into the JSON object.
     */
    flumeMapper: function (item) {
      var finalConfig = jQuery.extend({}, this.config);
      var finalJson = this.parseIt(item, finalConfig);
      ;
      item.components.forEach(function (component) {
        if (component.ServiceComponentInfo && component.ServiceComponentInfo.component_name == "FLUME_SERVER") {
          if (!finalJson.nodes) {
            finalJson.nodes = [];
          }
          if (!finalJson.nodeObjs) {
            finalJson.nodeObjs = [];
          }
          if (component.host_components) {
            component.host_components.forEach(function (hc) {
              var fnode = {};
              fnode.id = hc.HostRoles.host_name;
              fnode.host_id = hc.HostRoles.host_name;
              fnode.channels = "";
              fnode.sources = "";
              fnode.sinks = "";
              if (hc.metrics != null && hc.metrics.flume && hc.metrics.flume.flume && hc.metrics.flume.flume) {
                if (hc.metrics.flume.flume.CHANNEL) {
                  for ( var c in hc.metrics.flume.flume.CHANNEL) {
                    if (fnode.channels.length < 1) {
                      fnode.channels += c;
                    } else {
                      fnode.channels += ("," + c);
                    }
                  }
                }
                if (hc.metrics.flume.flume.SINK) {
                  for ( var c in hc.metrics.flume.flume.SINK) {
                    if (fnode.sinks.length < 1) {
                      fnode.sinks += c;
                    } else {
                      fnode.sinks += ("," + c);
                    }
                  }
                }
                if (hc.metrics.flume.flume.SOURCE) {
                  for ( var c in hc.metrics.flume.flume.SOURCE) {
                    if (fnode.sources.length < 1) {
                      fnode.sources += c;
                    } else {
                      fnode.sources += ("," + c);
                    }
                  }
                }
              }
              finalJson.nodeObjs.push(fnode);
              finalJson.nodes.push(hc.HostRoles.host_name);
            });
          }
        }
      });
      return finalJson;
    }
  });
});
window.require.register("mappers/status_mapper", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.statusMapper = App.QuickDataMapper.create({

    config:{
      id:'ServiceInfo.service_name',
      work_status:'ServiceInfo.state'
    },

    config3:{
      id:'id',
      work_status:'HostRoles.state',
      desired_status: 'HostRoles.desired_state'
    },

    map:function (json) {
      var start = new Date().getTime();
      console.log('in status mapper');

      if (json.items) {
        var result = {};
        json.items.forEach(function (item) {
          item = this.parseIt(item, this.config);
          result[item.id] = item;
        }, this);

        var services = App.Service.find();
        services.forEach(function(service) {
          var item = result[service.get('id')];
          if (item) {
            service.set('workStatus', item.work_status);
          }
        });

        //host_components
        result = this.parse_host_components(json);

        // console.profile("App.statusMapper.map() profile");

        var hostComponents = App.HostComponent.find();

        hostComponents.forEach(function(hostComponent) {
          var item = result[hostComponent.get('id')];
          if (item) {
           hostComponent.set('workStatus', item.work_status);
          }
        });

        // console.profileEnd();

        console.log('out status mapper.  Took ' + (new Date().getTime() - start) + 'ms');
      }
    },

    parse_host_components: function(json) {
      var result = {};
      json.items.forEach(function (item) {
        item.components.forEach(function (component) {
          component.host_components.forEach(function (host_component) {
            host_component.id = host_component.HostRoles.component_name + "_" + host_component.HostRoles.host_name;
            result[host_component.id] = this.parseIt(host_component, this.config3);
          }, this)
        }, this)
      }, this);
      return result;
    }

  });
  
});
window.require.register("mappers/target_cluster_mapper", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  App.targetClusterMapper = App.QuickDataMapper.create({
    model: App.TargetCluster,
    config: {
      id: 'id',
      cluster_name: 'Clusters.name',
      name_node_web_url: 'name_node_web_url',
      name_node_rpc_url: 'name_node_rpc_url',
      oozie_server_url: 'oozie_server_url'
    },
    map: function (json) {
      if (!this.get('model')) {
        return;
      }
      if (json && json.items && json.items.length > 0) {
        var target_cluster_results = [];
        json.items.forEach(function (item) {
          try {
            item.name_node_web_url = (item.Clusters.interfaces.interface.findProperty("type", "readonly")).endpoint;
            item.name_node_rpc_url = (item.Clusters.interfaces.interface.findProperty("type", "write")).endpoint;
            item.oozie_server_url = (item.Clusters.interfaces.interface.findProperty("type","workflow")).endpoint;
            item.id = item.Clusters.name;

            var re = new RegExp(" ", "g");
            item.id = item.id.replace(re, "_");


            item = this.parseIt(item, this.config);
            target_cluster_results.push(item);
          } catch (ex) {
            console.error('Exception occurred: ' + ex);
          }
        }, this);
        App.store.loadMany(this.get('model'), target_cluster_results);
      }
    }
  });
  
});
window.require.register("mappers/users_mapper", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.usersMapper = App.QuickDataMapper.create({
    model : App.User,
    config : {
      id : 'Users.user_name',
      user_name : 'Users.user_name',
      roles : 'Users.roles',
      is_ldap: 'Users.ldap_user',
      admin: 'Users.admin'
    },
    map: function (json) {
      var self = this;
      json.items.forEach(function (item) {
        var result= [];
        if(!App.User.find().someProperty("userName", item.Users.user_name)) {
          item.Users.admin = self.isAdmin(item.Users.roles);
          result.push(self.parseIt(item, self.config));
          App.store.loadMany(self.get('model'), result);
        }
      });
    },
    isAdmin: function(roles) {
      return (roles.indexOf("admin") >= 0);
    }
  });
  
});
window.require.register("messages", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  Em.I18n.translations = {

     'app.name':'大数据平台',
    'app.reloadPopup.link': '加载页',
    'app.reloadPopup.text': '正在连接服务器...',
    'app.reloadPopup.header': '重新加载页面',

    'app.loadingPlaceholder': '正在加载...',
    'app.signout':'退出',

    'apply':'应用',
    'and':'和',
    'none':'没有',
    'all':'全部',
    'minimum':'最小',
    'from':'从',
    'to':'到',
    'ok':'好',
    'as':'as',
    'any': 'Any',
    'more':'更多',
    'yes':'是',
    'no':'否',
    'add': '增加',
    'common.learnMore':'了解更多详情',
    'common.back':'回退',
    'common.prev':'上一个',
    'common.next':'下一个',
    'common.host':'主机',
    'common.hosts':'主机',
    'common.services':'服务',
    'common.group':'群组',
    'common.progress':'Progress',
    'common.status':'状态',
    'common.action':'操作',
    'common.addComponent':'添加组件',
    'common.remove':'删除',
    'common.retry':'重试',
    'common.show':'展示',
    'common.hide':'隐藏',
    'common.cancel':'取消',
    'common.apply':'应用',
    'common.done':'完成',
    'common.service': '服务',
    'common.version':'版本',
    'common.description':'描述',
    'common.client':'客户端',
    'common.zookeeper':'ZooKeeper',
    'common.hbase':'HBase',
    'common.regionServer':'RegionServer',
    'common.taskTracker':'TaskTracker',
    'common.dataNode':'DataNode',
    'common.more': '更多...',
    'common.print':'打印',
    'common.deploy':'部署',
    'common.message':'消息',
    'common.tasks':'Tasks',
    'common.open':'打开',
    'common.copy':'复制',
    'common.complete':'完成',
    'common.metrics':'度量指标',
    'common.timeRange':'时间范围',
    'common.name':'Name',
    'common.value':'Value',
    'common.ipAddress':'IP 地址',
    'common.cpu':'CPU',
    'common.ram':'RAM',
    'common.disk':'Disk',
    'common.diskUsage':'硬盘使用',
    'common.loadAvg':'平均负载',
    'common.components':'组件',
    'common.component':'组件',
    'common.quickLinks':'快速链接',
    'common.save':'保存',
    'common.servers':'服务器',
    'common.clients':'客户端',
    'common.user': '用户',
    'common.users': '用户',
    'common.os':'OS',
    'common.memory':'内存',
    'common.maximum':'最大',
    'common.start':'启动',
    'common.stop':'停止',
    'common.pause':'暂停',
    'common.decommission':'停用',
    'common.recommission':'使用',
    'common.failure': '失败',
    'common.type': '类型',
    'common.close': '关闭',
    'common.warning': '警告',
    'common.information': '信息',
    'common.all':'全部',
    'common.success': '成功',
    'common.fail':'失败',
    'common.error': '错误',
    'common.loading': '加载',
    'common.search': '搜索',
    'common.confirm': '进一步确认',
    'common.upgrade': '升级',
    'common.reUpgrade': '重新升级',
    'common.security':'安全',
    'common.cluster':'集群',
    'common.add': '增加',
    'common.edit': '编辑',
    'common.delete': '删除',
    'common.empty': '清空',
    'common.exception':'异常',
    'common.undo':'撤销',
    'common.details':'详情',
    'common.stats':'Stats',
    'common.abort': '中止',
    'common.misc': '其他',
    'common.operations': '操作',
    'common.reinstall': '重新安装',
    'common.errorPopup.header': '遇到一个错误',
    'common.use': '使用',
    'common.stacks': 'Stacks',
    'common.reset': '重启',
    'common.path': '路径',
    'common.package': '打包',
    'common.proceed': '继续进行',
    'common.process': '处理进程',
    'common.property': '属性',
    'common.installed': '已安装',
    'common.persist.error' : 'ambari服务器web客户端状态保持失败',
    'common.update.error' : '从ambari服务器获取web客户端状态失败',
    'requestInfo.installComponents':'安装组件',
    'requestInfo.installServices':'安装服务',
    'requestInfo.startServices':'启动服务',
    'requestInfo.stopAllServices':'关闭所有服务',
    'requestInfo.startAllServices':'启动所有服务',
    'requestInfo.startHostComponent':'启动',
    'requestInfo.startHostComponents':'启动组件',
    'requestInfo.upgradeHostComponent':'升级',
    'requestInfo.stopHostComponent':'停止',
    'requestInfo.installHostComponent':'安装',
    'requestInfo.installNewHostComponent':'安装',
    'requestInfo.stopService':'停止',
    'requestInfo.startService':'启动',

    'hostPopup.noServicesToShow':'没有可显示的服务',
    'hostPopup.noHostsToShow':'没有可显示的主机',
    'hostPopup.noTasksToShow':'没有可显示的tasks',
    'hostPopup.status.category.all':'全部 ({0})',
    'hostPopup.status.category.pending':'等待中 ({0})',
    'hostPopup.status.category.inProgress':'进程中 ({0})',
    'hostPopup.status.category.failed':'失败 ({0})',
    'hostPopup.status.category.success':'成功 ({0})',
    'hostPopup.status.category.aborted':'中止 ({0})',
    'hostPopup.status.category.timedout':'超时 ({0})',
    'hostPopup.header.postFix':' 后台操作运行中',

    'question.sure':'你确定吗?',

    'popup.highlight':'点击高亮区域',
    'popup.confirmation.commonHeader':'配置信息',

    'router.hadoopClusterNotSetUp':'管理员还没有创建一个Hadoop集群.',

    'login.header':'登录',
    'login.username':'用户名',
    'login.password':'密码',
    'login.loginButton':'登录',
    'login.error':'无效的用户/密码组合.',
    
    'graphs.noData.title': '没有数据',
    'graphs.noData.message': '没有可用的数据. 可能是连接不上Ganglia服务的原因.',
    'graphs.noDataAtTime.message': '这期间没有有效数据.',
    'graphs.error.title': '错误',
    'graphs.error.message': '图形数据的获取出现问题({0}: {1})',
    'graphs.timeRange.hour': '近 1 小时',
    'graphs.timeRange.twoHours': '近 2 小时',
    'graphs.timeRange.fourHours': '近 4 小时',
    'graphs.timeRange.twelveHours': '近 12 小时',
    'graphs.timeRange.day': '近 24 小时',
    'graphs.timeRange.week': '近 1 周',
    'graphs.timeRange.month': '近 1 月',
    'graphs.timeRange.year': '近 1 年',

    'users.userName.validationFail': '只允许小写字母和数字; 首字母必须为字符',

    'services.nagios.description':'Nagios 监听和报警系统',
    'services.ganglia.description':'Ganglia 度量指标收集系统',
    'services.hdfs.description':'Apache Hadoop分布式文件系统',
    'services.hcfs.description':'Apache Hadoop Compatible 文件系统 (必须手动安装)',
    'services.mapreduce.description':'Apache Hadoop 分布式处理框架',
    'services.sqoop.description':'Apache Hadoop和结构化存储的数据（譬如关系型数据库）之间大容量数据迁移的工具',
    'services.pig.description':'大规模数据分析的脚本平台',
    'services.hive.description':'数据仓库系统for ad-hoc queries & analysis of large datasets and table & storage management service',
    'services.oozie.description':'System for workflow coordination and execution of Apache Hadoop jobs',
    'services.zookeeper.description':'提供集中式的高可靠的分布式协同服务',
    'services.hbase.description':'非关系型的分布式数据库和 集中式的配置管理和同步服务',
    'services.hive.databaseComponent':'数据库服务器',
    'services.mapreduce2.description':'Apache Hadoop NextGen MapReduce (client libraries)',
    'services.yarn.description':'Apache Hadoop NextGen MapReduce (YARN)',
    'services.tez.description':'Tez is the next generation Hadoop Query Processing framework written on top of YARN',

    'services.alerts.head':'You have {0} 严重报警通知(s).',
    'services.alerts.OK.timePrefix': '正常 for ',
    'services.alerts.WARN.timePrefix': '警告 for ',
    'services.alerts.CRIT.timePrefix': 'CRIT for ',
   // 'topnav.logo.href':'http://incubator.apache.org/ambari/',
    'topnav.logo.href':'',   
	'services.alerts.UNKNOWN.timePrefix': '未知  for ',
    'services.alerts.headingOfList': '警告及检查',
    'services.alerts.goToService': '返回到服务',
    'services.alerts.goToNagios': '返回到Nagios 用户界面',


   //'topnav.help.href':'https://cwiki.apache.org/confluence/display/AMBARI/Ambari',
	'topnav.help.href':'',

    'installer.header':'集群安装向导',
    'installer.navigation.warning.header':'导航警告',

    'installer.noHostsAssigned':'没有分配的主机',
    'installer.slaveComponentHosts.selectHosts':'给群组选择主机',
    'installer.slaveComponentHostsPopup.header':'选择哪些主机应该属于哪一个{0} 群组',

    'installer.controls.slaveComponentGroups':' 群组',
    'installer.controls.serviceConfigPopover.title':'{0}<br><small>{1}</small>',
    'installer.controls.serviceConfigMultipleHosts.other':'1 其他',
    'installer.controls.serviceConfigMultipleHosts.others':'{0} 其他',
    'installer.controls.serviceConfigMasterHosts.header':'{0} 主机',
    'installer.controls.addSlaveComponentGroupButton.title':'增加 一个 {0} 群组',
    'installer.controls.addSlaveComponentGroupButton.content':'如果你需要在特定的{0}s有不同的配置 , 可以增加一个 {1} 群组.<br>在相同的群组所有的 {2}s 需要用相同的配置. 可以创建多个群组.',
    'installer.controls.slaveComponentChangeGroupName.error':'这个群组名已存在',

    'installer.step0.header':'欢迎',
    'installer.step0.body.header':'欢迎来到大数据平台!',
    'installer.step0.body':'Ambari使Hadoop集群的安装、管理和监测更容易.<br>' +
      '我们将通过step-by-step向导帮助你完成集群的安装过程.',
    'installer.step0.clusterName':'给集群起名',
    'installer.step0.clusterName.tooltip.title':'集群名',
    'installer.step0.clusterName.tooltip.content':'输入一个唯一的集群名. 集群名以后不能更改.',
    'installer.step0.clusterName.error.required':'集群名是必填项',
    'installer.step0.clusterName.error.whitespaces':'及群名不能包含空格字符',
    'installer.step0.clusterName.error.specialChar':'集群名不能包含特殊字符',

    'installer.step1.header':'选择Stack',
    'installer.step1.body':'请选择你想要在安装Hadoop集群时使用的服务stack.',
    'installer.step1.advancedRepo.title':'高级存储选项',
    'installer.step1.advancedRepo.message':'指定软件包的存储下载的地址. 如果你的主机连接不了网络, 需要创建一个能被所有主机访问到的本地存储镜像，并在此处指明Base URL.',
    'installer.step1.advancedRepo.localRepo.error.modifyUrl':'必须修改本地存储的URL',
    'installer.step1.advancedRepo.localRepo.error.noUrl':'需要本地存储的Base URL ',
    'installer.step1.advancedRepo.localRepo.column.baseUrl':'Base URL',
    'installer.step1.advancedRepo.localRepo.label.os':'操作系统',
    'installer.step1.advancedRepo.localRepo.label.baseUrl':'存储Base URL',
    'installer.step1.advancedRepo.localRepo.label.stack':'Stack',

    'installer.step2.header':'安装选项',
    'installer.step2.body':'键入集群中已存在的主机列表，并提供ssh密钥.',
    'installer.step2.targetHosts':'目标主机',
    'installer.step2.targetHosts.info':'使用Fully Qualified Domain Name (FQDN)键入主机列表,按行输入，一行一个主机',
    'installer.step2.hostPattern.tooltip.title':'模式表达式',
    'installer.step2.hostPattern.tooltip.content':'可以使用模式表达式来指定一组目标主机.例如, 要指定host01.domain 到 host10.domain,在目标主机文本输入框输入 host[01-10].domain.',
    'installer.step2.hostName.error.required':'必须指定至少一个主机名',
    'installer.step2.hostName.error.already_installed':'所有的主机都已经是集群中的一部分了',
    'installer.step2.hostName.error.notRequired':'如果不使用SSH 来动态配置主机，主机名将被略过',
    'installer.step2.hostName.error.invalid':'不合法的主机名(s)',
    'installer.step2.hostName.pattern.header':'主机名模式表达式',
    'installer.step2.sshKey':'主机注册信息',
    'installer.step2.sshKey.error.required':'需要SSH私钥',
    'installer.step2.passphrase.error.match':'密码不匹配',
    'installer.step2.manualInstall.label':'不使用SSH 来动态配置主机',
    'installer.step2.manualInstall.info':'不使用SSH连接目标主机, 你必须按向导顺序在每台主机上手动安装 ' +
      'Ambari Agent 来完成必须的配置和软件安装.',
    'installer.step2.advancedOption':'高级选项',
    'installer.step2.repoConf':'软件存储配置文件路径',
    'installer.step2.advancedOptions.header':'高级选项',
    'installer.step2.localRepo.label_use':'使用一个',
    'installer.step2.localRepo.label_instead':'代替从网络上下载软件包',
    'installer.step2.localRepo.error.required':'本地存储文件路径是必填项',
    'installer.step2.localRepo.tooltip.title':'本地软件存储',
    'installer.step2.localRepo.tooltip.content': '集群的安装需要连接网络来从远程的存储镜像获取软件.' +
      '在一些情况下,没有可用的有效带宽，不得不预防一再地从远程存储镜像下载软件包 ' +
      '. 还有一些情况是, 你集群的主机不能连接互联网' +
      '. 在这种情形下, 你必须建立一个机器可访问到的本地的存储镜像版本,' +
      '这一本地版本镜像被称为 <b>Local Software Repository</b>',
    'installer.step2.javaHome.label' : ' 64位JDK路径',
    'installer.step2.javaHome.tooltip.title' : 'JAVA_HOME',
    'installer.step2.javaHome.tooltip.content' : '64位 JAVA_HOME的路径. Ambari默认使用的路径是/usr/jdk/jdk1.6.0_31. 可以重新指定一个包含JDK的路径. <br/> 注意: 该路径必须在你的集群 <b>所有</b> 主机上都合法.',
    'installer.step2.javaHome.tooltip.placeholder' : '/usr/jdk/jdk1.6.0_31',
    'installer.step2.useSsh.provide' : '提供你的',
    'installer.step2.useSsh.provide_id_rsa' : '自动注册主机',
    'installer.step2.useSsh.tooltip.title':'SSH 私钥',
    'installer.step2.useSsh.tooltip.content':'The <b>SSH 私钥文件</b> 用来在安装Ambari Agent时连接集群上的目标主机.',
    'installer.step2.manualInstall.perform':'执行',
    'installer.step2.manualInstall.perform_on_hosts':'在主机上，并且不使用 SSH',
    'installer.step2.manualInstall.tooltip.title':'手动注册',
    'installer.step2.manualInstall.tooltip.content':'在每台主机上手动注册Ambari Agent消除使用SSH的需要,并应该在继续安装集群前执行完成.',
    'installer.step2.manualInstall.popup.header':'在继续进行前',
    'installer.step2.manualInstall.popup.body':'在继续进行前，需要在每台拟管理的主机上安装Ambari Agents.',
    'installer.step2.warning.popup.body':'<p>一下的主机名不是合法的FQDNs:</p><p> {0} </p><p>在安装过程中可能导致一些问题. 确定要继续吗?</p>',
    'installer.step2.orUse':'或使用',
    'installer.step2.registerAndConfirm':'注册并进一步确认',
    'installer.step2.evaluateStep.installedHosts':'这些主机已经在集群中安装，将略过:',
    'installer.step2.evaluateStep.continueConfirm':'是否继续?',
    'installer.step2.evaluateStep.hostRegInProgress':'当前的主机注册正在进行. 请稍候再试.',
    'installer.step2.sshUser':'SSH 用户 (root 或',
    'installer.step2.sshUser.link':'无密码的 sudo',
    'installer.step2.sshUser.account':'帐户)',
    'installer.step2.sshUser.toolTip':'帐户不需要输入密码就可执行sudo命令',
    'installer.step2.sshUser.placeholder':'输入用户名',
    'installer.step2.sshUser.required':'用户名是必填项',

    'installer.step3.header':'确认主机',
    'installer.step3.body':'注册主机.<br>' +
      '请确认主机列表，并删除不想包含在该集群中的所有主机.',
    'installer.step3.hostLog.popup.header':'注册日志 for {0}',
    'installer.step3.hosts.remove.popup.header':'移除主机',
    'installer.step3.hosts.remove.popup.body':'确定移除已选择的主机吗?',
    'installer.step3.hostInformation.popup.header':'重新获取主机信息失败',
    'installer.step3.hostInformation.popup.body' : '所有 bootstrapped 主机已注册,但是不能获取cpu和内存相关信息',
    'installer.step3.hostWarningsPopup.report':'展示报告',
    'installer.step3.hostWarningsPopup.report.header': '<p style="font-family: monospace">######################################<br># 主机检测报告<br>#<br># 生成: ',
    'installer.step3.hostWarningsPopup.report.hosts': '<br>######################################<br><br>######################################<br># Hosts<br>#<br># A space delimited list of hosts which have issues.<br># Provided so that administrators can easily copy hostnames into scripts, email etc.<br>######################################<br>HOSTS<br>',
    'installer.step3.hostWarningsPopup.report.fileFolders': '<br><br>######################################<br># Files and Folders<br>#<br># A space delimited list of files and folders which should not exist.<br># Provided so that administrators can easily copy paths into scripts, email etc.<br># Example: rm -r /etc/hadoop /etc/hbase /etc/some\\ /folder<br>######################################<br>FILES AND FOLDERS<br>',
    'installer.step3.hostWarningsPopup.report.process': '<br><br>######################################<br># Processes<br>#<br># A comma separated list of process tuples which should not be running.<br># Provided so that administrators can easily copy paths into scripts, email etc.<br>######################################<br>PROCESSES<br>',
    'installer.step3.hostWarningsPopup.report.package': '<br><br>######################################<br># Packages<br>#<br># A space delimited list of software packages which should be uninstalled.<br># Provided so that administrators can easily copy paths into scripts, email etc.<br># Example: yum remove hadoop-hdfs nagios<br>######################################<br>PACKAGES<br>',
    'installer.step3.hostWarningsPopup.report.service': '<br><br>######################################<br># Services<br>#<br># A space delimited list of services which should be up and running.<br># Provided so that administrators can easily copy paths into scripts, email etc.<br># Example: services start ntpd httpd<br>######################################<br>SERVICES<br>',
    'installer.step3.hostWarningsPopup.report.user': '<br><br>######################################<br># Users<br>#<br># A space delimited list of users who should not exist.<br># Provided so that administrators can easily copy paths into scripts, email etc.<br># Example: userdel hdfs<br>######################################<br>USERS<br>',
    'installer.step3.hostWarningsPopup.report.folder': '\\ /folder',
    'installer.step3.hostWarningsPopup.checks': '主机检测发现问题',
    'installer.step3.hostWarningsPopup.notice':'手动解决这些问题后, 点击 <b>重新执行检测</b>.',
    'installer.step3.hostWarningsPopup.summary':'{0} 在 {1}',
    'installer.step3.hostWarningsPopup.process':'进程问题',
    'installer.step3.hostWarningsPopup.processes.message':'以下进程不应该运行',
    'installer.step3.hostWarningsPopup.fileAndFolder':'文件和文件夹问题',
    'installer.step3.hostWarningsPopup.fileFolders.message':'以下文件和文件夹不应该存在',
    'installer.step3.hostWarningsPopup.package':'软件包问题',
    'installer.step3.hostWarningsPopup.packages.message':'以下软件包应该卸载',
    'installer.step3.hostWarningsPopup.user':'用户问题',
    'installer.step3.hostWarningsPopup.users.message':'以下用户应该被移除',
    'installer.step3.hostWarningsPopup.service':'服务问题',
    'installer.step3.hostWarningsPopup.services.message':'以下服务应该启动',
    'installer.step3.hostWarningsPopup.issue':'问题',
    'installer.step3.hostWarningsPopup.issues':'问题',
    'installer.step3.hostWarningsPopup.emptyMessage':'没有不需要的',
    'installer.step3.hostWarningsPopup.empty.filesAndFolders':'文件和文件夹',
    'installer.step3.hostWarningsPopup.empty.processes':'进程',
    'installer.step3.hostWarningsPopup.empty.packages':'软件包',
    'installer.step3.hostWarningsPopup.empty.users':'用户',
    'installer.step3.hostWarningsPopup.empty.services':'服务',
    'installer.step3.hostWarningsPopup.action.exists':'存在在',
    'installer.step3.hostWarningsPopup.action.notRunning':'没有运行在',
    'installer.step3.hostWarningsPopup.action.installed':'已安装在',
    'installer.step3.hostWarningsPopup.action.running':'正运行在',
    'installer.step3.hostWarningsPopup.host':'主机',
    'installer.step3.hostWarningsPopup.hosts':'主机',
    'installer.step3.hostWarningsPopup.moreHosts':'{0} more hosts...<br>点击链接来查看全部主机.',
    'installer.step3.hostWarningsPopup.allHosts':'主机列表',
    'installer.step3.hostWarningsPopup.rerunChecks':'重新执行检测',
    'installer.step3.hostWarningsPopup.hostHasWarnings':'警告: Host checks failed on some of your hosts. It is highly recommended that you fix these problems first before proceeding to prevent potentially major problems with cluster installation. Are you sure you want to ignore these warnings and proceed?',
    'installer.step3.warningsWindow.allHosts':'Warnings across all hosts',
    'installer.step3.warningsWindow.warningsOn':'Warnings on ',
    'installer.step3.warningsWindow.directoriesAndFiles':'DIRECTORIES AND FILES',
    'installer.step3.warningsWindow.noWarnings':'无警告',
    'installer.step3.hosts.noHosts':'No hosts to display',
    'installer.step3.warnings.popup.header':'Host Checks',
    'installer.step3.warnings.description':'Some warnings were encountered while performing checks against the above hosts.',
    'installer.step3.warnings.linkText':'Click here to see the warnings.',
    'installer.step3.noWarnings.linkText':'Click here to see the check results.',
    'installer.step3.warnings.noWarnings':'All host checks passed on {0} registered hosts.',
    'installer.step3.warnings.fails':'Some warnings were encountered while performing checks against the {0} registered hosts above',
    'installer.step3.warnings.someWarnings':'All host checks passed on {0} registered hosts. Note: Host checks were skipped on {1} hosts that failed to register.',
    'installer.step3.warnings.allFailed':'Host checks were skipped on {0} hosts that failed to register.',
    'installer.step3.warnings.updateChecks.success':'Host Checks successfully updated',
    'installer.step3.warnings.updateChecks.failed':'Host Checks update failed',
    'installer.step3.removeSelected':'移除选择',
    'installer.step3.retryFailed':'重试失败',
    'installer.step3.hosts.status.registering':'正在注册',
    'installer.step3.hosts.status.installing':'正在安装',
    'installer.step3.hosts.bootLog.failed':'\nRegistration with the server failed.',
    'installer.step3.hosts.bootLog.registering':'\nRegistering with the server...',
    'installer.step3.hostLogPopup.highlight':'click to highlight',
    'installer.step3.hostLogPopup.copy':'按CTRL+C键',

    'installer.step4.header':'选择服务',
    'installer.step4.body':'Choose which services you want to install on your cluster.',
    'installer.step4.hdfsCheck.popup.header':'Hadoop File System Needed',
    'installer.step4.hdfsCheck.popup.body':'不需要选择HDFS 或 HCFS, 但必须填写一个.  我们将自动选择HDFS. 可以吗?',
    'installer.step4.multipleDFS.popup.header':'Multiple File Systems Selected',
    'installer.step4.multipleDFS.popup.body':'You selected more than one file system.  We will automatically select only HDFS.  Is this OK?',
    'installer.step4.mapreduceCheck.popup.header':'MapReduce Needed',
    'installer.step4.mapreduceCheck.popup.body':'You did not select MapReduce, but it is needed by other services you selected.  We will automatically add MapReduce.  Is this OK?',
    'installer.step4.monitoringCheck.popup.header':'Limited Functionality Warning',
    'installer.step4.monitoringCheck.popup.body':'You did not select Nagios and/or Ganglia.  If both are not selected, monitoring and alerts will not function properly.  Is this OK?',

    'installer.step5.header':'分配Masters',
    'installer.step5.reassign.header':'选择目标主机',
    'installer.step5.attention':'主机没有运行master服务',
    'installer.step5.body':'分配master组件给拟在上面运行的主机.',
    'installer.step5.body.hive':'<i class="icon-asterisks">&#10037</i> HiveServer2, Hive Metastore,和WebHCat Server同处于一个服务器.',
    'installer.step5.hostInfo':'%@ (%@, %@ cores)',
    'installer.step5.hiveGroup':'HiveServer2, WebHCat Server, MySQL Server',

    'installer.step6.header':'分配Slaves和客户端',
    'installer.step6.body':'分配slave 和客户端组件到你想运行其上的主机.<br/>被分配master组件的主机显示 <i class=icon-asterisks>&#10037</i>. <br/>&quot;Client&quot; 将安装',
    'installer.step6.error.mustSelectOne':'每个组件必须至少安置在一台主机上.',
    'installer.step6.error.mustSelectOneForHost':'每台主机都必须分配至少一个slave/客户端组件.',
    'installer.step6.wizardStep6Host.title':'master 组件安装在 {0}',
    'installer.step6.addHostWizard.body':'分配HBase master and ZooKeeper server.',
    'installer.step6.error.mustSelectOneForSlaveHost': '每一台没有master组件的主机，都必须分配至少一个slave/客户端组件',

    'installer.step7.header':'自定义服务',
    'installer.step7.body':'我们已经为你选择的服务提供了一些推荐的配置项. 如有合适的，请随便使用.',
    'installer.step7.attentionNeeded':'<b>注意:</b> 在继续安装前需要注意一些配置项.',
    'installer.step7.config.addProperty':'添加属性',
    'installer.step7.ConfigErrMsg.header':'自定义配置错误: ',
    'installer.step7.ConfigErrMsg.message':'自定义配置错误. 一些键入的属性信息已经陈列在当前页面',
    'installer.step7.popup.currentValue':'当前值',
    'installer.step7.popup.adjustedValue':'调整值',

    'installer.step8.header':'检查',
    'installer.step8.body':'请在安装前检查配置信息',
    'installer.step8.deployPopup.message':'准备部署: {0} of {1} 任务已完成.',
    'installer.step8.hosts':' 主机',
    'installer.step8.host':' 主机',
    'installer.step8.other':' 和 {0} 其他主机',
    'installer.step8.securityWarning':'正在安全模式下运行集群.在继续安装前必须为所有增加的主机创建keytabs.',
    'installer.step8.securityConfirmationPopupBody':'在继续安装前，必须确保遵照检查页面上的指示已经为增加的主机创建了keytabs. 否则,已分配的组件将不能在增加的主机上启动成功.',

    'installer.step9.header':'安装,启动和测试',
    'installer.step9.body':'选择的服务在安装和启动完成前请耐心等待.',
    'installer.step9.status.success':'安装和启动服务成功.',
    'installer.step9.status.warning':'已安装和启动的服务有些警告信息.',
    'installer.step9.status.failed':'安装/启动 服务失败.',
    'installer.step9.host.status.success':'成功',
    'installer.step9.host.status.warning':'遇到警告',
    'installer.step9.host.status.failed':'遇到失败',
    'installer.step9.host.status.nothingToInstall':'等待中 (没有可安装的)',
    'installer.step9.hosts.status.label.inProgress':'进程中',
    'installer.step9.hosts.status.label.warning':'警告',
    'installer.step9.hostLog.popup.header':'任务. 执行 ',
    'installer.step9.hostLog.popup.categories.all':'所有',
    'installer.step9.hostLog.popup.categories.pending':'排队 / 等待',
    'installer.step9.hostLog.popup.categories.in_progress':'进程中',
    'installer.step9.hostLog.popup.categories.failed':'失败',
    'installer.step9.hostLog.popup.categories.completed':'成功',
    'installer.step9.hostLog.popup.categories.aborted':'取消',
    'installer.step9.hostLog.popup.categories.timedout':'超时',
    'installer.step9.hostLog.popup.noTasksToShow':'没有可显示的任务',
    'installer.step9.overallProgress':'{0} % 全部',
    'installer.step9.serviceStatus.install.pending':'正在准备安装 ',
    'installer.step9.serviceStatus.install.queued':'等待安装中 ',
    'installer.step9.serviceStatus.install.inProgress':'正在安装 ',
    'installer.step9.serviceStatus.install.completed':'安装成功',
    'installer.step9.serviceStatus.install.failed':'安装失败',
    'installer.step9.serviceStatus.uninstall.pending':'正在准备卸载 ',
    'installer.step9.serviceStatus.uninstall.queued':'等待卸载中',
    'installer.step9.serviceStatus.uninstall.inProgress':'正在卸载 ',
    'installer.step9.serviceStatus.uninstall.completed':'卸载成功',
    'installer.step9.serviceStatus.uninstall.failed':'卸载失败',
    'installer.step9.serviceStatus.start.pending':'准备启动',
    'installer.step9.serviceStatus.start.queued':'等待启动',
    'installer.step9.serviceStatus.start.inProgress':'正在启动 ',
    'installer.step9.serviceStatus.start.completed':' 启动成功',
    'installer.step9.serviceStatus.start.failed':'启动失败',
    'installer.step9.serviceStatus.stop.pending':'准备关闭',
    'installer.step9.serviceStatus.stop.queued':'等待关闭',
    'installer.step9.serviceStatus.stop.inProgress':'关闭中 ',
    'installer.step9.serviceStatus.stop.completed':'关闭成功',
    'installer.step9.serviceStatus.stop.failed':'关闭失败',
    'installer.step9.serviceStatus.execute.pending':'准备执行',
    'installer.step9.serviceStatus.execute.queued':'等待执行',
    'installer.step9.serviceStatus.execute.inProgress':'正在执行 ',
    'installer.step9.serviceStatus.execute.completed':'执行成功',
    'installer.step9.serviceStatus.execute.failed':'执行失败',
    'installer.step9.serviceStatus.abort.pending':'准备取消',
    'installer.step9.serviceStatus.abort.queued':'等待取消',
    'installer.step9.serviceStatus.abort.inProgress':'正在取消 ',
    'installer.step9.serviceStatus.abort.completed':'取消成功',
    'installer.step9.serviceStatus.abort.failed':' 取消失败',
    'installer.step9.serviceStatus.upgrade.pending':'准备升级中 ',
    'installer.step9.serviceStatus.upgrade.queued':'等待升级中 ',
    'installer.step9.serviceStatus.upgrade.inProgress':'正在升级 ',
    'installer.step9.serviceStatus.upgrade.completed':' 升级成功',
    'installer.step9.serviceStatus.upgrade.failed':' 升级失败',

    'installer.step10.header':'概要',
    'installer.step10.body':'此处为安装过程的概要.',
    'installer.step10.nagiosRestartRequired':'<b>重要!</b> 为了报警和通知服务运行正常，需要重启Nagios服务.在点击完成按钮离开安装向导后，前往服务 -> Nagios来重启Nagios服务.',
    'installer.step10.hostsSummary':'集群包含{0} 主机',
    'installer.step10.servicesSummary':'已安装和启动成功的服务 on {0} new ',
    'installer.step10.warnings':' 警告',
    'installer.step10.clusterState.installing':'安装中 ',
    'installer.step10.clusterState.starting':'启动中 ',
    'installer.step10.taskStatus.failed':' 失败 ',
    'installer.step10.taskStatus.aborted':' 取消 ',
    'installer.step10.taskStatus.timedOut':' 超时 ',
    'installer.step10.installStatus.failed':'安装 master 服务失败',
    'installer.step10.installStatus.installed':'Master 服务已安装',
    'installer.step10.master.nameNode':'NameNode 安装在',
    'installer.step10.master.secondaryNameNode':'SecondaryNameNode安装在',
    'installer.step10.master.jobTracker':'JobTracker 安装在',
    'installer.step10.master.historyServer':'History Server 安装在',
    'installer.step10.master.resourceManager':'Resource Manager 安装在',
    'installer.step10.master.zooKeeper':'ZooKeeper 安装在',
    'installer.step10.master.hbase':'HBase Master 安装在',
    'installer.step10.master.hiveMetastore':'Hive Metastore 安装在',
    'installer.step10.master.oozie':'Oozie Server 安装在',
    'installer.step10.master.ganglia':'Ganglia Server 安装在 ',
    'installer.step10.master.nagios':'Nagios Server 安装在 ',
    'installer.step10.startStatus.failed':'启动服务失败',
    'installer.step10.startStatus.passed':'所有测试通过',
    'installer.step10.startStatus.started':'所有服务已启动',
    'installer.step10.installTime.seconds':'安装和启动在 {0} 秒内完成',
    'installer.step10.installTime.minutes':' {0} 分  {1} 秒安装和启动完成',
    'installer.step11.header':'先决条件',
    'installer.step12.header':'重新配置',
    'installer.step13.header':'检查',
    'installer.step13.body':'请检查所做更改',
    'installer.step13.targetHost':'目标主机:',
    'installer.step13.sourceHost':'源主机:',
    'installer.step13.changes':'更改配置:',
    'installer.step13.component':'组件名:',
    'installer.step13.oldValue':'旧值',
    'installer.step13.newValue':'新值',
    'installer.step14.task0':'{0} 停止',
    'installer.step14.task1':'{0} 创建',
    'installer.step14.task2':'{0} 创建配置',
    'installer.step14.task3':'{0} 应用配置',
    'installer.step14.task4':'{0} put 在维修模式',
    'installer.step14.task5':'{0} 安装',
    'installer.step14.task6':'{0} 启动',
    'installer.step14.task7':'{0} 移除',
    'installer.step14.status.success': '重新分配成功 {0}',
    'installer.step14.status.failed': '重新分配失败 {0}',
    'installer.step14.status.info': '正在重新分配 {0}. \n在全部任务完成前请耐心等待.',
    'installer.step14.retry': '可以点击重试 或者 取消 按钮来重新执行失败的任务 或者 取消变更',
    'installer.step14.abortError': '取消变更失败.',

    'installer.stackUpgrade.header':'Stack 升级向导',
    'installer.stackUpgrade.step1.newVersion':'新版本',
    'installer.stackUpgrade.step1.installedVersion':'已安装版本',
    'installer.stackUpgrade.step1.installedStackVersion':'已安装的stack版本',
    'installer.stackUpgrade.step1.upgradeStackVersion':'升级stack版本',
    'installer.stackUpgrade.step1.description':'Stack升级向导将帮助你一步步完成集群升级到最近可用的stack版本.',

    'installer.stackUpgrade.step2.notice.header':'在继续升级前重要的是, 请执行完成如下所列.',
    'installer.stackUpgrade.step2.notice.first':'确保NameNode已备份.',
    'installer.stackUpgrade.step2.notice.second':'确保NameNode已备份.',
    'installer.stackUpgrade.step2.notice.third':'确保NameNode已备份.',
    'installer.stackUpgrade.step2.notice.complete':'一旦完成了如上所列, 点击Upgrade来开始集群中所有主机的升级进程',
    'installer.stackUpgrade.step2.advancedOption':'高级选项',
    'installer.stackUpgrade.step2.localRepository':'使用本地存储库',
    'installer.stackUpgrade.step2.popup.body':'因为master的一些组件当前没有运行，所以我们无法进行下去. 在继续前，请确保所有的服务都在运行状态.',
    'installer.stackUpgrade.step3.ProceedWithWarning':'带警告信息的运行',
    'installer.stackUpgrade.step3.status.success':'成功将集群升级到了 {0}',
    'installer.stackUpgrade.step3.status.info':"正在升级集群. \n执行集群升级时请耐心等待.",
    'installer.stackUpgrade.step3.status.warning':"集群升级到了 {0} 带有一些警告信息.\n你可以开始使用集群，但是那些升级失败的组件将不起作用."+
    "可以点击重试按钮重新升级失败的组件. 你也可以继续使用，同时到主机详情页面重新升级单独的组件.",
    'installer.stackUpgrade.step3.status.failed':"升级主机失败. 点击每台主机查看可能的运行错误.\n 修复问题后, 点击重试按钮",
    'installer.stackUpgrade.step3.host.nothingToUpgrade':'等待 (没有需要升级的)',
    'installer.stackUpgrade.step3.service.upgraded':'服务已升级',
    'installer.stackUpgrade.step3.service.upgrading':'服务升级正在进行',
    'installer.stackUpgrade.step3.service.pending':'服务升级等待中',
    'installer.stackUpgrade.step3.service.failedUpgrade':'服务升级失败',
    'installer.stackUpgrade.step3.service.stopped':'所有服务已关闭',
    'installer.stackUpgrade.step3.service.stopping':'所有服务正在关闭',
    'installer.stackUpgrade.step3.service.stopFail':'所有服务关闭失败',
    'installer.stackUpgrade.step3.service.stopPending':'所有服务停止等待',
    'installer.stackUpgrade.step3.retry.upgrade':'重试升级',
    'installer.stackUpgrade.step3.retry.services':'重试关闭服务',
    'installer.stackUpgrade.step3.upgrade.header':'升级所有服务',
    'installer.stackUpgrade.step3.stop.header':'关闭所有服务',
    'form.create':'创建',
    'form.save':'保存',
    'form.cancel':'取消',
    'form.password':'密码',
    'form.passwordRetype':'重新输入密码',
    'form.saveSuccess':'保存成功.',
    'form.saveError':'抱歉，有错误.',
    'form.item.placeholders.typePassword':'输入密码',

    'form.validator.invalidIp':'请输入有效的IP地址',
    'form.validator.configKey':'不合法的密钥. 仅仅允许alphanumerics, hyphens, underscores, and periods.',

    'admin.advanced.title':'高级',
    'admin.advanced.caution':'这一部分仅面向高级用户.<br/>谨慎从事.',
    'admin.advanced.button.uninstallIncludingData':'卸载集群并删除所有数据.',
    'admin.advanced.button.uninstallKeepData':'卸载集群，但是保留数据.',

    'admin.advanced.popup.header':'卸载集群',

    /*'admin.advanced.popup.text':'Uninstall Cluster',*/

    'admin.audit.grid.date':"日期/时间",
    'admin.audit.grid.category':"类别",
    'admin.audit.grid.operationName':"操作",
    'admin.audit.grid.performedBy':"执行者",
    'admin.audit.grid.service':"类别",

    'admin.authentication.form.method.database':'使用Ambari数据库来认证用户',
    'admin.authentication.form.method.ldap':'使用LDAP/Active目录来认证',
    'admin.authentication.form.primaryServer':'Primary 服务器',
    'admin.authentication.form.secondaryServer':'Secondary 服务器',
    'admin.authentication.form.useSsl':'使用SSL',
    'admin.authentication.form.bind.anonymously':"匿名绑定",
    'admin.authentication.form.bind.useCrenedtials':"使用 Credentials 来绑定",
    'admin.authentication.form.bindUserDN':'绑定 User DN',
    'admin.authentication.form.searchBaseDN':'搜索 Base DN',
    'admin.authentication.form.usernameAttribute':'用户名属性',

    'admin.authentication.form.userDN':'用户DN',
    'admin.authentication.form.password':'密码',
    'admin.authentication.form.configurationTest':'配置测试',
    'admin.authentication.form.testConfiguration':'测试配置',

    'admin.authentication.form.test.success':'配置通过了测试',
    'admin.authentication.form.test.fail':'配置未通过测试',

    'admin.security.title':'Kerberos 安全功能未开启.',
    'admin.security.enabled': 'Kerberos 安全功能已经可用',
    'admin.security.disabled': 'Kerberos 安全功能已经关闭',
    'admin.security.button.enable':'开启安全功能',
    'admin.security.button.disable':'关闭安全功能',
    'admin.security.enable.popup.body': '我们会通过安全向导帮助你增加安全功能',
    'admin.security.enable.popup.header': '增加安全功能',
    'admin.security.disable.popup.header': '移除安全功能',
    'admin.security.disable.popup.body': '集群将关闭Kerberos安全功能',
    'admin.security.disable.popup.body.warning' : '提示: 执行前, 需要手动移除所有TaskTracker主机上mapred-site.xml文件mapred.local.dir配置项里列出的所有地址目录;否则,关闭安全功能后MapReduce将不能正常运行.',
    'admin.addSecurity.header': '开启安全功能向导',
    'admin.security.step1.header': '开始',
    'admin.security.step2.header': '配置服务',
    'admin.security.step3.header': '创建准则和Keytabs',
    'admin.security.step4.header': '保存并应用配置',
    'admin.security.step1.body.header': '重要提示: 在配置大数据平台来管理你的集群之前, ' +
      '你必须在你的集群上执行以下步骤. 对于每台主机和每个hadoop服务准则，确定记录了keytab文件的位置.' +
      ' 使用向导时需要该信息.',
    'admin.security.step1.body.instruction1': '安装、配置并且启动Kerberos KDC',
    'admin.security.step1.body.instruction2': '在集群中每台主机安装并配置Kerberos客户端',
    'admin.security.step1.body.instruction3': '为hadoop服务和主机创建Kerberos准则',
    'admin.security.step1.body.instruction4': '为每个安全准则生成keytabs，并放置在合适的主机上',
    'admin.security.step2.body.header': '配置Kerberos安全功能属性',
    'admin.security.step3.notice': '你需要在显示的主机上创建以下准则和keytabs.<br />'+
    '你可以下载该列表作为一个CSV文件。并且用它创建一个脚本来生成准则和keytabs. ' +
    '一旦准则和keytabs被创建, 点击 <i>应用</i> 继续. 如果你要修改配置, 点击<i>上一步</i>.',
    'admin.security.step3.table.principal': '准则',
    'admin.security.step3.table.keytab': 'Keytab',
    'admin.security.step3.downloadCSV': '下载CSV',
    'admin.security.step4.body.header': '应用kerberos安全功能到集群',
    'admin.security.step4.body.success.header' : '基于Kerberos的安全功能已经在你的集群上启用. Please wait while services are started in secure mode.',
    'admin.security.step4.body.failure.header' : '在你的集群上打开基于Kerberos的安全功能失败. 你的集群将继续运行在非安全模式下.',
    'admin.security.apply.configuration.error' : '集群的安全配置应用失败. 请按照"配置服务"步骤的指引进行，并确保所有的服务配置参数取值都恰当合法.',
    'admin.security.disable.body.header' : '集群正在关闭kerberos安全功能',
    'admin.security.disable.body.success.header': '基于Kerberos的安全功能已经在你的集群上关闭. 服务正在非安全模式下启动，请等待.',
    'admin.security.disable.body.failure.header': '在你的集群上关闭基于Kerberos的安全功能失败. 你的集群将继续运行在安全模式下.',
    'admin.addSecurity.apply.stage1': '1. 检查KDC',
    'admin.addSecurity.apply.stage2': '1. 停止服务',
    'admin.addSecurity.apply.stage3': '2. 保存配置',
    'admin.addSecurity.apply.stage4': '3. 启动服务',
    'admin.addSecurity.apply.stage5': '5. 冒烟测试',
    'admin.addSecurity.user.smokeUser': '冒烟测试用户',
    'admin.addSecurity.user.hdfsUser': 'HDFS用户',
    'admin.addSecurity.user.hbaseUser': 'HBase用户',
    'admin.addSecurity.hdfs.user.httpUser': 'HDFS SPNEGO用户',
    'admin.addSecurity.webhcat.user.httpUser': 'WebHCat SPNEGO用户',
    'admin.addSecurity.oozie.user.httpUser': 'Oozie SPNEGO用户',
    'admin.addSecurity.enable.onClose': '正在执行在你的集群中启用安全功能的进程. ' +
      '确定要中止吗? 如果中止, ' +
      '再次启用安全功能时你可能需要从安全向导首页重新开始运行.',
    'admin.addSecurity.enable.after.stage2.onClose': '服务正在按照设定的Kerberos配置进行启动.'+
      '建议你耐心等待，直到所有服务都启动完成以确保服务都启动成功.',
    'admin.addSecurity.disable.onClose': '正在执行在你的集群中关闭安全功能的进程. ' +
      '确定要中止吗?',
    'admin.removeSecurity.header': '关闭安全功能',
    'admin.security.applying.config.header': '应用配置',
    'admin.security.applying.config.body':'配置正在应用生效过程中，不能中止安全向导',
    'admin.security.status.error' : 'Error in retrieving cluster security status from Ambari server/Ambari服务器检索集群安全状态错误',
    'admin.users.ldapAuthUsed':'LDAP Authentication is being used to authenticate users/LDAP身份验证用于验证用户的身份',
    'admin.users.delete.yourself.message':'You can\'t delete yourself/你不能删除自己',
    'admin.users.delete.yourself.header':'删除警告',

    'admin.users.delete.header':'删除 {0}',

    'admin.users.addButton':'添加本地用户',
    'admin.users.editButton': '编辑本地用户',
    'admin.users.delete':'删除',
    'admin.users.edit':'编辑',
    'admin.users.privileges':'Admin/管理员',
    'admin.users.type':'类型',
    'admin.users.action':'Action',
    'admin.users.password':'密码',
    'admin.users.passwordRetype':'重新输入新密码',
    'admin.users.username':'用户名',
    'admin.users.createSuccess': '用户创建成功',
    'admin.users.createError': '用户创建失败.',
    'admin.users.createError.passwordValidation': '密码不一致',
    'admin.users.createError.userNameExists': '用户名已存在',
    'admin.users.editError.requiredField': '必填项',

    'admin.confirmUninstall':'Confirm Uninstall/确认卸载',
    'admin.cluster.stackVersion':'集群软件包版本',
    'admin.cluster.upgradeAvailable':'Upgrade available/可升级',
    'admin.cluster.upgradeUnavailable':'Upgrade unavailable/无法升级',

    'admin.misc.header': '服务用户和群组',
    'admin.misc.nothingToShow': '没有可显示的用户账号',

    'services.service.start':'开始',
    'services.service.stop':'停止',
    'services.service.summary.version':'版本',
    'services.service.summary.viewHost':'查看主机',
    'services.service.summary.viewHosts':'查看主机',
    'services.service.summary.DataNodesLive':'DataNodes 存活',
    'services.service.summary.TrackersLive':'Trackers 存活',
    'services.service.summary.RegionServersLIVE':'RegionServers 存活',
    'services.service.summary.GangliaMonitorsLIVE':'Ganglia监听器 存活',
    'services.service.summary.nameNode':'NameNode 用户界面',
    'services.service.summary.nameNodeUptime':'NameNode 正常运行时间',
    'services.service.summary.nameNodeHeap':'NameNode 堆',
    'services.service.summary.pendingUpgradeStatus':'升级状态',
    'services.service.summary.pendingUpgradeStatus.pending':'等待升级',
    'services.service.summary.pendingUpgradeStatus.notPending':'升级完成',
    'services.service.summary.safeModeStatus':'安全模式状态',
    'services.service.summary.safeModeStatus.inSafeMode':'在安全模式',
    'services.service.summary.safeModeStatus.notInSafeMode':'不在安全模式',
    'services.service.summary.dataNodes':'DataNodes',
    'services.service.summary.diskCapacity':'HDFS Disk 容量',
    'services.service.summary.blocksTotal':'块 (总量)',
    'services.service.summary.blockErrors':'块错误',
    'services.service.summary.totalFiles':'全部文件 + 目录',
    'services.service.summary.jobTracker':'JobTracker',
    'services.service.summary.jobTrackerWebUI':'JobTracker用户界面',
    'services.service.summary.jobTrackerUptime':'JobTracker正常运行时间',
    'services.service.summary.trackersLiveTotal':'Trackers',
    'services.service.summary.trackersBlacklistGraylist':'Trackers',
    'services.service.summary.jobTrackerHeap':'JobTracker 堆',
    'services.service.summary.totalSlotsCapacity':'全部Slots 容量',
    'services.service.summary.totalJobs':'全部Jobs',
    'services.service.summary.currentSlotUtiliMaps':'Map Slots',
    'services.service.summary.currentSlotUtiliReduces':'Reduce Slots',
    'services.service.summary.tasksMaps':'Tasks: Maps',
    'services.service.summary.tasksReduces':'Tasks: Reduces',
    'services.service.summary.hbaseMaster':'HBase Master用户界面',
    'services.service.summary.regionServerCount':'RegionServer Count/区域服务器数量',
    'services.service.summary.regionInTransition':'Region In Transition',
    'services.service.summary.masterStarted':'Master 已启动',
    'services.service.summary.masterActivated':'Master 已激活',
    'services.service.summary.averageLoad':'平均负载',
    'services.service.summary.masterHeap':'Master 堆',
    'services.service.summary.moreStats':'more stats here/更多统计',
    'services.service.summary.clientCount': '{0} Client Hosts/客户端主机',
    'services.service.actions.run.rebalancer':'Run Rebalancer/执行重新平衡',
    'services.service.actions.run.compaction':'Run Compaction/进行压缩',
    'services.service.actions.run.smoke':'运行冒烟测试',
    'services.service.actions.reassign.master':'Reassign/重新分配 {0}',
    'services.service.actions.reassign.master.hive':'Reassign HiveServer2, WebHCat Server, MySQL Server/重新分配HiveServer2，WebHCat服务器，MySQL服务器',
    'services.service.actions.maintenance':'维护',
    'services.service.summary.unknown':'未知',
    'services.service.summary.notRunning':'没有运行',
    'services.service.summary.notAvailable':'n/a',
    'services.service.summary.diskInfoBar.used':'已使用',

    'services.service.info.metrics.flume.channelFillPercent':'Channel Fill Percentage/通道填充率',
    'services.service.info.metrics.flume.channelSize':'通道大小',
    'services.service.info.metrics.flume.sinkDrainSuccess':'Sink Event Drain Count/接收器漏记数量',
    'services.service.info.metrics.flume.sourceAccepted':'Source Event Accepted Count/源事件接受数量',
    'services.service.info.metrics.flume.sinkConnectionFailed':'Sink Connection Failed Count/接收器连接失败数量',
    'services.service.info.metrics.flume.gc':'Garbage Collection Time/垃圾收集时间',
    'services.service.info.metrics.flume.cpu.user':'CPU (User)',
    'services.service.info.metrics.flume.jvmThreadsRunnable':'JVM 可运行线程',
    'services.service.info.metrics.flume.jvmHeapUsed':'JVM 已使用堆内存',
    'services.service.info.metrics.flume.channelName':'Channel/通道 {0}',
    'services.service.info.metrics.flume.sinkName':'Sink/接收器 {0}',
    'services.service.info.metrics.flume.sourceName':'Source/源 {0}',
    'services.service.info.metrics.flume.hostName':'主机: {0}',

    'services.service.info.metrics.hbase.clusterRequests':'集群请求',
    'services.service.info.metrics.hbase.clusterRequests.displayNames.requestCount':'请求数',
    'services.service.info.metrics.hbase.hlogSplitSize':'HLog 切分大小',
    'services.service.info.metrics.hbase.hlogSplitSize.displayNames.splitSize':'切分大小',
    'services.service.info.metrics.hbase.hlogSplitTime':'HLog 切分时间',
    'services.service.info.metrics.hbase.hlogSplitTime.displayNames.splitTime':'切分时间',
    'services.service.info.metrics.hbase.regionServerQueueSize':'域服务器队列长度',
    'services.service.info.metrics.hbase.regionServerQueueSize.displayNames.compactionQueueSize':'Compaction 队列长度',
    'services.service.info.metrics.hbase.regionServerQueueSize.displayNames.flushQueueSize':'Flush 队列长度',
    'services.service.info.metrics.hbase.regionServerRegions':'域服务器域个数',
    'services.service.info.metrics.hbase.regionServerRegions.displayNames.regions':'域',
    'services.service.info.metrics.hbase.regionServerRequests':'累计请求',
    'services.service.info.metrics.hbase.regionServerRequests.displayNames.writeRequests':'写请求',
    'services.service.info.metrics.hbase.regionServerRequests.displayNames.readRequests':'读请求',

    'services.service.info.metrics.hdfs.blockStatus':'块状态',
    'services.service.info.metrics.hdfs.blockStatus.displayNames.pendingReplicationBlocks':'待复制块',
    'services.service.info.metrics.hdfs.blockStatus.displayNames.underReplicatedBlocks':'已复制块',
    'services.service.info.metrics.hdfs.fileOperations':'文件操作',
    'services.service.info.metrics.hdfs.fileOperations.displayNames.fileInformationOperations':'文件信息操作',
    'services.service.info.metrics.hdfs.fileOperations.displayNames.deleteFileOperations':'删除文件操作',
    'services.service.info.metrics.hdfs.fileOperations.displayNames.createFileOperations':'新建文件操作',
    'services.service.info.metrics.hdfs.gc':'垃圾回收',
    'services.service.info.metrics.hdfs.gc.displayNames.gcTimeMillis':'时间',
    'services.service.info.metrics.hdfs.io':'HDFS I/O',
    'services.service.info.metrics.hdfs.io.displayNames.bytesWritten':'已写字节',
    'services.service.info.metrics.hdfs.io.displayNames.bytesRead':'已读字节',
    'services.service.info.metrics.hdfs.jvmHeap':'JVM 内存状态',
    'services.service.info.metrics.hdfs.jvmHeap.displayNames.memHeapCommittedM':'预留的堆内存',
    'services.service.info.metrics.hdfs.jvmHeap.displayNames.memNonHeapUsedM':'没有使用的堆内存',
    'services.service.info.metrics.hdfs.jvmHeap.displayNames.memHeapUsedM':'已使用堆内存',
    'services.service.info.metrics.hdfs.jvmHeap.displayNames.memNonHeapCommittedM':'没有预留的堆内存',
    'services.service.info.metrics.hdfs.jvmThreads':'JVM 线程状态',
    'services.service.info.metrics.hdfs.jvmThreads.displayNames.threadsBlocked':'已阻塞线程',
    'services.service.info.metrics.hdfs.jvmThreads.displayNames.threadsWaiting':'正在等待的线程',
    'services.service.info.metrics.hdfs.jvmThreads.displayNames.threadsTimedWaiting':'正在计时等待的线程',
    'services.service.info.metrics.hdfs.jvmThreads.displayNames.threadsRunnable':'可运行的线程',
    'services.service.info.metrics.hdfs.rpc':'RPC',
    'services.service.info.metrics.hdfs.rpc.displayNames.rpcQueueTimeAvgTime':'队列平均等待时间',
    'services.service.info.metrics.hdfs.spaceUtilization':'全部空间利用率',
    'services.service.info.metrics.hdfs.spaceUtilization.displayNames.capacityRemainingGB':'剩余容量',
    'services.service.info.metrics.hdfs.spaceUtilization.displayNames.capacityUsedGB':'已使用容量',
    'services.service.info.metrics.hdfs.spaceUtilization.displayNames.capacityTotalGB':'全部容量',

    'services.service.info.metrics.mapreduce.gc':'垃圾回收',
    'services.service.info.metrics.mapreduce.gc.displayNames.gcTimeMillis':'时间',
    'services.service.info.metrics.mapreduce.jobsStatus':'作业状态',
    'services.service.info.metrics.mapreduce.jobsStatus.displayNames.jobsRunning':'正在运行',
    'services.service.info.metrics.mapreduce.jobsStatus.displayNames.jobsFailed':'失败',
    'services.service.info.metrics.mapreduce.jobsStatus.displayNames.jobsCompleted':'成功',
    'services.service.info.metrics.mapreduce.jobsStatus.displayNames.jobsPreparing':'准备中',
    'services.service.info.metrics.mapreduce.jobsStatus.displayNames.jobsSubmitted':'已提交',
    'services.service.info.metrics.mapreduce.jvmHeap':'JVM 内存状态',
    'services.service.info.metrics.mapreduce.jvmHeap.displayNames.memHeapCommittedM':'预留的堆内存',
    'services.service.info.metrics.mapreduce.jvmHeap.displayNames.memNonHeapUsedM':'没有使用的堆内存',
    'services.service.info.metrics.mapreduce.jvmHeap.displayNames.memHeapUsedM':'已使用堆内存',
    'services.service.info.metrics.mapreduce.jvmHeap.displayNames.memNonHeapCommittedM':'没有预留的堆内存',
    'services.service.info.metrics.mapreduce.jvmThreads':'JVM 线程状态',
    'services.service.info.metrics.mapreduce.jvmThreads.displayNames.threadsBlocked':'已阻塞线程',
    'services.service.info.metrics.mapreduce.jvmThreads.displayNames.threadsWaiting':'正在等待的线程',
    'services.service.info.metrics.mapreduce.jvmThreads.displayNames.threadsTimedWaiting':'正在计时等待的线程',
    'services.service.info.metrics.mapreduce.jvmThreads.displayNames.threadsRunnable':'可运行的线程',
    'services.service.info.metrics.mapreduce.mapSlots':'Map Slots 利用',
    'services.service.info.metrics.mapreduce.mapSlots.displayNames.reservedMapSlots':'Map Slots 预留',
    'services.service.info.metrics.mapreduce.mapSlots.displayNames.occupiedMapSlots':'Map Slots 占用',
    'services.service.info.metrics.mapreduce.reduceSlots':'Reduce Slots 利用',
    'services.service.info.metrics.mapreduce.reduceSlots.displayNames.reservedReduceSlots':'Reduce Slots 预留',
    'services.service.info.metrics.mapreduce.reduceSlots.displayNames.occupiedReduceSlots':'Reduce Slots 占用',
    'services.service.info.metrics.mapreduce.rpc':'RPC',
    'services.service.info.metrics.mapreduce.rpc.displayNames.RpcQueueTimeAvgTime':'队列平均等待时间',
    'services.service.info.metrics.mapreduce.tasksRunningWaiting':'Tasks (运行中/等待中)',
    'services.service.info.metrics.mapreduce.tasksRunningWaiting.displayNames.runningMaps':'运行中的 Map Tasks',
    'services.service.info.metrics.mapreduce.tasksRunningWaiting.displayNames.runningReduces':'运行中的 Reduce Tasks',
    'services.service.info.metrics.mapreduce.tasksRunningWaiting.displayNames.waitingMaps':'等待中的 Map Tasks',
    'services.service.info.metrics.mapreduce.tasksRunningWaiting.displayNames.waitingReduces':'等待中的 Reduce Tasks',

    'services.service.info.menu.summary':'概要',
    'services.service.info.menu.configs':'配置',
    'services.service.info.summary.hostsRunningMonitor':'{0}/{1}',
    'services.service.info.summary.serversHostCount':'{0} 更多',
    'services.service.info.summary.nagiosWebUI':'Nagios 用户界面',
    'services.service.info.summary.nagios.noAlerts':'无报警',
    'services.service.info.summary.nagios.alerts':'Nagios 服务查看报警信息',

    'services.service.config.saved':'保存配置变更',
    'services.service.config.notSaved':'无法保存配置变更',
    'services.service.config.restartService.TooltipMessage':'<b>Restart Service</b><br>Stale configuration used by {0} 组件 on {1} 主机:{2}',
    'services.service.config.saved.message':'保存服务配置变更成功。',
    'services.service.config.msgServiceStop':'无法保存配置变更。请先停止服务。停止所有组件后才能保存配置变更',
    'services.service.config.msgHDFSMapRServiceStop':'配置变更目前不能保存. 请先关闭HDFS和MapReduce. 待HDFS和MapReduce的所有组件都关闭后，可以保存配置变更.',
    'services.service.config.failCreateConfig' : '创建服务配置失败',
    'services.service.config.failSaveConfig':'保存服务配置失败',
    'services.service.config.failSaveConfigHostExceptions':'Failure in saving service configuration host exceptions',
    'services.service.config.addPropertyWindow.errorMessage':'这是必须的',
    'services.service.config.addPropertyWindow.error.derivedKey':'此属性已定义',
    'services.service.config.stopService.runningHostComponents':'{0} 组件 on {1} 主机仍在运行中',
    'services.service.config.stopService.unknownHostComponents':'主机{1}上运行的组件{0}处于未识别状态。这些组件可能正在运行，重启后变更才能生效',
    'services.service.config.confirmDirectoryChange':'You are about to make changes to service directories that are core to {0}. Before you proceed, be absolutely certain of the implications and that you have taken necessary manual steps, if any, for the changes. Are you sure you want to proceed?',

    'services.add.header':'增加服务向导',
    'services.reassign.header':'重新指定Master',
    'services.service.add':'增加服务',
    'services.service.startAll':'启动所有',
    'services.service.stopAll':'停止所有',

    /** services page constants **/

    'service.hbase.activeMaster': '活动Master',
    'service.hbase.passiveMasters': 'and {0} Standby Masters',

    'services.hive.client': 'Hive Client',
    'services.hive.clients': 'Hive Clients',

    'services.oozie.client': 'Oozie Client',
    'services.oozie.clients': 'Oozie Clients',
    'services.oozie.webUi': 'Oozie 用户界面',

    'services.hue.webUi': 'Hue 用户界面',

    'services.ganglia.webUi': 'Ganglia 用户界面',
    'services.ganglia.monitors': 'Ganglia 监听器',

    'services.zookeeper.prefix': '{0} of',
    'services.zookeeper.title': '{0} ZooKeepers',
    'services.zookeeper.postfix': 'running',
    'services.zookeeper.clients': 'ZooKeeper Clients',
    'services.zookeeper.client': 'ZooKeeper Client',

    'services.mapreduce2.history.running': '历史服务器正在运行',
    'services.mapreduce2.history.stopped': '历史服务器已停止',

    'services.mapReduce.config.addQueue':'增加队列',
    'services.mapReduce.config.editQueue':'编辑队列',
    'services.mapReduce.config.capacitySchedulerXml':'Custom capacity-scheduler.xml',
    'services.mapReduce.config.queue.header':'队列',
    'services.mapReduce.config.queue.name':'队列名',
    'services.mapReduce.config.queue.groups':'Groups',
    'services.mapReduce.config.queue.capacity':'容量',
    'services.mapReduce.config.queue.maxCapacity':'最大容量',
    'services.mapReduce.config.queue.minUserLimit':'最小用户数',
    'services.mapReduce.config.queue.userLimitFactor':'用户限制因素',
    'services.mapReduce.config.queue.supportsPriority': '支持优先级',
    'services.mapReduce.config.queue.adminUsers':'管理员用户',
    'services.mapReduce.config.queue.adminGroups':'管理员组',
    'services.mapReduce.config.queue.maxActiveTasks':'最大活动初始化任务',
    'services.mapReduce.config.queue.maxActiveTasksPerUser':'单个用户最大活动初始化任务',
    'services.mapReduce.config.queue.initAcceptJobsFactor':'初始接受任务因素',
    'services.mapReduce.extraConfig.queue.name':'队列名',
    'services.mapReduce.description.queue.name':'队列名称',
    'services.mapReduce.description.queue.submit.user':"允许提交job到队列的用户列别，以逗号分隔。" +
      "如果值为'*'，表示所有用户都可以提交job",
    'services.mapReduce.description.queue.admin.user':"允许对非当前用户拥有的job进行删除或修改job优先级的用户列表，以逗号隔开。如果值为'*'，则表示所有用户都有该操作权限",
    'services.mapReduce.description.queue.submit.group':'允许向列队提交job的组名称列表，以逗号分隔。',
    'services.mapReduce.description.queue.admin.group':"允许对非该组创建的job进行删除和修改优先级的组名称列表，以逗号分隔。",

    'services.hbase.master.error':'没有活动的HBase Masters',

    'hosts.host.add':'增加新主机',
    'hosts.table.noHosts':'没有可显示的主机',
    
    'hosts.selectHostsDialog.title': '选择异常主机',
    'hosts.selectHostsDialog.message': 'Select hosts where the exception has to be applied',
    'hosts.selectHostsDialog.filter.placeHolder': 'Filter...',
    'hosts.selectHostsDialog.selectedHostsLink': '{0} out of {1} hosts selected',

    'hosts.host.metrics.cpu':'CPU 使用率',
    'hosts.host.metrics.cpu.displayNames.cpu_wio':'CPU I/O 空闲',
    'hosts.host.metrics.cpu.displayNames.cpu_idle':'CPU 空闲',
    'hosts.host.metrics.cpu.displayNames.cpu_nice':'CPU 正常',
    'hosts.host.metrics.cpu.displayNames.cpu_aidle':'CPU Boot 空闲',
    'hosts.host.metrics.cpu.displayNames.cpu_system':'CPU 系统',
    'hosts.host.metrics.cpu.displayNames.cpu_user':'CPU 用户',
    'hosts.host.metrics.disk':'硬盘使用率',
    'hosts.host.metrics.disk.displayNames.disk_total':'全部',
    'hosts.host.metrics.disk.displayNames.disk_free':'可用',
    'hosts.host.metrics.load':'负载',
    'hosts.host.metrics.load.displayNames.load_fifteen':'15分钟负载',
    'hosts.host.metrics.load.displayNames.load_one':'1分钟负载',
    'hosts.host.metrics.load.displayNames.load_five':'5分钟负载',
    'hosts.host.metrics.memory':'内存使用率',
    'hosts.host.metrics.memory.displayNames.mem_shared':'共享区',
    'hosts.host.metrics.memory.displayNames.swap_free':'互换区',
    'hosts.host.metrics.memory.displayNames.mem_buffers':'缓冲区',
    'hosts.host.metrics.memory.displayNames.mem_free':'释放',
    'hosts.host.metrics.memory.displayNames.mem_cached':'缓存',
    'hosts.host.metrics.network':'网络使用率',
    'hosts.host.metrics.network.displayNames.pkts_out':'发出包数',
    'hosts.host.metrics.network.displayNames.bytes_in':'收到字节数',
    'hosts.host.metrics.network.displayNames.bytes_out':'发出字节数',
    'hosts.host.metrics.network.displayNames.pkts_in':'收到包数',
    'hosts.host.metrics.processes':'进程',
    'hosts.host.metrics.processes.displayNames.proc_total':'总进程',
    'hosts.host.metrics.processes.displayNames.proc_run':'运行进程',

    'hosts.host.summary.header':'概要',
    'hosts.host.summary.hostname':'主机名',
    'hosts.host.summary.agentHeartbeat':'代理 <br/> 心跳',
    'hosts.host.summary.hostMetrics':'主机指标',

    'hosts.host.details.deleteHost':'删除主机',

    'host.host.componentFilter.master':'Master 组件',
    'host.host.componentFilter.slave':'Slave 组件',
    'host.host.componentFilter.client':'Client 组件',
    'hosts.host.addComponent.note':'注意：在安装完该组件后，进入服务-〉Nagios，重启Nagios服务。只有这样警报和通知才能正常工作。',
    'hosts.host.addComponent.securityNote':'You are running your cluster in secure mode. You must set up the keytab for {0} on {1} before you proceed. Otherwise, the component will not be able to start properly.',
    'hosts.host.datanode.decommission':'停用的DataNode',
    'hosts.host.datanode.recommission':'使用的DataNode',


    'hosts.host.alert.noAlerts':'无报警',
    'hosts.host.alert.noAlerts.message':'这台主机没有报警.',
    'hosts.host.healthStatus.heartBeatNotReceived':'The server has not received a heartbeat from this host for more than 3 minutes.',
    'hosts.host.healthStatus.mastersDown':"The following master components are down:\n",
    'hosts.host.healthStatus.slavesDown':"The following slave components are down:\n",
    'hosts.host.healthStatus.allUp':'All components are up',
    'hosts.host.healthStatusCategory.green': "健康",
    'hosts.host.healthStatusCategory.red': "Master 崩溃",
    'hosts.host.healthStatusCategory.orange': "Slave 崩溃",
    'hosts.host.healthStatusCategory.yellow': "无心跳",
    'hosts.host.alerts.label': '报警',
    'hosts.host.alerts.st':'&nbsp;!&nbsp;',
    'hosts.decommission.popup.body':'你确定嘛？',
    'hosts.decommission.popup.header':'确认',
    'hosts.delete.popup.body':'你确定吗？',
    'hosts.delete.popup.header':'确认',
    'hosts.cant.do.popup.header':'Operation not allowed/操作被禁止',
    'hosts.cant.do.popup.masterList.body':'你无法删除该主机，因为它承载以下主服务 {0}.',
    'hosts.cant.do.popup.workingList.body':'你无法删除该主机，因为下面的从属服务没有完全停止或退役 {0}.',
    'hosts.add.header':'添加主机向导',
    'hosts.assignRack':'分配机架',

    'charts.horizon.chart.showText':'显示',
    'charts.horizon.chart.hideText':'隐藏',
    'charts.horizon.chart.attributes.cpu':'CPU',
    'charts.horizon.chart.attributes.memory':'Memory',
    'charts.horizon.chart.attributes.network':'Network',
    'charts.horizon.chart.attributes.io':'I/O',

    'charts.heatmap.selectMetric':'选择度量指标...',

    'charts.heatmap.category.host':'主机',
    'charts.heatmap.item.host.memory':'Memory 使用',
    'charts.heatmap.item.host.disk':'磁盘空间使用',
    'charts.heatmap.item.host.process':'正在处理的全部进程',
    'charts.heatmap.category.hdfs':'HDFS',
    'charts.heatmap.category.mapreduce': 'MapReduce',
    'charts.heatmap.category.hbase': 'HBase',
    'charts.heatmap.unknown': '未知',
    'charts.heatmap.label.notApplicable' :'不适用',
    'charts.heatmap.label.invalidData' :'无效数据',
    'charts.heatmap.metrics.bytesRead' :'HDFS Bytes Read',
    'charts.heatmap.metrics.bytesWritten' :'HDFS Bytes Written',
    'charts.heatmap.metrics.DFSGarbageCollection' :'HDFS 垃圾回收时间',
    'charts.heatmap.metrics.DFSMemHeapUsed' :'HDFS JVM 已使用堆内存',
    'charts.heatmap.metrics.diskSpaceUsed' :'主机磁盘空间使用率 %',
    'charts.heatmap.metrics.MapReduceGCTime' :'MapReduce 垃圾回收时间',
    'charts.heatmap.metrics.mapsRunning' :'MapReduce Maps 运行中',
    'charts.heatmap.metrics.MRMemHeapUsed' :'MapReduce JVM 已使用堆内存',
    'charts.heatmap.metrics.reducesRunning' :'MapReduce Reduces 运行中',
    'charts.heatmap.metrics.memoryUsed' :'主机内存已使用%',
    'charts.heatmap.metrics.processRun' :'正在处理的全部进程',
    'charts.heatmap.metrics.cpuWaitIO':'Host CPU Wait I/O %',
    'charts.heatmap.metrics.HbaseRegionServerReadCount': 'HBase 读请求数',
    'charts.heatmap.metrics.HbaseRegionServerWriteCount': 'HBase 写请求数',
    'charts.heatmap.metrics.HbaseRegionServerCompactionQueueSize': 'HBase Compaction 队列长度',
    'charts.heatmap.metrics.HbaseRegionServerRegions': 'HBase Regions',
    'charts.heatmap.metrics.HbaseRegionServerMemStoreSize': 'HBase Memstore 大小',
    'metric.notFound':'no items found',
    'metric.default':'combined',
    'metric.cpu':'cpu',
    'metric.memory':'disk 使用',
    'metric.network':'network',
    'metric.io':'io',
    'metric.more':'more',
    'metric.more.cpu':'CPU',
    'metric.more.disk':'Disk',
    'metric.more.load':'Load',
    'metric.more.memory':'Memory',
    'metric.more.network':'Network',
    'metric.more.process':'Process',

    'dashboard.clusterMetrics':'集群的度量指标',

    'dashboard.clusterMetrics.cpu':'CPU使用率',
    'dashboard.clusterMetrics.cpu.displayNames.idle':'空闲',
    'dashboard.clusterMetrics.load':'集群负载',
    'dashboard.clusterMetrics.memory':'Memory使用率',
    'dashboard.clusterMetrics.network':'Network使用率',

    'dashboard.widgets': '集群的状态和度量指标',
    'dashboard.button.switch': '切换到经典仪表盘',
    'dashboard.button.switchShort': '切换',
    'dashboard.button.reset': '重置到默认的widgets ',
    'dashboard.button.gangliaLink': '查看Ganglia度量指标',

    'dashboard.widgets.NameNodeHeap': 'NameNode堆',
    'dashboard.widgets.NameNodeCpu': 'NameNode CPU WIO',
    'dashboard.widgets.NameNodeCapacity': 'HDFS容量',
    'dashboard.widgets.JobTrackerHeap': 'JobTracker堆',
    'dashboard.widgets.JobTrackerCpu': 'JobTracker CPU WIO',
    'dashboard.widgets.JobTrackerCapacity': 'JobTracker 容量',
    'dashboard.widgets.DataNodeUp': 'DataNodes存活',
    'dashboard.widgets.TaskTrackerUp': 'TaskTrackers存活',
    'dashboard.widgets.NameNodeRpc': 'NameNode RPC',
    'dashboard.widgets.JobTrackerRpc': 'JobTracker RPC',
    'dashboard.widgets.MapReduceSlots': 'MapReduce Slots',
    'dashboard.widgets.mapSlots': 'Map Slots',
    'dashboard.widgets.reduceSlots': 'Reduce Slots',
    'dashboard.widgets.nothing': 'No Widget to Add',
    'dashboard.widgets.NameNodeUptime': 'NameNode 正常运行时间',
    'dashboard.widgets.JobTrackerUptime': 'JobTracker 正常运行时间',
    'dashboard.widgets.HDFSLinks': 'HDFS 链接',
    'dashboard.widgets.MapReduceLinks': 'MapReduce 链接',
    'dashboard.widgets.HBaseLinks': 'HBase 链接',
    'dashboard.widgets.HBaseAverageLoad': 'HBase 平均负载',
    'dashboard.widgets.HBaseMasterHeap': 'HBase Master 堆',
    'dashboard.widgets.HBaseRegionsInTransition': 'Region In Transition',
    'dashboard.widgets.HBaseMasterUptime': 'HBase Master 正常运行时间',

    'dashboard.services':'服务',
    'dashboard.services.hosts':'主机',
    'dashboard.services.uptime':'{0}',
    'dashboard.services.hdfs.summary':'{0} of {1} nodes 存活, {2}% capacity 已使用',
    'dashboard.services.hdfs.nanmenode':'NameNode',
    'dashboard.services.hdfs.snanmenode':'Secondary NameNode',
    'dashboard.services.hdfs.capacity':'HDFS Disk 容量',
    'dashboard.services.hdfs.capacityUsed':'{0} / {1} ({2}% 已使用)',
    'dashboard.services.hdfs.totalFilesAndDirs':'总的文件数+目录数',
    'dashboard.services.hdfs.datanodes':'DataNodes',
    'dashboard.services.hdfs.datanodecounts':'DataNodes 状态',
    'dashboard.services.hdfs.version':'版本',
    'dashboard.services.hdfs.nameNodeWebUI':'NameNode 用户界面',
    'dashboard.services.hdfs.nodes.live':'存活',
    'dashboard.services.hdfs.nodes.dead':'失效',
    'dashboard.services.hdfs.nodes.decom':'正在解除',
    'dashboard.services.hdfs.nodes.uptime':'NameNode 正常运行时间',
    'dashboard.services.hdfs.nodes.heap':'NameNode 堆',
    'dashboard.services.hdfs.nodes.heapUsed':'{0} / {1} ({2}% 已使用)',
    'dashboard.services.hdfs.chart.label':'容量 (已使用/总容量)',
    'dashboard.services.hdfs.blockErrors':'{0} 损坏 / {1} 丢失 / {2} 正在复制',

    'dashboard.services.mapreduce.summary':'{0} of {1} trackers 存活, {2} jobs 正在运行, {3} jobs 等待',
    'dashboard.services.mapreduce.taskTrackers':'TaskTrackers',
    'dashboard.services.mapreduce.taskTrackerCounts':'TaskTrackers 状态',
    'dashboard.services.mapreduce.trackers':'Trackers',
    'dashboard.services.mapreduce.nodes.blacklist':'黑名单',
    'dashboard.services.mapreduce.nodes.graylist':'灰名单',
    'dashboard.services.mapreduce.slotCapacity':' Slots 总容量',
    'dashboard.services.mapreduce.trackersSummary':'{0}/{1}',
    'dashboard.services.mapreduce.jobs':'全部Jobs',
    'dashboard.services.mapreduce.jobsSummary':'{0} 提交 / {1} 完成',
    'dashboard.services.mapreduce.mapSlots':'Map Slots/Map槽',
    'dashboard.services.mapreduce.mapSlotsSummary':'{0} 已占用 / {1} 预留',
    'dashboard.services.mapreduce.reduceSlots':'Reduce Slots/Reduce槽',
    'dashboard.services.mapreduce.tasks.maps':'Tasks: Maps',
    'dashboard.services.mapreduce.tasks.reduces':'Tasks: Reduces',
    'dashboard.services.mapreduce.reduceSlotsSummary':'{0} 已占用 / {1} 预留',
    'dashboard.services.mapreduce.tasksSummary':'{0} 运行 / {1} 等待',
    'dashboard.services.mapreduce.slotCapacitySummary':'{0} maps / {1} reduces / {2} 每个节点平均数',
    'dashboard.services.mapreduce.jobTrackerHeap':'JobTracker 堆',
    'dashboard.services.mapreduce.jobTrackerHeapSummary':'{0} of {1} ({2}% 已使用)',
    'dashboard.services.mapreduce.jobTrackerUptime':'Job Trackers 正常运行时间',
    'dashboard.services.mapreduce.chart.label':'Jobs 正在运行',

    'dashboard.services.flume.summary.single':'{0} Flume Agent',
    'dashboard.services.flume.summary.multiple':'{0} Flume Agents',
    'dashboard.services.flume.agentsLabel': 'Flume Agents',
    'dashboard.services.flume.channels': 'Channels/通道',
    'dashboard.services.flume.sources': '资源',
    'dashboard.services.flume.sinks': 'Sinks/接受器',
    
    
    'dashboard.services.hbase.summary':'{0} region servers with {1} average load',
    'dashboard.services.hbase.masterServer':'HBase Master',
    'dashboard.services.hbase.noMasterServer':'没有活动的master',
    'dashboard.services.hbase.masterServerHeap':'Master 堆',
    'dashboard.services.hbase.masterServerHeap.summary':'{0} / {1} ({2}% used)',
    'dashboard.services.hbase.masterServerUptime':'Master Server 正常运行时间',
    'dashboard.services.hbase.averageLoad':'平均负载',
    'dashboard.services.hbase.averageLoadPerServer':'每个域服务器包括{0}个域',
    'dashboard.services.hbase.regionServers':'域服务器',
    'dashboard.services.hbase.regionServersSummary':'{0} 存活 / {1} 全部',
    'dashboard.services.hbase.chart.label':'请求数',
    'dashboard.services.hbase.version':'版本',
    'dashboard.services.hbase.masterWebUI':'Master 用户界面',
    'dashboard.services.hbase.regions.transition':'过渡区',
    'dashboard.services.hbase.masterStarted':'Master 已启动',
    'dashboard.services.hbase.masterActivated':'Master 已激活',

    'dashboard.services.hive.clients':'Hive 客户端',
    'dashboard.services.hive.client':'Hive 客户端',

    'dashboard.services.oozie.clients':'Oozie 客户端',
    'dashboard.services.oozie.client':'Oozie 客户端',

    'dashboard.services.configs.popup.stopService.header':'停止服务',
    'dashboard.services.configs.popup.stopService.body' : '重新配置需要关闭服务',
    'dashboard.services.configs.popup.restartService.header' : '重启服务',
    'dashboard.services.configs.popup.restartService.body' : '重新配置需要重启服务',
    'timeRange.presets.1hour':'1小时',
    'timeRange.presets.12hour':'12小时',
    'timeRange.presets.1day':'1天',
    'timeRange.presets.1week':'1周',
    'timeRange.presets.1month':'1月',
    'timeRange.presets.1year':'1年',

    'apps.item.dag.job': 'Job',
    'apps.item.dag.jobId': 'Job Id',
    'apps.item.dag.status': '状态',
    'apps.item.dag.maps': 'Maps',
    'apps.item.dag.reduces': 'Reduces',
    'apps.item.dag.input': '输入',
    'apps.item.dag.output': '输出',
    'apps.item.dag.duration': '期限',

    'apps.table.column.appId':'App ID',
    'apps.table.column.runDate': '运行时间',
    'apps.avgTable.avg': '平均值',
    'apps.avgTable.min': '最大',
    'apps.avgTable.max': '最小',
    'apps.avgTable.jobs': 'Jobs',
    'apps.avgTable.input': '输入',
    'apps.avgTable.output': '输出',
    'apps.avgTable.duration': '持续时间',
    'apps.avgTable.oldest': '最久',
    'apps.avgTable.mostRecent': '最近',
    'apps.filters.all': '全部',
    'apps.filters.filtered': '过滤',
    'apps.filters.clearFilters': '清晰过滤器',
    'apps.filters.paginationInfo': '{0} - {1} of {2}',
    'apps.filters.customRunDate':'执行日期自定义过滤器',
    'apps.filters.nothingToShow': '没有可显示的作业',
    'apps.dagCharts.popup':'Job Charts',
    'apps.dagCharts.popup.job': 'Job',
    'apps.dagCharts.popup.dag':'Job时间线',
    'apps.dagCharts.popup.tasks':'Job Tasks',
    'apps.isRunning.popup.title':'正在运行',
    'apps.isRunning.popup.content':'作业正在运行',

    'mirroring.dataset.AllDataSets':'所有数据集',
    'mirroring.dataset.createNewDataset':'创建新的数据集',
    'mirroring.dataset.newDataset':'新建数据集',
    'mirroring.dataset.editDataset':'编辑数据集',
    'mirroring.dataset.selectTargetClusters':'选择目标集群...',
    'mirroring.dataset.name':'名称',
    'mirroring.dataset.save': '保存 & 运行',
    'mirroring.dataset.sourceDir':'源集群目录',
    'mirroring.dataset.target':'目标集群',
    'mirroring.dataset.source':'源',
    'mirroring.dataset.avgData':'平均数据',
    'mirroring.dataset.dateCreated':'创建日期',
    'mirroring.dataset.targetDir':'目标集群目录',
    'mirroring.dataset.schedule':'时间表',
    'mirroring.dataset.schedule.to':'至',
    'mirroring.dataset.schedule.repeatEvery':'每次重复',
    'mirroring.dataset.addTargetCluster':'添加目标群',
    'mirroring.dataset.toggle.active':'激活',
    'mirroring.dataset.toggle.suspended':'中止',

    'mirroring.targetcluster.nameNodeWebUrl':'NameNode 用户界面',
    'mirroring.targetcluster.nameNodeRpcUrl':'NameNode RPC',
    'mirroring.targetcluster.oozieServerUrl':'Oozie服务',
    'mirroring.targetcluster.addCluster':'增加集群',
    'mirroring.targetcluster.testConnection':'测试连接',
    'mirroring.targetcluster.enterClusterName':'目标集群的名字',

    'mirroring.table.noDatasets':'没有可显示的数据集',
    'mirroring.table.datasetSource':'数据集源',
    'mirroring.table.lastSuccess':'最后一次成功',
    'mirroring.table.lastFail':'最后一次失败',
    'mirroring.table.lastDuration':'最后期限',
    'mirroring.table.avgData':'平均数据',
    'mirroring.table.noJobs':'没有可显示的作业',
    'mirroring.table.jobId':'Job ID',
    'mirroring.table.start':'开始',
    'mirroring.table.end':'结束',
    'mirroring.table.duration':'期限',
    'mirroring.table.data':'数据',

    'mirroring.sidebar.header.history': '历史',
    'mirroring.sidebar.header.clusters': '目标集群',
    'mirroring.sidebar.popup.clusters.header': '集群管理',
    'mirroring.sidebar.popup.clusters.body': '这里有一些内容',

    'mirroring.required.error': '此字段是必须的',
    'mirroring.dateOrder.error': '结束时间要晚于开始时间',
    'mirroring.required.invalidNumberError' : '输入有效数字',


    'menu.item.dashboard':'仪表盘',
    'menu.item.heatmaps':'热点图',
    'menu.item.services':'服务',
    'menu.item.hosts':'主机',
    'menu.item.mirroring':'镜像',
    'menu.item.jobs':'作业',
    'menu.item.admin':'管理员',

    'common.combobox.placeholder': '过滤...',
    'common.combobox.dropdown.1': '无效的配置项',
    'common.combobox.dropdown.2': '修改的配置项',
    'common.combobox.dropdown.3': '配置生效需要重启',

    'quick.links.error.label': '主机名没有定义',

    'contact.administrator': '更多信息，请联系系统管理员!'

  };
  
});
window.require.register("models", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  // load all models here

  require('models/form'); // should be the 1st
  require('models/authentication');
  require('models/cluster');
  require('models/cluster_states');
  require('models/hosts');
  require('models/quick_links');
  require('models/service');
  require('models/service_config');
  require('models/service_audit');
  require('models/service/hdfs');
  require('models/service/mapreduce');
  require('models/service/hbase');
  require('models/service/flume');
  require('models/alert');
  require('models/user');
  require('models/host');
  require('models/rack');
  require('models/job');
  require('models/run');
  require('models/app');
  require('models/background_operation');
  require('models/host_component');
  require('models/target_cluster');
  require('models/dataset');
  require('models/dataset_job');
  require('classes/run_class');
  require('classes/job_class');
  require('classes/job_class');
  
});
window.require.register("models/alert", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.AlertStatus = {
    negative: 'corrupt',
    positive: 'ok'
  }

  /**
   * Defines structure for App.Alert class. Keys mentioned here are for JSON data
   * which comes back from NAGIOS server.
   */
  App.Alert = DS.Model.extend({
    alertId: DS.attr('string'),
    primaryKey: 'alertId',
    title: DS.attr('string'),//service_description in ajax response
    serviceType: DS.attr('string'),
    date: DS.attr('date'),
    status: DS.attr('string'),//current_state in ajax response
    message: DS.attr('string'),//plugin_output in ajax response
    hostName: DS.attr('string'),
    currentAttempt: DS.attr('string'),
    lastHardStateChange: DS.attr('number'),
    lastHardState: DS.attr('number'),
    lastTimeOk: DS.attr('number'),
    lastTimeWarning: DS.attr('number'),
    lastTimeUnknown: DS.attr('number'),
    lastTimeCritical: DS.attr('number'),
    isFlapping: DS.attr('number'),
    lastCheck: DS.attr('number'),

    /**
     * Used to show correct icon in UI
     */
    isOk: function () {
      return this.get('status') == "0";
    }.property('status'),

    /**
     * Used to show correct icon in UI
     */
    isWarning: function () {
      return this.get('status') == "1";
    }.property('status'),

    /**
     * Used to show correct icon in UI
     */
    isCritical: function() {
      return this.get('status') == '2';
    }.property('status'),

    /**
     * Used to show only required alerts at the service level
     */
    ignoredForServices: function() {
      return ['TaskTracker process down', 'RegionServer process down', 'DataNode process down', 'DataNode storage full', 'ZooKeeper Server process down'].contains(this.get('title'));
    }.property('title'),

    /**
     * Used to show only required alerts at the host level
     */
    ignoredForHosts: function() {
      return this.get('title').indexOf('Percent') != -1;
    }.property('title'),

    /**
     * Provides how long ago this alert happened.
     * 
     * @type {String}
     */
    timeSinceAlert: function () {
      var d = this.get('date');
      if (d) {
        var prefix = this.t('services.alerts.OK.timePrefix');
        switch (this.get('status')) {
          case "1":
            prefix = this.t('services.alerts.WARN.timePrefix');
            break;
          case "2":
            prefix = this.t('services.alerts.CRIT.timePrefix');
            break;
          case "3":
            prefix = this.t('services.alerts.UNKNOWN.timePrefix');
            break;
        }
        var prevSuffix = $.timeago.settings.strings.suffixAgo;
        $.timeago.settings.strings.suffixAgo = '';
        var since = prefix + $.timeago(this.makeTimeAtleastMinuteAgo(d));
        $.timeago.settings.strings.suffixAgo = prevSuffix;
        return since;
      }
      return "";
    }.property('date', 'status'),
    
    makeTimeAtleastMinuteAgo: function(d){
      var diff = new Date().getTime() - d.getTime();
      if (diff < 60000) {
        diff = 60000 - diff;
        var newD = new Date(d.getTime() - diff );
        //console.log("Making time more than 1 minute. New time=",newD,", Old time=",d);
        return newD;
      }
      return d;
    },

    /**
     * Provides more details about when this alert happened.
     * 
     * @type {String}
     */
    timeSinceAlertDetails: function () {
      var details = "";
      var date = this.get('date');
      if (date) {
        var dateString = date.toDateString();
        dateString = dateString.substr(dateString.indexOf(" ") + 1);
        dateString = "Occurred on " + dateString + ", " + date.toLocaleTimeString();
        details += dateString;
      }
      var lastCheck = this.get('lastCheck');
      if (lastCheck) {
        lastCheck = new Date(lastCheck * 1000);
        details = details + "<br>Last checked " + $.timeago(lastCheck);
      }
      return details;
    }.property('lastCheck', 'date'),

    /**
     * Used to show appropriate service label in UI
     */
    serviceName: function () {
      if (this.get('serviceType')) {
        var type = this.get('serviceType').toLowerCase();
        switch (type) {
          case 'mapreduce':
            return 'MapReduce';
          case 'hdfs':
            return 'HDFS';
          case 'hbase':
            return "HBase";
          case 'zookeeper':
            return "Zookeeper";
          case 'oozie':
            return "Oozie";
          case 'hive':
            return 'Hive';
        }
      }
      return null;
    }.property('serviceType'),

    /**
     * Used to provide appropriate service link in UI
     */
    serviceLink: function () {
      if (this.get('serviceType')) {
        var type = this.get('serviceType').toLowerCase();
        switch (type) {
          case 'mapreduce':
            return '#/main/services/MAPREDUCE/summary';
          case 'hdfs':
            return '#/main/services/HDFS/summary';
          case 'hbase':
            return '#/main/services/HBASE/summary';
          case 'zookeeper':
            return '#/main/services/ZOOKEEPER/summary';
          case 'oozie':
            return '#/main/services/OOZIE/summary';
          case 'hive':
            return '#/main/services/HIVE/summary';
        }
      }
      return null;
    }.property('serviceType')

  });

  App.Alert.FIXTURES = [
  ];
  
});
window.require.register("models/app", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.App = DS.Model.extend({
    appName: DS.attr('string'),
    type: DS.attr('string'),
    numJobsTotal: DS.attr('number'),
    userName: DS.attr('string'),
    executionTime: DS.attr('string'),
    runs: DS.hasMany('App.Run')
  });

  App.App.FIXTURES = [
    {
      id: 1,
      app_name: 'pigs.sh',
      type: 'Hive',
      num_jobs_total: 5,
      user_name: 'root',
      execution_time: '1347629541543',
      runs: [1, 2, 3]
    },
    {
      id: 2,
      app_name: 'pigsm.sh',
      type: 'pig',
      num_jobs_total: 3,
      user_name: 'user1',
      execution_time: '1347656741515',
      runs: [6, 4, 5]
    },
    {
      id: 3,
      app_name: 'pigsmo.sh',
      type: 'pig',
      num_jobs_total: 4,
      user_name: 'user3',
      execution_time: '1347629587687',
      runs: [7, 8, 9, 10, 11]
    },
    {
      id: 4,
      app_name: 'pigsmok.sh',
      type: 'MapReduce',
      num_jobs_total: 0,
      user_name: 'root',
      execution_time: '134762957834',
      runs: []
    }
  ]
  
});
window.require.register("models/authentication", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  App.Authentication = DS.Model.extend({
    method:DS.attr('boolean'), // use LDAP
    primaryServer:DS.attr('string'),
    secondaryServer:DS.attr('string'),
    useSsl:DS.attr('boolean'),
    bindMethod:DS.attr('boolean'), // use credentials
    bindUser:DS.attr('string'),
    password:DS.attr('string'),
    passwordRetype:DS.attr('string'),
    searchBaseDn:DS.attr('string'),
    usernameAttribute:DS.attr('string')
  });

  App.Authentication.FIXTURES = [
    {
      id:1,
      method:0,
      primary_server:"",
      secondary_server:"",
      use_ssl:false,
      bind_method:0,
      bind_user:"",
      password:"",
      password_retype:"",
      search_base_dn:"",
      username_attribute:""
    }
  ]

  App.AuthenticationForm = App.Form.extend({
    testResult:false,
    fieldsOptions:[
      { name:"method", displayName:"", isRequired:false, displayType:"select",
        values:[
          {value:0, label:Em.I18n.t("admin.authentication.form.method.database")},
          {value:1, label:Em.I18n.t("admin.authentication.form.method.ldap")}
        ]
      },
      { name:"primaryServer", displayName:Em.I18n.t("admin.authentication.form.primaryServer"), /*validator:'ipaddress',*/
        isRequired:function () {
          return this.get('form.field.method.value');
        }.property('form.field.method.value')
      },
      { name:"secondaryServer", displayName:Em.I18n.t("admin.authentication.form.secondaryServer"), /*validator:'ipaddress',*/ isRequired:false},
      { name:"useSsl", displayName:Em.I18n.t("admin.authentication.form.useSsl"), displayType:"checkbox", isRequired:false },
      { name:"bindMethod", displayName:'', displayType:"select", isRequired:false,
        values:[
          {value:0, label:Em.I18n.t("admin.authentication.form.bind.anonymously")},
          {value:1, label:Em.I18n.t("admin.authentication.form.bind.useCrenedtials")}
        ]},
      { name:"bindUser", displayName:Em.I18n.t('admin.authentication.form.bindUserDN'), isRequired:function () {
        return this.get('form.field.bindMethod.value');
      }.property('form.field.bindMethod.value')},
      { name:"password", displayName:Em.I18n.t('form.password'), displayType:"password",
        isRequired:function () {
          return this.get('form.field.bindMethod.value');
        }.property('form.field.bindMethod.value') },
      { name:"passwordRetype", displayName:Em.I18n.t('form.passwordRetype'), displayType:"password",
        validator: "passwordRetype",
        isRequired:function () {
          return this.get('form.field.bindMethod.value');
        }.property('form.field.bindMethod.value')},
      { name:"searchBaseDn", displayName:Em.I18n.t('admin.authentication.form.searchBaseDN'),
        isRequired:function () {
          return this.get('form.field.method.value');
        }.property('form.field.method.value')
      },
      { name:"usernameAttribute", displayName:Em.I18n.t('admin.authentication.form.usernameAttribute'),
        isRequired:function () {
          return this.get('form.field.method.value');
        }.property('form.field.method.value')
      },

      { name:"userDN", displayName:Em.I18n.t('admin.authentication.form.userDN') },
      { name:"userPassword", displayName:Em.I18n.t('admin.authentication.form.password'), displayType:'password'}
    ],
    fields:[],
    testConfiguration:function () {
      console.warn('Configuration test is randomized');
      this.set('testResult', parseInt(Math.random() * 2));
      return true;
    },
    testConfigurationMessage:function () {
      return this.get('testResult') ? Em.I18n.t('admin.authentication.form.test.success') : Em.I18n.t('admin.authentication.form.test.fail');
    }.property('testResult'),
    testConfigurationClass:function () {
      return this.get('testResult') ? "text-success" : "text-error";
    }.property('testConfigurationMessage')
  })
  ;
});
window.require.register("models/background_operation", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.BackgroundOperation = DS.Model.extend({
    operationName:DS.attr('string'),
    events: DS.hasMany('App.BackgroundOperationEvent'),
    cluster:DS.belongsTo('App.Cluster'),
    host:DS.belongsTo('App.Host'),
    operationLog: DS.attr('string')
  });

  App.BackgroundOperation.FIXTURES = [
    {
      id:1,
      operation_name:'Decommissioning host1',
      operation_log:'Decommissioning log',
      events:[1,2],
      cluster_id:1,
      host_id:1
    },
    {
      id:2,
      operation_name:'Starting DataNode on host4',
      operation_log:'Starting DataNode log',
      events:[3],
      cluster_id:1,
      host_id:1
    }
  ];

  App.BackgroundOperationEvent = DS.Model.extend({
    eventName:DS.attr('string'),
    operation:DS.belongsTo('App.BackgroundOperation'),
    eventDate: DS.attr('string')
  });

  App.BackgroundOperationEvent.FIXTURES = [
    {
      id:1,
      event_name:'Some intermediate operation',
      operation_id:1,
      event_date:'4 min ago'
    },
    {
      id:2,
      event_name:'Operation started',
      operation_id:1,
      event_date:'5 min ago'
    },
    {
      id:3,
      event_name:'Operation started',
      operation_id:2,
      event_date:'5 min ago'
    }
  ];

  
});
window.require.register("models/cluster", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.Cluster = DS.Model.extend({
    clusterName: DS.attr('string'),
    stackName: DS.attr('string'),
    version: DS.attr('string'),
    hosts: DS.hasMany('App.Host'),
    racks: DS.hasMany('App.Rack'),
    maxHostsPerRack: DS.attr('number'),
    /**
     * Array containing desired configs. New array
     * should be set by instances of class.
     */
    desiredConfigs: null
  });

  App.Cluster.FIXTURES = [/*
    {
      id: 1,
      cluster_name: 'cluster1',
      stack_name: 'HDP',
      hosts: [1, 2, 3, 4],
      racks: [1, 2, 3, 4, 5, 6],
      max_hosts_per_rack: 10
    }*/
  ];
});
window.require.register("models/cluster_states", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var App = require('app');

  App.clusterStatus = Ember.Object.create({
    clusterName: '',
    validStates: ['CLUSTER_NOT_CREATED_1', 'CLUSTER_DEPLOY_PREP_2', 'CLUSTER_INSTALLING_3', 'SERVICE_STARTING_3', 'CLUSTER_INSTALLED_4',  'CLUSTER_STARTED_5',
      'ADD_HOSTS_DEPLOY_PREP_2', 'ADD_HOSTS_INSTALLING_3', 'ADD_HOSTS_INSTALLED_4', 'ADD_HOSTS_COMPLETED_5',
      'ADD_SERVICES_DEPLOY_PREP_2', 'ADD_SERVICES_INSTALLING_3', 'ADD_SERVICES_INSTALLED_4', 'ADD_SERVICES_COMPLETED_5',
      'STOPPING_SERVICES', 'STACK_UPGRADING', 'STACK_UPGRADE_FAILED', 'STACK_UPGRADED', 'STACK_UPGRADE_COMPLETED', 'ADD_SECURITY_STEP_1',
      'ADD_SECURITY_STEP_2', 'ADD_SECURITY_STEP_3', 'ADD_SECURITY_STEP_4', 'DISABLE_SECURITY', 'SECURITY_COMPLETED'],
    clusterState: 'CLUSTER_NOT_CREATED_1',
    wizardControllerName: null,
    localdb: null,
    key: 'CLUSTER_CURRENT_STATUS',
    /**
     * get cluster data from server and update cluster status
     * @param isAsync: set this to true if the call is to be made asynchronously.  if unspecified, false is assumed
     * @return promise object for the get call
     */
    updateFromServer: function(isAsync) {
      // if isAsync is undefined, set it to false
      isAsync = isAsync || false;
      var url = App.apiPrefix + '/persist/' + this.get('key');
      return jQuery.ajax(
        {
          url: url,
          context: this,
          async: isAsync,
          success: function (response) {
            if (response) {
              var newValue = jQuery.parseJSON(response);
              if (newValue.clusterState) {
                this.set('clusterState', newValue.clusterState);
              }
              if (newValue.clusterName) {
                this.set('clusterName', newValue.clusterName);
              }
              if (newValue.wizardControllerName) {
                this.set('wizardControllerName', newValue.wizardControllerName);
              }
              if (newValue.localdb) {
                this.set('localdb', newValue.localdb);
              }
            } else {
              // default status already set
            }
          },
          error: function (xhr) {
            if (xhr.status == 404) {
              // default status already set
              console.log('Persist API did NOT find the key CLUSTER_CURRENT_STATUS');
              return;
            }
            App.ModalPopup.show({
              header: Em.I18n.t('common.error'),
              secondary: false,
              onPrimary: function () {
                this.hide();
              },
              bodyClass: Ember.View.extend({
                template: Ember.Handlebars.compile('<p>{{t common.update.error}}</p>')
              })
            });
          },
          statusCode: require('data/statusCodes')
        }
      );
    },
    /**
     * update cluster status and post it on server
     * @param newValue
     * @return {*}
     */
    setClusterStatus: function(newValue){
      if(App.testMode) return false;
      if (newValue) {
        //setter
        if (newValue.clusterState) {
          this.set('clusterState', newValue.clusterState);
        }
        if (newValue.clusterName) {
          this.set('clusterName', newValue.clusterName);
        }
        if (newValue.wizardControllerName) {
          this.set('wizardControllerName', newValue.wizardControllerName);
        }
        if (newValue.localdb) {
          this.set('localdb', newValue.localdb);
        }

        var url = App.apiPrefix + '/persist/';
        var keyValuePair = {};
        var val = {
          clusterName: this.get('clusterName'),
          clusterState: this.get('clusterState'),
          wizardControllerName: this.get('wizardControllerName'),
          localdb: this.get('localdb')
        };
        keyValuePair[this.get('key')] = JSON.stringify(val);


        jQuery.ajax({
          async: false,
          context: this,
          type: "POST",
          url: url,
          data: JSON.stringify(keyValuePair),
          beforeSend: function () {
            console.log('BeforeSend: persistKeyValues', keyValuePair);
          },
          error: function () {
            console.log("ERROR");
            if(newValue.errorCallBack) {
              newValue.errorCallBack();
            } else {
              this.clusterStatusErrorCallBack();
            }
          },
          statusCode: require('data/statusCodes')
        });
        return newValue;
      }
    },

    clusterStatusErrorCallBack: function() {
      App.ModalPopup.show({
        header: Em.I18n.t('common.error'),
        secondary: false,
        onPrimary: function () {
          this.hide();
        },
        bodyClass: Ember.View.extend({
          template: Ember.Handlebars.compile('<p>{{t common.persist.error}}</p>')
        })
      });
    },

    /**
     * general info about cluster
     */
    value: function () {
        return {
          clusterName: this.get('clusterName'),
          clusterState: this.get('clusterState'),
          wizardControllerName: this.get('wizardControllerName'),
          localdb: this.get('localdb')
        };
    }.property('clusterName', 'clusterState', 'localdb', 'wizardControllerName')

  });
  
});
window.require.register("models/dataset", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.Dataset = DS.Model.extend({
    id: DS.attr('string'),
    name: DS.attr('string'),
    status: DS.attr('string'),
    sourceClusterName: DS.attr('string'),
    targetCluster: DS.belongsTo('App.TargetCluster'),
    sourceDir: DS.attr('string'),
    targetDir: DS.attr('string'),
    schedule: DS.belongsTo('App.Dataset.Schedule'),
    lastSucceededDate: DS.attr('number'),
    lastFailedDate: DS.attr('number'),
    lastDuration: DS.attr('number'),
    avgData: DS.attr('string'),
    createdDate: DS.attr('string'),
    datasetJobs: DS.hasMany('App.DataSetJob')
  });


  App.Dataset.Schedule = DS.Model.extend({
    id: DS.attr('string'),
    startDate: DS.attr('string'),
    endDate: DS.attr('string'),
    startTime: DS.attr('string'),
    endTime: DS.attr('string'),
    timezone: DS.attr('string'),
    frequency: DS.attr('string'),
    dataset: DS.belongsTo('App.Dataset')
  });

  App.Dataset.FIXTURES = [/*
   {
   id: 1,
   cluster_name: 'cluster1',
   stack_name: 'HDP',
   hosts: [1, 2, 3, 4],
   racks: [1, 2, 3, 4, 5, 6],
   max_hosts_per_rack: 10
   }*/
  ];

  App.Dataset.Schedule.FIXTURES = [/*
   {
   id: 1,
   cluster_name: 'cluster1',
   stack_name: 'HDP',
   hosts: [1, 2, 3, 4],
   racks: [1, 2, 3, 4, 5, 6],
   max_hosts_per_rack: 10
   }*/
  ];
});
window.require.register("models/dataset_job", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');
  var date = require('utils/date');

  App.DataSetJob = DS.Model.extend({
    dataset: DS.belongsTo('App.Dataset'),
    status: DS.attr('string'),
    startDate: DS.attr('number'),
    endDate: DS.attr('number'),
    duration: DS.attr('number'),
    startDateFormatted: function () {
      return date.dateFormatShort(this.get('startDate'));
    }.property('startDate')
    //data : DS.attr('string')
  });


  App.DataSetJob.FIXTURES = [/*
   {
   id: 1,
   cluster_name: 'cluster1',
   stack_name: 'HDP',
   hosts: [1, 2, 3, 4],
   racks: [1, 2, 3, 4, 5, 6],
   max_hosts_per_rack: 10
   }*/
  ];
});
window.require.register("models/form", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var App = require('app');

  // move this to models cause some errors
  App.Form = Em.View.extend({
    /**
     * generating fields from fieldsOptions
     */
    classNames:["form-horizontal"],
    attributeBindings: ['autocomplete'],
    autocomplete: 'off',
    i18nprefix:'form.',
    fields:[],
    field:{},
    messages:[],
    object:false,
    result:0, // save result var (-1 - error; 0 - init; 1 - success)
    templateName:require('templates/common/form'),
    tagName:'form',

    init:function () {
      var thisForm = this;
      if (!this.fields.length) {
        this.fieldsOptions.forEach(
          function (options) {
            var field = App.FormField.create(options);
            field.set('form', thisForm);
            thisForm.fields.push(field);
            thisForm.set("field." + field.get('name'), field);
          }
        );
      }
      this._super();
    },

    getField:function (name) {
      var field = false;
      $.each(this.fields, function () {
        if (this.get('name') == name) {
          return field = this;
        }
      });
      return field;
    },

    isValid:function () {
      var isValid = true;
      $.each(this.fields, function () {
        this.validate();
        if (!this.get('isValid')) {
          isValid = false;
          console.warn(this.get('name') + " IS INVALID : " + this.get('errorMessage'));
        }
      })

      return isValid;
    },

    updateValues:function () {
      var object = this.get('object');
      if (object instanceof Em.Object) {
        $.each(this.fields, function () {
          this.set('value', (this.get('displayType') == 'password') ? '' : object.get(this.get('name')));
        });
      } else {
        this.clearValues();
      }

    }.observes("object"),

    clearValues:function () {
      $.each(this.fields, function () {
        this.set('value', '');
      });
    },

    visibleFields:function () {
      var fields = this.get('fields');
      var visible = [];
      fields.forEach(function (field) {
        if (!field.get('isHiddenField')) {
          visible.push(field);
        }
      });
      return visible;
    }.property('fields'),

    resultText:function () {
      var text = "";
      switch (this.get('result')) {
        case -1:
          text = this.t("form.saveError");
          break;
        case 1:
          text = this.t("form.saveSuccess");
          break;
      }

      return text;
    }.property('result')
  });

  App.FormField = Em.Object.extend({ // try to realize this as view
    name:'',
    displayName:'',
  //  defaultValue:'', NOT REALIZED YET
    description:'',
    disabled:false,
    displayType:'string', // string, digits, number, directories, textarea, checkbox
    disableRequiredOnPresent:false,
    errorMessage:'',
    form:false,
    isRequired:true, // by default a config property is required
    unit:'',
    value:'',

    observeValue:function () {

      if (this.get('displayType') == 'hidden')
        console.warn(" FORM FIELD VALUE: ", this.get('value'));

    }.observes('value'),

    isValid:function () {
      return this.get('errorMessage') === '';
    }.property('errorMessage'),

    viewClass:function () {
      var options = {};
      var element = Em.TextField;
      switch (this.get('displayType')) {
        case 'checkbox':
          element = Em.Checkbox;
          options.checkedBinding = "value";
          break;
        case 'select':
          element = Em.Select;
          options.content = this.get('values');
          options.valueBinding = "value";
          options.optionValuePath = "content.value";
          options.optionLabelPath = "content.label";
          break;
        case 'password':
          options['type'] = 'password';
          break;
        case 'textarea':
          element = Em.TextArea;
          break;
        case 'hidden':
          options.type = "hidden";
          break;
      }

      return element.extend(options);
    }.property('displayType'),

    validate:function () {
      var value = this.get('value');
      var isError = false;
      this.set('errorMessage', '');

      if (this.get('isRequired') && (typeof value === 'string' && value.trim().length === 0)) {
        this.set('errorMessage', 'This is required');
        isError = true;
      }

      if (typeof value === 'string' && value.trim().length === 0) { // this is not to validate empty field.
        isError = true;
      }

      if (!isError) {
        if(this.get('validator') === 'passwordRetype'){
          var form = this.get('form');
          var passwordField = form.getField('password');
          if (passwordField.get('isValid')
            && (passwordField.get('value') != this.get('value'))
            && passwordField.get('value') && this.get('value')
            ) {
            this.set('errorMessage', "Passwords are different");
            isError = true;
          }
        }
      }
      if (!isError) {
        this.set('errorMessage', '');
      }
    },

    isHiddenField:function () {
      return this.get('displayType') == 'hidden';
    }.property('type')
  });
  
});
window.require.register("models/host", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');
  var misc = require('utils/misc');

  App.Host = DS.Model.extend({
    hostName: DS.attr('string'),
    publicHostName: DS.attr('string'),
    cluster: DS.belongsTo('App.Cluster'),
    hostComponents: DS.hasMany('App.HostComponent'),
    cpu: DS.attr('string'),
    memory: DS.attr('string'),
    diskTotal: DS.attr('number'),
    diskFree: DS.attr('number'),
    osArch: DS.attr('string'),
    ip: DS.attr('string'),
    rack: DS.attr('string'),
    healthStatus: DS.attr('string'),
    cpuUsage: DS.attr('number'),
    memoryUsage: DS.attr('number'),
    lastHeartBeatTime: DS.attr('number'),
    osType: DS.attr("string"),
    diskInfo: DS.attr('object'),
    loadOne:DS.attr('number'),
    loadFive:DS.attr('number'),
    loadFifteen:DS.attr('number'),

    criticalAlertsCount: function () {
      return App.router.get('clusterController.alerts').filterProperty('hostName', this.get('hostName')).filterProperty('isOk', false).filterProperty('ignoredForHosts', false).length;
    }.property('App.router.clusterController.alerts.length'),

    publicHostNameFormatted: function() {
      return this.get('publicHostName').length < 23 ? this.get('publicHostName') : this.get('publicHostName').substr(0, 20) + '...';
    }.property('publicHostName'),
    /**
     * API return diskTotal and diskFree. Need to save their different
     */
    diskUsed: function(){
      return this.get('diskTotal') - this.get('diskFree');
    }.property('diskFree', 'diskTotal'),
    /**
     * Format diskUsed value to float with 2 digits (also convert to GB)
     */
    diskUsedFormatted: function() {
      return Math.round(this.get('diskUsed') * Math.pow(10, 2)) / Math.pow(10, 2) + 'GB';
    }.property('diskUsed'),
    /**
     * Format diskTotal value to float with 2 digits (also convert to GB)
     */
    diskTotalFormatted: function() {
      return Math.round(this.get('diskTotal') * Math.pow(10, 2)) / Math.pow(10, 2) + 'GB';
    }.property('diskTotal'),
    /**
     * Percent value of used disk space
     */
    diskUsage: function() {
      return (this.get('diskUsed')) / this.get('diskTotal') * 100;
    }.property('diskUsed', 'diskTotal'),
    /**
     * Format diskUsage to float with 2 digits
     */
    diskUsageFormatted: function() {
      if (isNaN(this.get('diskUsage')) || this.get('diskUsage') < 0) {
        return 'Data Unavailable';
      }
      var s = Math.round(this.get('diskUsage') * Math.pow(10, 2)) / Math.pow(10, 2);
      if (isNaN(s)) {
        s = 0;
      }
      return s + '%';
    }.property('diskUsage'),

    diskInfoBar: function() {
      if (isNaN(this.get('diskUsage')) || this.get('diskUsage') < 0) {
        return this.get('diskUsageFormatted');
      }
      return this.get('diskUsedFormatted') + '/' + this.get('diskTotalFormatted') + ' (' + this.get('diskUsageFormatted')
        + ' ' + Em.I18n.t('services.service.summary.diskInfoBar.used') + ')';
    }.property('diskUsedFormatted', 'diskTotalFormatted'),
    /**
     * formatted bytes to appropriate value
     */
    memoryFormatted: function () {
      return misc.formatBandwidth(this.get('memory') * 1024);
    }.property('memory'),
    /**
     * Return true if the host has not sent heartbeat within the last 180 seconds
     */
    isNotHeartBeating : function() {
      return (App.testMode) ? false : ((new Date()).getTime() - this.get('lastHeartBeatTime')) > 180 * 1000;
    }.property('lastHeartBeatTime'),

    loadAvg: function() {
      if (this.get('loadOne') != null) return this.get('loadOne').toFixed(2);
      if (this.get('loadFive') != null) return this.get('loadFive').toFixed(2);
      if (this.get('loadFifteen') != null) return this.get('loadFifteen').toFixed(2);
    }.property('loadOne', 'loadFive', 'loadFifteen'),

    // Instead of making healthStatus a computed property that listens on hostComponents.@each.workStatus,
    // we are creating a separate observer _updateHealthStatus.  This is so that healthStatus is updated
    // only once after the run loop.  This is because Ember invokes the computed property every time
    // a property that it depends on changes.  For example, App.statusMapper's map function would invoke
    // the computed property too many times and freezes the UI without this hack.
    // See http://stackoverflow.com/questions/12467345/ember-js-collapsing-deferring-expensive-observers-or-computed-properties
    healthClass: '',

    _updateHealthClass: function(){
      Ember.run.once(this, 'updateHealthClass');
    }.observes('healthStatus', 'hostComponents.@each.workStatus'),

    updateHealthClass: function(){
      var healthStatus = this.get('healthStatus');
      /**
       * Do nothing until load
       */
      if (!this.get('isLoaded') || this.get('isSaving')) {
      } else {
        var status;
        var masterComponents = this.get('hostComponents').filterProperty('isMaster');
        var masterComponentsRunning = masterComponents.everyProperty('workStatus', App.HostComponentStatus.started);
        var slaveComponents = this.get('hostComponents').filterProperty('isSlave');
        var slaveComponentsRunning = slaveComponents.everyProperty('workStatus', App.HostComponentStatus.started);
        if (this.get('isNotHeartBeating') || healthStatus == 'UNKNOWN') {
          status = 'DEAD-YELLOW';
        } else if (masterComponentsRunning && slaveComponentsRunning) {
          status = 'LIVE';
        } else if (masterComponents.length > 0 && !masterComponentsRunning) {
          status = 'DEAD-RED';
        } else {
          status = 'DEAD-ORANGE';
        }
        if (status) {
          healthStatus = status;
        }
      }
      this.set('healthClass', 'health-status-' + healthStatus);
    },

    healthToolTip: function(){
      var hostComponents = this.get('hostComponents').filter(function(item){
        if(item.get('workStatus') !== App.HostComponentStatus.started){
          return true;
        }
      });
      var output = '';
      switch (this.get('healthClass')){
        case 'health-status-DEAD-RED':
          hostComponents = hostComponents.filterProperty('isMaster', true);
          output = Em.I18n.t('hosts.host.healthStatus.mastersDown');
          hostComponents.forEach(function(hc, index){
            output += (index == (hostComponents.length-1)) ? hc.get('displayName') : (hc.get('displayName')+", ");
          }, this);
          break;
        case 'health-status-DEAD-YELLOW':
          output = Em.I18n.t('hosts.host.healthStatus.heartBeatNotReceived');
          break;
        case 'health-status-DEAD-ORANGE':
          hostComponents = hostComponents.filterProperty('isSlave', true);
          output = Em.I18n.t('hosts.host.healthStatus.slavesDown');
          hostComponents.forEach(function(hc, index){
            output += (index == (hostComponents.length-1)) ? hc.get('displayName') : (hc.get('displayName')+", ");
          }, this);
          break;
        case 'health-status-LIVE':
          output = Em.I18n.t('hosts.host.healthStatus.allUp');
          break;
      }
      return output;
    }.property('hostComponents.@each.workStatus')
  });

  App.Host.FIXTURES = [];
  
});
window.require.register("models/host_component", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.HostComponent = DS.Model.extend({
    workStatus: DS.attr('string'),
    componentName: DS.attr('string'),
    haStatus: DS.attr('string'),
    host: DS.belongsTo('App.Host'),
    service: DS.belongsTo('App.Service'),
    actualConfigs: null,
    isClient:function () {
      if(['PIG', 'SQOOP', 'HCAT', 'MAPREDUCE2_CLIENT'].contains(this.get('componentName'))){
        return true;
      }

      return Boolean(this.get('componentName').match(/_client/gi));
    }.property('componentName'),
    isRunning: function(){
      return (this.get('workStatus') == 'STARTED' || this.get('workStatus') == 'STARTING');
    }.property('workStatus'),
    displayName: function () {
      return App.format.role(this.get('componentName'));
    }.property('componentName'),
    isMaster: function () {
      switch (this.get('componentName')) {
        case 'NAMENODE':
        case 'SECONDARY_NAMENODE':
        case 'SNAMENODE':
        case 'JOBTRACKER':
        case 'ZOOKEEPER_SERVER':
        case 'HIVE_SERVER':
        case 'HIVE_METASTORE':
        case 'MYSQL_SERVER':
        case 'HBASE_MASTER':
        case 'NAGIOS_SERVER':
        case 'GANGLIA_SERVER':
        case 'OOZIE_SERVER':
        case 'WEBHCAT_SERVER':
        case 'HUE_SERVER':
        case 'HISTORYSERVER':
        case 'FLUME_SERVER':
          return true;
        default:
          return false;
      }
    }.property('componentName'),
    isSlave: function(){
      switch (this.get('componentName')) {
        case 'DATANODE':
        case 'TASKTRACKER':
        case 'HBASE_REGIONSERVER':
        case 'GANGLIA_MONITOR':
          return true;
        default:
          return false;
      }
    }.property('componentName'),
    /**
     * A host-component is decommissioning when it is in HDFS service's list of
     * decomNodes.
     */
    isDecommissioning: function () {
      var decommissioning = false;
      var hostName = this.get('host.hostName');
      var componentName = this.get('componentName');
      var hdfsSvc = App.HDFSService.find().objectAt(0);
      if (componentName === 'DATANODE' && hdfsSvc) {
        var decomNodes = hdfsSvc.get('decommissionDataNodes');
        var decomNode = decomNodes != null ? decomNodes.findProperty("hostName", hostName) : null;
        decommissioning = decomNode != null;
      }
      return decommissioning;
    }.property('componentName', 'host.hostName', 'App.router.clusterController.isLoaded', 'App.router.updateController.isUpdated'),
    /**
     * User friendly host component status
     */
    componentTextStatus: function () {
      var value = this.get("workStatus");

      switch(value){
        case "INSTALLING":
          return '安装中...';
        case "INSTALL_FAILED":
          return '安装失败';
        case "INSTALLED":
          return '已停止';
        case "STARTED":
          return '已启动';
        case "STARTING":
          return '启动中...';
        case "STOPPING":
          return '停止中...';
        case "UNKNOWN":
          return '心跳丢失...';
        case "UPGRADE_FAILED":
          return '升级失败';
      }
      return 'Unknown';
    }.property('workStatus','isDecommissioning')
  });

  App.HostComponent.FIXTURES = [];

  App.HostComponentStatus = {
    started: "STARTED",
    starting: "STARTING",
    stopped: "INSTALLED",
    stopping: "STOPPING",
    install_failed: "INSTALL_FAILED",
    installing: "INSTALLING",
    upgrade_failed: "UPGRADE_FAILED",
    unknown: "UNKNOWN",

    getKeyName:function(value){
      switch(value){
        case this.started:
          return 'started';
        case this.starting:
          return 'starting';
        case this.stopped:
          return 'installed';
        case this.stopping:
          return 'stopping';
        case this.install_failed:
          return 'install_failed';
        case this.installing:
          return 'installing';
        case this.upgrade_failed:
          return 'upgrade_failed';
        case this.unknown:
          return 'unknown';
      }
      return 'none';
    }
  };

  
});
window.require.register("models/hosts", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.HostInfo = Ember.Object.extend({
    elementId: 'host',
    name: '',
    cpu: null,
    memory: null,
    message: 'Information',
    barColor: 'progress-info',
    isChecked: true,
    bootLog:null,
    bootStatus: 'PENDING',
    
    bootStatusForDisplay:function () {
      switch (this.get('bootStatus')) {
        case 'PENDING':
          return 'Preparing';
        case 'REGISTERED':
          return 'Success';
        case 'FAILED':
          return 'Failed';
        case 'RUNNING':
          return 'Installing';
        case 'DONE':
        case 'REGISTERING':
        default:
          return 'Registering';
      }
    }.property('bootStatus'),

    bootBarColor:function () {
      switch (this.get('bootStatus')) {
        case 'REGISTERED':
          return 'progress-success';
        case 'FAILED':
          return 'progress-danger';
        case 'PENDING':
        case 'RUNNING':
        case 'DONE':
        case 'REGISTERING':
        default:
          return 'progress-info';
      }
    }.property('bootStatus'),

    bootStatusColor:function () {
      switch (this.get('bootStatus')) {
        case 'REGISTERED':
          return 'text-success';
        case 'FAILED':
          return 'text-error';
        case 'PENDING':
        case 'RUNNING':
        case 'DONE':
        case 'REGISTERING':
        default:
          return 'text-info';
      }
    }.property('bootStatus'),

    isBootDone:function () {
      switch (this.get('bootStatus')) {
        case 'REGISTERED':
        case 'FAILED':
          return true;
        case 'PENDING':
        case 'RUNNING':
        case 'DONE':
        case 'REGISTERING':
        default:
          return false;
      }

    }.property('bootStatus')
  });
  
});
window.require.register("models/job", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');
  var date = require('utils/date');
  var misc = require('utils/misc');

  App.Job = DS.Model.extend({

    run: DS.belongsTo('App.Run'),

    jobName: DS.attr('string'),
    workflowEntityName: DS.attr('string'),
    userName: DS.attr('string'),
    confPath: DS.attr('string'),
    submitTime: DS.attr('number'),
    maps: DS.attr('number'),
    reduces: DS.attr('number'),
    status: DS.attr('string'),
    input: DS.attr('number'),
    output: DS.attr('number'),
    elapsedTime: DS.attr('number'),
    duration: function () {
      return date.timingFormat(parseInt(this.get('elapsedTime')));
    }.property('elapsedTime'),
    jobTimeLine: DS.attr('string'),
    jobTaskView: DS.attr('string'),
    /**
     *  Sum of input bandwidth for all jobs with appropriate measure
     */
    inputFormatted: function () {
      var input = this.get('input');
      return misc.formatBandwidth(input);
    }.property('input'),
    /**
     *  Sum of output bandwidth for all jobs with appropriate measure
     */
    outputFormatted: function () {
      var output = this.get('output');
      return misc.formatBandwidth(output);
    }.property('output')

  });

  App.Job.FIXTURES = [];
  
});
window.require.register("models/quick_links", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.QuickLinks = DS.Model.extend({
    label: DS.attr('string'),
    url: DS.attr('string'),
    service_id: DS.attr('string')
  });

  App.QuickLinks.FIXTURES = [
    {
      id:1,
      label:'NameNode UI',
      url:'http://%@:50070/dfshealth.jsp',
      service_id: 'HDFS'
    },
    {
      id:2,
      label:'NameNode logs',
      url:'http://%@:50070/logs',
      service_id: 'HDFS'
    },
    {
      id:3,
      label:'NameNode JMX',
      url:'http://%@:50070/jmx',
      service_id: 'HDFS'
    },
    {
      id:4,
      label:'Thread Stacks',
      url:'http://%@:50070/stacks',
      service_id: 'HDFS'
    },
    {
      id:5,
      label:'JobTracker UI',
      url:'http://%@:50030/jobtracker.jsp',
      service_id: 'MAPREDUCE'
    },
    {
      id:6,
      label:'Scheduling Info',
      url:'http://%@:50030/scheduler',
      service_id: 'MAPREDUCE'
    },
    {
      id:7,
      label:'Running Jobs',
      url:'http://%@:50030/jobtracker.jsp#running_jobs',
      service_id: 'MAPREDUCE'
    },
    {
      id:8,
      label:'Retired Jobs',
      url:'http://%@:50030/jobtracker.jsp#retired_jobs',
      service_id: 'MAPREDUCE'
    },
    {
      id:9,
      label:'JobHistory Server',
      url:'http://%@:51111/jobhistoryhome.jsp',
      service_id: 'MAPREDUCE'
    },
    {
      id:10,
      label:'JobTracker Logs',
      url:'http://%@:50030/logs',
      service_id: 'MAPREDUCE'
    },
    {
      id:11,
      label:'JobTracker JMX',
      url:'http://%@:50030/jmx',
      service_id: 'MAPREDUCE'
    },
    {
      id:12,
      label:'Thread Stacks',
      url:'http://%@:50030/stacks',
      service_id: 'MAPREDUCE'
    },
    {
      id:13,
      label:'HBase Master UI',
      url:'http://%@:60010/master-status',
      service_id: 'HBASE'
    },
    {
      id:14,
      label:'HBase Logs',
      url:'http://%@:60010/logs',
      service_id: 'HBASE'
    },
    {
      id:15,
      label:'Zookeeper Info',
      url:'http://%@:60010/zk.jsp',
      service_id: 'HBASE'
    },
    {
      id:16,
      label:'HBase Master JMX',
      url:'http://%@:60010/jmx',
      service_id: 'HBASE'
    },
    {
      id:17,
      label:'Debug Dump',
      url:'http://%@:60010/dump',
      service_id: 'HBASE'
    },
    {
      id:18,
      label:'Thread Stacks',
      url:'http://%@:60010/stacks',
      service_id: 'HBASE'
    },
    {
      id:19,
      label:'Oozie Web UI',
      url:'http://%@:11000/oozie',
      service_id: 'OOZIE'
    },
    {
      id:20,
      label:'Ganglia Web UI',
      url:'http://%@/ganglia',
      service_id: 'GANGLIA'
    },
    {
      id:21,
      label:'Nagios Web UI',
      url:'http://%@/nagios',
      service_id: 'NAGIOS'
    },
    {
      id:22,
      label:'Hue Web UI',
      url:'http://%@/hue',
      service_id: 'HUE'
    }
  ];
  
});
window.require.register("models/rack", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.Rack = DS.Model.extend({
    name: DS.attr('string'),
    status: DS.attr('string'),
    criticalHostsCount: DS.attr('number'),
    deadHostsCount: DS.attr('number'),
    hosts: function(){
      return App.Host.find();
    }.property('name'),
    liveHostsCount: function(){
      var count = 0;
      this.get('hosts').forEach(function(host){
        if(host.get('healthStatus')=="HEALTHY"){
          count++;
        }
      });
      return count;
    }.property('hosts')
  });

  App.Rack.FIXTURES = [
    //here example of data
    /*{
      id: 1,
      name: 'Rack-0',
      hosts: ['host01', 'host06', 'host05'],
      status: 'LIVE',
      live_hosts_count: 5,
      critical_hosts_count: 0,
      dead_hosts_count: 2
    }*/
  ];
});
window.require.register("models/run", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');
  var date = require('utils/date');
  var misc = require('utils/misc');

  App.Run = DS.Model.extend({
    appName: DS.attr('string'),
    userName:DS.attr('string'),
    numJobsTotal: DS.attr('number'),
    numJobsCompleted: DS.attr('number'),
    startTime:DS.attr('string'),
    elapsedTime:DS.attr('string'),
    workflowContext:DS.attr('string'),
    input: DS.attr('number'),
    output: DS.attr('number'),

    loadAllJobs : false,

    isStared: false,
    isFiltered: false,

    /**
     * runId  short part
     */
    idFormatted: function() {
      return this.get('id').substr(0, 20);
    }.property('id'),

    /**
     * Jobs in the current run
     */
    jobs: function() {
      return App.Job.find().filterProperty('run.id', this.get('id'));
    }.property('loadAllJobs'),

    /**
     * Run duration
     */
    duration: function() {
      return date.timingFormat(parseInt(this.get('elapsedTime')));
    }.property('elapsedTime'),
    /**
     * Status of running jobs
     */
    isRunning: function () {
      return !this.get('numJobsTotal') == this.get('numJobsCompleted');
    }.property('numJobsTotal', 'numJobsCompleted'),
    /**
     * Sum of input bandwidth for all jobs with appropriate measure
     */
    inputFormatted: function () {
      var input = this.get('input');
      input = misc.formatBandwidth(input);
      return input;
    }.property('input'),

    /**
     *  Sum of output bandwidth for all jobs with appropriate measure
     */
    outputFormatted: function () {
      var output = this.get('output');
      output = misc.formatBandwidth(output);
      return output;
    }.property('output'),

    /**
     *
     */
    lastUpdateTime: function() {
      return parseInt(this.get('startTime')) + parseInt(this.get('elapsedTime'));
    }.property('elapsedTime', 'startTime'),
    /**
     *
     */
    lastUpdateTimeFormatted: function() {
      return date.dateFormat(this.get('lastUpdateTime'));
    }.property('lastUpdateTime'),
    lastUpdateTimeFormattedShort: function(){
      return date.dateFormatShort(this.get('lastUpdateTime'));
    }.property('lastUpdateTime'),
    /**
     * Type value based on first part of id
     */
    type: function() {
      if (this.get('id').indexOf('pig_') === 0) {
        return 'Pig';
      }
      if (this.get('id').indexOf('hive_') === 0) {
        return 'Hive';
      }
      if (this.get('id').indexOf('mr_') === 0) {
        return 'MapReduce';
      }
    }.property('id')
  });

  App.Run.FIXTURES = [];
  
});
window.require.register("models/service", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');
  require('utils/config');

  App.Service = DS.Model.extend({

    serviceName: DS.attr('string'),

    workStatus: DS.attr('string'),
    rand: DS.attr('string'),
    alerts: DS.hasMany('App.Alert'),
    quickLinks: DS.hasMany('App.QuickLinks'),
    hostComponents: DS.hasMany('App.HostComponent'),
    serviceConfigsTemplate: App.config.get('preDefinedServiceConfigs'),
    runningHostComponents: null,

    // Instead of making healthStatus a computed property that listens on hostComponents.@each.workStatus,
    // we are creating a separate observer _updateHealthStatus.  This is so that healthStatus is updated
    // only once after the run loop.  This is because Ember invokes the computed property every time
    // a property that it depends on changes.  For example, App.statusMapper's map function would invoke
    // the computed property too many times and freezes the UI without this hack.
    // See http://stackoverflow.com/questions/12467345/ember-js-collapsing-deferring-expensive-observers-or-computed-properties
    healthStatus: '',

    updateHealthStatus: function () {
      // console.log('model:service.healthStatus ' + this.get('serviceName'));
      var components = this.get('hostComponents').filterProperty('isMaster', true);
      var isGreen = (this.get('serviceName') === 'HBASE' && App.supports.multipleHBaseMasters ?
        components.someProperty('workStatus', App.HostComponentStatus.started) :
        components.everyProperty('workStatus', App.HostComponentStatus.started));

      if (isGreen) {
        this.set('healthStatus', 'green');
      } else if (components.someProperty('workStatus', App.HostComponentStatus.unknown)) {
        this.set('healthStatus', 'yellow');
      } else if (components.someProperty('workStatus', App.HostComponentStatus.starting)) {
        this.set('healthStatus', 'green-blinking');
      } else if (components.someProperty('workStatus', App.HostComponentStatus.stopped)) {
        this.set('healthStatus', 'red');
      } else {
        this.set('healthStatus', 'red-blinking');
      }

      if (this.get('serviceName') === 'HBASE' && App.supports.multipleHBaseMasters) {
        var active = this.get('hostComponents').findProperty('haStatus', 'active');
        if (!active) {
          this.set('healthStatus', 'red');
        }
      }
    },

    /**
     * Every time when changes workStatus of any component we schedule recalculating values related from them
     */
    _updateHealthStatus: (function() {
      Ember.run.once(this, 'updateHealthStatus');
      Ember.run.once(this, 'updateIsStopped');
      Ember.run.once(this, 'updateIsStarted');
    }).observes('hostComponents.@each.workStatus'),

    isStopped: false,
    isStarted: false,

    updateIsStopped: function () {
      var components = this.get('hostComponents');
      var flag = true;
      var runningHCs = [];
      var unknownHCs = [];

      components.forEach(function (_component) {
        if (
          _component.get('workStatus') !== App.HostComponentStatus.stopped &&
          _component.get('workStatus') !== App.HostComponentStatus.install_failed &&
          _component.get('workStatus') !== App.HostComponentStatus.unknown
        ) {
          flag = false;
          runningHCs.addObject(_component);
        } else if (_component.get('workStatus') == App.HostComponentStatus.unknown) {
          unknownHCs.addObject(_component);
        }
      }, this);
      this.set('runningHostComponents', runningHCs);
      this.set('unknownHostComponents', unknownHCs);
      this.set('isStopped', flag);
    },

    updateIsStarted: function () {
      var components = this.get('hostComponents').filterProperty('isMaster', true);
      this.set('isStarted',
        components.everyProperty('workStatus', App.HostComponentStatus.started)
      );
    },

    isConfigurable: function () {
      var configurableServices = [
        "HDFS",
        "YARN",
        "MAPREDUCE",
        "MAPREDUCE2",
        "HBASE",
        "OOZIE",
        "HIVE",
        "WEBHCAT",
        "ZOOKEEPER",
        "PIG",
        "SQOOP",
        "NAGIOS",
        "HUE"
      ];
      return configurableServices.contains(this.get('serviceName'));
    }.property('serviceName'),

    displayName: function () {
      switch (this.get('serviceName').toLowerCase()) {
        case 'hdfs':
          return 'HDFS';
        case 'yarn':
          return 'YARN';
        case 'mapreduce':
          return 'MapReduce';
        case 'mapreduce2':
          return 'MapReduce2';
        case 'tez':
          return 'Tez';
        case 'hbase':
          return 'HBase';
        case 'oozie':
          return 'Oozie';
        case 'hive':
          return 'Hive';
        case 'hcatalog':
          return 'HCat';
        case 'zookeeper':
          return 'ZooKeeper';
        case 'pig':
          return 'Pig';
        case 'sqoop':
          return 'Sqoop';
        case 'webhcat':
          return 'WebHCat';
        case 'ganglia':
          return 'Ganglia';
        case 'nagios':
          return 'Nagios';
        case 'hue':
          return 'Hue';
        case 'flume':
          return 'Flume';
      }
      return this.get('serviceName');
    }.property('serviceName'),
    
    /**
     * For each host-component, if the desired_configs dont match the
     * actual_configs, then a restart is required. Except for Global site
     * properties, which need to be checked with map.
     */
    isRestartRequired: function () {
      var restartRequired = false;
      var restartRequiredHostsAndComponents = {};
      var clusterDesiredConfigs = App.router.get('mainServiceController.cluster.desiredConfigs');
      var serviceTemplate = this.serviceConfigsTemplate.findProperty('serviceName', this.get('serviceName'));
      if (clusterDesiredConfigs != null && serviceTemplate!=null) {
        var clusterToDesiredMap = {};
        clusterDesiredConfigs.forEach(function (config) {
          clusterToDesiredMap[config.site] = config;
        });
        this.get('hostComponents').forEach(function(hostComponent){
          var host = hostComponent.get('host');
          var hostName = host.get('hostName');
          hostComponent.get('actualConfigs').forEach(function(config){
            if(serviceTemplate.sites.contains(config.site)){
              var desiredClusterTag = clusterToDesiredMap[config.site].tag;
              var desiredHostOverrideTag = clusterToDesiredMap[config.site].hostOverrides[hostName];
              var actualClusterTag = config.tag;
              var actualHostOverrideTag = config.hostOverrides[hostName];
              var siteRestartRequired = false;
              if(actualClusterTag !== desiredClusterTag || actualHostOverrideTag !== desiredHostOverrideTag){
                var publicHostName = host.get('publicHostName');
                if(config.site=='global'){
                  var serviceName = hostComponent.get('service.serviceName');
                  if(actualClusterTag !== desiredClusterTag){
                    siteRestartRequired = App.config.isServiceEffectedByGlobalChange(serviceName, actualClusterTag, desiredClusterTag);
                  }
                  if(actualHostOverrideTag !== desiredHostOverrideTag){
                    siteRestartRequired = App.config.isServiceEffectedByGlobalChange(serviceName, actualHostOverrideTag, desiredHostOverrideTag);
                  }
                }else{
                  siteRestartRequired = true
                }
                if(siteRestartRequired){
                  restartRequired = true;
                  if(!(publicHostName in restartRequiredHostsAndComponents)){
                    restartRequiredHostsAndComponents[publicHostName] = [];
                  }
                  var hostComponentName = hostComponent.get('displayName');
                  if(restartRequiredHostsAndComponents[publicHostName].indexOf(hostComponentName)<0){
                    restartRequiredHostsAndComponents[publicHostName].push(hostComponentName);
                  }
                }
              }
            }
          });
        });
      }
      this.set('restartRequiredHostsAndComponents', restartRequiredHostsAndComponents);
      return restartRequired;
    }.property('serviceName', 'hostComponents', 'hostComponents.@each.actualConfigs', 'hostComponents.@each.actualConfigs.@each.tag', 
        'App.router.mainServiceController.cluster.desiredConfigs', 'App.router.mainServiceController.cluster.desiredConfigs.@each.tag'),
    
    /**
     * Contains a map of which hosts and host_components
     * need a restart. This is populated when calculating
     * #isRestartRequired()
     * Example:
     * {
     *  'publicHostName1': ['TaskTracker'],
     *  'publicHostName2': ['JobTracker', 'TaskTracker']
     * }
     */
    restartRequiredHostsAndComponents: {},
    
    /**
     * Based on the information in #restartRequiredHostsAndComponents
     */
    restartRequiredMessage: function () {
      var restartHC = this.get('restartRequiredHostsAndComponents');
      var hostCount = 0;
      var hcCount = 0;
      var hostsMsg = "<ul>";
      for(var host in restartHC){
        hostCount++;
        hostsMsg += "<li>"+host+"</li><ul>";
        restartHC[host].forEach(function(c){
          hcCount++;
          hostsMsg += "<li>"+c+"</li>";       
        })
        hostsMsg += "</ul>";
      }
      hostsMsg += "</ul>"
      return this.t('services.service.config.restartService.TooltipMessage').format(hcCount, hostCount, hostsMsg);
    }.property('restartRequiredHostsAndComponents')
  });

  App.Service.Health = {
    live: "LIVE",
    dead: "DEAD-RED",
    starting: "STARTING",
    stopping: "STOPPING",
    unknown: "DEAD-YELLOW",

    getKeyName: function (value) {
      switch (value) {
        case this.live:
          return 'live';
        case this.dead:
          return 'dead';
        case this.starting:
          return 'starting';
        case this.stopping:
          return 'stopping';
        case this.unknown:
          return 'unknown';
      }
      return 'none';
    }
  };

  App.Service.FIXTURES = [];
  
});
window.require.register("models/service/flume", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.FlumeService = App.Service.extend({
    version: DS.attr('string'),
    nodes: DS.hasMany('App.FlumeNode'),
    channelsCount: function () {
      var nodes = this.get('nodes');
      var count = 0;
      nodes.forEach(function (node) {
        count += node.get('channelsCount');
      });
      return count;
    }.property('nodes.@each.channelsCount'),

    sourcesCount: function () {
      var nodes = this.get('nodes');
      var count = 0;
      nodes.forEach(function (node) {
        count += node.get('sourcesCount');
      });
      return count;
    }.property('nodes.@each.sourcesCount'),

    sinksCount: function () {
      var nodes = this.get('nodes');
      var count = 0;
      nodes.forEach(function (node) {
        count += node.get('sinksCount');
      });
      return count;
    }.property('nodes.@each.sinksCount')
  });

  App.FlumeNode = DS.Model.extend({
    host: DS.belongsTo('App.Host'),

    /**
     * A comma separated list of channels.
     */
    channels: DS.attr('string'),

    /**
     * A comma separated list of sources.
     */
    sources: DS.attr('string'),

    /**
     * A comma separated list of sinks.
     */
    sinks: DS.attr('string'),

    channelsCount: function () {
      var channels = this.get('channels');
      if (!channels) {
        return 0;
      } else {
        return channels.split(',').length;
      }
    }.property('channels'),

    sourcesCount: function () {
      var sources = this.get('sources');
      if (!sources) {
        return 0;
      } else {
        return sources.split(',').length;
      }
    }.property('sources'),

    sinksCount: function () {
      var sinks = this.get('sinks');
      if (!sinks) {
        return 0;
      } else {
        return sinks.split(',').length;
      }
    }.property('sinks')
  });

  App.FlumeService.FIXTURES = [];
  App.FlumeNode.FIXTURES = [];
  
});
window.require.register("models/service/hbase", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.HBaseService = App.Service.extend({
    version: DS.attr('string'),
    master: DS.belongsTo('App.Host'),
    regionServers: DS.hasMany('App.Host'),
    masterStartTime: DS.attr('number'),
    masterActiveTime: DS.attr('number'),
    averageLoad: DS.attr('number'),
    regionsInTransition: DS.attr('number'),
    revision: DS.attr('string'),
    heapMemoryUsed: DS.attr('number'),
    heapMemoryMax: DS.attr('number')
  });

  App.HBaseService.FIXTURES = [];
  
});
window.require.register("models/service/hdfs", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.HDFSService = App.Service.extend({
    version: DS.attr('string'),
    nameNode: DS.belongsTo('App.Host'),
    snameNode: DS.belongsTo('App.Host'),
    dataNodes: DS.hasMany('App.Host'),
    nameNodeStartTime: DS.attr('number'),
    jvmMemoryHeapUsed: DS.attr('number'),
    jvmMemoryHeapCommitted: DS.attr('number'),
    liveDataNodes: DS.hasMany('App.Host'),
    deadDataNodes: DS.hasMany('App.Host'),
    decommissionDataNodes: DS.hasMany('App.Host'),
    capacityUsed: DS.attr('number'),
    capacityTotal: DS.attr('number'),
    capacityRemaining: DS.attr('number'),
    dfsTotalBlocks: DS.attr('number'),
    dfsCorruptBlocks: DS.attr('number'),
    dfsMissingBlocks: DS.attr('number'),
    dfsUnderReplicatedBlocks: DS.attr('number'),
    dfsTotalFiles: DS.attr('number'),
    upgradeStatus: DS.attr('boolean'),
    safeModeStatus: DS.attr('string'),
    nameNodeCpu: DS.attr('number'),
    nameNodeRpc: DS.attr('number')
  });

  App.HDFSService.FIXTURES = [];
  
});
window.require.register("models/service/mapreduce", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.MapReduceService = App.Service.extend({
    version: DS.attr('string'),
    jobTracker: DS.belongsTo('App.Host'),
    taskTrackers: DS.hasMany('App.Host'),
    jobTrackerStartTime: DS.attr('number'),
    jobTrackerHeapUsed: DS.attr('number'),
    jobTrackerHeapMax: DS.attr('number'),
    aliveTrackers: DS.hasMany('App.Host'),
    blackListTrackers: DS.hasMany('App.Host'),
    grayListTrackers: DS.hasMany('App.Host'),
    mapSlots: DS.attr('number'),
    reduceSlots: DS.attr('number'),
    jobsSubmitted: DS.attr('number'),
    jobsCompleted: DS.attr('number'),
    mapSlotsOccupied: DS.attr('number'),
    mapSlotsReserved: DS.attr('number'),
    reduceSlotsOccupied: DS.attr('number'),
    reduceSlotsReserved: DS.attr('number'),
    mapsRunning: DS.attr('number'),
    mapsWaiting: DS.attr('number'),
    reducesRunning: DS.attr('number'),
    reducesWaiting: DS.attr('number'),
    trackersDecommissioned: DS.attr('number'),
    jobTrackerCpu: DS.attr('number'),
    jobTrackerRpc: DS.attr('number')
  });

  App.MapReduceService.FIXTURES = [];
  
});
window.require.register("models/service_audit", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.ServiceAudit = DS.Model.extend({
    date: DS.attr('date'),
    service: DS.belongsTo('App.Service'),
    operationName: DS.attr('string'),
    user: DS.belongsTo('App.User')
  });

  App.ServiceAudit.FIXTURES = [
    {
      id: 1,
      date: 'September 12, 2012 17:00',
      operation_name: 'Reconfigure',
      user_id: 2,
      service_id: 1
    },
    {
      id: 2,
      date: 'September 13, 2012 17:00',
      operation_name: 'Start',
      user_id: 1,
      service_id: 1
    },
    {
      id: 3,
      date: 'September 14, 2012 17:00',
      operation_name: 'Install',
      user_id: 1,
      service_id: 1
    },
    {
      id: 4,
      date: 'September 12, 2012 17:00',
      operation_name: 'Reconfigure',
      user_id: 2,
      service_id: 2
    },
    {
      id: 5,
      date: 'September 13, 2012 17:00',
      operation_name: 'Start',
      user_id: 1,
      service_id: 2
    },
    {
      id: 6,
      date: 'September 14, 2012 17:00',
      operation_name: 'Install',
      user_id: 1,
      service_id: 2
    }
  ];
});
window.require.register("models/service_config", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var validator = require('utils/validator');

  App.ServiceConfig = Ember.Object.extend({
    serviceName: '',
    configCategories: [],
    configs: null,
    restartRequired: false,
    restartRequiredMessage: '',
    restartRequiredHostsAndComponents: {},
    errorCount: function () {
      var overrideErrors = 0;
      this.get('configs').filterProperty("overrides").forEach(function (e) {
        e.overrides.forEach(function (e) {
          if (e.error) {
            overrideErrors += 1;
          }
        })
      })
      var masterErrors = this.get('configs').filterProperty('isValid', false).filterProperty('isVisible', true).get('length');
      var slaveErrors = 0;
      this.get('configCategories').forEach(function (_category) {
        slaveErrors += _category.get('slaveErrorCount');
      }, this);
      return masterErrors + slaveErrors + overrideErrors;
    }.property('configs.@each.isValid', 'configs.@each.isVisible', 'configCategories.@each.slaveErrorCount', 'configs.@each.overrideErrorTrigger')
  });

  App.ServiceConfigCategory = Ember.Object.extend({
    name: null,
    /**
     *  We cant have spaces in the name as this is being used as HTML element id while rendering. Hence we introduced 'displayName' where we can have spaces like 'Secondary Name Node' etc.
     */
    displayName: null,
    slaveConfigs: null,
    /**
     * check whether to show custom view in category instead of default
     */
    isCustomView: false,
    customView: null,
    /**
     * Each category might have a site-name associated (hdfs-site, core-site, etc.)
     * and this will be used when determining which category a particular property
     * ends up in, based on its site.
     */
    siteFileName: null,
    /**
     * Can this category add new properties. Used for custom configurations.
     */
    canAddProperty: false,
    primaryName: function () {
      switch (this.get('name')) {
        case 'DataNode':
          return 'DATANODE';
          break;
        case 'TaskTracker':
          return 'TASKTRACKER';
          break;
        case 'RegionServer':
          return 'HBASE_REGIONSERVER';
      }
    }.property('name'),


    isForMasterComponent: function () {
      var masterServices = [ 'NameNode', 'SNameNode', 'JobTracker', 'HBase Master', 'Oozie Master',
        'Hive Metastore', 'WebHCat Server', 'ZooKeeper Server', 'Nagios', 'Ganglia' ];

      return (masterServices.contains(this.get('name')));
    }.property('name'),

    isForSlaveComponent: function () {
      return this.get('name') === 'DataNode' || this.get('name') === 'TaskTracker' ||
        this.get('name') === 'RegionServer';
    }.property('name'),

    slaveErrorCount: function () {
      var length = 0;
      if (this.get('slaveConfigs.groups')) {
        this.get('slaveConfigs.groups').forEach(function (_group) {
          length += _group.get('errorCount');
        }, this);
      }
      return length;
    }.property('slaveConfigs.groups.@each.errorCount'),

    isAdvanced : function(){
      var name = this.get('name');
      return name.indexOf("Advanced") !== -1 ;
    }.property('name')
  });


  App.SlaveConfigs = Ember.Object.extend({
    componentName: null,
    displayName: null,
    hosts: null,
    groups: null
  });

  App.Group = Ember.Object.extend({
    name: null,
    hostNames: null,
    properties: null,
    errorCount: function () {
      if (this.get('properties')) {
        return this.get('properties').filterProperty('isValid', false).filterProperty('isVisible', true).get('length');
      }
    }.property('properties.@each.isValid', 'properties.@each.isVisible')
  });


  App.ServiceConfigProperty = Ember.Object.extend({

    id: '', //either 'puppet var' or 'site property'
    name: '',
    displayName: '',
    value: '',
    retypedPassword: '',
    defaultValue: '',
    defaultDirectory: '',
    description: '',
    displayType: 'string', // string, digits, number, directories, custom
    unit: '',
    category: 'General',
    isRequired: true, // by default a config property is required
    isReconfigurable: true, // by default a config property is reconfigurable
    isEditable: true, // by default a config property is editable
    isVisible: true,
    isSecureConfig: false,
    errorMessage: '',
    serviceConfig: null, // points to the parent App.ServiceConfig object
    filename: '',
    isOriginalSCP : true, // if true, then this is original SCP instance and its value is not overridden value.
    parentSCP: null, // This is the main SCP which is overridden by this. Set only when isOriginalSCP is false.
    selectedHostOptions : null, // contain array of hosts configured with overridden value
    overrides : null,
    isUserProperty: null, // This property was added by user. Hence they get removal actions etc.
    isOverridable: true,
    error: false,
    overrideErrorTrigger: 0, //Trigger for overrridable property error
    isRestartRequired: false,
    restartRequiredMessage: 'Restart required',
    index: null, //sequence number in category
    editDone: false, //Text field: on focusOut: true, on focusIn: false

    /**
     * On Overridable property error message, change overrideErrorTrigger value to recount number of errors service have
     */
    observeErrors: function () {
      this.set("overrideErrorTrigger", this.get("overrideErrorTrigger") + 1);
    }.observes("overrides.@each.errorMessage"),
    /**
     * No override capabilities for fields which are not edtiable
     * and fields which represent master hosts.
     */
    isPropertyOverridable : function() {
      var overrideable = this.get('isOverridable');
    	var editable = this.get('isEditable');
    	var dt = this.get('displayType');
    	return overrideable && editable && ("masterHost"!=dt);
    }.property('isEditable', 'displayType', 'isOverridable'),
    isOverridden: function() {
      var overrides = this.get('overrides');
      return (overrides != null && overrides.get('length')>0) || !this.get('isOriginalSCP');
    }.property('overrides', 'overrides.length', 'isOriginalSCP'),
    isRemovable: function() {
      var isOriginalSCP = this.get('isOriginalSCP');
      var isUserProperty = this.get('isUserProperty');
      // Removable when this is a user property, or it is not an original property
      return isUserProperty || !isOriginalSCP;
    }.property('isUserProperty', 'isOriginalSCP'),
    init: function () {
      if(this.get("displayType")=="password"){
        this.set('retypedPassword', this.get('defaultValue'));
        this.set('value', this.get('defaultValue'));
      }
      if ((this.get('id') === 'puppet var') && this.get('value') == '') {
        this.set('value', this.get('defaultValue'));
      }
      // TODO: remove mock data
    },

    /**
     * Indicates when value is not the default value.
     * Returns false when there is no default value.
     */
    isNotDefaultValue: function () {
      var value = this.get('value');
      var dValue = this.get('defaultValue');
      var isEditable = this.get('isEditable');
      return isEditable && dValue != null && value !== dValue;
    }.property('value', 'defaultValue', 'isEditable'),

    /**
     * Don't show "Undo" for hosts on Installer Step7
     */
    cantBeUndone: function() {
      var types = ["masterHost", "slaveHosts", "masterHosts", "slaveHost","radio button"];
      var displayType = this.get('displayType');
      var result = false;
      types.forEach(function(type) {
        if (type === displayType) {
          result = true;
          return;
        }
      });
      return result;
    }.property('displayType'),

    initialValue: function (localDB) {
      var masterComponentHostsInDB = localDB.masterComponentHosts;
      //console.log("value in initialvalue: " + JSON.stringify(masterComponentHostsInDB));
      var hostsInfo = localDB.hosts; // which we are setting in installerController in step3.
      var slaveComponentHostsInDB = localDB.slaveComponentHosts;
      var isOnlyFirstOneNeeded = true;
      switch (this.get('name')) {
        case 'namenode_host':
          var temp = masterComponentHostsInDB.findProperty('component', 'NAMENODE');
          this.set('value', temp.hostName);
          break;
        case 'snamenode_host':
          this.set('value', masterComponentHostsInDB.findProperty('component', 'SECONDARY_NAMENODE').hostName);
          break;
        case 'datanode_hosts':
          this.set('value', slaveComponentHostsInDB.findProperty('componentName', 'DATANODE').hosts.mapProperty('hostName'));
          break;
        case 'hs_host':
          this.set('value', masterComponentHostsInDB.filterProperty('component', 'HISTORYSERVER').mapProperty('hostName'));
          break;
        case 'rm_host':
          this.set('value', masterComponentHostsInDB.findProperty('component', 'RESOURCEMANAGER').hostName);
          break;
        case 'nm_hosts':
          this.set('value', slaveComponentHostsInDB.findProperty('componentName', 'NODEMANAGER').hosts.mapProperty('hostName'));
          break;
        case 'jobtracker_host':
          this.set('value', masterComponentHostsInDB.findProperty('component', 'JOBTRACKER').hostName);
          break;
        case 'tasktracker_hosts':
          this.set('value', slaveComponentHostsInDB.findProperty('componentName', 'TASKTRACKER').hosts.mapProperty('hostName'));
          break;
        case 'hbasemaster_host':
          this.set('value', masterComponentHostsInDB.filterProperty('component', 'HBASE_MASTER').mapProperty('hostName'));
          break;
        case 'regionserver_hosts':
          this.set('value', slaveComponentHostsInDB.findProperty('componentName', 'HBASE_REGIONSERVER').hosts.mapProperty('hostName'));
          break;
        case 'hivemetastore_host':
          this.set('value', masterComponentHostsInDB.findProperty('component', 'HIVE_SERVER').hostName);
          break;
        case 'hive_ambari_host':
          this.set('value', masterComponentHostsInDB.findProperty('component', 'HIVE_SERVER').hostName);
          break;
        case 'oozieserver_host':
          this.set('value', masterComponentHostsInDB.findProperty('component', 'OOZIE_SERVER').hostName);
          break;
        case 'webhcatserver_host':
          this.set('value', masterComponentHostsInDB.findProperty('component', 'WEBHCAT_SERVER').hostName);
          break;
        case 'hueserver_host':
          this.set('value', masterComponentHostsInDB.findProperty('component', 'HUE_SERVER').hostName);
          break;
        case 'oozie_ambari_host':
          this.set('value', masterComponentHostsInDB.findProperty('component', 'OOZIE_SERVER').hostName);
          break;
        case 'zookeeperserver_hosts':
          this.set('value', masterComponentHostsInDB.filterProperty('component', 'ZOOKEEPER_SERVER').mapProperty('hostName'));
          break;
        case 'dfs_name_dir':
        case 'dfs_data_dir':
        case 'mapred_local_dir':
          this.unionAllMountPoints(!isOnlyFirstOneNeeded, localDB);
          break;
        case 'fs_checkpoint_dir':
        case 'zk_data_dir':
        case 'oozie_data_dir':
          this.unionAllMountPoints(isOnlyFirstOneNeeded, localDB);
          break;
      }
    },

    unionAllMountPoints: function (isOnlyFirstOneNeeded, localDB) {
      var hostname = '';
      var mountPointsPerHost = [];
      var mountPointAsRoot;
      var masterComponentHostsInDB = localDB.masterComponentHosts;
      var slaveComponentHostsInDB = localDB.slaveComponentHosts;
      var hostsInfo = localDB.hosts; // which we are setting in installerController in step3.
      App.Host.find().forEach(function(item){
        if(!hostsInfo[item.get('id')]){
          hostsInfo[item.get('id')] = {
            name: item.get('id'),
            cpu: item.get('cpu'),
            memory: item.get('memory'),
            disk_info: item.get('diskInfo'),
            bootStatus: "REGISTERED",
            isInstalled: true
          };
        }
      });
      var temp = '';
      var setOfHostNames = [];
      switch (this.get('name')) {
        case 'dfs_name_dir':
          var components = masterComponentHostsInDB.filterProperty('component', 'NAMENODE');
          components.forEach(function (component) {
            setOfHostNames.push(component.hostName);
          }, this);
          break;
        case 'fs_checkpoint_dir':
          var components = masterComponentHostsInDB.filterProperty('component', 'SECONDARY_NAMENODE');
          components.forEach(function (component) {
            setOfHostNames.push(component.hostName);
          }, this);
          break;
        case 'dfs_data_dir':
          temp = slaveComponentHostsInDB.findProperty('componentName', 'DATANODE');
          temp.hosts.forEach(function (host) {
            setOfHostNames.push(host.hostName);
          }, this);
          break;
        case 'mapred_local_dir':
          temp = slaveComponentHostsInDB.findProperty('componentName', 'TASKTRACKER') || slaveComponentHostsInDB.findProperty('componentName', 'NODEMANAGER');
          temp.hosts.forEach(function (host) {
            setOfHostNames.push(host.hostName);
          }, this);
          break;
        case 'zk_data_dir':
          var components = masterComponentHostsInDB.filterProperty('component', 'ZOOKEEPER_SERVER');
          components.forEach(function (component) {
            setOfHostNames.push(component.hostName);
          }, this);
          break;
        case 'oozie_data_dir':
          var components = masterComponentHostsInDB.filterProperty('component', 'OOZIE_SERVER');
          components.forEach(function (component) {
            setOfHostNames.push(component.hostName);
          }, this);
          break;
      }

      // In Add Host Wizard, if we did not select this slave component for any host, then we don't process any further.
      if (setOfHostNames.length === 0) {
        return;
      }

      var allMountPoints = [];
      for (var i = 0; i < setOfHostNames.length; i++) {
        hostname = setOfHostNames[i];

        mountPointsPerHost = hostsInfo[hostname].disk_info;

        mountPointAsRoot = mountPointsPerHost.findProperty('mountpoint', '/');

        mountPointsPerHost = mountPointsPerHost.filter(function (mPoint) {
          return !(['/', '/home', '/boot'].contains(mPoint.mountpoint) || ['devtmpfs', 'tmpfs', 'vboxsf'].contains(mPoint.type));
        });

        mountPointsPerHost.forEach(function (mPoint) {
          if( !allMountPoints.findProperty("mountpoint", mPoint.mountpoint)) {
            allMountPoints.push(mPoint);
          }
        }, this);
      }
      if (allMountPoints.length == 0) {
        allMountPoints.push(mountPointAsRoot);
      }
      this.set('value', '');
      if (!isOnlyFirstOneNeeded) {
        allMountPoints.forEach(function (eachDrive) {
          var mPoint = this.get('value');
          if (!mPoint) {
            mPoint = "";
          }
          if (eachDrive.mountpoint === "/") {
            mPoint += this.get('defaultDirectory') + "\n";
          } else {
            mPoint += eachDrive.mountpoint + this.get('defaultDirectory') + "\n";
          }
          this.set('value', mPoint);
          this.set('defaultValue', mPoint);
        }, this);
      } else {
        var mPoint = allMountPoints[0].mountpoint;
        if (mPoint === "/") {
          mPoint = this.get('defaultDirectory') + "\n";
        } else {
          mPoint = mPoint + this.get('defaultDirectory') + "\n";
        }
        this.set('value', mPoint);
        this.set('defaultValue', mPoint);
      }
    },

    isValid: function () {
      return this.get('errorMessage') === '';
    }.property('errorMessage'),

    viewClass: function () {
      switch (this.get('displayType')) {
        case 'checkbox':
          return App.ServiceConfigCheckbox;
        case 'password':
          return App.ServiceConfigPasswordField;
        case 'combobox':
          return App.ServiceConfigComboBox;
        case 'radio button':
          return App.ServiceConfigRadioButtons;
          break;
        case 'directories':
          return App.ServiceConfigTextArea;
          break;
        case 'multiLine':
          return App.ServiceConfigTextArea;
          break;
        case 'custom':
          return App.ServiceConfigBigTextArea;
        case 'masterHost':
          return App.ServiceConfigMasterHostView;
        case 'masterHosts':
          return App.ServiceConfigMasterHostsView;
        case 'slaveHosts':
          return App.ServiceConfigSlaveHostsView;
        default:
          if (this.get('unit')) {
            return App.ServiceConfigTextFieldWithUnit;
          } else {
            return App.ServiceConfigTextField;
          }
      }
    }.property('displayType'),

    validate: function () {
      var value = this.get('value');
      var valueRange = this.get('valueRange');
      var values = [];//value split by "," to check UNIX users, groups list

      var isError = false;

      if (typeof value === 'string' && value.length === 0) {
        if (this.get('isRequired')) {
          this.set('errorMessage', 'This is required');
          isError = true;
        } else {
          return;
        }
      }

      if (!isError) {
        switch (this.get('displayType')) {
          case 'int':
            if (!validator.isValidInt(value)) {
              this.set('errorMessage', 'Must contain digits only');
              isError = true;
            } else {
              if(valueRange){
                if(value < valueRange[0] || value > valueRange[1]){
                  this.set('errorMessage', 'Must match the range');
                  isError = true;
                }
              }
            }
            break;
          case 'float':
            if (!validator.isValidFloat(value)) {
              this.set('errorMessage', 'Must be a valid number');
              isError = true;
            }
            break;
          case 'UNIXList':
            if(value != '*'){
              values = value.split(',');
              for(var i = 0, l = values.length; i < l; i++){
                if(!validator.isValidUNIXUser(values[i])){
                  if(this.get('type') == 'USERS'){
                    this.set('errorMessage', 'Must be a valid list of user names');
                  } else {
                    this.set('errorMessage', 'Must be a valid list of group names');
                  }
                  isError = true;
                }
              }
            }
            break;
          case 'checkbox':
            break;
          case 'directories':
            if (!validator.isValidDir(value)) {
              this.set('errorMessage', 'Must be a slash at the start');
              isError = true;
            }
            break;
          case 'directory':
            if (!validator.isValidDir(value)) {
              this.set('errorMessage', 'Must be a slash at the start');
              isError = true;
            }
            break;
          case 'custom':
            break;
          case 'user':
            if (!validator.isValidUserName(value)) {
              this.set('errorMessage', Em.I18n.t('users.userName.validationFail'));
              isError = true;
            }
            break;
          case 'email':
            if (!validator.isValidEmail(value)) {
              this.set('errorMessage', 'Must be a valid email address');
              isError = true;
            }
            break;
          case 'password':
            // retypedPassword is set by the retypePasswordView child view of App.ServiceConfigPasswordField
            if (value !== this.get('retypedPassword')) {
              this.set('errorMessage', 'Passwords do not match');
              isError = true;
            }
        }
      }

      if (!isError) {
        // Check if this value is already in any of the overrides
        var self = this;
        var isOriginalSCP = this.get('isOriginalSCP');
        var parentSCP = this.get('parentSCP');
        if (!isOriginalSCP) {
          var hosts = this.get('selectedHostOptions');
          if(hosts==null || hosts.get('length')<1){
            this.set('errorMessage', 'Select hosts to apply exception to');
            isError = true;
          }
          if (!isError && parentSCP != null) {
            if (value === parentSCP.get('value')) {
              this.set('errorMessage', 'Host exceptions must have different value');
              isError = true;
            } else {
              var overrides = parentSCP.get('overrides');
              overrides.forEach(function (override) {
                if (self != override && value === override.get('value')) {
                  self.set('errorMessage', 'Multiple host exceptions cannot have same value');
                  isError = true;
                }
              });
            }
          }
        }
      }

      if (!isError) {
        this.set('errorMessage', '');
        this.set('error', false);
      } else {
        this.set('error', true);
      }
    }.observes('value', 'retypedPassword')

  });

  App.ConfigSiteTag = Ember.Object.extend({
    site: DS.attr('string'),
    tag: DS.attr('string'),
    /**
     * Object map of hostname->override-tag for overrides.
     * <b>Creators should set new object here.<b>
     */
    hostOverrides: null
  });
  
});
window.require.register("models/target_cluster", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.TargetCluster = DS.Model.extend({
    id: DS.attr('string'),
    clusterName: DS.attr('string'),
    nameNodeWebUrl: DS.attr('string'),
    nameNodeRpcUrl: DS.attr('string'),
    oozieServerUrl: DS.attr('string')
  });

  App.TargetCluster.FIXTURES = [/*
   {
   id: 1,
   cluster_name: 'cluster1',
   stack_name: 'HDP',
   hosts: [1, 2, 3, 4],
   racks: [1, 2, 3, 4, 5, 6],
   max_hosts_per_rack: 10
   }*/
  ];
});
window.require.register("models/user", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var validator = require('utils/validator');

  App.User = DS.Model.extend({
    userName:DS.attr('string'),
    id:function(){
      return this.get('userName');
    }.property('userName'),
    roles:DS.attr('string'),
    isLdap:DS.attr('boolean'),
    type: function(){
      if(this.get('isLdap')){
        return 'LDAP';
      }
      return 'Local';
    }.property('isLdap'),
    auditItems:DS.hasMany('App.ServiceAudit'),
    admin: DS.attr('boolean')
  });

  App.EditUserForm = App.Form.extend({
    className:App.User,
    object:function () {
      return App.router.get('mainAdminUserEditController.content');
    }.property('App.router.mainAdminUserEditController.content'),

    fieldsOptions:[
      { name:"userName", displayName:"Username" },
      { name:"old_password", displayName:"Current Password", displayType:"password", isRequired: false },
      { name:"new_password", displayName:"New Password", displayType:"password",  isRequired: false },
      { name:"admin", displayName:"Admin", displayType:"checkbox", isRequired:false },
      { name:"roles", displayName:"Role", isRequired:false, isHidden:true },
      { name:"isLdap", displayName:"Type", isRequired:false, isHidden:true }
    ],
    fields:[],
    disableUsername:function () {
      this.getField("userName").set("disabled", "disabled");
    }.observes('object'),
    disableAdminCheckbox:function () {
      var object = this.get('object');
      if (object) {
        if ((object.get('userName') == App.get('router').getLoginName()) || App.supports.ldapGroupMapping && object.get("isLdap")) {
          this.getField("admin").set("disabled", true);
        } else {
          this.getField("admin").set("disabled", false);
        }
      }
    }.observes('object'),

    isValid:function () {

      var isValid = this._super();
      thisForm = this;

      var newPass = this.get('field.new_password');
      var oldPass = this.get('field.old_password');

      if (!validator.empty(newPass.get('value')) && validator.empty(oldPass.get('value'))) {
          oldPass.set('errorMessage', this.t('admin.users.editError.requiredField'));
          isValid = false;
      }

      return isValid;
    },

    save: function () {
      var object = this.get('object');
      var formValues = {};
      $.each(this.get('fields'), function () {
        formValues[this.get('name')] = this.get('value');
      });

      $.each(formValues, function (k, v) {
        object.set(k, v);
      });

      //App.store.commit();
      this.set('result', 1);

      return true;
    }
  });
  App.CreateUserForm = App.Form.extend({
    className:App.User,
    object:function () {
      return App.router.get('mainAdminUserCreateController.content');
    }.property('App.router.mainAdminUserCreateController.content'),

    fieldsOptions:[
      { name:"userName", displayName:"Username", toLowerCase: function(){var v = this.get('value'); this.set('value', v.toLowerCase())}.observes('value') },
      { name:"password", displayName:"Password", displayType:"password", isRequired: true },
      { name:"passwordRetype", displayName:"Retype Password", displayType:"password", validator:"passwordRetype", isRequired: true },
      { name:"admin", displayName:"Admin", displayType:"checkbox", isRequired:false },
      { name:"roles", displayName:"Role", isRequired:false, isHidden:true }
    ],
    fields:[],

    isValid:function () {
      var isValid = this._super();

      var passField = this.get('field.password');
      var passRetype = this.get('field.passwordRetype');

      if (!validator.empty(passField.get('value'))) {
        if (passField.get('value') != passRetype.get('value')) {
          passRetype.set('errorMessage', this.t('admin.users.createError.passwordValidation'));
          isValid = false;
        }
      }

      if (isValid) {
        var users = App.User.find();
        var userNameField = this.getField('userName');
        var userName = userNameField.get('value');

        if (!validator.isValidUserName(userName)) {
          userNameField.set('errorMessage', this.t('users.userName.validationFail'));
          isValid = false;
        }

        if (users.mapProperty('userName').contains(userName)) {
          userNameField.set('errorMessage', this.t('admin.users.createError.userNameExists'));
          return isValid = false;
        }
      }

      return isValid;
    },

    save: function () {

      var object = this.get('object');
      var formValues = {};
      $.each(this.get('fields'), function () {
        formValues[Ember.String.decamelize(this.get('name'))] = this.get('value');
      });

      if (this.get('className')) {
        App.store.load(this.get('className'), formValues.user_name, formValues);
      }
      else {
        console.log("Please define class name for your form " + this.constructor);
      }

      this.set('result', 1);

      return true;
    }
  });
  App.User.FIXTURES = [];

  
});
window.require.register("router", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  App.Router = Em.Router.extend({

    enableLogging: true,
    isFwdNavigation: true,
    backBtnForHigherStep: false,

    setNavigationFlow: function (step) {
      var matches = step.match(/\d+$/);
      var newStep;
      if (matches) {
        newStep = parseInt(matches[0]);
      }
      var previousStep = parseInt(this.getInstallerCurrentStep());
      this.set('isFwdNavigation', newStep >= previousStep);
    },


    clearAllSteps: function () {
      this.get('installerController').clear();
      this.get('addHostController').clear();
      this.get('addServiceController').clear();
      this.get('stackUpgradeController').clear();
      this.get('reassignMasterController').clear();
      for (i = 1; i < 11; i++) {
        this.set('wizardStep' + i + 'Controller.hasSubmitted', false);
        this.set('wizardStep' + i + 'Controller.isDisabled', true);
      }
    },

    /**
     * Temporary fix for getting cluster name
     * @return {*}
     */

    getClusterName: function () {
      return App.router.get('clusterController').get('clusterName');
    },


    /**
     * Get current step of Installer wizard
     * @return {*}
     */
    getInstallerCurrentStep: function () {
      return this.getWizardCurrentStep('installer');
    },

    /**
     * Get current step for <code>wizardType</code> wizard
     * @param wizardType one of <code>installer</code>, <code>addHost</code>, <code>addServices</code>
     */
    getWizardCurrentStep: function (wizardType) {
      var loginName = this.getLoginName();
      var currentStep = App.db.getWizardCurrentStep(wizardType);
      console.log('getWizardCurrentStep: loginName=' + loginName + ", currentStep=" + currentStep);
      if (!currentStep) {
        currentStep = wizardType === 'installer' ? '0' : '1';
      }
      console.log('returning currentStep=' + currentStep);
      return currentStep;
    },

    loggedIn: false,

    loginName: function() {
      return this.getLoginName();
    }.property('loggedIn'),

    getAuthenticated: function () {
      var auth = App.db.getAuthenticated();
      var authResp = (auth && auth === true);
      if (authResp) {
        App.ajax.send({
          name: 'router.authentication',
          sender: this,
          success: 'onAuthenticationSuccess',
          error: 'onAuthenticationError'
        });
      } else {
        this.set('loggedIn', false);
      }
      return this.get('loggedIn');
    },

    onAuthenticationSuccess: function (data) {
      this.set('loggedIn', true);
    },

    onAuthenticationError: function (data) {
      if (data.status === 403) {
        this.set('loggedIn', false);
      } else {
        console.log('error in getAuthenticated');
      }
    },

    setAuthenticated: function (authenticated) {
      console.log("TRACE: Entering router:setAuthenticated function");
      App.db.setAuthenticated(authenticated);
      this.set('loggedIn', authenticated);
    },

    getLoginName: function () {
      return App.db.getLoginName();
    },

    setLoginName: function (loginName) {
      App.db.setLoginName(loginName);
    },

    /**
     * Set user model to local storage
     * @param user
     */
    setUser: function (user) {
      App.db.setUser(user);
    },

    /**
     * Get user model from local storage
     * @return {*}
     */
    getUser: function () {
      return App.db.getUser();
    },

    login: function () {
      var controller = this.get('loginController');
      var loginName = controller.get('loginName').toLowerCase();
      controller.set('loginName', loginName);
      var hash = window.btoa(loginName + ":" + controller.get('password'));
      var usr = '';

      if (App.testMode) {
        if (loginName === "admin" && controller.get('password') === 'admin') {
          usr = 'admin';
        } else if (loginName === 'user' && controller.get('password') === 'user') {
          usr = 'user';
        }
      }

      App.ajax.send({
        name: 'router.login',
        sender: this,
        data: {
          auth: "Basic " + hash,
          usr: usr,
          loginName: loginName
        },
        beforeSend: 'authBeforeSend',
        success: 'loginSuccessCallback',
        error: 'loginErrorCallback'
      });

    },

    authBeforeSend: function(opt, xhr, data) {
      xhr.setRequestHeader("Authorization", data.auth);
    },

    loginSuccessCallback: function(data, opt, params) {
      console.log('login success');
      var d = data;
      var isAdmin = data.Users.roles.indexOf('admin') >= 0;
      if (isAdmin) {
        var controller = this.get('loginController');
        this.setAuthenticated(true);
        this.setLoginName(params.loginName);
        App.usersMapper.map({"items": [data]});
        this.setUser(App.User.find(params.loginName));
        this.transitionTo(this.getSection());
        controller.postLogin(true);
      }
      else {
        App.ajax.send({
          name: 'router.login2',
          sender: this,
          data: {
            loginName: params.loginName,
            loginData: data
          },
          success: 'login2SuccessCallback',
          error: 'login2ErrorCallback'
        });
      }
    },

    loginErrorCallback: function(request, ajaxOptions, error, opt) {
      var controller = this.get('loginController');
      console.log("login error: " + error);
      this.setAuthenticated(false);
      controller.postLogin(false);
    },

    login2SuccessCallback: function (clusterResp, opt, params) {
      var controller = this.get('loginController');
      if (clusterResp.items.length) {
        this.setAuthenticated(true);
        this.setLoginName(params.loginName);
        App.usersMapper.map({"items": [params.loginData]});
        this.setUser(App.User.find(params.loginName));
        this.transitionTo(this.getSection());
        controller.postLogin(true);
      }
      else {
        controller.set('errorMessage', Em.I18n.t('router.hadoopClusterNotSetUp'));
      }
    },

    login2ErrorCallback: function (req) {
      console.log("Server not responding: " + req.statusCode);
    },

    setAmbariStacks: function () {
      App.ajax.send({
        name: 'router.set_ambari_stacks',
        sender: this,
        success: 'setAmbariStacksSuccessCallback',
        error: 'setAmbariStacksErrorCallback'
      });
    },

    setAmbariStacksSuccessCallback: function (jsonData) {
      console.log("TRACE: In success function for the setAmbariStacks call");
      var stacks = [];
      jsonData.forEach(function (_stack) {
        stacks.pushObject({
          name: _stack.name,
          version: _stack.version
        });
      }, this);
      App.db.setAmbariStacks(stacks);
      console.log('TRACEIINNGG: ambaristacks: ' + JSON.stringify(App.db.getAmbariStacks()));
    },

    setAmbariStacksErrorCallback: function (request, ajaxOptions, error) {
      console.log("TRACE: In error function for the setAmbariStacks call");
      console.log("TRACE: error code status is: " + request.status);
      console.log('Error message is: ' + request.responseText);
    },

    getSection: function () {
      if (App.testMode) {
        if (App.alwaysGoToInstaller) {
          return 'installer';
        } else {
          return 'main.index';
        }
      }
      App.clusterStatus.updateFromServer();
      var clusterStatusOnServer = App.clusterStatus.get('value');
      if (!localStorage.getObject('ambari').app.user.admin || clusterStatusOnServer && (clusterStatusOnServer.clusterState === 'CLUSTER_STARTED_5' ||
        clusterStatusOnServer.clusterState === 'ADD_HOSTS_COMPLETED_5' || clusterStatusOnServer.clusterState === 'STACK_UPGRADE_COMPLETED' ||
        clusterStatusOnServer.clusterState === 'REASSIGN_MASTER_COMPLETED') ||clusterStatusOnServer.clusterState === 'SECURITY_COMPLETED' ) {
        return 'main.index';
      } else if (clusterStatusOnServer && clusterStatusOnServer.wizardControllerName === App.router.get('addHostController.name')) {
        // if wizardControllerName == "addHostController", then it means someone closed the browser or the browser was crashed when we were last in Add Hosts wizard
        return 'main.hostAdd';
      } else if (clusterStatusOnServer && (clusterStatusOnServer.wizardControllerName === App.router.get('addSecurityController.name') || clusterStatusOnServer.wizardControllerName === App.router.get('mainAdminSecurityDisableController.name'))) {
        // if wizardControllerName == "addSecurityController", then it means someone closed the browser or the browser was crashed when we were last in Add Security wizard
        return 'main.admin.adminSecurity';
      } else if (clusterStatusOnServer && clusterStatusOnServer.wizardControllerName === App.router.get('addServiceController.name')) {
        // if wizardControllerName == "addHostController", then it means someone closed the browser or the browser was crashed when we were last in Add Hosts wizard
        return 'main.serviceAdd';
      } else if (clusterStatusOnServer && clusterStatusOnServer.wizardControllerName === App.router.get('stackUpgradeController.name')) {
        // if wizardControllerName == "stackUpgradeController", then it means someone closed the browser or the browser was crashed when we were last in Stack Upgrade wizard
        return 'main.stackUpgrade';
      } else if (clusterStatusOnServer && clusterStatusOnServer.wizardControllerName === App.router.get('reassignMasterController.name')) {
        // if wizardControllerName == "reassignMasterController", then it means someone closed the browser or the browser was crashed when we were last in Reassign Master wizard
        return 'main.reassignMaster';
      } else {
        // if wizardControllerName == "installerController", then it means someone closed the browser or the browser was crashed when we were last in Installer wizard
        return 'installer';
      }
    },

    logOff: function (context) {
      $('title').text('Ambari');
      var hash = window.btoa(this.get('loginController.loginName') + ":" + this.get('loginController.password'));

      App.router.get('mainController').stopPolling();
      // App.db.cleanUp() must be called before router.clearAllSteps().
      // otherwise, this.set('installerController.currentStep, 0) would have no effect
      // since it's a computed property but we are not setting it as a dependent of App.db.
      App.db.cleanUp();
      App.set('isAdmin', false);
      this.set('loggedIn', false);
      this.clearAllSteps();
      console.log("Log off: " + App.router.getClusterName());
      this.set('loginController.loginName', '');
      this.set('loginController.password', '');
      // When logOff is called by Sign Out button, context contains event object. As it is only case we should send logoff request, we are checking context below.
      if (!App.testMode && context) {
        App.ajax.send({
          name: 'router.logoff',
          sender: this,
          data: {
            auth: "Basic " + hash
          },
          beforeSend: 'authBeforeSend',
          success: 'logOffSuccessCallback',
          error:'logOffErrorCallback'
        });
      }
      this.transitionTo('login', context);
    },

    logOffSuccessCallback: function (data) {
      console.log("invoked logout on the server successfully");
    },

    logOffErrorCallback: function (req) {
      console.log("failed to invoke logout on the server");
    },

    root: Em.Route.extend({
      index: Em.Route.extend({
        route: '/',
        redirectsTo: 'login'
      }),

      login: Em.Route.extend({
        route: '/login',

        /**
         *  If the user is already logged in, redirect to where the user was previously
         */
        enter: function (router, context) {
          if (router.getAuthenticated()) {
            Ember.run.next(function () {
              console.log(router.getLoginName() + ' already authenticated.  Redirecting...');
              router.transitionTo(router.getSection(), context);
            });
          }
        },

        connectOutlets: function (router, context) {
          $('title').text(Em.I18n.t('app.name'));
          console.log('/login:connectOutlet');
          console.log('currentStep is: ' + router.getInstallerCurrentStep());
          console.log('authenticated is: ' + router.getAuthenticated());
          router.get('applicationController').connectOutlet('login');
        }
      }),

      installer: require('routes/installer'),

      main: require('routes/main'),

      logoff: function (router, context) {
        router.logOff(context);
      }

    })
  });
  
});
window.require.register("routes/add_host_routes", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  module.exports = Em.Route.extend({
    route: '/hosts/add',

    enter: function (router) {
      console.log('in /hosts/add:enter');

      Ember.run.next(function () {
        var addHostController = router.get('addHostController');
        App.router.get('updateController').set('isWorking', false);
        App.ModalPopup.show({
          classNames: ['full-width-modal'],
          header:Em.I18n.t('hosts.add.header'),
          bodyClass:  App.AddHostView.extend({
            controllerBinding: 'App.router.addHostController'
          }),
          primary:Em.I18n.t('form.cancel'),
          secondary: null,
          showFooter: false,

          onPrimary:function () {
            this.hide();
            App.router.get('updateController').set('isWorking', true);
            router.transitionTo('hosts.index');
          },
          onClose: function() {
            this.hide();
            App.router.get('updateController').set('isWorking', true);
            router.transitionTo('hosts.index');
          },
          didInsertElement: function(){
            this.fitHeight();
          }
        });
        App.clusterStatus.updateFromServer();
        var currentClusterStatus = App.clusterStatus.get('value');

        if (currentClusterStatus) {
          switch (currentClusterStatus.clusterState) {
            case 'ADD_HOSTS_DEPLOY_PREP_2' :
              addHostController.setCurrentStep('5');
              App.db.data = currentClusterStatus.localdb;
              break;
            case 'ADD_HOSTS_INSTALLING_3' :
            case 'SERVICE_STARTING_3' :
              addHostController.setCurrentStep('6');
              App.db.data = currentClusterStatus.localdb;
              break;
            case 'ADD_HOSTS_INSTALLED_4' :
              addHostController.setCurrentStep('7');
              App.db.data = currentClusterStatus.localdb;
              break;
            default:
              break;
          }
        }

        router.transitionTo('step' + addHostController.get('currentStep'));
      });

    },

    /*connectOutlets: function (router, context) {
      console.log('in /hosts/add:connectOutlets');
      router.get('mainController').connectOutlet('addHost');
    },*/

    step1: Em.Route.extend({
      route: '/step1',
      connectOutlets: function (router) {
        console.log('in addHost.step1:connectOutlets');
        var controller = router.get('addHostController');
        controller.setCurrentStep('1');
        controller.set('hideBackButton', true);
        controller.dataLoading().done(function () {
          controller.loadServicesFromServer();
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep2', controller.get('content'));
        })
      },

      next: function (router) {
        var controller = router.get('addHostController');
        controller.save('installOptions');
        //hosts was saved to content.hosts inside wizardStep2Controller
        controller.save('hosts');
        router.transitionTo('step2');
        App.db.setBootStatus(false);
      },
      evaluateStep: function (router) {
        console.log('in addHost.step1:evaluateStep');
        var addHostController = router.get('addHostController');
        var wizardStep2Controller = router.get('wizardStep2Controller');

        wizardStep2Controller.set('hasSubmitted', true);

        if (!wizardStep2Controller.get('isSubmitDisabled')) {
          wizardStep2Controller.evaluateStep();
        }
      }
    }),

    step2: Em.Route.extend({
      route: '/step2',
      connectOutlets: function (router) {
        console.log('in addHost.step2:connectOutlets');
        var controller = router.get('addHostController');
        controller.setCurrentStep('2');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep3', controller.get('content'));
        })
      },
      back: function(router){
        router.transitionTo('step1');
      },
      exit: function (router) {
        router.get('wizardStep3Controller').set('stopBootstrap', true);
      },
      next: function (router, context) {
        var addHostController = router.get('addHostController');
        var wizardStep3Controller = router.get('wizardStep3Controller');
        addHostController.saveConfirmedHosts(wizardStep3Controller);
        addHostController.saveClients();

        App.db.setBootStatus(true);
        router.transitionTo('step3');
      },
      /**
       * Wrapper for remove host action.
       * Since saving data stored in addHostController, we should call this from router
       * @param router
       * @param context Array of hosts to delete
       */
      removeHosts: function (router, context) {
        console.log('in addHost.step2.removeHosts:hosts to delete ', context);
        var controller = router.get('addHostController');
        controller.removeHosts(context);
      }
    }),

    step3: Em.Route.extend({
      route: '/step3',
      connectOutlets: function (router) {
        console.log('in addHost.step3:connectOutlets');
        var controller = router.get('addHostController');
        controller.setCurrentStep('3');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep6', controller.get('content'));
          var wizardStep6Controller = router.get('wizardStep6Controller');
          wizardStep6Controller.set('isMasters', true);
        })
      },
      back: function(router) {
        var controller = router.get('addHostController');
        if(!controller.get('content.skipMasterStep')) {
          router.transitionTo('step2');
        }
        else {
          router.transitionTo('step1');
        }
      },
      next: function (router, context) {
        var addHostController = router.get('addHostController');
        var wizardStep6Controller = router.get('wizardStep6Controller');
        addHostController.saveHbZk(wizardStep6Controller);
        App.db.setBootStatus(true);
        addHostController.loadServicesFromServer();
        router.transitionTo('step4');
      }
    }),

    step4: Em.Route.extend({
      route: '/step4',
      connectOutlets: function (router, context) {
        console.log('in addHost.step4:connectOutlets');
        var controller = router.get('addHostController');
        controller.setCurrentStep('4');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep6', controller.get('content'));
          var wizardStep6Controller = router.get('wizardStep6Controller');
          wizardStep6Controller.set('isMasters', false);
        });
      },
      back: function(router) {
        var controller = router.get('addHostController');
        if(!controller.get('content.skipMasterStep')) {
          router.transitionTo('step2');
        }
        else {
          router.transitionTo('step1');
        }
      },
      next: function (router) {
        var addHostController = router.get('addHostController');
        var wizardStep6Controller = router.get('wizardStep6Controller');

        if (wizardStep6Controller.validate()) {
          addHostController.saveSlaveComponentHosts(wizardStep6Controller);
          addHostController.get('content').set('serviceConfigProperties', null);
          App.db.setServiceConfigProperties(null);
          addHostController.loadAdvancedConfigs();
          var wizardStep7Controller = router.get('wizardStep7Controller');
          wizardStep7Controller.set('content', addHostController.get('content'));
          wizardStep7Controller.loadStep();
          addHostController.saveServiceConfigProperties(wizardStep7Controller);
          router.transitionTo('step5');
        }
      }
    }),

    step5: Em.Route.extend({
      route: '/step5',
      connectOutlets: function (router, context) {
        console.log('in addHost.step5:connectOutlets');
        var controller = router.get('addHostController');
        controller.setCurrentStep('5');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep8', controller.get('content'));
        })
      },
      back: Em.Router.transitionTo('step4'),
      next: function (router) {
        var addHostController = router.get('addHostController');
        var wizardStep8Controller = router.get('wizardStep8Controller');
        addHostController.installServices();
        addHostController.setInfoForStep9();

        // We need to do recovery based on whether we are in Add Host or Installer wizard
        addHostController.saveClusterState('ADD_HOSTS_INSTALLING_3');
        wizardStep8Controller.set('servicesInstalled', true);
        router.transitionTo('step6');
      }
    }),

    step6: Em.Route.extend({
      route: '/step6',
      connectOutlets: function (router, context) {
        console.log('in addHost.step6:connectOutlets');
        var controller = router.get('addHostController');
        controller.setCurrentStep('6');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          if (!App.testMode) {              //if test mode is ON don't disable prior steps link.
            controller.setLowerStepsDisable(6);
          }
          controller.connectOutlet('wizardStep9', controller.get('content'));
        })
      },
      back: Em.Router.transitionTo('step5'),
      retry: function(router,context) {
        var addHostController = router.get('addHostController');
        var wizardStep9Controller = router.get('wizardStep9Controller');
        if (wizardStep9Controller.get('showRetry')) {
          if (wizardStep9Controller.get('content.cluster.status') === 'INSTALL FAILED') {
            var isRetry = true;
            addHostController.installServices(isRetry);
            addHostController.setInfoForStep9();
            wizardStep9Controller.resetHostsForRetry();
            // We need to do recovery based on whether we are in Add Host or Installer wizard
            addHostController.saveClusterState('ADD_HOSTS_INSTALLING_3');
          }
          wizardStep9Controller.navigateStep();
        }
      },
      unroutePath: function() {
        return false;
      },
      next: function (router) {
        var addHostController = router.get('addHostController');
        var wizardStep9Controller = router.get('wizardStep9Controller');
        addHostController.saveInstalledHosts(wizardStep9Controller);

        // We need to do recovery based on whether we are in Add Host or Installer wizard
        addHostController.saveClusterState('ADD_HOSTS_INSTALLED_4');

        router.transitionTo('step7');
      }
    }),

    step7: Em.Route.extend({
      route: '/step7',
      connectOutlets: function (router, context) {
        console.log('in addHost.step6:connectOutlets');
        var controller = router.get('addHostController');
        controller.setCurrentStep('7');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          if (!App.testMode) {              //if test mode is ON don't disable prior steps link.
            controller.setLowerStepsDisable(7);
          }
          controller.connectOutlet('wizardStep10', controller.get('content'));
          App.router.get('updateController').set('isWorking', true);
        })
      },
      back: Em.Router.transitionTo('step6'),
      complete: function (router, context) {
        if (true) {   // this function will be moved to installerController where it will validate
          var addHostController = router.get('addHostController');
          App.router.get('updateController').updateAll();
          addHostController.finish();
          $(context.currentTarget).parents("#modal").find(".close").trigger('click');

          // We need to do recovery based on whether we are in Add Host or Installer wizard
          addHostController.saveClusterState('ADD_HOSTS_COMPLETED_5');

          router.transitionTo('main.index');
        } else {
          console.log('cluster installation failure');
          //$(context.currentTarget).parents("#modal").find(".close").trigger('click');
        }
      }
    }),

    backToHostsList: function (router, event) {
      App.router.get('updateController').set('isWorking', true);
      router.transitionTo('hosts.index');
    },

    gotoStep1: Em.Router.transitionTo('step1'),

    gotoStep2: Em.Router.transitionTo('step2'),

    gotoStep3: Em.Router.transitionTo('step3'),

    gotoStep4: Em.Router.transitionTo('step4'),

    gotoStep5: Em.Router.transitionTo('step5'),

    gotoStep6: Em.Router.transitionTo('step6'),

    gotoStep7: Em.Router.transitionTo('step7'),

    gotoStep8: Em.Router.transitionTo('step8'),

    gotoStep9: Em.Router.transitionTo('step9'),

    gotoStep10: Em.Router.transitionTo('step10')

  });
  
});
window.require.register("routes/add_security", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var App = require('app');

  module.exports = Em.Route.extend({
    route: '/addSecurity',
    enter: function (router) {
      console.log('in /security/add:enter');

      Ember.run.next(function () {
        //after refresh check if the wizard is open then restore it
        if (router.get('mainAdminSecurityController').getAddSecurityWizardStatus() === 'RUNNING') {
          var mainAdminSecurityController = router.get('mainAdminSecurityController');
          var addSecurityController = router.get('addSecurityController');
          var currentStep = router.get('addSecurityController').get('currentStep');
          App.router.get('updateController').set('isWorking', false);
          App.ModalPopup.show({
              classNames: ['full-width-modal'],
              header: Em.I18n.t('admin.addSecurity.header'),
              bodyClass: App.MainAdminSecurityAddMenuView.extend({
                controllerBinding: 'App.router.addSecurityController'
              }),
              primary: Em.I18n.t('form.cancel'),
              secondary: null,
              showFooter: false,

              onClose: function () {
                var self = this;
                if (router.get('addSecurityController.currentStep') == 4) {
                  var controller = router.get('mainAdminSecurityAddStep4Controller');
                  if (!controller.get('isSubmitDisabled')) {
                    router.get('mainAdminSecurityAddStep4Controller').clearStep();
                    self.proceedOnClose();
                    return;
                  }
                  var applyingConfigStage = router.get('mainAdminSecurityAddStep4Controller.stages').findProperty('stage', 'stage3');
                  if (applyingConfigStage) {
                    if (!applyingConfigStage.get('isCompleted')) {
                      if (applyingConfigStage.get('isStarted')) {
                        App.showAlertPopup(Em.I18n.t('admin.security.applying.config.header'), Em.I18n.t('admin.security.applying.config.body'));
                      } else {
                        App.showConfirmationPopup(function () {
                          self.proceedOnClose();
                        }, Em.I18n.t('admin.addSecurity.enable.onClose'));
                      }
                    } else {
                      App.showConfirmationPopup(function () {},
                        Em.I18n.t('admin.addSecurity.enable.after.stage2.onClose'),
                        function () {
                          self.proceedOnClose();
                        });
                    }
                    return;
                  }
                }
                router.get('mainAdminSecurityAddStep4Controller').clearStep();
                App.db.setSecurityDeployStages(undefined);
                self.proceedOnClose();
              },
              proceedOnClose: function () {
                this.hide();
                router.get('mainAdminSecurityAddStep4Controller').clearStep();
                router.get('addSecurityController.content.services').clear();
                router.set('addSecurityController.content.serviceConfigProperties', null);
                App.router.get('updateController').set('isWorking', true);
                mainAdminSecurityController.setAddSecurityWizardStatus(null);
                App.db.setSecurityDeployStages(undefined);
                router.get('addSecurityController').setCurrentStep(1);
                App.clusterStatus.setClusterStatus({
                  clusterName: router.get('content.cluster.name'),
                  clusterState: 'SECURITY_COMPLETED',
                  wizardControllerName: router.get('addSecurityController.name'),
                  localdb: App.db.data.AddSecurity
                });
                router.transitionTo('adminSecurity.index');
              },
              didInsertElement: function () {
                this.fitHeight();
              }
            }
          );

          App.router.transitionTo('step' + currentStep);
        } else {
          router.transitionTo('adminSecurity.index');
        }
      });
    },

    step1: Em.Route.extend({
      route: '/start',
      enter: function (router) {
        router.get('addSecurityController').setCurrentStep('1');
        if(!App.testMode){
          App.clusterStatus.setClusterStatus({
            clusterName: this.get('clusterName'),
            clusterState: 'ADD_SECURITY_STEP_1',
            wizardControllerName: router.get('addSecurityController.name'),
            localdb: App.db.data.AddSecurity
          });
        }
      },

      connectOutlets: function (router) {
        console.log('in addSecurity.step1:connectOutlets');
        var controller = router.get('addSecurityController');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('mainAdminSecurityAddStep1', controller.get('content'));
        })
      },

      next: function (router) {
        var addSecurityController = router.get('addSecurityController');
        addSecurityController.get('content').set('serviceConfigProperties', null);
        App.db.setSecureConfigProperties(null);
        router.transitionTo('step2');
      }
    }),

    step2: Em.Route.extend({
      route: '/configure',

      enter: function (router) {
        router.get('addSecurityController').setCurrentStep('2');
        if(!App.testMode){
          App.clusterStatus.setClusterStatus({
            clusterName: this.get('clusterName'),
            clusterState: 'ADD_SECURITY_STEP_2',
            wizardControllerName: router.get('addSecurityController.name'),
            localdb:  App.db.data.AddSecurity
          });
        }
      },
      connectOutlets: function (router) {
        console.log('in addSecurity.step2:connectOutlets');
        var controller = router.get('addSecurityController');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('mainAdminSecurityAddStep2', controller.get('content'));
        })
      },
      back: Em.Router.transitionTo('step1'),
      next: function (router) {
        var addSecurityController = router.get('addSecurityController');
        var addSecurityStep2Controller = router.get('mainAdminSecurityAddStep2Controller');
        addSecurityController.saveServiceConfigProperties(addSecurityStep2Controller);
        router.transitionTo('step3');
      }
    }),

    step3: Em.Route.extend({
      route: '/principal_keytab',

      enter: function (router) {
        router.get('addSecurityController').setCurrentStep('3');
        if(!App.testMode){
          App.clusterStatus.setClusterStatus({
            clusterName: this.get('clusterName'),
            clusterState: 'ADD_SECURITY_STEP_3',
            wizardControllerName: router.get('addSecurityController.name'),
            localdb:  App.db.data.AddSecurity
          });
        }
      },
      connectOutlets: function (router) {
        console.log('in addSecurity.step3:connectOutlets');
        var controller = router.get('addSecurityController');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('mainAdminSecurityAddStep3', controller.get('content'));
        })
      },
      back: Em.Router.transitionTo('step2'),
      next: function (router) {
        App.db.setSecurityDeployStages(undefined);
        router.transitionTo('step4');
      }
    }),

    step4: Em.Route.extend({
      route: '/apply',

      enter: function (router) {
        router.get('addSecurityController').setCurrentStep('4');
      },

      connectOutlets: function (router) {
        console.log('in addSecurity.step4:connectOutlets');
        var controller = router.get('addSecurityController');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.setLowerStepsDisable(4);
          controller.connectOutlet('mainAdminSecurityAddStep4', controller.get('content'));
        })
      },
      unroutePath: function () {
        return false;
      },
      back: function (router, context) {
        var controller = router.get('mainAdminSecurityAddStep4Controller');
        if (!controller.get('isBackBtnDisabled')) {
          router.transitionTo('step3');
        }
      },
      done: function (router, context) {
        var controller = router.get('mainAdminSecurityAddStep4Controller');
        if (!controller.get('isSubmitDisabled')) {
          $(context.currentTarget).parents("#modal").find(".close").trigger('click');
        }
      }
    }),

    gotoStep1: Em.Router.transitionTo('step1'),

    gotoStep2: Em.Router.transitionTo('step2'),

    gotoStep3: Em.Router.transitionTo('step3'),

    gotoStep4: Em.Router.transitionTo('step4')

  });

  
});
window.require.register("routes/add_service_routes", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  module.exports = Em.Route.extend({
    route: '/services/add',

    enter: function (router) {
      console.log('in /service/add:enter');
      if (App.db.getUser().admin) {
        Em.run.next(function () {
          var addServiceController = router.get('addServiceController');
          App.router.get('updateController').set('isWorking', false);
          App.ModalPopup.show({
            classNames: ['full-width-modal'],
            header:Em.I18n.t('services.add.header'),
            bodyClass:  App.AddServiceView.extend({
              controllerBinding: 'App.router.addServiceController'
            }),
            primary:Em.I18n.t('form.cancel'),
            showFooter: false,
            secondary: null,

            onPrimary:function () {
              this.hide();
              App.router.get('updateController').set('isWorking', true);
              App.router.transitionTo('main.services');
            },
            onClose: function() {
              this.hide();
              App.router.get('updateController').set('isWorking', true);
              App.router.transitionTo('main.services')
            },
            didInsertElement: function(){
              this.fitHeight();
            }
          });

          App.clusterStatus.updateFromServer();
          var currentClusterStatus = App.clusterStatus.get('value');

          if (currentClusterStatus) {
            switch (currentClusterStatus.clusterState) {
              case 'ADD_SERVICES_DEPLOY_PREP_2' :
                addServiceController.setCurrentStep('5');
                App.db.data = currentClusterStatus.localdb;
                break;
              case 'ADD_SERVICES_INSTALLING_3' :
              case 'SERVICE_STARTING_3' :
                addServiceController.setCurrentStep('6');
                App.db.data = currentClusterStatus.localdb;
                break;
              case 'ADD_SERVICES_INSTALLED_4' :
                addServiceController.setCurrentStep('7');
                App.db.data = currentClusterStatus.localdb;
                break;
              default:
                break;
            }
          }

          router.transitionTo('step' + addServiceController.get('currentStep'));
        });
      } else {
        Em.run.next(function () {
          App.router.transitionTo('main.services');
        });
      }

    },

    /*connectOutlets: function (router) {
      console.log('in /service/add:connectOutlets');
      router.get('mainController').connectOutlet('addService');
    },*/

    step1: Em.Route.extend({
      route: '/step1',
      connectOutlets: function (router) {
        console.log('in addService.step1:connectOutlets');
        var controller = router.get('addServiceController');
        controller.setCurrentStep('1');
        controller.set('hideBackButton', true);
        controller.dataLoading().done(function () {
          controller.loadServicesFromServer();
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep4', controller.get('content.services'));
        })
      },
      next: function (router) {
        var addServiceController = router.get('addServiceController');
        var wizardStep4Controller = router.get('wizardStep4Controller');
        addServiceController.saveServices(wizardStep4Controller);
        addServiceController.saveClients(wizardStep4Controller);
        App.db.setMasterComponentHosts(undefined);
        router.transitionTo('step2');
      }
    }),

    step2: Em.Route.extend({
      route: '/step2',
      connectOutlets: function (router) {
        console.log('in addService.step2:connectOutlets');
        var controller = router.get('addServiceController');
        controller.setCurrentStep('2');
        controller.set('hideBackButton', false);
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep5', controller.get('content'));
        })

      },
      back: Em.Router.transitionTo('step1'),
      next: function (router) {
        var addServiceController = router.get('addServiceController');
        var wizardStep5Controller = router.get('wizardStep5Controller');
        addServiceController.saveMasterComponentHosts(wizardStep5Controller);
        App.db.setSlaveComponentHosts(undefined);
        router.transitionTo('step3');
      }
    }),

    step3: Em.Route.extend({
      route: '/step3',
      connectOutlets: function (router) {
        console.log('in addService.step3:connectOutlets');
        var controller = router.get('addServiceController');
        controller.setCurrentStep('3');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep6', controller.get('content'));
          var wizardStep6Controller = router.get('wizardStep6Controller');
          wizardStep6Controller.set('isMasters', false);
        })
      },
      back: function(router){
        var controller = router.get('addServiceController');
        if(!controller.get('content.skipMasterStep')){
          router.transitionTo('step2');
        } else {
          router.transitionTo('step1');
        }
      },
      next: function (router) {
        var addServiceController = router.get('addServiceController');
        var wizardStep6Controller = router.get('wizardStep6Controller');

        if (wizardStep6Controller.validate()) {
          addServiceController.saveSlaveComponentHosts(wizardStep6Controller);
          addServiceController.get('content').set('serviceConfigProperties', null);
          App.db.setServiceConfigProperties(null);
          addServiceController.loadAdvancedConfigs();
          router.transitionTo('step4');
        }
      }
    }),

    step4: Em.Route.extend({
      route: '/step4',
      connectOutlets: function (router) {
        console.log('in addService.step4:connectOutlets');
        var controller = router.get('addServiceController');
        controller.setCurrentStep('4');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep7', controller.get('content'));
        })
      },
      back: function(router){
        var controller = router.get('addServiceController');
        if(!controller.get('content.skipSlavesStep')){
          router.transitionTo('step3');
        } else if(!controller.get('content.skipMasterStep')) {
          router.transitionTo('step2');
        } else {
          router.transitionTo('step1');
        }
      },
      next: function (router) {
        var addServiceController = router.get('addServiceController');
        var wizardStep7Controller = router.get('wizardStep7Controller');
        addServiceController.saveServiceConfigProperties(wizardStep7Controller);
        router.transitionTo('step5');
      }
    }),

    step5: Em.Route.extend({
      route: '/step5',
      connectOutlets: function (router, context) {
        console.log('in addService.step5:connectOutlets');
        var controller = router.get('addServiceController');
        controller.setCurrentStep('5');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep8', controller.get('content'));
        })
      },
      back: Em.Router.transitionTo('step4'),
      next: function (router) {
        var addServiceController = router.get('addServiceController');
        var wizardStep8Controller = router.get('wizardStep8Controller');
        addServiceController.installServices();
        addServiceController.setInfoForStep9();

        addServiceController.saveClusterState('ADD_SERVICES_INSTALLING_3');
        wizardStep8Controller.set('servicesInstalled', true);
        router.transitionTo('step6');
      }
    }),

    step6: Em.Route.extend({
      route: '/step6',
      connectOutlets: function (router, context) {
        console.log('in addService.step6:connectOutlets');
        var controller = router.get('addServiceController');
        controller.setCurrentStep('6');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          if (!App.testMode) {              //if test mode is ON don't disable prior steps link.
            controller.setLowerStepsDisable(6);
          }
          controller.connectOutlet('wizardStep9', controller.get('content'));
        })
      },
      back: Em.Router.transitionTo('step5'),
      retry: function(router,context) {
        var addServiceController = router.get('addServiceController');
        var wizardStep9Controller = router.get('wizardStep9Controller');
        if (wizardStep9Controller.get('showRetry')) {
          if (wizardStep9Controller.get('content.cluster.status') === 'INSTALL FAILED') {
            var isRetry = true;
            addServiceController.installServices(isRetry);
            addServiceController.setInfoForStep9();
            wizardStep9Controller.resetHostsForRetry();
            // We need to do recovery based on whether we are in Add Host or Installer wizard
            addServiceController.saveClusterState('ADD_SERVICES_INSTALLING_3');
          }
          wizardStep9Controller.navigateStep();
        }
      },
      unroutePath: function() {
        return false;
      },
      next: function (router) {
        var addServiceController = router.get('addServiceController');
        var wizardStep9Controller = router.get('wizardStep9Controller');
        addServiceController.saveInstalledHosts(wizardStep9Controller);

        // We need to do recovery based on whether we are in Add Host or Installer wizard
        addServiceController.saveClusterState('ADD_SERVICES_INSTALLED_4');

        router.transitionTo('step7');
      }
    }),

    step7: Em.Route.extend({
      route: '/step7',
      connectOutlets: function (router, context) {
        console.log('in addService.step7:connectOutlets');
        var controller = router.get('addServiceController');
        controller.setCurrentStep('7');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep10', controller.get('content'));
        })
      },
      back: Em.Router.transitionTo('step6'),
      complete: function (router, context) {
        if (true) {   // this function will be moved to installerController where it will validate
          var addServiceController = router.get('addServiceController');
          App.router.get('updateController').updateAll();
          addServiceController.finish();
          $(context.currentTarget).parents("#modal").find(".close").trigger('click');

          // We need to do recovery based on whether we are in Add Host or Installer wizard
          addServiceController.saveClusterState('ADD_SERVICES_COMPLETED_5');
        }
      }
    }),

    gotoStep1: Em.Router.transitionTo('step1'),

    gotoStep2: Em.Router.transitionTo('step2'),

    gotoStep3: Em.Router.transitionTo('step3'),

    gotoStep4: Em.Router.transitionTo('step4'),

    gotoStep5: Em.Router.transitionTo('step5'),

    gotoStep6: Em.Router.transitionTo('step6'),

    gotoStep7: Em.Router.transitionTo('step7'),

    backToServices: function (router) {
      App.router.get('updateController').set('isWorking', true);
      router.transitionTo('services');
    }

  });
  
});
window.require.register("routes/installer", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  module.exports = Em.Route.extend({
    route: '/installer',
    App: require('app'),

    enter: function (router) {
      console.log('in /installer:enter');

      App.clusterStatus.set('wizardControllerName',App.router.get('installerController.name'));

      if (router.getAuthenticated()) {
        var name = 'Cluster Install Wizard';
        $('title').text('Ambari - ' + name);

        if (App.db.getUser().admin) {
          router.get('mainController').stopPolling();
          console.log('In installer with successful authenticated');
          console.log('current step=' + router.get('installerController.currentStep'));
          Ember.run.next(function () {
            var installerController = router.get('installerController');

              App.clusterStatus.updateFromServer();
              var currentClusterStatus = App.clusterStatus.get('value');

              if (currentClusterStatus) {
                switch (currentClusterStatus.clusterState) {
                  case 'CLUSTER_DEPLOY_PREP_2' :
                    installerController.setCurrentStep('8');
                    App.db.data = currentClusterStatus.localdb;
                    break;
                  case 'CLUSTER_INSTALLING_3' :
                  case 'SERVICE_STARTING_3' :
                    if(!installerController.get('isStep9')){
                      installerController.setCurrentStep('9');
                    }
                    App.db.data = currentClusterStatus.localdb;
                    break;
                  case 'CLUSTER_INSTALLED_4' :
                    if(!installerController.get('isStep10')){
                      installerController.setCurrentStep('10');
                    }
                    App.db.data = currentClusterStatus.localdb;
                    break;
                  case 'CLUSTER_STARTED_5' :
                    router.transitionTo('main.index');
                    break;
                  default:
                    break;
                }
              }
            router.transitionTo('step' + installerController.get('currentStep'));
          });
        } else {
          Em.run.next(function () {
            App.router.transitionTo('main.services');
          });
        }
      } else {
        console.log('In installer but its not authenticated');
        console.log('value of authenticated is: ' + router.getAuthenticated());
        Ember.run.next(function () {
          router.transitionTo('login');
        });
      }
    },

    routePath: function (router, event) {
      console.log("INFO: value of router is: " + router);
      console.log("INFO: value of event is: " + event);
      router.setNavigationFlow(event);
      if (!router.isFwdNavigation) {
        this._super(router, event);
      } else {
        router.set('backBtnForHigherStep', true);

        var installerController = router.get('installerController');
        router.transitionTo('step' + installerController.get('currentStep'));
      }
    },

    connectOutlets: function (router, context) {
      console.log('in /installer:connectOutlets');
      router.get('applicationController').connectOutlet('installer');
    },

    step0: Em.Route.extend({
      route: '/step0',
      connectOutlets: function (router) {
        console.log('in installer.step0:connectOutlets');
        var controller = router.get('installerController');
        controller.setCurrentStep('0');
        controller.loadAllPriorSteps();
        controller.connectOutlet('wizardStep0', controller.get('content'));
      },

      next: function (router) {
        var installerController = router.get('installerController');
        installerController.save('cluster');
        router.transitionTo('step1');
      }
    }),

    step1: Em.Route.extend({
      route: '/step1',
      connectOutlets: function (router) {
        console.log('in installer.step1:connectOutlets');
        var controller = router.get('installerController');
        controller.setCurrentStep('1');
        controller.loadAllPriorSteps();
        controller.connectOutlet('wizardStep1', controller.get('content'));
      },
      back: Em.Router.transitionTo('step0'),
      next: function (router) {
        var wizardStep1Controller = router.get('wizardStep1Controller');
        var installerController = router.get('installerController');
        installerController.saveStacks(wizardStep1Controller);
        App.db.setService(undefined);
        installerController.clearInstallOptions();
        router.transitionTo('step2');
      }
    }),

    step2: Em.Route.extend({
      route: '/step2',
      connectOutlets: function (router, context) {
        router.setNavigationFlow('step2');

        var controller = router.get('installerController');
        controller.setCurrentStep('2');
        controller.loadAllPriorSteps();
        controller.connectOutlet('wizardStep2', controller.get('content'));
      },
      back: Em.Router.transitionTo('step1'),
      next: function (router) {
        var controller = router.get('installerController');
        controller.save('installOptions');
        //hosts was saved to content.hosts inside wizardStep2Controller
        controller.save('hosts');
        router.transitionTo('step3');
      }
    }),

    step3: Em.Route.extend({
      route: '/step3',
      connectOutlets: function (router) {
        console.log('in installer.step3:connectOutlets');
        var controller = router.get('installerController');
        controller.setCurrentStep('3');
        controller.loadAllPriorSteps();
        controller.connectOutlet('wizardStep3', controller.get('content'));
      },
      back: function(router){
          router.transitionTo('step2');
      },
      next: function (router, context) {
        var installerController = router.get('installerController');
        var wizardStep3Controller = router.get('wizardStep3Controller');
        installerController.saveConfirmedHosts(wizardStep3Controller);
        App.db.setBootStatus(true);
        installerController.loadServicesFromServer();
        router.transitionTo('step4');
      },
      exit: function (router) {
        router.get('wizardStep3Controller').set('stopBootstrap', true);
      },
      /**
       * Wrapper for remove host action.
       * Since saving data stored in installerController, we should call this from router
       * @param router
       * @param context Array of hosts to delete
       */
      removeHosts: function (router, context) {
        console.log('in installer.step2.removeHosts:hosts to delete ', context);
        var controller = router.get('installerController');
        controller.removeHosts(context);
      }
    }),

    step4: Em.Route.extend({
      route: '/step4',
      connectOutlets: function (router, context) {
        router.setNavigationFlow('step4');
        var controller = router.get('installerController');
        controller.setCurrentStep('4');
        controller.loadAllPriorSteps();
        controller.connectOutlet('wizardStep4', controller.get('content.services'));
      },
      back: Em.Router.transitionTo('step3'),

      next: function (router) {
        var controller = router.get('installerController');
        var wizardStep4Controller = router.get('wizardStep4Controller');
        controller.saveServices(wizardStep4Controller);
        controller.saveClients(wizardStep4Controller);

        App.db.setMasterComponentHosts(undefined);
        router.transitionTo('step5');
      }
    }),

    step5: Em.Route.extend({
      route: '/step5',
      connectOutlets: function (router, context) {
        router.setNavigationFlow('step5');

        var controller = router.get('installerController');
        var wizardStep5Controller = router.get('wizardStep5Controller');
        controller.setCurrentStep('5');
        controller.loadAllPriorSteps();
        controller.connectOutlet('wizardStep5', controller.get('content'));
      },
      back: Em.Router.transitionTo('step4'),
      next: function (router) {
        var controller = router.get('installerController');
        var wizardStep5Controller = router.get('wizardStep5Controller');
        controller.saveMasterComponentHosts(wizardStep5Controller);
        App.db.setSlaveComponentHosts(undefined);
        router.transitionTo('step6');
      }
    }),

    step6: Em.Route.extend({
      route: '/step6',
      connectOutlets: function (router, context) {
        router.setNavigationFlow('step6');

        var controller = router.get('installerController');
        controller.setCurrentStep('6');
        controller.loadAllPriorSteps();
        controller.connectOutlet('wizardStep6', controller.get('content'));
      },
      back: Em.Router.transitionTo('step5'),

      next: function (router) {
        var controller = router.get('installerController');
        var wizardStep6Controller = router.get('wizardStep6Controller');

        if (wizardStep6Controller.validate()) {
          controller.saveSlaveComponentHosts(wizardStep6Controller);
          controller.get('content').set('serviceConfigProperties', null);
          App.db.setServiceConfigProperties(null);
          App.db.setAdvancedServiceConfig(null);
          controller.loadAdvancedConfigs();
          router.transitionTo('step7');
        }
      }
    }),

    step7: Em.Route.extend({
      route: '/step7',
      enter: function (router) {
        console.log('in /wizardStep7Controller:enter');
        var controller = router.get('installerController');
        controller.setCurrentStep('7');
        controller.loadAllPriorSteps();
      },
      connectOutlets: function (router, context) {
        var controller = router.get('installerController');
        controller.connectOutlet('wizardStep7', controller.get('content'));
      },
      back: Em.Router.transitionTo('step6'),
      next: function (router) {
        var installerController = router.get('installerController');
        var wizardStep7Controller = router.get('wizardStep7Controller');
        installerController.saveServiceConfigProperties(wizardStep7Controller);
        router.transitionTo('step8');
      }
    }),

    step8: Em.Route.extend({
      route: '/step8',
      connectOutlets: function (router, context) {
        console.log('in installer.step8:connectOutlets');
        var controller = router.get('installerController');
        controller.setCurrentStep('8');
        controller.loadAllPriorSteps();
        controller.connectOutlet('wizardStep8', controller.get('content'));
      },
      back: Em.Router.transitionTo('step7'),
      next: function (router) {
        var installerController = router.get('installerController');
        var wizardStep8Controller = router.get('wizardStep8Controller');
        // invoke API call to install selected services
        installerController.installServices();
        installerController.setInfoForStep9();
        // We need to do recovery based on whether we are in Add Host or Installer wizard
        installerController.saveClusterState('CLUSTER_INSTALLING_3');
        wizardStep8Controller.set('servicesInstalled', true);
        router.transitionTo('step9');
      }
    }),

    step9: Em.Route.extend({
      route: '/step9',
      connectOutlets: function (router, context) {
        console.log('in installer.step9:connectOutlets');
        var controller = router.get('installerController');
        controller.setCurrentStep('9');
        controller.loadAllPriorSteps();
        if (!App.testMode) {
          controller.setLowerStepsDisable(9);
        }
        controller.connectOutlet('wizardStep9', controller.get('content'));
      },
      back: Em.Router.transitionTo('step8'),
      retry: function (router) {
        var installerController = router.get('installerController');
        var wizardStep9Controller = router.get('wizardStep9Controller');
        if (wizardStep9Controller.get('showRetry')) {
          if (wizardStep9Controller.get('content.cluster.status') === 'INSTALL FAILED') {
            var isRetry = true;
            installerController.installServices(isRetry);
            installerController.setInfoForStep9();
            wizardStep9Controller.resetHostsForRetry();
            // We need to do recovery based on whether we are in Add Host or Installer wizard
            installerController.saveClusterState('CLUSTER_INSTALLING_3');
          }
          wizardStep9Controller.navigateStep();
        }
      },
      unroutePath: function () {
        return false;
      },
      next: function (router) {
        var installerController = router.get('installerController');
        var wizardStep9Controller = router.get('wizardStep9Controller');
        installerController.saveInstalledHosts(wizardStep9Controller);

        installerController.saveClusterState('CLUSTER_INSTALLED_4');
        router.transitionTo('step10');
      }
    }),

    step10: Em.Route.extend({
      route: '/step10',
      connectOutlets: function (router, context) {
        console.log('in installer.step10:connectOutlets');
        var controller = router.get('installerController');
        controller.setCurrentStep('10');
        controller.loadAllPriorSteps();
        if (!App.testMode) {
          controller.setLowerStepsDisable(10);
        }
        controller.connectOutlet('wizardStep10', controller.get('content'));
      },
      back: Em.Router.transitionTo('step9'),
      complete: function (router, context) {
        if (true) {   // this function will be moved to installerController where it will validate
          var controller = router.get('installerController');
          controller.finish();

          // We need to do recovery based on whether we are in Add Host or Installer wizard
          controller.saveClusterState('CLUSTER_STARTED_5');

          router.transitionTo('main.index');
        } else {
          console.log('cluster installation failure');
        }
      }
    }),

    gotoStep0: Em.Router.transitionTo('step0'),

    gotoStep1: Em.Router.transitionTo('step1'),

    gotoStep2: Em.Router.transitionTo('step2'),

    gotoStep3: Em.Router.transitionTo('step3'),

    gotoStep4: Em.Router.transitionTo('step4'),

    gotoStep5: Em.Router.transitionTo('step5'),

    gotoStep6: Em.Router.transitionTo('step6'),

    gotoStep7: Em.Router.transitionTo('step7'),

    gotoStep8: Em.Router.transitionTo('step8'),

    gotoStep9: Em.Router.transitionTo('step9'),

    gotoStep10: Em.Router.transitionTo('step10')

  });
});
window.require.register("routes/main", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var stringUtils = require('utils/string_utils');

  module.exports = Em.Route.extend({
    route: '/main',
    enter: function (router) {
      App.db.updateStorage();
      console.log('in /main:enter');
      if (router.getAuthenticated()) {
        App.router.get('clusterController').loadClusterName(false);
        router.get('mainController').initialize();
        // TODO: redirect to last known state
      } else {
        Ember.run.next(function () {
          router.transitionTo('login');
        });
      }
    },
    /*
     routePath: function(router,event) {
     if (router.getAuthenticated()) {
     App.router.get('clusterController').loadClusterName(false);
     router.get('mainController').initialize();
     // TODO: redirect to last known state
     } else {
     Ember.run.next(function () {
     router.transitionTo('login');
     });
     }
     }, */

    index: Ember.Route.extend({
      route: '/',
      redirectsTo: 'dashboard'
    }),

    test: Em.Route.extend({
      route: '/test',
      connectOutlets: function (router, context) {
        router.get('mainController').connectOutlet('mainTest');
      }
    }),

    connectOutlets: function (router, context) {
      router.get('applicationController').connectOutlet('main');
    },

    charts: Em.Route.extend({
      route: '/charts',
      connectOutlets: function (router, context) {
        router.get('mainController').connectOutlet('mainCharts');
      },
      enter: function (router) {
        Em.run.next(function () {
          router.transitionTo('heatmap');
        });
      },
      index: Ember.Route.extend({
        route: '/',
        redirectsTo: 'heatmap'
      }),
      heatmap: Em.Route.extend({
        route: '/heatmap',
        connectOutlets: function (router, context) {
          router.get('mainChartsController').connectOutlet('mainChartsHeatmap');
        }
      }),
      horizon_chart: Em.Route.extend({
        route: '/horizon_chart',
        connectOutlets: function (router, context) {
          router.get('mainChartsController').connectOutlet('mainChartsHorizon');
        }
      }),
      showChart: function (router, event) {
        var parent = event.view._parentView;
        parent.deactivateChildViews();
        event.view.set('active', "active");
        router.transitionTo(event.context);
      }
    }),
    apps: Em.Route.extend({
      route: '/apps',
      connectOutlets: function (router) {
        if (stringUtils.compareVersions(App.get('currentStackVersionNumber'), "2.0") === 1 ||
          stringUtils.compareVersions(App.get('currentStackVersionNumber'), "2.0") === 0) {
          Em.run.next(function () {
            router.transitionTo('main.dashboard');
          });
        } else {
          router.get('mainAppsController').loadRuns();
          router.get('mainController').connectOutlet('mainApps');
        }
      }
    }),

    mirroring: Em.Route.extend({
      route: '/mirroring',
      index: Ember.Route.extend({
        route: '/',
        enter: function () {
          this.setupController()
        },
        setupController: function () {
          var controller = App.router.get('mainMirroringController');
          var datasets = App.Dataset.find();
          controller.set('datasets', datasets);
        },
        connectOutlets: function (router, context) {
          console.debug('Inside connectOutlets in ' + App.get('router.currentState.path'));
          router.get('mainController').connectOutlet('mainMirroring');
        }
      }),

      gotoMirroringHome: function (router) {
        router.transitionTo('mirroring/index');
      },
      addNewDataset: function (router) {
        router.transitionTo('addNewDatasetRoute');
      },

      addTargetCluster: function (router, event) {
        router.transitionTo('addTargetClusterRoute');
      },

      addNewDatasetRoute: Em.Route.extend({
        route: '/dataset/add',

        setupController: function (controller) {
          controller.createNewDataSet();
        },
        enter: function (router) {
          var controller = router.get('mainMirroringDataSetController');
          // if we are coming from closing AddCluster popup
          if (controller.isReturning) {
            controller.isReturning = false;
            return;
          }

          controller.set('isPopupForEdit', false);
          this.setupController(controller);

          var self = this;
          controller.set('isSubmitted', false);
          App.ModalPopup.show({
            classNames: ['sixty-percent-width-modal', 'hideCloseLink'],
            header: Em.I18n.t('mirroring.dataset.newDataset'),
            primary: Em.I18n.t('mirroring.dataset.save'),
            secondary: Em.I18n.t('common.cancel'),
            onPrimary: function () {
              controller.set('isSubmitted', true);
              var isValid = controller.validate();

              if (!isValid) {
                return;
              }
              newDataSet = controller.getNewDataSet();
              var schedule = newDataSet.get('schedule');
              var targetCluster = newDataSet.get('targetCluster');
              console.debug('Before setting, schedule = ' + schedule + " , targetCluster = " + targetCluster);
              var scheduleRecord = App.Dataset.Schedule.createRecord(schedule);
              var dataSetRecord = App.Dataset.createRecord(newDataSet);
              scheduleRecord.set('dataset', dataSetRecord);
              dataSetRecord.set('schedule', scheduleRecord);

              console.debug('After setting, schedule = ' + dataSetRecord.get('schedule') + " , targetCluster = " + dataSetRecord.get('targetCluster'));
              this.hide();
              router.transitionTo('main.mirroring.index');
            },
            onSecondary: function () {
              this.hide();
              router.transitionTo('main.mirroring.index');
            },
            bodyClass: App.MainMirroringDataSetView.extend({
              controller: router.get('mainMirroringDataSetController')
            })
          });
        }
      }),

      gotoShowJobs: function (router, event) {
        router.transitionTo('showDatasetJobs', event.context);
      },

      showDatasetJobs: Em.Route.extend({
        route: '/dataset/:dataset_id',
        connectOutlets: function (router, dataset) {
          router.get('mainController').connectOutlet('mainJobs', dataset);
        }
      }),

      editDataset: Em.Route.extend({
        route: '/dataset/:dataset_id/edit',
        setupController: function (controller, dataset) {
          controller.setOriginalDataSetRecord(dataset);
          controller.setDataSet(dataset);
        },


        connectOutlets: function (router, dataset) {
          var controller = router.get('mainMirroringDataSetController');
          // if we are coming from closing AddCluster popup
          if (controller.isReturning) {
            controller.isReturning = false;
            return;
          }
          // for showing delete button
          controller.set('isPopupForEdit', true);
          this.setupController(controller, dataset);

          var self = this;
          controller.set('isSubmitted', false);
          controller.set('popup', App.ModalPopup.show({
            classNames: ['sixty-percent-width-modal'],
            header: Em.I18n.t('mirroring.dataset.editDataset'),
            primary: Em.I18n.t('mirroring.dataset.save'),
            secondary: Em.I18n.t('common.cancel'),
            onPrimary: function () {
              controller.set('isSubmitted', true);
              var isValid = controller.validate();

              if (!isValid) {
                return;
              }
              newDataSet = controller.getNewDataSet();

              var originalRecord = controller.get('model.originalRecord');

              originalRecord.set('name', newDataSet.get('name'));
              originalRecord.set('sourceDir', newDataSet.get('sourceDir'));
              originalRecord.set('targetCluster', newDataSet.get('targetCluster'));
              originalRecord.set('targetDir', newDataSet.get('targetDir'));
              originalRecord.set('schedule', newDataSet.get('schedule'));
              this.hide();
              router.transitionTo('main.mirroring.index');
            },
            onSecondary: function () {
              this.hide();
              router.transitionTo('main.mirroring.index');
            },
            bodyClass: App.MainMirroringDataSetView.extend({
              controller: router.get('mainMirroringDataSetController')
            })
          })
          );
        }
      }),

      gotoEditDataset: function (router, event) {
        router.transitionTo('editDataset', event.context);
      },

      addTargetClusterRoute: Ember.Route.extend({
        route: '/targetCluster/add',
        initialState: 'testConnectionRoute',
        testConnectionRoute: Ember.Route.extend({
          setupController: function (controller) {
            controller.createTargetCluster();
            controller.set('model.isPopupForEdit', false);

          },

          enter: function (router, context) {

            console.debug('Inside connectOutlets in ' + App.get('router.currentState.path'));
            var self = this;
            var controller = App.router.get('mainMirroringTargetClusterController');
            this.setupController(controller);

            controller.set('isSubmitted1', false);
            controller.set('isSubmitted2', false);
            controller.set('popup', App.ModalPopup.show({
              classNames: ['sixty-percent-width-modal', 'hideCloseLink'],
              header: Em.I18n.t('mirroring.targetcluster.addCluster'),
              primary: Em.I18n.t('mirroring.targetcluster.testConnection'),
              onPrimary: function () {
                controller.set('isSubmitted1', true);
                var isValid = controller.validate1();

                if (!isValid) {
                  return;
                }

                App.router.transitionTo('testConnectionResultsRoute');
              },
              onSecondary: function () {
                this.hide();

                var dscontroller = App.router.get('mainMirroringDataSetController');
                var tccontroller = App.router.get('mainMirroringTargetClusterController');
                var returnRoute = tccontroller.get('returnRoute');
                // if we have come from addNewDatasetRoute
                if (returnRoute) {
                  dscontroller.isReturning = true;
                  App.router.transitionTo(returnRoute);
                }
                else
                  App.router.transitionTo('main.mirroring.index');
              },
              bodyClass: App.MainMirroringAddTargetClusterView.extend({
                controller: App.router.get('mainMirroringTargetClusterController')
              })
            }));
          },

          connectOutlets: function (router, context) {
            console.log("entering the connectOutlets method of testConnectionRoute.")
            var parentController = router.get('mainMirroringTargetClusterController');
            parentController.connectOutlet('testConnection', parentController.get('model'));
          },

          exit: function (stateManager) {
            console.log("exiting the testConnectionRoute state")
          }
        }),
        testConnectionResultsRoute: Ember.Route.extend({
          enter: function (stateManager) {
            console.log("entering the testConnectionResultsRoute state.")
            // lets change the primary button
            var controller = App.router.get('mainMirroringTargetClusterController');
            var popup = controller.get('popup');
            popup.set('primary', Em.I18n.t('common.save'));
            popup.set('onPrimary',
              function () {
                var controller = App.router.get('mainMirroringTargetClusterController');
                controller.set('isSubmitted2', true);
                var isValid = controller.validate2();

                if (!isValid) {
                  return;
                }

                var controller = App.router.get('testConnectionResultsController');
                controller.saveClusterName();
              }
            );

          },

          connectOutlets: function (router, context) {
            console.log("entering the connectOutlets method of testConnectionResultsRoute.")
            var parentController = router.get('mainMirroringTargetClusterController');
            parentController.connectOutlet('testConnectionResults', parentController.get('model'));
          },

          exit: function (stateManager) {
            console.log("exiting the connectionSuccessRoute state")
          }

        })
      }),
      editTargetClusterRoute: Em.Route.extend({
        route: '/targetCluster/:targetCluster_id/edit',

        initialState: 'testConnectionRoute',

        setupController: function (controller, targetCluster) {
          controller.setOriginalRecord(targetCluster);
          controller.setTargetCluster(targetCluster);
        },

        connectOutlets: function (router, targetCluster) {
          // this connectOutlets is mainly to receive the 'targetCluster' argument
          var controller = router.get('mainMirroringTargetClusterController');
          // for showing delete button
          controller.set('model.isPopupForEdit', true);
          this.setupController(controller, targetCluster);
        },

        testConnectionRoute: Em.Route.extend({
          connectOutlets: function (router, targetCluster) {
            var controller = router.get('mainMirroringTargetClusterController');
            controller.set('isSubmitted1', false);
            controller.set('isSubmitted2', false);

            controller.set('popup', App.ModalPopup.show({
              classNames: ['sixty-percent-width-modal'],
              header: Em.I18n.t('mirroring.dataset.editDataset'),
              primary: Em.I18n.t('mirroring.targetcluster.testConnection'),
              onPrimary: function () {
                var controller = App.router.get('mainMirroringTargetClusterController');
                controller.set('isSubmitted1', true);
                var isValid = controller.validate1();

                if (!isValid) {
                  return;
                }

                App.router.transitionTo('testConnectionResultsRoute');
              },
              secondary: Em.I18n.t('common.cancel'),
              onSecondary: function () {
                this.hide();
                router.transitionTo('main.mirroring.index');
              },
              bodyClass: App.MainMirroringAddTargetClusterView.extend({
                controller: App.router.get('mainMirroringTargetClusterController')
              })
            }));

            console.log("entering the connectOutlets method of testConnectionRoute.")
            var parentController = router.get('mainMirroringTargetClusterController');
            parentController.connectOutlet('testConnection', parentController.get('model'));

          }

        }),
        testConnection: function () {
          App.router.transitionTo('testConnectionResultsRoute');
        },
        testConnectionResultsRoute: Ember.Route.extend({
          enter: function (stateManager) {
            console.log("entering the testConnectionResultsRoute state.")
            // lets change the primary button
            var controller = App.router.get('mainMirroringTargetClusterController');
            var popup = controller.get('popup');
            popup.set('primary', Em.I18n.t('common.save'));
            popup.set('onPrimary',
              function () {
                var controller = App.router.get('mainMirroringTargetClusterController');
                controller.set('isSubmitted2', true);
                var isValid = controller.validate1();

                if (!isValid) {
                  return;
                }
                var controller2 = App.router.get('testConnectionResultsController');
                controller2.saveClusterName();
              }
            );

          },

          connectOutlets: function (router, context) {
            console.log("entering the connectOutlets method of testConnectionResultsRoute.");
            var parentController = router.get('mainMirroringTargetClusterController');
            parentController.connectOutlet('testConnectionResults', parentController.get('model'));
          },

          exit: function (stateManager) {
            console.log("exiting the connectionSuccessRoute state")
          }

        })

      }),

      editTargetCluster: function (router, event) {
        router.transitionTo('editTargetClusterRoute', event.context);
      }


    }),


    hosts: Em.Route.extend({
      route: '/hosts',
      index: Ember.Route.extend({
        route: '/',
        connectOutlets: function (router, context) {
          router.get('mainController').connectOutlet('mainHost');
        }
      }),

      hostDetails: Em.Route.extend({
        route: '/:host_id',
        connectOutlets: function (router, host) {
          router.get('mainController').connectOutlet('mainHostDetails', host);
        },

        index: Ember.Route.extend({
          route: '/',
          redirectsTo: 'summary'
        }),

        summary: Em.Route.extend({
          route: '/summary',
          connectOutlets: function (router, context) {
            router.get('mainHostDetailsController').connectOutlet('mainHostSummary');
          }
        }),

        configs: Em.Route.extend({
          route: '/configs',
          connectOutlets: function (router, context) {
            router.get('mainHostDetailsController').connectOutlet('mainHostConfigs');
          }
        }),

        metrics: Em.Route.extend({
          route: '/metrics',
          connectOutlets: function (router, context) {
            router.get('mainHostDetailsController').connectOutlet('mainHostMetrics');
          }
        }),

        audit: Em.Route.extend({
          route: '/audit',
          connectOutlets: function (router, context) {
            router.get('mainHostDetailsController').connectOutlet('mainHostAudit');
          }
        }),

        hostNavigate: function (router, event) {
          var parent = event.view._parentView;
          parent.deactivateChildViews();
          event.view.set('active', "active");
          router.transitionTo(event.context);
        }
      }),

      back: function (router, event) {
        window.history.back();
      },

      showDetails: function (router, event) {
        router.get('mainHostDetailsController').setBack(true);
        router.transitionTo('hostDetails.summary', event.context)
      },

      addHost: function (router) {
        if (App.clusterStatus) {
          App.clusterStatus.updateFromServer();
          var currentClusterStatus = App.clusterStatus.get('value');
          if (currentClusterStatus && currentClusterStatus.clusterState == "ADD_HOSTS_COMPLETED_5") {
            // The last time add hosts ran, it left the status
            // in this state. We need to clear any previous status
            // so that the hosts page starts from fresh.
            currentClusterStatus.clusterState = 'CLUSTER_STARTED_5';
          }
        }
        router.transitionTo('hostAdd');
      }

    }),

    hostAdd: require('routes/add_host_routes'),

    admin: Em.Route.extend({
      route: '/admin',
      enter: function (router, transition) {
        if (!App.isAdmin) {
          Em.run.next(function () {
            router.transitionTo('main.dashboard');
          });
        }
      },

      routePath: function (router, event) {
        if (!App.isAdmin) {
          Em.run.next(function () {
            App.router.transitionTo('main.dashboard');
          });
        } else {
          var controller = router.get('mainAdminController');
          router.transitionTo('admin' + controller.get('category').capitalize());
        }
      },
      connectOutlets: function (router, context) {
        router.get('mainController').connectOutlet('mainAdmin');
      },

      index: Em.Route.extend({
        /* enter: function(router, transition){
         var controller = router.get('mainAdminController');
         router.transitionTo('admin' + controller.get('category').capitalize());
         }, */
        route: '/',
        redirectsTo: 'adminUser'
      }),


      adminUser: Em.Route.extend({
        route: '/user',
        index: Em.Route.extend({
          route: '/',
          redirectsTo: 'allUsers'
        }),
        enter: function (router) {
          router.set('mainAdminController.category', "user");
          Em.run.next(function () {
            router.transitionTo('allUsers');
          });
        },
        routePath: function (router, event) {
          router.set('mainAdminController.category', "user");
          router.transitionTo('allUsers');
          Em.run.next(function () {
            router.transitionTo('allUsers');
          });
        },
        // events
        gotoUsers: Em.Router.transitionTo("allUsers"),
        gotoCreateUser: Em.Router.transitionTo("createUser"),
        gotoEditUser: function (router, event) {
          router.transitionTo("editUser", event.context)
        },

        // states
        allUsers: Em.Route.extend({
          route: '/allUsers',
          // index: Ember.Route.extend({
          //route: '/',
          connectOutlets: function (router) {
            router.get('mainAdminController').connectOutlet('mainAdminUser');
          }
          //})
        }),

        createUser: Em.Route.extend({
          route: '/create',
          connectOutlets: function (router) {
            router.get('mainAdminController').connectOutlet('mainAdminUserCreate', {});
          }
        }),

        editUser: Em.Route.extend({
          route: '/edit/:user_id',
          connectOutlets: function (router, user) {
            router.get('mainAdminController').connectOutlet('mainAdminUserEdit', user);
          }
        })
      }),


      adminAuthentication: Em.Route.extend({
        route: '/authentication',
        connectOutlets: function (router, context) {
          router.set('mainAdminController.category', "authentication");
          router.get('mainAdminController').connectOutlet('mainAdminAuthentication');
        }
      }),


      adminSecurity: Em.Route.extend({
        route: '/security',
        enter: function (router) {
          router.set('mainAdminController.category', "security");
          var controller = router.get('mainAdminSecurityController');
          if (!App.testMode) {
            App.clusterStatus.updateFromServer();
            var currentClusterStatus = App.clusterStatus.get('value');
            App.db.data.AddSecurity = currentClusterStatus.localdb;
            if (currentClusterStatus.localdb) {
              App.db.setSecurityDeployStages(currentClusterStatus.localdb.securityDeployStages);
              controller.setAddSecurityWizardStatus(currentClusterStatus.localdb.status);
              App.db.setSecureConfigProperties(currentClusterStatus.localdb.secureConfigProperties);
              App.db.setWizardCurrentStep('AddSecurity', currentClusterStatus.localdb.currentStep);
              App.db.setDisableSecurityStatus(currentClusterStatus.localdb.disableSecurityStatus);
            }
          }
          if (!(controller.getAddSecurityWizardStatus() === 'RUNNING') && !(controller.getDisableSecurityStatus() === 'RUNNING')) {
            Em.run.next(function () {
              router.transitionTo('adminSecurity.index');
            });
          } else if (controller.getAddSecurityWizardStatus() === 'RUNNING') {
            Em.run.next(function () {
              router.transitionTo('adminAddSecurity');
            });
          } else if (controller.getDisableSecurityStatus() === 'RUNNING') {
            Em.run.next(function () {
              router.transitionTo('disableSecurity');
            });
          }
        },

        index: Ember.Route.extend({
          route: '/',
          connectOutlets: function (router, context) {
            var controller = router.get('mainAdminController');
            controller.set('category', "security");
            controller.connectOutlet('mainAdminSecurity');
          }
        }),

        addSecurity: function (router, object) {
          router.get('mainAdminSecurityController').setAddSecurityWizardStatus('RUNNING');
          router.transitionTo('adminAddSecurity');
        },

        disableSecurity: Ember.Route.extend({
          route: '/disableSecurity',
          enter: function (router) {
            //after refresh check if the wizard is open then restore it
            if (router.get('mainAdminSecurityController').getDisableSecurityStatus() === 'RUNNING') {
              Ember.run.next(function () {
                App.router.get('updateController').set('isWorking', false);
                App.ModalPopup.show({
                  classNames: ['full-width-modal'],
                  header: Em.I18n.t('admin.removeSecurity.header'),
                  bodyClass: App.MainAdminSecurityDisableView.extend({
                    controllerBinding: 'App.router.mainAdminSecurityDisableController'
                  }),
                  primary: Em.I18n.t('form.cancel'),
                  secondary: null,
                  showFooter: false,

                  onClose: function () {
                    var self = this;
                    var controller = router.get('mainAdminSecurityDisableController');
                    if (!controller.get('isSubmitDisabled')) {
                      self.proceedOnClose();
                      return;
                    }
                    var applyingConfigStage = controller.get('stages').findProperty('stage', 'stage3');
                    if (applyingConfigStage && !applyingConfigStage.get('isCompleted')) {
                      if (applyingConfigStage.get('isStarted')) {
                        App.showAlertPopup(Em.I18n.t('admin.security.applying.config.header'), Em.I18n.t('admin.security.applying.config.body'));
                      } else {
                        App.showConfirmationPopup(function () {
                          self.proceedOnClose();
                        }, Em.I18n.t('admin.addSecurity.disable.onClose'));
                      }
                    } else {
                      self.proceedOnClose();
                    }
                  },
                  proceedOnClose: function () {
                    router.get('mainAdminSecurityDisableController').clearStep();
                    App.db.setSecurityDeployStages(undefined);
                    App.router.get('updateController').set('isWorking', true);
                    router.get('mainAdminSecurityController').setDisableSecurityStatus(undefined);
                    App.clusterStatus.setClusterStatus({
                      clusterName: router.get('content.cluster.name'),
                      clusterState: 'SECURITY_COMPLETED',
                      wizardControllerName: router.get('mainAdminSecurityDisableController.name'),
                      localdb: App.db.data.AddSecurity
                    });
                    this.hide();
                    router.transitionTo('adminSecurity.index');
                  },
                  didInsertElement: function () {
                    this.fitHeight();
                  }
                });
              });
            } else {
              router.transitionTo('adminSecurity.index');
            }
          },

          unroutePath: function () {
            return false;
          },

          done: function (router, context) {
            var controller = router.get('mainAdminSecurityDisableController');
            if (!controller.get('isSubmitDisabled')) {
              $(context.currentTarget).parents("#modal").find(".close").trigger('click');
            }
          }
        }),

        adminAddSecurity: require('routes/add_security')
      }),

      adminCluster: Em.Route.extend({
        route: '/cluster',
        connectOutlets: function (router) {
          router.set('mainAdminController.category', "cluster");
          router.get('mainAdminController').connectOutlet('mainAdminCluster');
        }
      }),
      adminAdvanced: Em.Route.extend({
        route: '/advanced',
        connectOutlets: function (router) {
          router.set('mainAdminController.category', "advanced");
          router.get('mainAdminController').connectOutlet('mainAdminAdvanced');
        }
      }),

      adminMisc: Em.Route.extend({
        route: '/misc',
        connectOutlets: function (router) {
          router.set('mainAdminController.category', "misc");
          router.get('mainAdminController').connectOutlet('mainAdminMisc');
        }
      }),

      adminAudit: Em.Route.extend({
        route: '/audit',
        connectOutlets: function (router) {
          router.set('mainAdminController.category', "audit");
          router.get('mainAdminController').connectOutlet('mainAdminAudit');
        }
      }),
      upgradeStack: function (router, event) {
        if (!$(event.currentTarget).hasClass('inactive')) {
          router.transitionTo('stackUpgrade');
        }
      },


      adminNavigate: function (router, object) {
        router.transitionTo('admin' + object.context.capitalize());
      },

  //events
      goToAdmin: function (router, event) {
        router.transitionTo(event.context);
      }

    }),
    stackUpgrade: require('routes/stack_upgrade'),

    dashboard: Em.Route.extend({
      route: '/dashboard',
      connectOutlets: function (router, context) {
        router.get('mainController').connectOutlet('mainDashboard');
      },
      showDetails: function (router, event) {
        router.get('mainHostDetailsController').setBack(true);
        router.transitionTo('hosts.hostDetails.summary', event.context);
      }
    }),

    services: Em.Route.extend({
      route: '/services',
      index: Ember.Route.extend({
        route: '/',
        enter: function (router) {
          Ember.run.next(function () {
            var controller = router.get('mainController');
            controller.dataLoading().done(function () {
              var service = router.get('mainServiceItemController.content');
              if (!service) {
                service = App.Service.find().objectAt(0); // getting the first service to display
              }
              router.transitionTo('service.summary', service);
            });
          });
        }
      }),
      connectOutlets: function (router, context) {
        router.get('mainController').connectOutlet('mainService');
      },
      service: Em.Route.extend({
        route: '/:service_id',
        connectOutlets: function (router, service) {
          router.get('mainServiceController').connectOutlet('mainServiceItem', service);
          router.transitionTo('summary');
        },
        index: Ember.Route.extend({
          route: '/'
        }),
        summary: Em.Route.extend({
          route: '/summary',
          connectOutlets: function (router, context) {
            var item = router.get('mainServiceItemController.content');
            var viewName = 'mainServiceInfoSummary';
            router.get('mainServiceItemController').connectOutlet('mainServiceInfoSummary', item);
          }
        }),
        metrics: Em.Route.extend({
          route: '/metrics',
          connectOutlets: function (router, context) {
            var item = router.get('mainServiceItemController.content');
            router.get('mainServiceItemController').connectOutlet('mainServiceInfoMetrics', item);
          }
        }),
        configs: Em.Route.extend({
          route: '/configs',
          connectOutlets: function (router, context) {
            var item = router.get('mainServiceItemController.content');
            router.get('mainServiceItemController').connectOutlet('mainServiceInfoConfigs', item);
          }
        }),
        audit: Em.Route.extend({
          route: '/audit',
          connectOutlets: function (router, context) {
            var item = router.get('mainServiceItemController.content');
            router.get('mainServiceItemController').connectOutlet('mainServiceInfoAudit', item);
          }
        }),
        showInfo: function (router, event) {
          var parent = event.view._parentView;
          parent.deactivateChildViews();
          event.view.set('active', "active");
          router.transitionTo(event.context);
        },
        showDetails: function (router, event) {
          router.get('mainHostDetailsController').setBack(true);
          router.transitionTo('hosts.hostDetails.summary', event.context);
        }
      }),
      showService: Em.Router.transitionTo('service'),
      addService: Em.Router.transitionTo('serviceAdd')
    }),


    serviceAdd: require('routes/add_service_routes'),
    reassignMaster: require('routes/reassign_master_routes'),


    selectService: Em.Route.transitionTo('services.service.summary'),
    selectHost: function (router, event) {
      router.get('mainHostDetailsController').setBack(false);
      router.transitionTo('hosts.hostDetails.index', event.context);
    },
    filterHosts: function (router, component) {
      router.get('mainHostController').filterByComponent(component.context);
      router.transitionTo('hosts.index');
    }
  });
});
window.require.register("routes/reassign_master_routes", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  module.exports = Em.Route.extend({
    route: '/services/reassign',

    enter: function (router) {
      console.log('in /service/reassign:enter');
        Em.run.next(function () {
          var reassignMasterController = router.get('reassignMasterController');
          App.router.get('updateController').set('isWorking', false);
          App.ModalPopup.show({
            classNames: ['full-width-modal'],
            header:Em.I18n.t('services.reassign.header'),
            bodyClass:  App.ReassignMasterView.extend({
              controller: reassignMasterController
            }),
            primary:Em.I18n.t('form.cancel'),
            showFooter: false,
            secondary: null,

            onPrimary:function () {
              this.hide();
              App.router.get('updateController').set('isWorking', true);
              App.router.transitionTo('main.services.index');
            },
            onClose: function() {
              this.hide();
              App.router.get('updateController').set('isWorking', true);
              App.router.transitionTo('main.services.index')
            },
            didInsertElement: function(){
              this.fitHeight();
            }
          });

          App.clusterStatus.updateFromServer();
          var currentClusterStatus = App.clusterStatus.get('value');
          if (currentClusterStatus && currentClusterStatus.clusterState == 'REASSIGN_MASTER_INSTALLING') {
            reassignMasterController.setCurrentStep('5');
            App.db.data = currentClusterStatus.localdb;
          }
          router.transitionTo('step' + reassignMasterController.get('currentStep'));
        });
    },

    step1: Em.Route.extend({
      route: '/step1',
      connectOutlets: function (router) {
        console.log('in reassignMaster.step1:connectOutlets');
        var controller = router.get('reassignMasterController');
        controller.setCurrentStep('1');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep11');
        })
      },
      next: function (router) {
        App.db.setMasterComponentHosts(undefined);
        router.transitionTo('step2');
      }
    }),

    step2: Em.Route.extend({
      route: '/step2',
      connectOutlets: function (router) {
        console.log('in reassignMaster.step2:connectOutlets');
        var controller = router.get('reassignMasterController');
        controller.setCurrentStep('2');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep5', controller.get('content'));
        })

      },
      back: Em.Router.transitionTo('step1'),
      next: function (router) {
        var controller = router.get('reassignMasterController');
        var wizardStep5Controller = router.get('wizardStep5Controller');
        controller.saveMasterComponentHosts(wizardStep5Controller);
        router.transitionTo('step3');
      }
    }),

    step3: Em.Route.extend({
      route: '/step3',
      connectOutlets: function (router) {
        console.log('in reassignMaster.step3:connectOutlets');
        var controller = router.get('reassignMasterController');
        if (controller.get('skipStep3')) {
          router.transitionTo('step4');
        } else {
          controller.setCurrentStep('3');
          controller.dataLoading().done(function () {
            controller.loadAllPriorSteps();
            controller.set('content.serviceName', controller.get('content.reassign.service_id'));
            controller.connectOutlet('wizardStep12', controller.get('content'));
          })
        }
      },
      back: Em.Router.transitionTo('step2'),
      next: function (router) {
        var controller = router.get('reassignMasterController');
        var wizardStep12Controller = router.get('wizardStep12Controller');
        controller.set('content.modifiedConfigs', wizardStep12Controller.get('modifiedConfigs'));
        controller.saveServiceConfigProperties(wizardStep12Controller);
        router.transitionTo('step4');
      }
    }),

    step4: Em.Route.extend({
      route: '/step4',
      connectOutlets: function (router) {
        console.log('in reassignMaster.step4:connectOutlets');
        var controller = router.get('reassignMasterController');
        controller.setCurrentStep('4');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep13', controller.get('content'));
        })
      },
      back: Em.Router.transitionTo('step3'),
      next: function (router) {
        App.db.setReassignTasksStatuses(['INITIALIZE', 'INITIALIZE', 'INITIALIZE', 'INITIALIZE', 'INITIALIZE', 'INITIALIZE', 'INITIALIZE', 'INITIALIZE']);
        App.clusterStatus.setClusterStatus({
          clusterName: router.get('reassignMasterController.content.cluster.name'),
          clusterState: 'REASSIGN_MASTER_INSTALLING',
          wizardControllerName: 'reassignMasterController',
          localdb: App.db.data
        });
        router.transitionTo('step5');
      }
    }),

    step5: Em.Route.extend({
      route: '/step5',
      connectOutlets: function (router) {
        console.log('in reassignMaster.step5:connectOutlets');
        var controller = router.get('reassignMasterController');
        controller.setCurrentStep('5');
        controller.dataLoading().done(function () {
          controller.loadAllPriorSteps();
          controller.connectOutlet('wizardStep14', controller.get('content'));
        })
      },
      back: Em.Router.transitionTo('step3'),
      complete: function (router, context) {
        var controller = router.get('reassignMasterController');
        var wizardStep14Controller = router.get('wizardStep14Controller');
        if (!wizardStep14Controller.get('isSubmitDisabled')) {
          controller.finish();
          $(context.currentTarget).parents("#modal").find(".close").trigger('click');
          App.clusterStatus.setClusterStatus({
            clusterName: router.get('reassignMasterController.content.cluster.name'),
            clusterState: 'REASSIGN_MASTER_COMPLETED',
            wizardControllerName: 'reassignMasterController',
            localdb: App.db.data
          });
          router.transitionTo('main.index');
        }
      }
    }),


    gotoStep1: Em.Router.transitionTo('step1'),

    gotoStep2: Em.Router.transitionTo('step2'),

    gotoStep3: Em.Router.transitionTo('step3'),

    gotoStep4: Em.Router.transitionTo('step4'),

    gotoStep5: Em.Router.transitionTo('step5'),

    gotoStep6: Em.Router.transitionTo('step6'),

    backToServices: function (router) {
      App.router.get('updateController').set('isWorking', true);
      router.transitionTo('services');
    }

  });
  
});
window.require.register("routes/stack_upgrade", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  module.exports = Em.Route.extend({
    route: 'admin/cluster/upgrade',

    enter: function (router) {
      console.log('in /admin/cluster/upgrade:enter');
      Ember.run.next(function () {
        var stackUpgradeController = router.get('stackUpgradeController');
        App.router.get('updateController').set('isWorking', false);
        App.ModalPopup.show({
          classNames: ['full-width-modal'],
          header:Em.I18n.t('installer.stackUpgrade.header'),
          bodyClass:  App.StackUpgradeView.extend({
            controllerBinding: 'App.router.stackUpgradeController'
          }),
          showFooter: false,
          onClose: function() {
            this.hide();
            App.router.get('updateController').set('isWorking', true);
            router.transitionTo('admin.adminCluster');
          },
          didInsertElement: function(){
            this.fitHeight();
          }
        });
        var statuses = ['STOPPING_SERVICES', 'STACK_UPGRADING', 'STACK_UPGRADE_FAILED', 'STACK_UPGRADED'];
        var currentClusterStatus = App.clusterStatus.get('value');
        if (currentClusterStatus.localdb) App.db.data = currentClusterStatus.localdb;
        if (statuses.contains(currentClusterStatus.clusterState)) {
          stackUpgradeController.setCurrentStep(3);
        }
        router.transitionTo('step' + stackUpgradeController.get('currentStep'));
      });
    },

    step1: Em.Route.extend({
      route: '/step1',
      connectOutlets: function (router) {
        console.log('in stackUpgrade.step1:connectOutlets');
        var controller = router.get('stackUpgradeController');
        controller.setCurrentStep('1');
        controller.loadAllPriorSteps();
        controller.connectOutlet('stackUpgradeStep1', controller.get('content'));
      },
      next: Em.Router.transitionTo('step2')
    }),

    step2: Em.Route.extend({
      route: '/step2',
      connectOutlets: function (router) {
        console.log('in stackUpgrade.step2:connectOutlets');
        var controller = router.get('stackUpgradeController');
        controller.setCurrentStep('2');
        controller.loadAllPriorSteps();
        controller.connectOutlet('stackUpgradeStep2', controller.get('content'));
      },
      back: Em.Router.transitionTo('step1'),
      next: function(router){
        var controller = router.get('stackUpgradeController');
        var stepController = router.get('stackUpgradeStep3Controller');
        controller.save('upgradeOptions');
        router.transitionTo('step3');
        App.clusterStatus.setClusterStatus({
          clusterName: controller.get('content.cluster.name'),
          clusterState: 'PENDING',
          wizardControllerName: 'stackUpgradeController',
          localdb: App.db.data
        });
        stepController.stopServices();
      }
    }),

    step3: Em.Route.extend({
      route: '/step3',
      connectOutlets: function (router, context) {
        console.log('in stackUpgrade.step3:connectOutlets');
        var controller = router.get('stackUpgradeController');
        controller.setCurrentStep('3');
        controller.setLowerStepsDisable(3);
        controller.loadAllPriorSteps();
        controller.connectOutlet('stackUpgradeStep3', controller.get('content'));
      },
      finish: function (router, context) {
        var controller = router.get('stackUpgradeController');
        var stepController = router.get('stackUpgradeStep3Controller');
        controller.finish();
        $(context.currentTarget).parents("#modal").find(".close").trigger('click');
        App.clusterStatus.setClusterStatus({
          clusterName: controller.get('content.cluster.name'),
          clusterState: 'STACK_UPGRADE_COMPLETED',
          wizardControllerName: 'stackUpgradeController',
          localdb: App.db.data
        });
        App.router.get('updateController').updateAll();
        App.set('currentStackVersion', controller.get('content.upgradeVersion'));
      }
    }),
    backToCluster: function(router, context){
      var controller = router.get('stackUpgradeController');
      controller.finish();
      $(context.currentTarget).parents("#modal").find(".close").trigger('click');
    },

    gotoStep1: Em.Router.transitionTo('step1'),

    gotoStep2: Em.Router.transitionTo('step2'),

    gotoStep3: Em.Router.transitionTo('step3')

  });
  
});
window.require.register("templates", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */



  // load templates here

  require('templates/main/service/info/summary/ganglia');
  require('templates/main/service/info/summary/oozie');
  require('templates/main/service/info/summary/zookeeper');
  require('templates/main/service/info/summary/mapreduce2');
  require('templates/main/service/info/summary/hive');
  require('templates/main/service/info/summary/hue');
  
});
window.require.register("templates/application", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n              <a class=\"brand cluster-name\" href=\"javascript:void(null);\" ");
    stack1 = {};
    stack2 = "clusterName";
    stack1['title'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                <span ");
    stack1 = depth0;
    stack2 = "showPopup";
    stack3 = {};
    stack4 = "App.router.backgroundOperationsController";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " >");
    stack1 = depth0;
    stack2 = "clusterDisplayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " </span>\n\n                ");
    stack1 = depth0;
    stack2 = "App.router.backgroundOperationsController";
    stack3 = helpers['with'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n              </a>\n          ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                  ");
    stack1 = depth0;
    stack2 = "allOperationsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(5, program5, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                ");
    return buffer;}
  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n                      <span class=\"label operations-count\" ");
    stack1 = depth0;
    stack2 = "showPopup";
    stack3 = {};
    stack4 = "App.router.backgroundOperationsController";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "allOperationsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                      ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n                      <span class=\"label\" ");
    stack1 = depth0;
    stack2 = "showPopup";
    stack3 = {};
    stack4 = "App.router.backgroundOperationsController";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "allOperationsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                  ");
    return buffer;}

  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            <div class=\"btn-group pull-right usermenu-wrapper\">\n              <button class=\"btn btn-group dropdown-toggle\"  data-toggle=\"dropdown\">\n                ");
    stack1 = depth0;
    stack2 = "App.router.loginName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "&nbsp;<span class=\"caret\"></span>\n              </button>\n              <ul class=\"dropdown-menu\">\n                <li><a href=\"\" ");
    stack1 = depth0;
    stack2 = "logoff";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "app.signout";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              </ul>\n            </div>\n          ");
    return buffer;}

    data.buffer.push("\n\n<div id=\"main\">\n  <div id=\"top-nav\">\n    <div class=\"navbar navbar-static-top\">\n      <div class=\"navbar-inner\">\n        <div class=\"container\">\n          <a ");
    stack1 = {};
    stack2 = "topnav.logo.href";
    stack1['href'] = stack2;
    foundHelper = helpers.translateAttr;
    stack2 = foundHelper || depth0.translateAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, tmp1); }
    else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "translateAttr", tmp1); }
    else { stack1 = stack2; }
    data.buffer.push(escapeExpression(stack1) + " class=\"logo\" target=\"_blank\"><img src=\"/img/logo.png\" alt=\"大数据平台\" title=\"大数据平台\"></a>\n          <a class=\"brand\" ");
    stack1 = {};
    stack2 = "topnav.logo.href";
    stack1['href'] = stack2;
    foundHelper = helpers.translateAttr;
    stack2 = foundHelper || depth0.translateAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, tmp1); }
    else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "translateAttr", tmp1); }
    else { stack1 = stack2; }
    data.buffer.push(escapeExpression(stack1) + " target=\"_blank\" alt=\"大数据平台\" title=\"大数据平台\">");
    stack1 = depth0;
    stack2 = "app.name";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n\n          ");
    stack1 = depth0;
    stack2 = "isClusterDataLoaded";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n          ");
    stack1 = depth0;
    stack2 = "App.router.loggedIn";
    stack3 = helpers['if'];
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class=\"container\">\n    <div id=\"content\">\n      ");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </div>\n  </div>\n</div>\n\n\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/configs/addPropertyWindow", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;


    data.buffer.push("\n  <form class=\"form-horizontal\" autocomplete=\"off\">\n    <div class=\"each-row\">\n      <label class=\"control-label\">Type</label>\n      <div class=\"controls\">\n        ");
    stack1 = depth0;
    stack2 = "view.serviceConfigProperty.filename";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </div>\n    </div>\n    <div ");
    stack1 = {};
    stack2 = "view.serviceConfigProperty.isKeyError:error :each-row :control-group";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <label class=\"control-label\">Key</label>\n      <div class=\"controls\">\n        ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "view.serviceConfigProperty.name";
    stack3['valueBinding'] = stack4;
    stack4 = "span4";
    stack3['class'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "view.serviceConfigProperty.errorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n      </div>\n    </div>\n    <div class=\"each-row\">\n      <label class=\"control-label\">Value</label>\n      <div class=\"controls\">\n        ");
    stack1 = depth0;
    stack2 = "Ember.TextArea";
    stack3 = {};
    stack4 = "view.serviceConfigProperty.value";
    stack3['valueBinding'] = stack4;
    stack4 = "4";
    stack3['rows'] = stack4;
    stack4 = "span6";
    stack3['classNames'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </div>\n    </div>\n  </form>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/configs/capacity_scheduler", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n                    <div class=\"btn pull-right\" ");
    stack1 = depth0;
    stack2 = "queuePopup";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "services.mapReduce.config.addQueue";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n                ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n                  <tr ");
    stack1 = depth0;
    stack2 = "queue.name";
    stack3 = depth0;
    stack4 = "queuePopup";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                      <td><a href=\"javascript:void(0)\">\n                          <i ");
    stack1 = {};
    stack2 = "queue.color";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"marker\"></i>");
    stack1 = depth0;
    stack2 = "queue.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n                      </td>\n                      <td>");
    stack1 = depth0;
    stack2 = "queue.users";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n                      <td>");
    stack1 = depth0;
    stack2 = "queue.groups";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n                      <td>");
    stack1 = depth0;
    stack2 = "queue.capacity";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "&#37;</td>\n                      <td>");
    stack1 = depth0;
    stack2 = "queue.maxCapacity";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "&#37;</td>\n                      <td>");
    stack1 = depth0;
    stack2 = "queue.minUserLimit";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "&#37;</td>\n                      <td>");
    stack1 = depth0;
    stack2 = "queue.userLimitFactor";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n                      <td>");
    stack1 = depth0;
    stack2 = "queue.supportsPriority";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n                  </tr>\n                  ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                    ");
    stack1 = depth0;
    stack2 = "isVisible";
    stack3 = helpers['if'];
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                  ");
    return buffer;}
  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n                        <div class=\"row-fluid\">\n                            <div ");
    stack1 = {};
    stack2 = "errorMessage:error :control-label-span :span4";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                                <label>");
    stack1 = depth0;
    stack2 = "displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</label>\n                            </div>\n                            <div class=\"span8\">\n                                <div ");
    stack1 = {};
    stack2 = "errorMessage:error: :control-group";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                                  ");
    stack1 = depth0;
    stack2 = "viewClass";
    stack3 = {};
    stack4 = "this";
    stack3['serviceConfigBinding'] = stack4;
    stack4 = "view.categoryConfigs";
    stack3['categoryConfigsBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                                  ");
    stack1 = depth0;
    stack2 = "view.canEdit";
    stack3 = helpers['if'];
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                                    <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "errorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                                </div>\n                            </div>\n                        </div>\n                    ");
    return buffer;}
  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                                      ");
    stack1 = depth0;
    stack2 = "isRemovable";
    stack3 = helpers['if'];
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                                  ");
    return buffer;}
  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n                                          <a class=\"action\" ");
    stack1 = depth0;
    stack2 = "";
    stack3 = depth0;
    stack4 = "removeProperty";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ><i class=\"icon-minus-sign\"></i>");
    stack1 = depth0;
    stack2 = "common.remove";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n                                      ");
    return buffer;}

  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "view.category.canAddProperty";
    stack3 = helpers['if'];
    tmp1 = self.program(11, program11, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      ");
    return buffer;}
  function program11(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n              <div>\n                  <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "";
    stack3 = depth0;
    stack4 = "showAddPropertyWindow";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " >");
    stack1 = depth0;
    stack2 = "installer.step7.config.addProperty";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "...</a>\n              </div>\n          ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"accordion-heading\" ");
    stack1 = depth0;
    stack2 = "view.category";
    stack3 = depth0;
    stack4 = "onToggleBlock";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n    <i class=\"pull-left accordion-toggle\" ");
    stack1 = {};
    stack2 = "view.category.isCollapsed:icon-caret-right:icon-caret-down ";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></i>\n    <a class=\"accordion-toggle\">");
    stack1 = depth0;
    stack2 = "view.category.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n</div>\n\n<div ");
    stack1 = {};
    stack2 = "view.category.name";
    stack1['id'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"accordion-body collapse in\">\n    <div class=\"accordion-inner capacity-scheduler\">\n        <div class=\"row-fluid header\">\n            <div class=\"span1\">");
    stack1 = depth0;
    stack2 = "services.mapReduce.config.queue.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n            <div class=\"offset9 span2\">\n                ");
    stack1 = depth0;
    stack2 = "view.canEdit";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            </div>\n        </div>\n        <div>\n            <table class=\"table table-bordered table-striped\">\n                <thead>\n                <tr>\n                    <th>");
    stack1 = depth0;
    stack2 = "services.mapReduce.config.queue.name";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n                    <th>");
    stack1 = depth0;
    stack2 = "common.users";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n                    <th>");
    stack1 = depth0;
    stack2 = "services.mapReduce.config.queue.groups";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n                    <th>");
    stack1 = depth0;
    stack2 = "services.mapReduce.config.queue.capacity";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n                    <th>");
    stack1 = depth0;
    stack2 = "services.mapReduce.config.queue.maxCapacity";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n                    <th>");
    stack1 = depth0;
    stack2 = "services.mapReduce.config.queue.minUserLimit";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n                    <th>");
    stack1 = depth0;
    stack2 = "services.mapReduce.config.queue.userLimitFactor";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n                    <th>");
    stack1 = depth0;
    stack2 = "services.mapReduce.config.queue.supportsPriority";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n                </tr>\n                </thead>\n                <tbody>\n                  ");
    stack1 = depth0;
    stack2 = "view.tableContent";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "queue";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                </tbody>\n            </table>\n        </div>\n        <div class=\"row-fluid\">\n            <div class=\"span8\">\n                <div><strong>");
    stack1 = depth0;
    stack2 = "admin.advanced.title";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</strong></div>\n                <form class=\"form-horizontal\" autocomplete=\"off\">\n                  ");
    stack1 = depth0;
    stack2 = "view.advancedConfigs";
    stack3 = helpers.each;
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                </form>\n            </div>\n            <div class=\"span4\">\n                <div class=\"frame\">\n                  <div id=\"section_label\"></div>\n                  ");
    stack1 = depth0;
    stack2 = "view.pieChart";
    stack3 = {};
    stack4 = "view.queues";
    stack3['queuesBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                </div>\n            </div>\n        </div>\n      ");
    data.buffer.push("\n      ");
    stack1 = depth0;
    stack2 = "view.canEdit";
    stack3 = helpers['if'];
    tmp1 = self.program(10, program10, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/configs/overriddenProperty", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n    ");
    data.buffer.push("\n    <div ");
    stack1 = {};
    stack2 = "overriddenSCP.errorMessage:error: :control-group :overrideField";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      ");
    stack1 = depth0;
    stack2 = "overriddenSCP.viewClass";
    stack3 = {};
    stack4 = "overriddenSCP";
    stack3['serviceConfigBinding'] = stack4;
    stack4 = "view.categoryConfigs";
    stack3['categoryConfigsBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      ");
    stack1 = depth0;
    stack2 = "view.hostsCountView";
    stack3 = {};
    stack4 = "overriddenSCP";
    stack3['overriddenSCPBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      ");
    stack1 = depth0;
    stack2 = "isNotDefaultValue";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      <a class=\"action\" ");
    stack1 = depth0;
    stack2 = "overriddenSCP";
    stack3 = depth0;
    stack4 = "removeOverride";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ><i class=\"icon-minus-sign\"></i>Remove</a>\n      <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "overriddenSCP.errorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n    </div>\n");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n        <a class=\"action\" ");
    stack1 = depth0;
    stack2 = "";
    stack3 = depth0;
    stack4 = "doRestoreDefaultValue";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ><i class=\"icon-undo\"></i>Undo</a>\n      ");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.serviceConfigProperty.overrides";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "overriddenSCP";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/configs/overrideWindow", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n	        <div class=\"text-warning\">\n	          ");
    stack1 = depth0;
    stack2 = "view.parentView.warningMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n	        </div>\n        ");
    return buffer;}

  function program3(depth0,data) {
    
    
    data.buffer.push("\n                <i class='icon-ok-sign'></i>\n              ");}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n			                    <li>\n			                      <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "column";
    stack3 = depth0;
    stack4 = "selectFilterColumn";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n			                        ");
    stack1 = depth0;
    stack2 = "column.selected";
    stack3 = helpers['if'];
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(8, program8, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n			                        ");
    stack1 = depth0;
    stack2 = "column.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n			                      </a>\n			                    </li>\n			                  ");
    return buffer;}
  function program6(depth0,data) {
    
    
    data.buffer.push("\n	                              <i class='icon-ok-sign'></i>\n	                            ");}

  function program8(depth0,data) {
    
    
    data.buffer.push("\n                                <i class='icon-placeholder'></i>\n	                            ");}

  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n                        <li>\n                          <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "component";
    stack3 = depth0;
    stack4 = "selectFilterComponent";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                            ");
    stack1 = depth0;
    stack2 = "component.selected";
    stack3 = helpers['if'];
    tmp1 = self.program(11, program11, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(13, program13, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n	                          ");
    stack1 = depth0;
    stack2 = "component.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n	                        </a>\n                        </li>\n                      ");
    return buffer;}
  function program11(depth0,data) {
    
    
    data.buffer.push("\n                              <i class='icon-ok-sign'></i>\n                            ");}

  function program13(depth0,data) {
    
    
    data.buffer.push("\n                              <i class='icon-placeholder'></i>\n	                          ");}

  function program15(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n            <tr>\n              <td width=\"10%\">\n                ");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "entry.selected";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n              </td>\n              <td width=\"45%\">\n                ");
    stack1 = depth0;
    stack2 = "entry.host.publicHostName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n              </td>\n              <td>\n                ");
    stack1 = depth0;
    stack2 = "entry.filterColumnValue";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n              </td>\n            </tr>\n          ");
    return buffer;}

    data.buffer.push("\n\n");
    data.buffer.push("\n  <form class=\"form-horizontal\" autocomplete=\"off\">\n      <div class=\"override-controls\">\n        <h4 class=\"message\">");
    stack1 = depth0;
    stack2 = "hosts.selectHostsDialog.message";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h4>\n        ");
    stack1 = depth0;
    stack2 = "view.parentView.warningMessage";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        <table style=\"width: 100%;\">\n          <tr>\n            <td>\n              <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "toggleShowSelectedHosts";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.hostSelectMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n              ");
    stack1 = depth0;
    stack2 = "view.showOnlySelectedHosts";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            </td>\n            <td width=\"30%\">\n              <div class=\"row\">\n                <div class=\"span2\" id=\"filter-dropdown-div\">\n                  <!-- Filter text box with drop-down -->\n		              <div class=\"input-append\">\n		                ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "view.filterText";
    stack3['valueBinding'] = stack4;
    stack4 = "appendedDropdownButton";
    stack3['id'] = stack4;
    stack4 = "view.filterTextPlaceholder";
    stack3['placeholderBinding'] = stack4;
    stack4 = "span2";
    stack3['class'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n		                <div class=\"btn-group\">\n		                  <button class=\"btn dropdown-toggle\" data-toggle=\"dropdown\">\n		                    <span class=\"caret\"></span>\n		                  </button>\n		                  <ul class=\"dropdown-menu\">\n			                  ");
    stack1 = depth0;
    stack2 = "view.filterColumns";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "column";
    stack7 = helpers.each;
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n		                  </ul>\n		                </div>\n		              </div>\n                </div>\n                <div class=\"span2\" id=\"component-dropdown-div\">\n                  <!-- Host-components drop-down -->\n		              <div class=\"btn-group\">\n		                <a class=\"btn dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">\n		                  Components\n		                  <span class=\"caret\"></span>\n		                </a>\n		                <ul class=\"dropdown-menu\">\n		                  <!-- dropdown menu links -->\n		                  ");
    stack1 = depth0;
    stack2 = "view.filterComponents";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "component";
    stack7 = helpers.each;
    tmp1 = self.program(10, program10, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n		                </ul>\n                  </div>\n                </div>\n              </div>\n            </td>\n          </tr>\n        </table>\n        <table class=\"table table-striped hosts-table\">\n          <thead>\n            <tr class=\"success\">\n              <th width=\"10%\">\n                ");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "view.allHostsSelected";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n              </th>\n              <th width=\"45%\">Host</th>\n              <th width=\"45%\">");
    stack1 = depth0;
    stack2 = "view.filterColumn.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n            </tr>\n          </thead>\n         </table>\n        <div class=\"hosts-table-container\">\n          <table class=\"table table-striped hosts-table\">\n          ");
    stack1 = depth0;
    stack2 = "view.filteredHosts";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "entry";
    stack7 = helpers.each;
    tmp1 = self.program(15, program15, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n         </table>\n        </div>\n      </div>\n  </form>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/configs/propertyDependence", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <tr>\n      <td>");
    stack1 = depth0;
    stack2 = "property.serviceName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "property.propertyDisplayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "property.curValue";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "property.newValue";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n    </tr>\n  ");
    return buffer;}

    data.buffer.push("\n\n<table class=\"table table-bordered table-striped\">\n  <thead>\n  <tr>\n    <th>");
    stack1 = depth0;
    stack2 = "common.service";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n    <th>");
    stack1 = depth0;
    stack2 = "common.property";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n    <th>");
    stack1 = depth0;
    stack2 = "installer.step7.popup.currentValue";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n    <th>");
    stack1 = depth0;
    stack2 = "installer.step7.popup.adjustedValue";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n  </tr>\n  </thead>\n  <tbody>\n  ");
    stack1 = depth0;
    stack2 = "view.propertyChange";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "property";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </tbody>\n</table>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/configs/service_config", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "selectedService.restartRequired";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n	<div class=\"alert\">\n	  <div class=\"clearfix like_pointer collapsable\" ");
    stack1 = depth0;
    stack2 = "toggleRestartMessageView";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n	      ");
    stack1 = depth0;
    stack2 = "view.isRestartMessageCollapsed";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(5, program5, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n	      <i class=\"icon-refresh\"></i>\n	      <strong>Restart Service</strong> ");
    stack1 = depth0;
    stack2 = "selectedService.restartRequiredMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n	  </div>\n	  <div class=\"service-body\">\n	    <ul>\n	    ");
    stack1 = depth0;
    stack2 = "selectedService.restartRequiredHostsAndComponents";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "host";
    stack7 = helpers.each;
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n	    </ul>\n	  </div>\n	</div>\n	");
    return buffer;}
  function program3(depth0,data) {
    
    
    data.buffer.push("\n	        <i class=\"icon-caret-down pull-left\"></i>\n	      ");}

  function program5(depth0,data) {
    
    
    data.buffer.push("\n	        <i class=\"icon-caret-right pull-left\"></i>\n	      ");}

  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n	      <li>\n	        <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "host.hostData";
    stack3 = depth0;
    stack4 = "showDetails";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "host.hostData.publicHostName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n	        <ul>\n	          ");
    stack1 = depth0;
    stack2 = "host.components";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "component";
    stack7 = helpers.each;
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n	        </ul>\n	      </li>\n	    ");
    return buffer;}
  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n	            <li>");
    stack1 = depth0;
    stack2 = "component.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</li>\n	          ");
    return buffer;}

  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "category.isCustomView";
    stack3 = helpers['if'];
    tmp1 = self.program(11, program11, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(14, program14, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  ");
    return buffer;}
  function program11(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      ");
    stack1 = depth0;
    stack2 = "App.supports.capacitySchedulerUi";
    stack3 = helpers['if'];
    tmp1 = self.program(12, program12, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    return buffer;}
  function program12(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "category.customView";
    stack3 = {};
    stack4 = "category";
    stack3['categoryBinding'] = stack4;
    stack4 = "selectedService";
    stack3['serviceBinding'] = stack4;
    stack4 = "view.canEdit";
    stack3['canEditBinding'] = stack4;
    stack4 = "selectedService.configs";
    stack3['serviceConfigsBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      ");
    return buffer;}

  function program14(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "App.ServiceConfigsByCategoryView";
    stack3 = {};
    stack4 = "category";
    stack3['categoryBinding'] = stack4;
    stack4 = "view.canEdit";
    stack3['canEditBinding'] = stack4;
    stack4 = "selectedService";
    stack3['serviceBinding'] = stack4;
    stack4 = "selectedService.configs";
    stack3['serviceConfigsBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(15, program15, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    return buffer;}
  function program15(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n\n            <div class=\"accordion-heading\" ");
    stack1 = depth0;
    stack2 = "category";
    stack3 = depth0;
    stack4 = "onToggleBlock";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                <i ");
    stack1 = {};
    stack2 = ":pull-left :accordion-toggle category.isCollapsed:icon-caret-right:icon-caret-down";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></i>\n                <a class=\"accordion-toggle\">");
    stack1 = depth0;
    stack2 = "category.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n            </div>\n\n            <div class=\"accordion-body collapse in\">\n              <div class=\"accordion-inner service-config-section\">\n                <form class=\"form-horizontal\" autocomplete=\"off\">\n\n                  ");
    stack1 = depth0;
    stack2 = "view.filteredCategoryConfigs";
    stack3 = helpers.each;
    tmp1 = self.program(16, program16, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n                  ");
    data.buffer.push("\n                  ");
    stack1 = depth0;
    stack2 = "view.canEdit";
    stack3 = helpers['if'];
    tmp1 = self.program(34, program34, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                </form>\n              </div>\n            </div>\n\n\n    ");
    return buffer;}
  function program16(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n                      <div ");
    stack1 = {};
    stack2 = ":entry-row isOverridden:overridden-property";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                          <span ");
    stack1 = {};
    stack2 = "errorMessage:error: :control-group :control-label-span";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                            <label class=\"control-label\">\n                              ");
    stack1 = depth0;
    stack2 = "App.supports.hostOverrides";
    stack3 = helpers['if'];
    tmp1 = self.program(17, program17, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                              ");
    stack1 = depth0;
    stack2 = "displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                              ");
    stack1 = depth0;
    stack2 = "App.supports.secureCluster";
    stack3 = helpers['if'];
    tmp1 = self.program(20, program20, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                            </label>\n                          </span>\n                          <div class=\"controls\">\n                            ");
    data.buffer.push("\n                              <div ");
    stack1 = {};
    stack2 = "errorMessage:error: :control-group";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                                ");
    stack1 = depth0;
    stack2 = "viewClass";
    stack3 = {};
    stack4 = "this";
    stack3['serviceConfigBinding'] = stack4;
    stack4 = "view.categoryConfigsAll";
    stack3['categoryConfigsAllBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                                ");
    stack1 = depth0;
    stack2 = "view.canEdit";
    stack3 = helpers['if'];
    tmp1 = self.program(23, program23, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                                  <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "errorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                              </div>\n                            ");
    stack1 = depth0;
    stack2 = "isOverridden";
    stack3 = helpers['if'];
    tmp1 = self.program(32, program32, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                          </div>\n                      </div>\n                  ");
    return buffer;}
  function program17(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n		                            ");
    stack1 = depth0;
    stack2 = "isRestartRequired";
    stack3 = helpers['if'];
    tmp1 = self.program(18, program18, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n		                          ");
    return buffer;}
  function program18(depth0,data) {
    
    var buffer = '', stack1, stack2;
    data.buffer.push("\n		                              <i class=\"icon-refresh restart-required-property\" rel=\"tooltip\" ");
    stack1 = {};
    stack2 = "restartRequiredMessage";
    stack1['title'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></i>\n		                            ");
    return buffer;}

  function program20(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                                ");
    stack1 = depth0;
    stack2 = "isSecureConfig";
    stack3 = helpers['if'];
    tmp1 = self.program(21, program21, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                              ");
    return buffer;}
  function program21(depth0,data) {
    
    
    data.buffer.push("\n                                  <a href=\"javascript:void(null);\"><i class=\"icon-lock\" rel=\"tooltip\" data-toggle=\"tooltip\" title=\"security knob\"></i></a>\n                                ");}

  function program23(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n	                                ");
    stack1 = depth0;
    stack2 = "isPropertyOverridable";
    stack3 = helpers['if'];
    tmp1 = self.program(24, program24, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n	                                ");
    stack1 = depth0;
    stack2 = "cantBeUndone";
    stack3 = helpers.unless;
    tmp1 = self.program(27, program27, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n	                                ");
    stack1 = depth0;
    stack2 = "isRemovable";
    stack3 = helpers['if'];
    tmp1 = self.program(30, program30, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                                ");
    return buffer;}
  function program24(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                                    ");
    stack1 = depth0;
    stack2 = "App.supports.hostOverrides";
    stack3 = helpers['if'];
    tmp1 = self.program(25, program25, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n	                                ");
    return buffer;}
  function program25(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n	                                    <a class=\"action\" ");
    stack1 = depth0;
    stack2 = "";
    stack3 = depth0;
    stack4 = "createOverrideProperty";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ><i class=\"icon-plus-sign\"></i>");
    stack1 = depth0;
    stack2 = "common.exception";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n                                    ");
    return buffer;}

  function program27(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n	                                  ");
    stack1 = depth0;
    stack2 = "isNotDefaultValue";
    stack3 = helpers['if'];
    tmp1 = self.program(28, program28, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n	                                ");
    return buffer;}
  function program28(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n	                                      <a class=\"action\" ");
    stack1 = depth0;
    stack2 = "";
    stack3 = depth0;
    stack4 = "doRestoreDefaultValue";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ><i class=\"icon-undo\"></i>");
    stack1 = depth0;
    stack2 = "common.undo";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n	                                  ");
    return buffer;}

  function program30(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n	                                    <a class=\"action\" ");
    stack1 = depth0;
    stack2 = "";
    stack3 = depth0;
    stack4 = "removeProperty";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ><i class=\"icon-minus-sign\"></i>");
    stack1 = depth0;
    stack2 = "common.remove";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n	                                ");
    return buffer;}

  function program32(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n                              ");
    stack1 = depth0;
    stack2 = "App.ServiceConfigView.SCPOverriddenRowsView";
    stack3 = {};
    stack4 = "this";
    stack3['serviceConfigPropertyBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                            ");
    return buffer;}

  function program34(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n	                  ");
    stack1 = depth0;
    stack2 = "category.canAddProperty";
    stack3 = helpers['if'];
    tmp1 = self.program(35, program35, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n	                ");
    return buffer;}
  function program35(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n	                      <div>\n	                          <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "";
    stack3 = depth0;
    stack4 = "showAddPropertyWindow";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " >");
    stack1 = depth0;
    stack2 = "installer.step7.config.addProperty";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "...</a>\n	                      </div>\n	                  ");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "App.supports.hostOverrides";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n<div class=\"accordion\">\n  ");
    stack1 = depth0;
    stack2 = "selectedService.configCategories";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "category";
    stack7 = helpers.each;
    tmp1 = self.program(10, program10, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/configs/services_config", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "service.showConfig";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      ");
    stack1 = depth0;
    stack2 = "App.ServiceConfigTab";
    stack3 = helpers.view;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    return buffer;}
  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n        <a class=\"active\" href=\"#");
    stack1 = depth0;
    stack2 = "service.serviceName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\"\n           data-toggle=\"tab\" ");
    stack1 = depth0;
    stack2 = "service";
    stack3 = depth0;
    stack4 = "selectService";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n          ");
    stack1 = depth0;
    stack2 = "service.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1));
    stack1 = depth0;
    stack2 = "service.errorCount";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("</a>\n      ");
    return buffer;}
  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("<span\n                class=\"badge badge-important\">");
    stack1 = depth0;
    stack2 = "service.errorCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>");
    return buffer;}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  <div class=\"alert\">");
    stack1 = depth0;
    stack2 = "installer.step7.attentionNeeded";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n");
    return buffer;}

    data.buffer.push("\n\n<ul class=\"nav nav-tabs\">\n  ");
    stack1 = depth0;
    stack2 = "controller.stepConfigs";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "service";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</ul>\n");
    stack1 = depth0;
    stack2 = "App.ServiceConfigView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n");
    stack1 = depth0;
    stack2 = "isSubmitDisabled";
    stack3 = helpers['if'];
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/filter_combobox", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n            <li>\n                <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "column";
    stack3 = depth0;
    stack4 = "selectFilterColumn";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                  <i ");
    stack1 = {};
    stack2 = "column.selected:icon-ok-sign:icon-placeholder";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></i>\n                  ");
    stack1 = depth0;
    stack2 = "column.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                </a>\n            </li>\n        ");
    return buffer;}

    data.buffer.push("\n\n  ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "view.filter";
    stack3['valueBinding'] = stack4;
    stack4 = "view.placeHolder";
    stack3['placeholderBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  <div class=\"btn-group\">\n      <button class=\"btn dropdown-toggle\" data-toggle=\"dropdown\">\n          <span class=\"caret\"></span>\n      </button>\n      <ul class=\"dropdown-menu\">\n        ");
    stack1 = depth0;
    stack2 = "view.columns";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "column";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </ul>\n  </div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/form", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "App.FormFieldTemplate";
    stack3 = {};
    stack4 = "field";
    stack3['fieldBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.fields";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "field";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/form/checkbox", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<div class=\"controls\">\n  <label class=\"checkbox\" for=\"input");
    stack1 = depth0;
    stack2 = "view.field.name";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\">\n    ");
    stack1 = depth0;
    stack2 = "view.field.viewClass";
    stack3 = {};
    stack4 = "view.field.value";
    stack3['valueBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "view.field.displayName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  </label>\n  <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "view.field.errorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/form/field", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<label class=\"control-label\"\n       for=\"input");
    stack1 = depth0;
    stack2 = "view.field.name";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\">");
    stack1 = depth0;
    stack2 = "view.field.displayName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</label>\n\n<div class=\"controls\">\n  ");
    stack1 = depth0;
    stack2 = "view.field.viewClass";
    stack3 = {};
    stack4 = "view.field.value";
    stack3['valueBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "view.field.errorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/grid/filter", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n<li>\n  <label class=\"checkbox\">\n    ");
    stack1 = depth0;
    stack2 = "Em.Checkbox";
    stack3 = {};
    stack4 = "filter.checked";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "filter.label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  </label>\n</li>\n");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.filters";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "filter";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/grid/header", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "view.filter";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  <a ");
    stack1 = depth0;
    stack2 = "applyFilter";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "apply";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "<i ");
    stack1 = depth0;
    stack2 = "toggleFilter";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"icon-filter\"></i>\n");
    stack1 = depth0;
    stack2 = "view.showFilter";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/grid/pager", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n    <li ");
    stack1 = {};
    stack2 = "page.activeClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ><a ");
    stack1 = depth0;
    stack2 = "page";
    stack3 = depth0;
    stack4 = "activatePage";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"#\">");
    stack1 = depth0;
    stack2 = "page.number";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n  ");
    return buffer;}

    data.buffer.push("\n\n<ul>\n    <li ");
    stack1 = {};
    stack2 = "view.prevPageDisabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a ");
    stack1 = depth0;
    stack2 = "activatePrevPage";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"#\">");
    stack1 = depth0;
    stack2 = "common.prev";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n  ");
    stack1 = depth0;
    stack2 = "view.pages";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "page";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    <li ");
    stack1 = {};
    stack2 = "view.nextPageDisabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a ");
    stack1 = depth0;
    stack2 = "activateNextPage";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"#\">");
    stack1 = depth0;
    stack2 = "common.next";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n</ul>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/host_progress_popup", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n    <!-- SERVICES --->\n\n    <div ");
    stack1 = {};
    stack2 = "view.isServiceListHidden:hidden :task-list-main-warp";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <div class=\"task-top-wrap\">\n        ");
    stack1 = depth0;
    stack2 = "common.operations";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        <div class=\"select-wrap\">\n          ");
    stack1 = depth0;
    stack2 = "common.show";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":\n          ");
    stack1 = depth0;
    stack2 = "Ember.Select";
    stack3 = {};
    stack4 = "view.categories";
    stack3['contentBinding'] = stack4;
    stack4 = "content.value";
    stack3['optionValuePath'] = stack4;
    stack4 = "content.label";
    stack3['optionLabelPath'] = stack4;
    stack4 = "view.serviceCategory";
    stack3['selectionBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        </div>\n      </div>\n      <div id=\"service-info\">\n        ");
    stack1 = depth0;
    stack2 = "view.services";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "servicesInfo";
    stack7 = helpers.each;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "view.isServiceEmptyList";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </div>\n    </div>\n\n\n  <!-- HOSTS --->\n\n  <div ");
    stack1 = {};
    stack2 = "view.isHostListHidden:hidden :task-list-main-warp";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n    <div class=\"task-top-wrap\">\n      ");
    stack1 = depth0;
    stack2 = "controller.showServices";
    stack3 = helpers['if'];
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      <span class=\"task-detail-log-rolename\" >");
    stack1 = depth0;
    stack2 = "common.hosts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</span>\n      <div class=\"select-wrap\">\n        ");
    stack1 = depth0;
    stack2 = "common.show";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":\n        ");
    stack1 = depth0;
    stack2 = "Ember.Select";
    stack3 = {};
    stack4 = "view.categories";
    stack3['contentBinding'] = stack4;
    stack4 = "content.value";
    stack3['optionValuePath'] = stack4;
    stack4 = "content.label";
    stack3['optionLabelPath'] = stack4;
    stack4 = "view.hostCategory";
    stack3['selectionBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </div>\n    </div>\n    <div id=\"host-info\">\n      ");
    stack1 = depth0;
    stack2 = "view.hosts";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "hostInfo";
    stack7 = helpers.each;
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      ");
    stack1 = depth0;
    stack2 = "view.isHostEmptyList";
    stack3 = helpers['if'];
    tmp1 = self.program(10, program10, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </div>\n  </div>\n\n\n  <!-- TASKS --->\n\n  <div ");
    stack1 = {};
    stack2 = "view.isTaskListHidden:hidden :task-list-main-warp";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n    <div class=\"task-top-wrap\">\n       <a class=\"task-detail-back-to-hosts\" href=\"javascript:void(null)\" ");
    stack1 = depth0;
    stack2 = "backToHostList";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ><i class=\"icon-arrow-left\"></i>&nbsp;");
    stack1 = depth0;
    stack2 = "common.hosts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n       <div>\n         <span class=\"task-detail-log-rolename\" >");
    stack1 = depth0;
    stack2 = "common.tasks";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</span>\n       </div>\n      <div class=\"select-wrap tasks-list-select\">\n        ");
    stack1 = depth0;
    stack2 = "common.show";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":\n        ");
    stack1 = depth0;
    stack2 = "Ember.Select";
    stack3 = {};
    stack4 = "view.categories";
    stack3['contentBinding'] = stack4;
    stack4 = "content.value";
    stack3['optionValuePath'] = stack4;
    stack4 = "content.label";
    stack3['optionLabelPath'] = stack4;
    stack4 = "view.taskCategory";
    stack3['selectionBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </div>\n    </div>\n    <div id=\"host-log\">\n      ");
    stack1 = depth0;
    stack2 = "view.tasks";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "taskInfo";
    stack7 = helpers.each;
    tmp1 = self.program(12, program12, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      ");
    stack1 = depth0;
    stack2 = "view.isTasksEmptyList";
    stack3 = helpers['if'];
    tmp1 = self.program(14, program14, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </div>\n  </div>\n\n\n  <!-- TASK DETAILS --->\n\n  <div ");
    stack1 = {};
    stack2 = "view.isLogWrapHidden:hidden :task-detail-info";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n    <div class=\"task-top-wrap\">\n      <a class=\"task-detail-back\" href=\"javascript:void(null)\" ");
    stack1 = depth0;
    stack2 = "backToTaskList";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ><i class=\"icon-arrow-left\"></i>&nbsp;");
    stack1 = depth0;
    stack2 = "common.tasks";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n      <div>\n        <i ");
    stack1 = {};
    stack2 = "view.openedTask.status :task-detail-status-ico view.openedTask.icon";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"task-detail-status-ico\"></i>\n        <span class=\"task-detail-log-rolename\" >");
    stack1 = depth0;
    stack2 = "view.openedTask.role";
    stack3 = {};
    stack4 = "true";
    stack3['unescaped'] = stack4;
    stack4 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push(" ");
    stack1 = depth0;
    stack2 = "view.openedTask.command";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n      </div>\n      <div class=\"task-detail-ico-wrap\">\n        <a title=\"Click to Copy\" ");
    stack1 = depth0;
    stack2 = "taskInfo";
    stack3 = depth0;
    stack4 = "textTrigger";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"task-detail-copy\"><i class=\"icon-copy\"></i> ");
    stack1 = depth0;
    stack2 = "common.copy";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n        <a title=\"Open in New Window\" ");
    stack1 = depth0;
    stack2 = "openTaskLogInDialog";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"task-detail-open-dialog\"><i class=\"icon-external-link\"></i> ");
    stack1 = depth0;
    stack2 = "common.open";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n      </div>\n    </div>\n    <div class=\"task-detail-log-info\">\n      <div class=\"content-area\" >\n        <div class=\"task-detail-log-clipboard-wrap\" ></div>\n        <div class=\"task-detail-log-maintext\">\n          <h5>stderr:</h5>\n          <pre class=\"stderr\">");
    stack1 = depth0;
    stack2 = "view.openedTask.stderr";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</pre>\n          <h5>stdout:</h5>\n          <pre class=\"stdout\">");
    stack1 = depth0;
    stack2 = "view.openedTask.stdout";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n    ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n        <div ");
    stack1 = {};
    stack2 = "servicesInfo.isVisible::hidden :log-list-wrap";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n          <div ");
    stack1 = depth0;
    stack2 = "servicesInfo";
    stack3 = depth0;
    stack4 = "gotoHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"task-list-line-cursor\">\n            <div class=\"host-name-icon-wrap\">\n              <i ");
    stack1 = {};
    stack2 = "servicesInfo.status servicesInfo.icon";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></i>\n              <a href=\"#\">\n                ");
    stack1 = depth0;
    stack2 = "servicesInfo.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n              </a>\n            </div>\n            <div class=\"progress-bar span2\">\n                <div ");
    stack1 = {};
    stack2 = "servicesInfo.isInProgress:progress-striped :active servicesInfo.barColor :progress";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                    <div class=\"bar\" ");
    stack1 = {};
    stack2 = "servicesInfo.barWidth";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n                </div>\n            </div>\n            <div class=\"host-progress-num\">");
    stack1 = depth0;
    stack2 = "servicesInfo.progress";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "%</div>\n            <div class=\"show-details\"><i class=\"icon-caret-right\"></i></div>\n          </div>\n        </div>\n        ");
    return buffer;}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <div class=\"log-list-wrap\">");
    stack1 = depth0;
    stack2 = "hostPopup.noServicesToShow";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n        ");
    return buffer;}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n        <a class=\"task-detail-back-to-hosts\" href=\"javascript:void(null)\" ");
    stack1 = depth0;
    stack2 = "backToServiceList";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " >\n          <i class=\"icon-arrow-left\"></i>&nbsp;");
    stack1 = depth0;
    stack2 = "common.operations";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        </a>\n      ");
    return buffer;}

  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n      <div ");
    stack1 = {};
    stack2 = "hostInfo.isVisible::hidden :log-list-wrap";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        <div ");
    stack1 = depth0;
    stack2 = "hostInfo";
    stack3 = depth0;
    stack4 = "gotoTasks";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"task-list-line-cursor\">\n          <div class=\"host-name-icon-wrap\">\n            <i ");
    stack1 = {};
    stack2 = "hostInfo.status hostInfo.icon";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></i>\n            <a href=\"#\">\n              ");
    stack1 = depth0;
    stack2 = "hostInfo.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            </a>\n          </div>\n          <div class=\"progress-bar span2\">\n              <div ");
    stack1 = {};
    stack2 = "hostInfo.isInProgress:progress-striped :active hostInfo.barColor :progress";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                  <div class=\"bar\" ");
    stack1 = {};
    stack2 = "hostInfo.barWidth";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n              </div>\n          </div>\n          <div class=\"host-progress-num\">");
    stack1 = depth0;
    stack2 = "hostInfo.progress";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "%</div>\n          <div class=\"show-details\"><i class=\"icon-caret-right\"></i></div>\n        </div>\n      </div>\n      ");
    return buffer;}

  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n        <div class=\"log-list-wrap\">");
    stack1 = depth0;
    stack2 = "hostPopup.noHostsToShow";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n      ");
    return buffer;}

  function program12(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n      <div ");
    stack1 = {};
    stack2 = "taskInfo.isVisible::hidden :log-list-wrap";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        <div ");
    stack1 = depth0;
    stack2 = "taskInfo";
    stack3 = depth0;
    stack4 = "toggleTaskLog";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"task-list-line-cursor\">\n          <i ");
    stack1 = {};
    stack2 = "taskInfo.status taskInfo.icon";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></i>\n          <a href=\"#\">\n            ");
    stack1 = depth0;
    stack2 = "taskInfo.role";
    stack3 = {};
    stack4 = "true";
    stack3['unescaped'] = stack4;
    stack4 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push(" ");
    stack1 = depth0;
    stack2 = "taskInfo.command";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          </a>\n          <div class=\"show-details\"><i class=\"icon-caret-right\"></i></div>\n        </div>\n      </div>\n      ");
    return buffer;}

  function program14(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n        <div class=\"log-list-wrap\">");
    stack1 = depth0;
    stack2 = "hostPopup.noTasksToShow";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n      ");
    return buffer;}

  function program16(depth0,data) {
    
    
    data.buffer.push("\n      <div class=\"spinner\"></div>\n    ");}

    data.buffer.push("\n\n<div class=\"host-component-popup-wrap\">\n\n    ");
    stack1 = depth0;
    stack2 = "view.parentView.isLoaded";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(16, program16, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/metric", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "view.itemView";
    stack3 = {};
    stack4 = "metric";
    stack3['metricBinding'] = stack4;
    stack4 = "view";
    stack3['widgetBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <div class=\"accordion\" id=\"metricAccordion\">\n      ");
    stack1 = depth0;
    stack2 = "view.moreMetrics";
    stack3 = helpers.each;
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </div>\n    ");
    return buffer;}
  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <div class=\"accordion-group\">\n        <div class=\"accordion-heading\">\n          <a class=\"accordion-toggle\" data-toggle=\"collapse\" data-parent=\"#metricAccordion\"\n             href=\"#");
    stack1 = depth0;
    stack2 = "code";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "Collapse\">\n            <i class=\"icon-play\"></i>");
    stack1 = depth0;
    stack2 = "label";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          </a>\n        </div>\n        <div id=\"");
    stack1 = depth0;
    stack2 = "code";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "Collapse\" class=\"accordion-body collapse\">\n          <div class=\"accordion-inner\">\n            ");
    stack1 = depth0;
    stack2 = "items.length";
    stack3 = helpers['if'];
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(8, program8, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          </div>\n        </div>\n      </div>\n      ");
    return buffer;}
  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n            <ul class=\"items\">\n              ");
    stack1 = depth0;
    stack2 = "items";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "metric";
    stack7 = helpers.each;
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            </ul>\n            ");
    return buffer;}
  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n              ");
    stack1 = depth0;
    stack2 = "view.moreItemView";
    stack3 = {};
    stack4 = "metric";
    stack3['metricBinding'] = stack4;
    stack4 = "view";
    stack3['widgetBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n              ");
    return buffer;}

  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "metric.notFound";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"span title\">\n  ");
    stack1 = depth0;
    stack2 = "common.metrics";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " <i class=\"icon-question-sign\"></i>\n</div>\n<ul class=\"display-inline-block nav nav-pills\">\n  ");
    stack1 = depth0;
    stack2 = "view.metrics";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "metric";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n  <li class=\"dropdown\">\n    <a ");
    stack1 = depth0;
    stack2 = "toggleMore";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"#\">\n      ");
    stack1 = depth0;
    stack2 = "metric.more";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n      <b class=\"caret\"></b>\n    </a>\n\n    ");
    stack1 = depth0;
    stack2 = "view.showMore";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </li>\n</ul>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/common/time_range", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "view.presetView";
    stack3 = {};
    stack4 = "preset";
    stack3['presetBinding'] = stack4;
    stack4 = "view";
    stack3['widgetBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"span title\">\n  ");
    stack1 = depth0;
    stack2 = "common.timeRange";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " <i class=\"icon-question-sign\"></i>\n</div>\n<ul class=\"display-inline-block nav nav-pills\">\n  ");
    stack1 = depth0;
    stack2 = "view.presets";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "preset";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "from";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "view.dateFromView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    stack1 = depth0;
    stack2 = "to";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "view.dateToView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n</ul>\n<div id=\"slider\">\n  <sapn class=\"period-marker\">");
    stack1 = depth0;
    stack2 = "view.rangeLabel";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</sapn>\n  <sapn class=\"now-marker\">");
    stack1 = depth0;
    stack2 = "view.nowLabel";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</sapn>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/installer", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<div class=\"wizard\">\n  <div class=\"container\">\n    <div class=\"container-fluid\">\n      <div class=\"row-fluid\">\n        <div class=\"span3\">\n          <!--Sidebar content-->\n          <div class=\"well\">\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li class=\"nav-header\">");
    stack1 = depth0;
    stack2 = "installer.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</li>\n              <li ");
    stack1 = {};
    stack2 = "isStep0:active view.isStep0Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep0";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step0.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep1:active view.isStep1Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep1";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step1.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep2:active view.isStep2Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep2";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step2.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep3:active view.isStep3Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep3";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step3.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep4:active view.isStep4Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep4";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step4.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep5:active view.isStep5Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep5";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step5.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep6:active view.isStep6Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep6";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step6.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep7:active view.isStep7Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep7";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step7.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep8:active view.isStep8Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep8";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step8.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep9:active view.isStep9Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep9";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step9.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep10:active view.isStep10Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\" ");
    stack1 = depth0;
    stack2 = "gotoStep10";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step10.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n            </ul>\n          </div>\n        </div>\n        <div class=\"wizard-content well span9\">\n          ");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/login", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <div class=\"alert alert-error\">\n        ");
    stack1 = depth0;
    stack2 = "errorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </div>\n    ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"well login span4\">\n    <h2>");
    stack1 = depth0;
    stack2 = "login.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n    ");
    stack1 = depth0;
    stack2 = "errorMessage";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    <label>");
    stack1 = depth0;
    stack2 = "login.username";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</label>\n    ");
    stack1 = depth0;
    stack2 = "view.loginTextField";
    stack3 = {};
    stack4 = "loginName";
    stack3['valueBinding'] = stack4;
    stack4 = "span4";
    stack3['class'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    <label>");
    stack1 = depth0;
    stack2 = "login.password";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</label>\n    ");
    stack1 = depth0;
    stack2 = "view.passTextField";
    stack3 = {};
    stack4 = "password";
    stack3['type'] = stack4;
    stack4 = "password";
    stack3['valueBinding'] = stack4;
    stack4 = "span4";
    stack3['class'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        <button class=\"btn btn-success\" ");
    stack1 = depth0;
    stack2 = "submit";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "login.loginButton";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  <div id=\"main-nav\">\n    <div class=\"navbar\">\n      <div class=\"navbar-inner\">\n        ");
    stack1 = depth0;
    stack2 = "App.MainMenuView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </div>\n    </div>\n  </div>\n  ");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  <h2>");
    stack1 = depth0;
    stack2 = "app.loadingPlaceholder";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " </h2>\n  <div class=\"progress progress-striped active\">\n    <div class=\"bar\" ");
    stack1 = {};
    stack2 = "controller.clusterDataLoadedPercent";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n  </div>\n");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "isClusterDataLoaded";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "isClusterDataLoaded";
    stack3 = helpers.unless;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "view.NavItemView";
    stack3 = {};
    stack4 = "category.name";
    stack3['itemBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n              <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "category.url";
    stack3 = depth0;
    stack4 = "goToAdmin";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " >");
    stack1 = depth0;
    stack2 = "category.label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n          ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"row-fluid\">\n  <div id=\"main-admin-menu\" class=\"well span2\">\n      <ul class=\"nav nav-list\">\n        ");
    stack1 = depth0;
    stack2 = "view.categories";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "category";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </ul>\n  </div>\n  <div class=\"span10\">\n    <div class=\"row-fluid\">\n      ");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </div>\n  </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/advanced", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<h5>");
    stack1 = depth0;
    stack2 = "admin.advanced.title";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "<i class=\"icon-question-sign\"></i></h5>\n<div class=\"row\">\n  ");
    stack1 = depth0;
    stack2 = "admin.advanced.caution";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n</div>\n<div class=\"row\">\n  <button ");
    stack1 = depth0;
    stack2 = "uninstall";
    stack3 = {};
    stack4 = "App.router.mainAdminAdvancedController";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"btn\"><i class=\"icon-trash\"></i>&nbsp;");
    stack1 = depth0;
    stack2 = "admin.advanced.button.uninstallIncludingData";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n  <br/>\n  <button ");
    stack1 = depth0;
    stack2 = "view.params";
    stack3 = depth0;
    stack4 = "uninstall";
    stack5 = {};
    stack6 = "App.router.mainAdminAdvancedController";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"btn\"><i class=\"icon-trash\"></i>&nbsp;");
    stack1 = depth0;
    stack2 = "admin.advanced.button.uninstallKeepData";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/advanced/uninstall", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "admin.confirmUninstall";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1));
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/audit", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "column";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "row";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "view.pager";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n");
    return buffer;}

    data.buffer.push("\n\n<table class=\"table table-striped\">\n  <thead>\n  <tr>\n    ");
    stack1 = depth0;
    stack2 = "view.columns";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "column";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </tr>\n  </thead>\n  <tbody>\n  ");
    stack1 = depth0;
    stack2 = "view.rows";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "row";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </tbody>\n</table>\n");
    stack1 = depth0;
    stack2 = "view.pager";
    stack3 = helpers['if'];
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/authentication", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "App.FormFieldTemplate";
    stack3 = {};
    stack4 = "view.form.field.primaryServer";
    stack3['fieldBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    stack1 = depth0;
    stack2 = "App.FormFieldTemplate";
    stack3 = {};
    stack4 = "view.form.field.secondaryServer";
    stack3['fieldBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    stack1 = depth0;
    stack2 = "App.FormFieldTemplate";
    stack3 = {};
    stack4 = "view.form.field.useSsl";
    stack3['fieldBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    stack1 = depth0;
    stack2 = "App.FormFieldTemplate";
    stack3 = {};
    stack4 = "view.form.field.bindMethod";
    stack3['fieldBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    stack1 = depth0;
    stack2 = "view.useCredentials";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n    ");
    stack1 = depth0;
    stack2 = "App.FormFieldTemplate";
    stack3 = {};
    stack4 = "view.form.field.searchBaseDn";
    stack3['fieldBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    ");
    stack1 = depth0;
    stack2 = "App.FormFieldTemplate";
    stack3 = {};
    stack4 = "view.form.field.usernameAttribute";
    stack3['fieldBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n\n    <h5>");
    stack1 = depth0;
    stack2 = "admin.authentication.form.configurationTest";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h5>\n    ");
    stack1 = depth0;
    stack2 = "App.FormFieldTemplate";
    stack3 = {};
    stack4 = "view.form.field.userDN";
    stack3['fieldBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    ");
    stack1 = depth0;
    stack2 = "App.FormFieldTemplate";
    stack3 = {};
    stack4 = "view.form.field.userPassword";
    stack3['fieldBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n\n    <button ");
    stack1 = depth0;
    stack2 = "testConfiguration";
    stack3 = {};
    stack4 = "click";
    stack3['on'] = stack4;
    stack4 = "view.form";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"btn\">");
    stack1 = depth0;
    stack2 = "admin.authentication.form.testConfiguration";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n\n    ");
    stack1 = depth0;
    stack2 = "view.form.testConfigurationMessage";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "App.FormFieldTemplate";
    stack3 = {};
    stack4 = "view.form.field.bindUser";
    stack3['fieldBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    ");
    stack1 = depth0;
    stack2 = "App.FormFieldTemplate";
    stack3 = {};
    stack4 = "view.form.field.password";
    stack3['fieldBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    ");
    stack1 = depth0;
    stack2 = "App.FormFieldTemplate";
    stack3 = {};
    stack4 = "view.form.field.passwordRetype";
    stack3['fieldBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    return buffer;}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <p ");
    stack1 = {};
    stack2 = "view.form.testConfigurationClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.form.testConfigurationMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</p>\n    ");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "App.FormFieldTemplate";
    stack3 = {};
    stack4 = "view.form.field.method";
    stack3['fieldBinding'] = stack4;
    stack4 = "user-auth-method";
    stack3['id'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n\n");
    stack1 = depth0;
    stack2 = "view.ldapChecked";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n<div style=\"margin:40px 0\">\n  <button ");
    stack1 = depth0;
    stack2 = "updateValues";
    stack3 = {};
    stack4 = "view.form";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"btn\">");
    stack1 = depth0;
    stack2 = "form.cancel";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n  <button ");
    stack1 = depth0;
    stack2 = "view.form";
    stack3 = depth0;
    stack4 = "save";
    stack5 = {};
    stack6 = "App.router.mainAdminAuthenticationController";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"btn btn-primary\">");
    stack1 = depth0;
    stack2 = "form.save";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/cluster", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            (<a href=\"true\" ");
    stack1 = {};
    stack2 = "view.isUpgradeAvailable::inactive";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1));
    stack1 = depth0;
    stack2 = "upgradeStack";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n            ");
    stack1 = depth0;
    stack2 = "view.isUpgradeAvailable";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(4, program4, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            </a>)\n          ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    stack1 = depth0;
    stack2 = "admin.cluster.upgradeAvailable";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": ");
    stack1 = depth0;
    stack2 = "upgradeVersion";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    return buffer;}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push(" ");
    stack1 = depth0;
    stack2 = "admin.cluster.upgradeUnavailable";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    return buffer;}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "service.isHidden";
    stack3 = helpers.unless;
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    return buffer;}
  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n        <tr>\n            <td>");
    stack1 = depth0;
    stack2 = "service.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n            <td>");
    stack1 = depth0;
    stack2 = "service.version";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n            <td>");
    stack1 = depth0;
    stack2 = "service.description";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n        </tr>\n        ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"admin-cluster\">\n    <div class=\"header\">\n        <strong>");
    stack1 = depth0;
    stack2 = "admin.cluster.stackVersion";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": ");
    stack1 = depth0;
    stack2 = "App.currentStackVersion";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "App.supports.stackUpgrade";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </strong>\n    </div>\n    <table class=\"table table-bordered table-striped\">\n        <thead>\n        <tr>\n            <th>");
    stack1 = depth0;
    stack2 = "common.service";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n            <th>");
    stack1 = depth0;
    stack2 = "common.version";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n            <th>");
    stack1 = depth0;
    stack2 = "common.description";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n        </tr>\n        </thead>\n        <tbody>\n        ");
    stack1 = depth0;
    stack2 = "services";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "service";
    stack7 = helpers.each;
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </tbody>\n    </table>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/misc", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "controller.users";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(6, program6, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n      <div class=\"span6\">\n        <table class=\"table table-bordered table-striped\">\n          <thead>\n            <tr>\n              <th>");
    stack1 = depth0;
    stack2 = "common.name";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n              <th>");
    stack1 = depth0;
    stack2 = "common.value";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n            </tr>\n          </thead>\n          <tbody>\n            ");
    stack1 = depth0;
    stack2 = "controller.users";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "user";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          </tbody>\n        </table>\n      </div>\n    ");
    return buffer;}
  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              ");
    stack1 = depth0;
    stack2 = "user.isVisible";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            ");
    return buffer;}
  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                <tr>\n                  <td>");
    stack1 = depth0;
    stack2 = "user.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n                  <td>");
    stack1 = depth0;
    stack2 = "user.value";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n                </tr>\n              ");
    return buffer;}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <p>");
    stack1 = depth0;
    stack2 = "admin.misc.nothingToShow";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</p>\n    ");
    return buffer;}

  function program8(depth0,data) {
    
    
    data.buffer.push("\n    <div class=\"spinner\"></div>\n  ");}

    data.buffer.push("\n<div class=\"admin-misc\">\n  <div class=\"header\">\n    <strong>");
    stack1 = depth0;
    stack2 = "admin.misc.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</strong>\n  </div>\n  ");
    stack1 = depth0;
    stack2 = "controller.dataIsLoaded";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(8, program8, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/security", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "securityEnabled";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(4, program4, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <div>\n      <p class=\"text-success\">");
    stack1 = depth0;
    stack2 = "admin.security.enabled";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        <a\n                class=\"btn btn-padding btn-warning\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "notifySecurityOffPopup";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "admin.security.button.disable";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        </a> <br/>\n      </p>\n    </div>\n    <div>\n      ");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </div>\n  ");
    return buffer;}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <div>\n      <p class=\"muted\">");
    stack1 = depth0;
    stack2 = "admin.security.disabled";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        <a\n                class=\"btn btn-padding btn-success\" ");
    stack1 = depth0;
    stack2 = "addSecurity";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "admin.security.button.enable";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        </a> <br/>\n      </p>\n    </div>\n  ");
    return buffer;}

  function program6(depth0,data) {
    
    
    data.buffer.push("\n  <div class=\"spinner\"></div>\n");}

    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "dataIsLoaded";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(6, program6, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/security/add/menu", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n\n<div class=\"wizard\" id=\"enable_security\">\n    <div class=\"container\">\n        <div class=\"container-fluid\">\n            <div class=\"row-fluid\">\n                <div class=\"span3\">\n                    <!--Sidebar content-->\n                    <div class=\"well\">\n                        <ul class=\"nav nav-pills nav-stacked\">\n                            <li class=\"nav-header\">");
    stack1 = depth0;
    stack2 = "admin.addSecurity.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</li>\n                            <li ");
    stack1 = {};
    stack2 = "isStep1:active view.isStep1Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep1";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "admin.security.step1.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n                            <li ");
    stack1 = {};
    stack2 = "isStep2:active view.isStep2Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep2";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "admin.security.step2.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n                            <li ");
    stack1 = {};
    stack2 = "isStep3:active view.isStep3Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep3";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "admin.security.step3.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n                            <li ");
    stack1 = {};
    stack2 = "isStep4:active view.isStep4Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep4";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "admin.security.step4.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n                        </ul>\n                    </div>\n                </div>\n                <div class=\"wizard-content well span9\">\n                  ");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/security/add/step1", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<h2>");
    stack1 = depth0;
    stack2 = "admin.security.step1.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n<p class=\"alert\">\n  ");
    stack1 = depth0;
    stack2 = "admin.security.step1.body.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n</p>\n<div class=\"alert alert-info\">\n    <ol>\n        <li>");
    stack1 = depth0;
    stack2 = "admin.security.step1.body.instruction1";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</li>\n        <li>");
    stack1 = depth0;
    stack2 = "admin.security.step1.body.instruction2";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</li>\n        <li>");
    stack1 = depth0;
    stack2 = "admin.security.step1.body.instruction3";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</li>\n        <li>");
    stack1 = depth0;
    stack2 = "admin.security.step1.body.instruction4";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</li>\n    </ol>\n</div>\n\n\n<div class=\"btn-area\">\n    <a class=\"btn btn-success pull-right\" ");
    stack1 = depth0;
    stack2 = "next";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.next";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/security/add/step2", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<h2>");
    stack1 = depth0;
    stack2 = "admin.security.step2.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n\n<div id=\"serviceConfig\">\n  <p class=\"alert alert-info\">\n    ");
    stack1 = depth0;
    stack2 = "admin.security.step2.body.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n  </p>\n  ");
    stack1 = depth0;
    stack2 = "App.ServicesConfigView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n\n  <div class=\"btn-area\">\n    <a class=\"btn\" ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">&larr; ");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n\n    <a class=\"btn btn-success pull-right\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      ");
    stack1 = depth0;
    stack2 = "submit";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.next";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n  </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/security/add/step3", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            <tr>\n                <td>");
    stack1 = depth0;
    stack2 = "hostComponent.host";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n                <td>");
    stack1 = depth0;
    stack2 = "hostComponent.component";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n                <td>");
    stack1 = depth0;
    stack2 = "hostComponent.principal";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n                <td>");
    stack1 = depth0;
    stack2 = "hostComponent.keytab";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n            </tr>\n        ");
    return buffer;}

    data.buffer.push("\n\n<h2>");
    stack1 = depth0;
    stack2 = "admin.security.step3.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n<div class=\"alert alert-info\">");
    stack1 = depth0;
    stack2 = "admin.security.step3.notice";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n<div class=\"step3\">\n    <table class=\"table table-bordered table-striped\">\n        <thead>\n        <tr>\n            <th>");
    stack1 = depth0;
    stack2 = "common.host";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n            <th>");
    stack1 = depth0;
    stack2 = "common.component";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n            <th>");
    stack1 = depth0;
    stack2 = "admin.security.step3.table.principal";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n            <th>");
    stack1 = depth0;
    stack2 = "admin.security.step3.table.keytab";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n            </tr>\n        </thead>\n        <tbody>\n        ");
    stack1 = depth0;
    stack2 = "hostComponents";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "hostComponent";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </tbody>\n    </table>\n</div>\n<div class=\"btn-area\">\n    <a class=\"btn\" ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">&larr; ");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n    <div class=\"pull-right\">\n        <a class=\"btn btn-info\" ");
    stack1 = depth0;
    stack2 = "doDownloadCsv";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "admin.security.step3.downloadCSV";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n        <a class=\"btn btn-success\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "next";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.apply";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n    </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/security/add/step4", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  <p ");
    stack1 = {};
    stack2 = "view.msgColor :alert";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.message";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</p>\n");
    return buffer;}

    data.buffer.push("\n\n<h2>");
    stack1 = depth0;
    stack2 = "admin.security.step4.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n\n");
    stack1 = depth0;
    stack2 = "view.message";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "App.MainServiceReconfigureView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n\n<div class=\"btn-area\">\n  <a class=\"btn\" ");
    stack1 = {};
    stack2 = "isBackBtnDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">&larr; ");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n  <a class=\"btn btn-success pull-right\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    ");
    stack1 = depth0;
    stack2 = "done";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.done";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " </a>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/security/disable", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  <p ");
    stack1 = {};
    stack2 = "view.msgColor :alert";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.message";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</p>\n");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.message";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "App.MainServiceReconfigureView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n<div class=\"btn-area\">\n  <a class=\"btn btn-success pull-right\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    ");
    stack1 = depth0;
    stack2 = "done";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.done";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " </a>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/stack_upgrade", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;


    data.buffer.push("\n\n<div id=\"stack-upgrade\">\n  <div class=\"container\">\n    <div class=\"container-fluid\">\n      <div class=\"row-fluid\">\n        <div class=\"span3\">\n          <!--Sidebar content-->\n          <div class=\"well\">\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li ");
    stack1 = {};
    stack2 = "isStep1:active view.isStep1Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep1";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.start";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep2:active view.isStep2Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep2";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.confirm";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep3:active view.isStep3Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep3";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.upgrade";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n            </ul>\n          </div>\n        </div>\n        <div class=\"content well span9\">\n          ");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/user", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n<p class=\"text-info\">");
    stack1 = depth0;
    stack2 = "admin.users.ldapAuthUsed";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ".</p>\n");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n<table class=\"table table-bordered table-striped span6\">\n  <thead>\n  <tr>\n    <th style=\"width:50%\">");
    stack1 = depth0;
    stack2 = "admin.users.username";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n    <th style=\"width:10%\">");
    stack1 = depth0;
    stack2 = "admin.users.privileges";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n    <th style=\"width:20%\">");
    stack1 = depth0;
    stack2 = "admin.users.type";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n    <th style=\"width:20%\">");
    stack1 = depth0;
    stack2 = "admin.users.action";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n  </tr>\n  </thead>\n  <tbody>\n  ");
    stack1 = depth0;
    stack2 = "view.users";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "user";
    stack7 = helpers.each;
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </tbody>\n</table>\n<div class=\"span2\">\n  <button class=\"btn\" ");
    stack1 = depth0;
    stack2 = "gotoCreateUser";
    stack3 = {};
    stack4 = "click";
    stack3['on'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " >\n    <i class=\"icon-plus\"></i>");
    stack1 = depth0;
    stack2 = "admin.users.addButton";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n  </button>\n</div>\n");
    return buffer;}
  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "App.MainAdminUserRowView";
    stack3 = {};
    stack4 = "user";
    stack3['userBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.ldapUser";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(3, program3, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/user/create", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "field.isHidden";
    stack3 = helpers.unless;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n  <div ");
    stack1 = {};
    stack2 = "field.errorMessage:error :control-group";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n    <label class=\"control-label\" for=\"input");
    stack1 = depth0;
    stack2 = "field.name";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\">");
    stack1 = depth0;
    stack2 = "field.displayName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</label>\n    <div class=\"controls\">\n        ");
    stack1 = depth0;
    stack2 = "field.viewClass";
    stack3 = {};
    stack4 = "field.value";
    stack3['valueBinding'] = stack4;
    stack4 = "field.disabled";
    stack3['disabledBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "field.errorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n    </div>\n  </div>\n  ");
    return buffer;}

    data.buffer.push("\n\n<form class=\"form-horizontal\" autocomplete=\"off\">\n  ");
    stack1 = depth0;
    stack2 = "view.userForm.fields";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "field";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  <div class=\"control-group\">\n    <div class=\"controls\">\n      <button type=\"submit\" class=\"btn\" ");
    stack1 = depth0;
    stack2 = "gotoUsers";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "form.cancel";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n      <button type=\"submit\"\n              class=\"btn btn-primary\" ");
    stack1 = depth0;
    stack2 = "create";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">Create</button>\n    </div>\n  </div>\n</form>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/user/edit", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "field.isHidden";
    stack3 = helpers.unless;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n  <div ");
    stack1 = {};
    stack2 = "field.errorMessage:error :control-group";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n    <label class=\"control-label\" for=\"input");
    stack1 = depth0;
    stack2 = "field.name";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\">");
    stack1 = depth0;
    stack2 = "field.displayName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</label>\n    <div class=\"controls\">\n        ");
    stack1 = depth0;
    stack2 = "field.viewClass";
    stack3 = {};
    stack4 = "field.value";
    stack3['valueBinding'] = stack4;
    stack4 = "field.disabled";
    stack3['disabledBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "field.errorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n    </div>\n  </div>\n  ");
    return buffer;}

    data.buffer.push("\n\n<form class=\"form-horizontal\" autocomplete=\"off\">\n  ");
    stack1 = depth0;
    stack2 = "view.userForm.fields";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "field";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  <div class=\"control-group\">\n    <div class=\"controls\">\n      <button type=\"submit\" class=\"btn\" ");
    stack1 = depth0;
    stack2 = "gotoUsers";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "form.cancel";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n      <button type=\"submit\"\n              class=\"btn btn-primary\" ");
    stack1 = depth0;
    stack2 = "edit";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.save";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n    </div>\n  </div>\n</form>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/admin/user/row", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;


    data.buffer.push("\n\n<tr>\n  <td>");
    stack1 = depth0;
    stack2 = "user.userName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n  <td>");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "view.disableCheckBoxes";
    stack3['disabledBinding'] = stack4;
    stack4 = "user.admin";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n  <td>");
    stack1 = depth0;
    stack2 = "user.type";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n  <td>\n    <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "user";
    stack3 = depth0;
    stack4 = "gotoEditUser";
    stack5 = {};
    stack6 = "click";
    stack5['on'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "admin.users.edit";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>&nbsp;\n    <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "user";
    stack3 = depth0;
    stack4 = "deleteRecord";
    stack5 = {};
    stack6 = "App.router.mainAdminUserController";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "admin.users.delete";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n  </td>\n</tr>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/apps", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      ");
    stack1 = depth0;
    stack2 = "controller.columnsName";
    stack3 = helpers.each;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "view.parentView.sortingColumns";
    stack3 = {};
    stack4 = "this";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      ");
    return buffer;}
  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n         <tr>\n           <td class=\"no-data\" ");
    stack1 = {};
    stack2 = "controller.columnsName.content.length";
    stack1['colspan'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "apps.filters.nothingToShow";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n         </tr>\n       ");
    return buffer;}

  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n         ");
    stack1 = depth0;
    stack2 = "content";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "run";
    stack7 = helpers.each;
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n       ");
    return buffer;}
  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n           ");
    stack1 = depth0;
    stack2 = "view.containerRow";
    stack3 = {};
    stack4 = "run";
    stack3['runBinding'] = stack4;
    stack4 = "view.appTableRow";
    stack3['currentViewBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n         ");
    return buffer;}

    data.buffer.push("\n\n<div id=\"apps\">\n  <table class=\"table table-bordered avg-table\">\n    <tbody>\n    <tr>\n      <td></td>\n      <td>");
    stack1 = depth0;
    stack2 = "apps.avgTable.jobs";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "apps.avgTable.input";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "apps.avgTable.output";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "apps.avgTable.duration";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "apps.avgTable.oldest";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "apps.avgTable.mostRecent";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n    </tr>\n    <tr class=\"avg-info\">\n      <td>");
    stack1 = depth0;
    stack2 = "apps.avgTable.avg";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "summary.jobs.avg";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "summary.input.avg";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "summary.output.avg";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "summary.duration.avg";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "summary.times.oldest";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "summary.times.youngest";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n\n    </tr>\n    <tr class=\"compare-info\">\n      <td>");
    stack1 = depth0;
    stack2 = "apps.avgTable.min";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " / ");
    stack1 = depth0;
    stack2 = "apps.avgTable.max";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "summary.jobs.min";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " / ");
    stack1 = depth0;
    stack2 = "summary.jobs.max";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "summary.input.min";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " / ");
    stack1 = depth0;
    stack2 = "summary.input.max";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "summary.output.min";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " / ");
    stack1 = depth0;
    stack2 = "summary.output.max";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "summary.duration.min";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " / ");
    stack1 = depth0;
    stack2 = "summary.duration.max";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td></td>\n      <td></td>\n    </tr>\n    </tbody>\n  </table>\n\n  <div class=\"filter_info\">\n\n    <div class=\"span4\" id=\"filter_buttons\">");
    stack1 = depth0;
    stack2 = "common.show";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":\n      <a class=\"all\" ");
    stack1 = depth0;
    stack2 = "clickViewType";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " data-view-type=\"all\">");
    stack1 = depth0;
    stack2 = "apps.filters.all";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        (");
    stack1 = depth0;
    stack2 = "controller.paginationObject.iTotalRecords";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ")</a> &#124;\n      <a class=\"filtered\" ");
    stack1 = depth0;
    stack2 = "clickViewType";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " data-view-type=\"filtered\">");
    stack1 = depth0;
    stack2 = "apps.filters.filtered";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        (");
    stack1 = depth0;
    stack2 = "controller.filterObject.filteredDisplayRecords";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ")</a>\n    </div>\n    <div class=\"span2 clear_filter\">\n        <a ");
    stack1 = depth0;
    stack2 = "clearFilters";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "apps.filters.clearFilters";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n    </div>\n    <div class=\"search-bar\">\n        ");
    stack1 = depth0;
    stack2 = "view.appSearchThrough";
    stack3 = {};
    stack4 = "controller.filterObject.sSearch";
    stack3['valueBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </div>\n  </div>\n\n  <table class=\"table table-striped runsList\">\n    <thead>\n    ");
    stack1 = depth0;
    stack2 = "view.wrapSorting";
    stack3 = helpers.view;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    <tr>\n      <th>");
    stack1 = depth0;
    stack2 = "view.appIdFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th>");
    stack1 = depth0;
    stack2 = "view.nameFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th>");
    stack1 = depth0;
    stack2 = "view.typeFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th>");
    stack1 = depth0;
    stack2 = "view.userFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th>");
    stack1 = depth0;
    stack2 = "view.jobsFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th>");
    stack1 = depth0;
    stack2 = "view.inputFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th>");
    stack1 = depth0;
    stack2 = "view.outputFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th>");
    stack1 = depth0;
    stack2 = "view.durationFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th>");
    stack1 = depth0;
    stack2 = "view.runDateFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n    </tr>\n    </thead>\n    <tbody>\n       ");
    stack1 = depth0;
    stack2 = "view.emptyData";
    stack3 = helpers['if'];
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(7, program7, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </tbody>\n  </table>\n\n  <div class=\"page-bar\">\n      <div class=\"items-on-page\">\n          <label>");
    stack1 = depth0;
    stack2 = "common.show";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": ");
    stack1 = depth0;
    stack2 = "view.runPerPageSelectView";
    stack3 = {};
    stack4 = "runPerPageSelectView";
    stack3['viewName'] = stack4;
    stack4 = "controller.filterObject.iDisplayLength";
    stack3['selectionBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</label>\n      </div>\n      <div class=\"info\">");
    stack1 = depth0;
    stack2 = "view.paginationInfo";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n      <div class=\"paging_two_button\">\n          ");
    stack1 = depth0;
    stack2 = "view.paginationLeft";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "view.paginationRight";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </div>\n  </div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/apps/item", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n    <li ");
    stack1 = {};
    stack2 = "tab.active";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "tab";
    stack3 = depth0;
    stack4 = "switchTab";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <a href=\"javascript:void(0)\">");
    stack1 = depth0;
    stack2 = "tab.label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n    </li>\n    ");
    return buffer;}

    data.buffer.push("\n\n<td colspan=\"10\">\n  <ul class=\"nav nav-tabs\">\n    ");
    stack1 = depth0;
    stack2 = "view.menuTabs";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "tab";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </ul>\n  <div class=\"content\">\n    ");
    stack1 = depth0;
    stack2 = "view.containerView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n </td>\n\n\n\n\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/apps/item/bar", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', foundHelper, self=this;


    data.buffer.push("\n\n<div id=\"job_tasks\"></div>\n<div class=\"clearfix\"></div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/apps/item/dag", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "view.parentView.hasManyJobs";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "view.parentView.idSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "view.parentView.statusSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "view.parentView.mapsSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "view.parentView.reducesSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "view.parentView.inputSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "view.parentView.outputSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "view.parentView.durationSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    return buffer;}
  function program2(depth0,data) {
    
    var stack1, stack2, stack3;
    stack1 = depth0;
    stack2 = "view.parentView.nameSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1));}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <tr>\n        ");
    stack1 = depth0;
    stack2 = "view.hasManyJobs";
    stack3 = helpers['if'];
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        <td>");
    stack1 = depth0;
    stack2 = "job.id";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "job.status";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "job.maps";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "job.reduces";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "job.inputFormatted";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "job.outputFormatted";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "job.duration";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      ");
    return buffer;}
  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("<td>");
    stack1 = depth0;
    stack2 = "job.workflow_entity_name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>");
    return buffer;}

    data.buffer.push("\n    <div id=\"dag_viewer\"></div>\n\n    <div id=\"dag_viewer_legend\">\n      <ul>\n        <li><span id=\"job\"></span>Unfinished Job</li>\n        <li><span id=\"allmap\"></span>All Maps on Cluster</li>\n        <li><span id=\"allshuffle\"></span>All Shuffles on Cluster</li>\n        <li><span id=\"allreduce\"></span>All Reduces on Cluster</li>\n        <li><span id=\"jobdone\"></span>Finished Job</li>\n        <li><span id=\"map\"></span>Maps for this App</li>\n        <li><span id=\"shuffle\"></span>Shuffles for this App</li>\n        <li><span id=\"reduce\"></span>Reduces for this App</li>\n      </ul>\n    </div>\n\n    <table class=\"table table-bordered table-striped\" id=\"innerTable\">\n      <thead>\n      <tr>\n        ");
    stack1 = depth0;
    stack2 = "view.sortView";
    stack3 = {};
    stack4 = "controller.content.jobs";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </tr>\n      </thead>\n      <tbody>\n      ");
    stack1 = depth0;
    stack2 = "controller.content.jobs";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "job";
    stack7 = helpers.each;
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </tbody>\n    </table>\n\n\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/apps/list_row", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n<td rel=\"popover\" ");
    stack1 = {};
    stack2 = "apps.isRunning.popup.title";
    stack1['title'] = stack2;
    stack2 = "apps.isRunning.popup.content";
    stack1['data-content'] = stack2;
    foundHelper = helpers.translateAttr;
    stack2 = foundHelper || depth0.translateAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, tmp1); }
    else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "translateAttr", tmp1); }
    else { stack1 = stack2; }
    data.buffer.push(escapeExpression(stack1) + ">\n    <span title=\"");
    stack1 = depth0;
    stack2 = "run.lastUpdateTimeFormatted";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\">");
    stack1 = depth0;
    stack2 = "run.lastUpdateTimeFormattedShort";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n    <b class='red'>*</b></td>\n");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n<td>\n    <span title=\"");
    stack1 = depth0;
    stack2 = "run.lastUpdateTimeFormatted";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\">");
    stack1 = depth0;
    stack2 = "run.lastUpdateTimeFormattedShort";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n</td>\n");
    return buffer;}

    data.buffer.push("\n\n<td class=\"appId\" title=\"");
    stack1 = depth0;
    stack2 = "run.id";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\">");
    stack1 = depth0;
    stack2 = "run.idFormatted";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n<td>");
    stack1 = depth0;
    stack2 = "run.appName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n<td>");
    stack1 = depth0;
    stack2 = "run.type";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n<td>");
    stack1 = depth0;
    stack2 = "run.userName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n<td>");
    stack1 = depth0;
    stack2 = "run.numJobsTotal";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n<td>");
    stack1 = depth0;
    stack2 = "run.inputFormatted";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n<td>");
    stack1 = depth0;
    stack2 = "run.outputFormatted";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n<td>");
    stack1 = depth0;
    stack2 = "run.duration";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n");
    stack1 = depth0;
    stack2 = "run.isRunning";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(3, program3, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/apps/user_filter", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <li>\n      <label class=\"checkbox\">");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "user.checked";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "user.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</label>\n    </li>\n  ");
    return buffer;}

    data.buffer.push("\n<button class=\"btn btn-info single-btn-group\" ");
    stack1 = depth0;
    stack2 = "clickFilterButton";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n  ");
    stack1 = depth0;
    stack2 = "common.user";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "&nbsp;<span class=\"caret\"></span>\n</button>\n<ul class=\"dropdown-menu filter-components\">\n  ");
    stack1 = depth0;
    stack2 = "view.users";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "user";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  <li>\n    <button class=\"btn\" ");
    stack1 = depth0;
    stack2 = "closeFilter";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.cancel";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n    <button class=\"btn btn-primary\" ");
    stack1 = depth0;
    stack2 = "applyFilter";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.apply";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n  </li>\n</ul>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/background_operations_popup", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "App.MainBackgroundOperation";
    stack3 = {};
    stack4 = "operation";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n<div>\n  <a ");
    stack1 = depth0;
    stack2 = "showOperationLog";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"#\">\n    <i ");
    stack1 = {};
    stack2 = "view.iconClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></i>\n    ");
    stack1 = depth0;
    stack2 = "view.isOpen";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(5, program5, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push(" info about ");
    stack1 = depth0;
    stack2 = "operation.command";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "operation.role";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    on ");
    stack1 = depth0;
    stack2 = "operation.host_name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  </a>\n  ");
    stack1 = depth0;
    stack2 = "view.hasProgressBar";
    stack3 = helpers['if'];
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  <div class=\"content-area\">\n    <div class=\"textTrigger\">");
    stack1 = depth0;
    stack2 = "popup.highlight";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n    ");
    stack1 = depth0;
    stack2 = "view.isOpen";
    stack3 = helpers['if'];
    tmp1 = self.program(9, program9, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n</div>\n  ");
    return buffer;}
  function program3(depth0,data) {
    
    var stack1, stack2, stack3;
    stack1 = depth0;
    stack2 = "common.hide";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1));}

  function program5(depth0,data) {
    
    var stack1, stack2, stack3;
    stack1 = depth0;
    stack2 = "common.show";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1));}

  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2;
    data.buffer.push("\n  <div ");
    stack1 = {};
    stack2 = "view.isInProgress:progress-striped :active view.barColor :progress";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n    <div class=\"bar\"></div>\n  </div>\n  ");
    return buffer;}

  function program9(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "view.isTextArea";
    stack3 = helpers['if'];
    tmp1 = self.program(10, program10, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(12, program12, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    return buffer;}
  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <div>\n      ");
    stack1 = depth0;
    stack2 = "view.textArea";
    stack3 = {};
    stack4 = "operation";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </div>\n    ");
    return buffer;}

  function program12(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n    <div>\n      <h5>exitcode:</h5>\n        <pre class=\"stderr\">");
    stack1 = depth0;
    stack2 = "operation.display_exit_code";
    stack3 = helpers['if'];
    tmp1 = self.program(13, program13, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("</pre>\n      <h5>stderr:</h5>\n      <pre class=\"stderr\">");
    stack1 = depth0;
    stack2 = "err;fail";
    stack3 = depth0;
    stack4 = "operation.stderr";
    foundHelper = helpers.highlight;
    stack5 = foundHelper || depth0.highlight;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack5 === functionType) { stack1 = stack5.call(depth0, stack4, stack2, tmp1); }
    else if(stack5=== undef) { stack1 = helperMissing.call(depth0, "highlight", stack4, stack2, tmp1); }
    else { stack1 = stack5; }
    data.buffer.push(escapeExpression(stack1) + "</pre>\n      <h5>stdout:</h5>\n      <pre class=\"stdout\">");
    stack1 = depth0;
    stack2 = "err;fail";
    stack3 = depth0;
    stack4 = "operation.stdout";
    foundHelper = helpers.highlight;
    stack5 = foundHelper || depth0.highlight;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack5 === functionType) { stack1 = stack5.call(depth0, stack4, stack2, tmp1); }
    else if(stack5=== undef) { stack1 = helperMissing.call(depth0, "highlight", stack4, stack2, tmp1); }
    else { stack1 = stack5; }
    data.buffer.push(escapeExpression(stack1) + "</pre>\n    </div>\n    ");
    return buffer;}
  function program13(depth0,data) {
    
    var stack1, stack2, stack3;
    stack1 = depth0;
    stack2 = "operation.exit_code";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1));}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "allOperations";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "operation";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/charts", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1));
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/charts/heatmap", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n               <li class=\"dropdown-submenu\">\n                <a tabindex=\"-1\" >");
    stack1 = depth0;
    stack2 = "category.label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n                <ul class=\"dropdown-menu\">\n                  ");
    stack1 = depth0;
    stack2 = "category.items";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "metric";
    stack7 = helpers.each;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                </ul>\n               </li>\n            ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n                    <li>\n                      <a tabindex=\"-1\" ");
    stack1 = depth0;
    stack2 = "metric";
    stack3 = depth0;
    stack4 = "showHeatMapMetric";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "metric.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n                    </li>\n                  ");
    return buffer;}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n					<table class=\"legend\">\n					  ");
    stack1 = depth0;
    stack2 = "controller.selectedMetric.slotDefinitions";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "slot";
    stack7 = helpers.each;
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n					</table>\n	        ");
    stack1 = depth0;
    stack2 = "common.maximum";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":\n	        <div id=\"inputMaximum\" class=\"control-group\">\n	          ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "text";
    stack3['type'] = stack4;
    stack4 = "8";
    stack3['maxlength'] = stack4;
    stack4 = "controller.inputMaximum";
    stack3['valueBinding'] = stack4;
    stack4 = "span6";
    stack3['class'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n	          ");
    stack1 = depth0;
    stack2 = "controller.selectedMetric.units";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n	        </div>\n        ");
    return buffer;}
  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n					    <tr>\n					      <td>\n					        <div class=\"tile\" ");
    stack1 = {};
    stack2 = "slot.cssStyle";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n					      </td>\n					      <td>");
    stack1 = depth0;
    stack2 = "slot.label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n					    </tr>\n					  ");
    return buffer;}

  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n				    <div ");
    stack1 = {};
    stack2 = "controller.rackClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n				      ");
    stack1 = depth0;
    stack2 = "App.MainChartsHeatmapRackView";
    stack3 = {};
    stack4 = "rack";
    stack3['rackBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n				    </div>\n				  ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"heatmap\">\n\n  <div class=\"container-fluid\">\n	  <div class=\"row-fluid\">\n	    <div class=\"span2 legend-column\">\n		     <div class=\"btn-group\">\n				  <button class=\"btn\">");
    stack1 = depth0;
    stack2 = "charts.heatmap.selectMetric";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n				  <button class=\"btn dropdown-toggle\" data-toggle=\"dropdown\">\n				    <span class=\"caret\"></span>\n				  </button>\n				  <ul class=\"dropdown-menu\">\n				    ");
    stack1 = depth0;
    stack2 = "controller.allMetrics";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "category";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n				  </ul>\n				</div>\n        ");
    stack1 = depth0;
    stack2 = "controller.selectedMetric";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n	    </div>\n	    <div class=\"span10\">\n	      <h4 id=\"heatmap-metric-loading\">\n	        <span id=\"heatmap-metric-title\">");
    stack1 = depth0;
    stack2 = "controller.selectedMetric.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n	      </h4>\n	      <div class=\"row-fluid\">\n				  ");
    stack1 = depth0;
    stack2 = "controller.cluster.racks";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "rack";
    stack7 = helpers.each;
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n			  </div>\n			  ");
    stack1 = depth0;
    stack2 = "App.MainChartsHeatmapHostDetailView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n	    </div>\n	  </div>\n  </div>\n\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/charts/heatmap/heatmap_host", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<div ");
    stack1 = {};
    stack2 = "view.hostClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = {};
    stack2 = "view.hostTemperatureStyle";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n  <a href=\"#\" class=\"heatmap-host\" ");
    stack1 = depth0;
    stack2 = "view.content";
    stack3 = depth0;
    stack4 = "routeHostDetail";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></a>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/charts/heatmap/heatmap_host_detail", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "view.details.metricName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ": ");
    stack1 = depth0;
    stack2 = "view.details.metricValue";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "<br/>\n");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "common.disk";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": ");
    stack1 = depth0;
    stack2 = "view.details.diskUsage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "% <br/>\n");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "common.cpu";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": ");
    stack1 = depth0;
    stack2 = "view.details.cpuUsage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "%<br/>\n");
    return buffer;}

  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "common.memory";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": ");
    stack1 = depth0;
    stack2 = "view.details.memoryUsage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "%<br/>\n");
    return buffer;}

  function program9(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "common.components";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": ");
    stack1 = depth0;
    stack2 = "view.details.hostComponents";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "<br/>\n");
    return buffer;}

    data.buffer.push("\n\n<b>");
    stack1 = depth0;
    stack2 = "view.details.publicHostName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</b><br/>\n");
    stack1 = depth0;
    stack2 = "common.os";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": ");
    stack1 = depth0;
    stack2 = "view.details.osType";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "<br/>\n");
    stack1 = depth0;
    stack2 = "common.ipAddress";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": ");
    stack1 = depth0;
    stack2 = "view.details.ip";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "<br/>\n");
    stack1 = depth0;
    stack2 = "view.details.metricName";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "view.details.diskUsage";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "view.details.cpuUsage";
    stack3 = helpers['if'];
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "view.details.memoryUsage";
    stack3 = helpers['if'];
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "view.details.hostComponents";
    stack3 = helpers['if'];
    tmp1 = self.program(9, program9, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/charts/heatmap/heatmap_rack", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <div ");
    stack1 = {};
    stack2 = "view.hostCssStyle";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      ");
    stack1 = depth0;
    stack2 = "App.MainChartsHeatmapHostView";
    stack3 = {};
    stack4 = "this";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </div>\n  ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"rackHeader\">\n  <div class=\"statusName clearfix\">\n    <div ");
    stack1 = {};
    stack2 = "view.statusIndicator rack.status";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n    <div class=\"rackName\">");
    stack1 = depth0;
    stack2 = "rack.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n    <!--<a href=\"#\" class=\"toggler\" ");
    data.buffer.push(">-->\n      <!--<span ");
    data.buffer.push("></span>-->\n    <!--</a>-->\n  </div>\n</div>\n<!--<div class=\"hostsSummary clearfix\">-->\n  <!--<div class=\"textBlock\">Total hosts: ");
    data.buffer.push("</div>-->\n  <!--");
    data.buffer.push("-->\n    <!--<div class=\"textBlock\">-->\n      <!--<div class=\"indicatorG\"></div>-->\n      <!--Hosts in live state: ");
    data.buffer.push("-->\n    <!--</div>-->\n    <!--<div class=\"textBlock\">-->\n      <!--<div class=\"indicatorY\"></div>-->\n      <!--Hosts in critical state: ");
    data.buffer.push("-->\n    <!--</div>-->\n    <!--<div class=\"textBlock\">-->\n      <!--<div class=\"indicatorR\"></div>-->\n      <!--Hosts in dead state: ");
    data.buffer.push("-->\n    <!--</div>-->\n  <!--");
    data.buffer.push("-->\n<!--</div>-->\n<div ");
    stack1 = {};
    stack2 = "view.heatmapTogglerClass view.hostsBlockClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n  ");
    stack1 = depth0;
    stack2 = "rack.hosts";
    stack3 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/charts/linear_time", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <div id=\"");
    stack1 = depth0;
    stack2 = "view.id";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "-title\" class=\"chart-title\">");
    stack1 = depth0;
    stack2 = "view.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n  ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"screensaver chart-container\" ");
    stack1 = {};
    stack2 = "view.isReady:hide";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " >\n  <div id=\"");
    stack1 = depth0;
    stack2 = "view.id";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "-title\" class=\"chart-title\">");
    stack1 = depth0;
    stack2 = "view.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n</div>\n<div  id=\"");
    stack1 = depth0;
    stack2 = "view.id";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "-container\" class=\"chart-container hide\" ");
    stack1 = {};
    stack2 = "view.isReady:show";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "  rel=\"ZoomInTooltip\" title=\"Click to zoom\">\n  <div id=\"");
    stack1 = depth0;
    stack2 = "view.id";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "-yaxis\" class=\"chart-y-axis\" ");
    stack1 = depth0;
    stack2 = "showGraphInPopup";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n  <div id=\"");
    stack1 = depth0;
    stack2 = "view.id";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "-xaxis\" class=\"chart-x-axis\" ");
    stack1 = depth0;
    stack2 = "showGraphInPopup";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n  <div id=\"");
    stack1 = depth0;
    stack2 = "view.id";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "-legend\" class=\"chart-legend\"></div>\n  <div id=\"");
    stack1 = depth0;
    stack2 = "view.id";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "-chart\" class=\"chart\"  ");
    stack1 = depth0;
    stack2 = "showGraphInPopup";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n  <div id=\"");
    stack1 = depth0;
    stack2 = "view.id";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "-timeline\" class=\"timeline\" ");
    stack1 = depth0;
    stack2 = "showGraphInPopup";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n  ");
    stack1 = depth0;
    stack2 = "view.noTitleUnderGraph";
    stack3 = helpers.unless;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n</div>\n\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "view.isClassicDashboard";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(5, program5, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n    <div class=\"row\">\n      <div class=\"span6\">\n        <div class=\"row\">\n          <div class=\"span6\">\n            <div class=\"box\">\n              <div class=\"box-header\">\n                <h4>");
    stack1 = depth0;
    stack2 = "dashboard.services";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h4>\n              </div>\n              <dl class=\"dl-horizontal services\">\n                ");
    stack1 = depth0;
    stack2 = "view.content";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "item";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n              </dl>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"span6\">\n        <div class=\"box\">\n          <div class=\"box-header\">\n            <h4>");
    stack1 = depth0;
    stack2 = "dashboard.clusterMetrics";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h4>\n              <div class=\"btn-group\">\n                <a class=\"btn\" target=\"_blank\" rel=\"tooltip\" title=\"Go to Ganglia\" ");
    stack1 = {};
    stack2 = "view.gangliaUrl";
    stack1['href'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><i class=\"icon-link\"></i></a>\n                <a href=\"javascript:void(null)\" class=\"btn btn-success switch-button\" data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "switchToNew";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                  ");
    stack1 = depth0;
    stack2 = "dashboard.button.switchShort";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                  <i class=\"icon-forward\"></i>\n                </a>\n              </div>\n          </div>\n          <div class=\"graphs-container\">\n            <table class=\"graphs\">\n              <tr>\n                <td>\n                  ");
    stack1 = depth0;
    stack2 = "App.ChartClusterMetricsNetwork";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                </td>\n                <td>\n                  ");
    stack1 = depth0;
    stack2 = "App.ChartClusterMetricsLoad";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                </td>\n              </tr>\n              <tr>\n                <td>\n                  ");
    stack1 = depth0;
    stack2 = "App.ChartClusterMetricsMemory";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                </td>\n                <td>\n                  ");
    stack1 = depth0;
    stack2 = "App.ChartClusterMetricsCPU";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                </td>\n              </tr>\n            </table>\n          </div>\n        </div>\n      </div>\n    </div>\n  ");
    return buffer;}
  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n                  ");
    stack1 = depth0;
    stack2 = "item.viewName";
    stack3 = {};
    stack4 = "item.model";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <div class=\"row-fluid\">\n      <div class=\"services-menu well span2\" style=\"padding: 8px 0\">\n        ");
    stack1 = depth0;
    stack2 = "App.MainServiceMenuView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </div>\n\n      <div class=\"span10\" id=\"dashboard-widgets-container\">\n        <div class=\"box\">\n          <div class=\"box-header\">\n            <div class=\"row-fluid\">\n              <h4 class=\"span10\">");
    stack1 = depth0;
    stack2 = "dashboard.widgets";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h4>\n                <a class=\"add-widget-button span1\">");
    stack1 = depth0;
    stack2 = "view.plusButtonFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n                <div class=\"btn-group\">\n                  <button class=\"btn dropdown-toggle span1 more-options-button\"  data-toggle=\"dropdown\">\n                    <i class=\"icon-cog\"></i> &nbsp;\n                    <span class= \"caret\"></span>\n                  </button>\n                  <ul class=\"dropdown-menu right-align-dropdown\">\n                    <li>\n                      <a ");
    stack1 = depth0;
    stack2 = "resetAllWidgets";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                        <i class=\"icon-refresh\"></i>\n                        ");
    stack1 = depth0;
    stack2 = "dashboard.button.reset";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                      </a>\n                    </li>\n                    <li>\n                      <a ");
    stack1 = depth0;
    stack2 = "switchToClassic";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                        <i class=\"icon-backward\"></i>\n                        ");
    stack1 = depth0;
    stack2 = "dashboard.button.switch";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                      </a>\n                    </li>\n                    <li>\n                      <a target=\"_blank\" ");
    stack1 = {};
    stack2 = "view.gangliaUrl";
    stack1['href'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                        <i class=\"icon-share\"></i>\n                        ");
    stack1 = depth0;
    stack2 = "dashboard.button.gangliaLink";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                      </a>\n                    </li>\n                  </ul>\n                </div>\n            </div>\n          </div>\n\n          <div id=\"dashboard-widgets\"  class=\"widgets-container\">\n            <div class=\"thumbnails row-fluid\" id=\"sortable\">\n              ");
    stack1 = depth0;
    stack2 = "view.visibleWidgets.length";
    stack3 = helpers['if'];
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            </div>\n          </div>\n\n        </div>\n      </div>\n    </div>\n  ");
    return buffer;}
  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n                ");
    stack1 = depth0;
    stack2 = "view.visibleWidgets";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "widgetClass";
    stack7 = helpers.each;
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n              ");
    return buffer;}
  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                  ");
    stack1 = depth0;
    stack2 = "widgetClass.isProgressBar";
    stack3 = helpers['if'];
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(10, program10, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                ");
    return buffer;}
  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                    <div class=\"span4p8\">\n                      ");
    stack1 = depth0;
    stack2 = "widgetClass";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                    </div>\n                  ");
    return buffer;}

  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                    <div class=\"span2p4\">\n                      ");
    stack1 = depth0;
    stack2 = "widgetClass";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                    </div>\n                  ");
    return buffer;}

    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "view.isDataLoaded";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/alert_notification_popup", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  <ul id='summary-alerts-list' class=\"alerts\">\n    ");
    stack1 = depth0;
    stack2 = "view.warnAlerts";
    stack3 = helpers.each;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </ul>\n");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n      ");
    stack1 = depth0;
    stack2 = "App.AlertItemView";
    stack3 = {};
    stack4 = "this";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    ");
    return buffer;}

    data.buffer.push("\n\n<p>");
    stack1 = depth0;
    stack2 = "view.warnAlertsMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</p>\n");
    stack1 = depth0;
    stack2 = "view.warnAlertsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n<p class=\"alertsPopupLinks\">\n    <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "selectService";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "services.alerts.goToService";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n    <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "viewNagiosUrl";
    stack3 = {};
    stack4 = "mouseUp";
    stack3['on'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "services.alerts.goToNagios";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n</p>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/edit_widget_popup", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n         ");
    stack1 = depth0;
    stack2 = "view.configPropertyObj.isGreenOrangeRed";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(4, program4, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n       ");
    return buffer;}
  function program2(depth0,data) {
    
    
    data.buffer.push("\n             <div class=\"progress span9\">\n                 <div class=\"bar bar-success\" style=\"width: 33%;\"></div>\n                 <div class=\"bar bar-warning\" style=\"width: 33%;\"></div>\n                 <div class=\"bar bar-danger\" style=\"width: 34%;\"></div>\n             </div>\n         ");}

  function program4(depth0,data) {
    
    
    data.buffer.push("\n             <div class=\"progress span9\">\n                 <div class=\"bar bar-danger\" style=\"width: 33%;\"></div>\n                 <div class=\"bar bar-warning\" style=\"width: 33%;\"></div>\n                 <div class=\"bar bar-success\" style=\"width: 34%;\"></div>\n             </div>\n         ");}

  function program6(depth0,data) {
    
    
    data.buffer.push("\n         <div class=\"span9\" id=\"slider-range\"></div>\n       ");}

    data.buffer.push("\n<form class=\"form-horizontal\" autocomplete=\"off\">\n    <div class=\"each-row\">\n        <div class=\"alert alert-info\">\n          ");
    stack1 = depth0;
    stack2 = "view.configPropertyObj.hintInfo";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        </div>\n    </div>\n\n    <div class=\"row-fluid\" id= \"min-height-limit\">\n       ");
    stack1 = depth0;
    stack2 = "view.configPropertyObj.isIE9";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(6, program6, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </div>\n\n    <div class=\"row-fluid\">\n        <div id=\"slider-value1\" class=\"value-on-slider span2\">0</div>\n        <div id=\"slider-value2\" ");
    stack1 = {};
    stack2 = "view.configPropertyObj.isThresh1Error:slider-error :value-on-slider :span4";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n          ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "view.configPropertyObj.thresh1";
    stack3['valueBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "view.configPropertyObj.errorMessage1";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n        </div>\n        <div id=\"slider-value3\" ");
    stack1 = {};
    stack2 = "view.configPropertyObj.isThresh2Error:slider-error :value-on-slider :span4";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n          ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "view.configPropertyObj.thresh2";
    stack3['valueBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "view.configPropertyObj.errorMessage2";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n        </div>\n        <div id=\"slider-value4\" class=\"value-on-slider span2\">");
    stack1 = depth0;
    stack2 = "view.configPropertyObj.maxValue";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n    </div>\n\n</form>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/plus_button_filter", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n    <li>\n      <ul>\n        ");
    stack1 = depth0;
    stack2 = "view.hiddenWidgets";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "widget";
    stack7 = helpers.each;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </ul>\n    </li>\n    <li>\n      <button class=\"btn\" ");
    stack1 = depth0;
    stack2 = "closeFilter";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.cancel";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n      <button class=\"btn btn-primary\" ");
    stack1 = depth0;
    stack2 = "applyFilter";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.apply";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n    </li>\n  ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n          <li>\n            <label class=\"checkbox\">\n              ");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "widget.checked";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "widget.displayName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            </label>\n          </li>\n        ");
    return buffer;}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <li>\n      <ul>\n      <li>");
    stack1 = depth0;
    stack2 = "dashboard.widgets.nothing";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</li>\n      </ul>\n    </li>\n    <li>\n      <button class=\"btn\" ");
    stack1 = depth0;
    stack2 = "closeFilter";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.cancel";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n    </li>\n\n  ");
    return buffer;}

    data.buffer.push("\n\n<button class=\"btn single-btn-group add-button\" ");
    stack1 = depth0;
    stack2 = "clickFilterButton";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " >\n    <i class=\"icon-plus\"></i> <span style=\"font-weight: bold\">");
    stack1 = depth0;
    stack2 = "common.add";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</span>\n</button>\n<ul class=\"dropdown-menu filter-components\" >\n  ");
    stack1 = depth0;
    stack2 = "view.hiddenWidgets.length";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(4, program4, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</ul>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/service/flume", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n<div class=\"clearfix like_pointer\" ");
    stack1 = depth0;
    stack2 = "toggleInfoView";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n  <div class=\"name span2\">\n    ");
    stack1 = depth0;
    stack2 = "view.isCollapsed";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(4, program4, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "App.MainDashboardServiceHealthView";
    stack3 = {};
    stack4 = "view.service";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    <a ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "selectService";
    stack5 = {};
    stack6 = true;
    stack5['href'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.service.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n    ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n  <div class=\"summary span\">\n    ");
    stack1 = depth0;
    stack2 = "view.summaryHeader";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n</div>\n<div class=\"service-body\">\n  <div class=\"span4\">\n    <table class=\"table no-borders\">\n      <tbody>\n    ");
    return buffer;}
  function program2(depth0,data) {
    
    
    data.buffer.push("\n    <i class=\"icon-caret-down pull-left\"></i>\n    ");}

  function program4(depth0,data) {
    
    
    data.buffer.push("\n    <i class=\"icon-caret-right pull-left\"></i>\n    ");}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n      <a href=\"#\" class=\"label label-important\" ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "showAlertsPopup";
    stack5 = {};
    stack6 = "view.parentView";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </a>\n    ");
    return buffer;}

  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              ");
    stack1 = depth0;
    stack2 = "channelsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(9, program9, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            ");
    return buffer;}
  function program9(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n                <li> ");
    stack1 = depth0;
    stack2 = "channels";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "host";
    stack3 = depth0;
    stack4 = "showDetails";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "host.publicHostName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              ");
    return buffer;}

  function program11(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              ");
    stack1 = depth0;
    stack2 = "sourcesCount";
    stack3 = helpers['if'];
    tmp1 = self.program(12, program12, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            ");
    return buffer;}
  function program12(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n                <li> ");
    stack1 = depth0;
    stack2 = "sources";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "host";
    stack3 = depth0;
    stack4 = "showDetails";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "host.publicHostName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              ");
    return buffer;}

  function program14(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              ");
    stack1 = depth0;
    stack2 = "sinksCount";
    stack3 = helpers['if'];
    tmp1 = self.program(15, program15, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            ");
    return buffer;}
  function program15(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n                <li> ");
    stack1 = depth0;
    stack2 = "sinks";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "host";
    stack3 = depth0;
    stack4 = "showDetails";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "host.publicHostName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              ");
    return buffer;}

  function program17(depth0,data) {
    
    
    data.buffer.push("\n      </tbody>\n    </table>\n  </div>\n</div>\n");}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.showOnlyRows";
    stack3 = helpers.unless;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      <!-- Flume Agents -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.flume.agentsLabel";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>\n            <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.flumeServerComponent";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.summaryHeader";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n        </td>\n      </tr>\n      <!-- Channels -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.flume.channels";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>\n          ");
    stack1 = depth0;
    stack2 = "view.service.channelsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "dashboard.services.flume.channels";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          <ul>\n            ");
    stack1 = depth0;
    stack2 = "view.service.nodes";
    stack3 = helpers.each;
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          </ul>\n        </td>\n      </tr>\n      <!-- Sources -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.flume.sources";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>\n          ");
    stack1 = depth0;
    stack2 = "view.service.sourcesCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "dashboard.services.flume.sources";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          <ul>\n            ");
    stack1 = depth0;
    stack2 = "view.service.nodes";
    stack3 = helpers.each;
    tmp1 = self.program(11, program11, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          </ul>\n        </td>\n      </tr>\n      <!-- Sinks -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.flume.sinks";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>\n          ");
    stack1 = depth0;
    stack2 = "view.service.sinksCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "dashboard.services.flume.sinks";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          <ul>\n            ");
    stack1 = depth0;
    stack2 = "view.service.nodes";
    stack3 = helpers.each;
    tmp1 = self.program(14, program14, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          </ul>\n        </td>\n      </tr>\n    ");
    stack1 = depth0;
    stack2 = "view.showOnlyRows";
    stack3 = helpers.unless;
    tmp1 = self.program(17, program17, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/service/hbase", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n<div class=\"clearfix like_pointer\" ");
    stack1 = depth0;
    stack2 = "toggleInfoView";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n  <div class=\"name span2\">\n    ");
    stack1 = depth0;
    stack2 = "view.isCollapsed";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(4, program4, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "App.MainDashboardServiceHealthView";
    stack3 = {};
    stack4 = "view.service";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    <a ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "selectService";
    stack5 = {};
    stack6 = true;
    stack5['href'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.service.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n    ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n  <div class=\"summary span\">\n    ");
    stack1 = depth0;
    stack2 = "view.summaryHeader";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n</div>\n<div class=\"service-body\">\n  <div class=\"span4\">\n    <table class=\"table no-borders\">\n      <tbody>\n    ");
    return buffer;}
  function program2(depth0,data) {
    
    
    data.buffer.push("\n    <i class=\"icon-caret-down pull-left\"></i>\n    ");}

  function program4(depth0,data) {
    
    
    data.buffer.push("\n    <i class=\"icon-caret-right pull-left\"></i>\n    ");}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n      <a href=\"#\" class=\"label label-important\" ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "showAlertsPopup";
    stack5 = {};
    stack6 = "view.parentView";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </a>\n    ");
    return buffer;}

  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      </tbody>\n    </table>\n  </div>\n<div class=\"dashboard-mini-chart span2\">\n  ");
    stack1 = depth0;
    stack2 = "App.ChartServiceMetricsHBASE_RegionServerReadWriteRequests";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  \n  ");
    stack1 = depth0;
    stack2 = "view.service.quickLinks.length";
    stack3 = helpers['if'];
    tmp1 = self.program(9, program9, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</div>\n</div>\n");
    return buffer;}
  function program9(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "App.QuickViewLinks";
    stack3 = {};
    stack4 = "view.service";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(10, program10, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  ");
    return buffer;}
  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  <div class=\"btn-group\">\n    <a class=\"btn btn-mini dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">\n      ");
    stack1 = depth0;
    stack2 = "common.quickLinks";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n      <span class=\"caret\"></span>\n    </a>\n    <ul class=\"dropdown-menu\">\n      ");
    stack1 = depth0;
    stack2 = "view.quickLinks";
    stack3 = helpers.each;
    tmp1 = self.program(11, program11, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </ul>\n  </div>\n  ");
    return buffer;}
  function program11(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n        <li><a ");
    stack1 = {};
    stack2 = "url";
    stack1['href'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " target=\"_blank\">");
    stack1 = depth0;
    stack2 = "label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n      ");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.showOnlyRows";
    stack3 = helpers.unless;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      <!-- HBase Master Server -->\n\n      ");
    stack1 = depth0;
    stack2 = "view.dashboardMasterComponentView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n\n      <!-- RegionServers -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.hbase.regionServers";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n         <td>\n            <span class=\"green-live\">");
    stack1 = depth0;
    stack2 = "view.liveRegionServes.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "/");
    stack1 = depth0;
    stack2 = "view.service.regionServers.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " </span> ");
    stack1 = depth0;
    stack2 = "services.service.summary.RegionServersLIVE";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n            <div class=\"summary-view-host\">\n              <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.regionServerComponent";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.regionServesText";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n            </div>\n         </td>\n      </tr>\n      <!-- Regions in Transition -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.hbase.regions.transition";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.service.regionsInTransition";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- HBase Master Started Time -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.hbase.masterStarted";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.masterStartedTime";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- HBase Master Activated Time -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.hbase.masterActivated";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.masterStartedTime";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- Average Load -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.hbase.averageLoad";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.averageLoad";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- Master Server Heap -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.hbase.masterServerHeap";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.masterServerHeapSummary";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n\n    ");
    stack1 = depth0;
    stack2 = "view.showOnlyRows";
    stack3 = helpers.unless;
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/service/hdfs", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n<div class=\"clearfix like_pointer\" ");
    stack1 = depth0;
    stack2 = "toggleInfoView";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n  <div class=\"name span2\">\n    ");
    stack1 = depth0;
    stack2 = "view.isCollapsed";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(4, program4, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "App.MainDashboardServiceHealthView";
    stack3 = {};
    stack4 = "view.service";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    <a ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "selectService";
    stack5 = {};
    stack6 = true;
    stack5['href'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.service.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n    ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n  <div class=\"summary span\">\n    ");
    stack1 = depth0;
    stack2 = "view.summaryHeader";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n</div>\n<div class=\"service-body\">\n  <div class=\"span4\">\n    <table class=\"table no-borders\">\n      <tbody>\n    ");
    return buffer;}
  function program2(depth0,data) {
    
    
    data.buffer.push("\n    <i class=\"icon-caret-down pull-left\"></i>\n    ");}

  function program4(depth0,data) {
    
    
    data.buffer.push("\n    <i class=\"icon-caret-right pull-left\"></i>\n    ");}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n      <a href=\"#\" class=\"label label-important\" ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "showAlertsPopup";
    stack5 = {};
    stack6 = "view.parentView";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </a>\n    ");
    return buffer;}

  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "services.service.summary.pendingUpgradeStatus.notPending";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    return buffer;}

  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "services.service.summary.pendingUpgradeStatus.pending";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    return buffer;}

  function program12(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "services.service.summary.safeModeStatus.inSafeMode";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    return buffer;}

  function program14(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "services.service.summary.safeModeStatus.notInSafeMode";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    return buffer;}

  function program16(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n      </tbody>\n    </table>\n  </div>\n<div class=\"dashboard-mini-chart span2\">\n  <div ");
    stack1 = {};
    stack2 = "view.capacity";
    stack1['title'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n    ");
    stack1 = depth0;
    stack2 = "view.Chart";
    stack3 = {};
    stack4 = "view.service";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n  <div class=\"chartLabel\">");
    stack1 = depth0;
    stack2 = "dashboard.services.hdfs.chart.label";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n  ");
    stack1 = depth0;
    stack2 = "view.service.quickLinks.length";
    stack3 = helpers['if'];
    tmp1 = self.program(17, program17, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</div>\n</div>\n");
    return buffer;}
  function program17(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "App.QuickViewLinks";
    stack3 = {};
    stack4 = "view.service";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(18, program18, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  ");
    return buffer;}
  function program18(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <div class=\"btn-group\">\n        <a class=\"btn btn-mini dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">\n          ");
    stack1 = depth0;
    stack2 = "common.quickLinks";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          <span class=\"caret\"></span>\n        </a>\n        <ul class=\"dropdown-menu\">\n          ");
    stack1 = depth0;
    stack2 = "view.quickLinks";
    stack3 = helpers.each;
    tmp1 = self.program(19, program19, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </ul>\n      </div>\n    ");
    return buffer;}
  function program19(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            <li><a ");
    stack1 = {};
    stack2 = "url";
    stack1['href'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " target=\"_blank\">");
    stack1 = depth0;
    stack2 = "label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n          ");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.showOnlyRows";
    stack3 = helpers.unless;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n      ");
    stack1 = depth0;
    stack2 = "view.dashboardMasterComponentView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n\n      <!-- Data Nodes -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.hdfs.datanodes";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>\n          <span class=\"green-live\">");
    stack1 = depth0;
    stack2 = "view.dataNodesLive.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "/");
    stack1 = depth0;
    stack2 = "view.service.dataNodes.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span> ");
    stack1 = depth0;
    stack2 = "services.service.summary.DataNodesLive";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          <div class=\"summary-view-host\">\n            <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.dataNodeComponent";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.dataNodeHostText";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n          </div>\n        </td>\n      </tr>\n      <!-- NameNode Uptime -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.hdfs.nodes.uptime";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.nodeUptime";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- NameNode Heap -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.hdfs.nodes.heap";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.nodeHeap";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- Data Node Counts -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.hdfs.datanodecounts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>\n          ");
    stack1 = depth0;
    stack2 = "view.service.liveDataNodes.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "dashboard.services.hdfs.nodes.live";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " /\n          ");
    stack1 = depth0;
    stack2 = "view.service.deadDataNodes.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "dashboard.services.hdfs.nodes.dead";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " /\n          ");
    stack1 = depth0;
    stack2 = "view.service.decommissionDataNodes.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "dashboard.services.hdfs.nodes.decom";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        </td>\n      </tr>\n      <!-- HDFS Capacity -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.hdfs.capacity";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.capacity";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- Blocks Total -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "services.service.summary.blocksTotal";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.dfsTotalBlocks";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- Block Errors -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "services.service.summary.blockErrors";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>\n          ");
    stack1 = depth0;
    stack2 = "view.blockErrorsMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        </td>\n      </tr>\n      <!-- Total Files And Directories -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.hdfs.totalFilesAndDirs";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.dfsTotalFiles";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- Upgrade Status -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "services.service.summary.pendingUpgradeStatus";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>\n          ");
    stack1 = depth0;
    stack2 = "view.service.upgradeStatus";
    stack3 = helpers['if'];
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(10, program10, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </td>\n      </tr>\n      <!-- Safe Mode Status -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "services.service.summary.safeModeStatus";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>\n          ");
    stack1 = depth0;
    stack2 = "view.isSafeMode";
    stack3 = helpers['if'];
    tmp1 = self.program(12, program12, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(14, program14, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </td>\n      </tr>\n\n    ");
    stack1 = depth0;
    stack2 = "view.showOnlyRows";
    stack3 = helpers.unless;
    tmp1 = self.program(16, program16, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/service/hive", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n      <a href=\"#\" class=\"label label-important\" ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "showAlertsPopup";
    stack5 = {};
    stack6 = "view.parentView";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </a>\n    ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n      <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "component.host";
    stack3 = depth0;
    stack4 = "showDetails";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "component.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>,\n    ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"clearfix\">\n  <div class=\"name span2\">\n    <i class=\"pull-left icon-empty\"></i>\n    ");
    stack1 = depth0;
    stack2 = "App.MainDashboardServiceHealthView";
    stack3 = {};
    stack4 = "view.service";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    <a ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "selectService";
    stack5 = {};
    stack6 = true;
    stack5['href'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.service.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n    ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n  <div class=\"summary span\">\n    ");
    stack1 = depth0;
    stack2 = "view.titleMasters";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "component";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n    <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.clients.component";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.clients.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n  </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/service/mapreduce", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n<div class=\"clearfix like_pointer\" ");
    stack1 = depth0;
    stack2 = "toggleInfoView";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n  <div class=\"name span2\">\n    ");
    stack1 = depth0;
    stack2 = "view.isCollapsed";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(4, program4, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "App.MainDashboardServiceHealthView";
    stack3 = {};
    stack4 = "view.service";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    <a ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "selectService";
    stack5 = {};
    stack6 = true;
    stack5['href'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.service.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n    ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n  <div class=\"summary span\">\n    ");
    stack1 = depth0;
    stack2 = "view.summaryHeader";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n</div>\n<div class=\"service-body\">\n  <div class=\"span4\">\n    <table class=\"table no-borders\">\n      <tbody>\n    ");
    return buffer;}
  function program2(depth0,data) {
    
    
    data.buffer.push("\n    <i class=\"icon-caret-down pull-left\"></i>\n    ");}

  function program4(depth0,data) {
    
    
    data.buffer.push("\n    <i class=\"icon-caret-right pull-left\"></i>\n    ");}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n      <a href=\"#\" class=\"label label-important\" ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "showAlertsPopup";
    stack5 = {};
    stack6 = "view.parentView";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </a>\n    ");
    return buffer;}

  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      </tbody>\n    </table>\n  </div>\n<div class=\"dashboard-mini-chart span2\">\n  ");
    stack1 = depth0;
    stack2 = "App.ChartServiceMetricsMapReduce_TasksRunningWaiting";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  \n  ");
    stack1 = depth0;
    stack2 = "view.service.quickLinks.length";
    stack3 = helpers['if'];
    tmp1 = self.program(9, program9, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</div>\n</div>\n");
    return buffer;}
  function program9(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "App.QuickViewLinks";
    stack3 = {};
    stack4 = "view.service";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(10, program10, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  ");
    return buffer;}
  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  <div class=\"btn-group\">\n    <a class=\"btn btn-mini dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">\n      ");
    stack1 = depth0;
    stack2 = "common.quickLinks";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n      <span class=\"caret\"></span>\n    </a>\n    <ul class=\"dropdown-menu\">\n      ");
    stack1 = depth0;
    stack2 = "view.quickLinks";
    stack3 = helpers.each;
    tmp1 = self.program(11, program11, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </ul>\n  </div>\n  ");
    return buffer;}
  function program11(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <li><a ");
    stack1 = {};
    stack2 = "url";
    stack1['href'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " target=\"_blank\">");
    stack1 = depth0;
    stack2 = "label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n      ");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.showOnlyRows";
    stack3 = helpers.unless;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n     ");
    stack1 = depth0;
    stack2 = "view.dashboardMasterComponentView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n\n      <!-- TaskTrackers -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.mapreduce.taskTrackers";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>\n\n          <span class=\"green-live\">");
    stack1 = depth0;
    stack2 = "view.trackersSummary";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span> ");
    stack1 = depth0;
    stack2 = "services.service.summary.TrackersLive";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          <div class=\"summary-view-host\">\n            <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.taskTrackerComponent";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.trackersText";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n          </div>\n        </td>\n      </tr>\n      <!-- Job Tracker Uptime -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.mapreduce.jobTrackerUptime";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.jobTrackerUptime";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- TaskTracker Counts -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.mapreduce.taskTrackerCounts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>\n          ");
    stack1 = depth0;
    stack2 = "view.service.grayListTrackers.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "dashboard.services.mapreduce.nodes.blacklist";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " /\n          ");
    stack1 = depth0;
    stack2 = "view.service.blackListTrackers.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "dashboard.services.mapreduce.nodes.graylist";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " /\n          ");
    stack1 = depth0;
    stack2 = "view.service.trackersDecommissioned";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "dashboard.services.hdfs.nodes.decom";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        </td>\n      </tr>\n      <!-- JobTracker Heap -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.mapreduce.jobTrackerHeap";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.trackersHeapSummary";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- Total slots capacity -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.mapreduce.slotCapacity";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.slotsCapacitySummary";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- Jobs -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.mapreduce.jobs";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.jobsSummary";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- Map Slots -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.mapreduce.mapSlots";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.mapSlotsSummary";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- Reduce Slots -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.mapreduce.reduceSlots";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.reduceSlotsSummary";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- Tasks:Maps -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.mapreduce.tasks.maps";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.mapTasksSummary";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n      <!-- Tasks:Reduces -->\n      <tr>\n        <td>");
    stack1 = depth0;
    stack2 = "dashboard.services.mapreduce.tasks.reduces";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n        <td>");
    stack1 = depth0;
    stack2 = "view.reduceTasksSummary";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      </tr>\n\n    ");
    stack1 = depth0;
    stack2 = "view.showOnlyRows";
    stack3 = helpers.unless;
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/service/mapreduce2", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n      <a href=\"#\" class=\"label label-important\" ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "showAlertsPopup";
    stack5 = {};
    stack6 = "view.parentView";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </a>\n    ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"clearfix\">\n  <div class=\"name span2\">\n    <i class=\"pull-left icon-empty\"></i>\n    ");
    stack1 = depth0;
    stack2 = "App.MainDashboardServiceHealthView";
    stack3 = {};
    stack4 = "view.service";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    <a ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "selectService";
    stack5 = {};
    stack6 = true;
    stack5['href'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.service.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n    ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n  <div class=\"summary span\">\n    ");
    stack1 = depth0;
    stack2 = "view.titleInfo";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/service/oozie", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n      <a href=\"#\" class=\"label label-important\" ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "showAlertsPopup";
    stack5 = {};
    stack6 = "view.parentView";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </a>\n    ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n      <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "component.host";
    stack3 = depth0;
    stack4 = "showDetails";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "component.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>,\n    ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"clearfix\">\n  <div class=\"name span2\">\n    <i class=\"pull-left icon-empty\"></i>\n    ");
    stack1 = depth0;
    stack2 = "App.MainDashboardServiceHealthView";
    stack3 = {};
    stack4 = "view.service";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    <a ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "selectService";
    stack5 = {};
    stack6 = true;
    stack5['href'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.service.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n    ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n  <div class=\"summary span\">\n    ");
    stack1 = depth0;
    stack2 = "view.masters";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "component";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n    <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.clients.component";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.clients.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>,\n\n    <a href=\"");
    stack1 = depth0;
    stack2 = "view.webUi";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\" target=\"_blank\">");
    stack1 = depth0;
    stack2 = "services.oozie.webUi";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n\n  </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/service/zookeeper", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n      <a href=\"#\" class=\"label label-important\" ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "showAlertsPopup";
    stack5 = {};
    stack6 = "view.parentView";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </a>\n    ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"clearfix\">\n  <div class=\"name span2\">\n    <i class=\"pull-left icon-empty\"></i>\n    ");
    stack1 = depth0;
    stack2 = "App.MainDashboardServiceHealthView";
    stack3 = {};
    stack4 = "view.service";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    <a ");
    stack1 = depth0;
    stack2 = "view.service";
    stack3 = depth0;
    stack4 = "selectService";
    stack5 = {};
    stack6 = true;
    stack5['href'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.service.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n    ");
    stack1 = depth0;
    stack2 = "view.criticalAlertsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n  <div class=\"summary span\">\n    ");
    stack1 = depth0;
    stack2 = "view.titleInfo.pre";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.titleInfo.component";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.titleInfo.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n    ");
    stack1 = depth0;
    stack2 = "services.zookeeper.postfix";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/widgets/cluster_metrics", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<div class=\"cluster-metrics\">\n  <li class=\"thumbnail row\">\n    <a class=\"corner-icon span1\" href=\"#\" ");
    stack1 = depth0;
    stack2 = "deleteWidget";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        <i class=\"icon-remove-sign icon-large\"></i>\n    </a>\n    <div class=\"caption span10\">");
    stack1 = depth0;
    stack2 = "view.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n\n    <div class=\"widget-content\" >\n      ");
    stack1 = depth0;
    stack2 = "view.content";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </div>\n  </li>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/widgets/hbase_links", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n              <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.activeMaster.host";
    stack3 = depth0;
    stack4 = "showDetails";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "dashboard.services.hbase.masterServer";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n              ");
    stack1 = depth0;
    stack2 = "view.passiveMasters.length";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                  ");
    stack1 = depth0;
    stack2 = "view.passiveMasterOutput";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n              ");
    return buffer;}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              ");
    stack1 = depth0;
    stack2 = "dashboard.services.hbase.noMasterServer";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    return buffer;}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              <a ");
    stack1 = {};
    stack2 = "view.hbaseMasterWebUrl";
    stack1['href'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " target=\"_blank\">");
    stack1 = depth0;
    stack2 = "dashboard.services.hbase.masterWebUI";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n            ");
    return buffer;}

  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              ");
    stack1 = depth0;
    stack2 = "services.service.summary.notAvailable";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    return buffer;}

  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "App.QuickViewLinks";
    stack3 = {};
    stack4 = "view.model";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(11, program11, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      ");
    return buffer;}
  function program11(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <div class=\"btn-group\">\n            <a class=\"btn btn-mini dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">\n              ");
    stack1 = depth0;
    stack2 = "common.more";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n              <span class=\"caret\"></span>\n            </a>\n            <ul class=\"dropdown-menu\">\n              ");
    stack1 = depth0;
    stack2 = "view.quickLinks";
    stack3 = helpers.each;
    tmp1 = self.program(12, program12, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            </ul>\n          </div>\n        ");
    return buffer;}
  function program12(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                <li><a ");
    stack1 = {};
    stack2 = "url";
    stack1['href'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " target=\"_blank\">");
    stack1 = depth0;
    stack2 = "label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"links\">\n  <li class=\"thumbnail row\">\n    <a class=\"corner-icon span1\" href=\"#\" ");
    stack1 = depth0;
    stack2 = "deleteWidget";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><i class=\"icon-remove-sign icon-large\"></i></a>\n    <div class=\"caption span10\"> ");
    stack1 = depth0;
    stack2 = "view.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n\n    <div class=\"widget-content\" >\n      <table>\n        <!--hbase master server-->\n        <tr>\n          <td>\n            ");
    stack1 = depth0;
    stack2 = "view.activeMaster";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(4, program4, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          </td>\n        </tr>\n        <!--region servers-->\n        <tr>\n            <td><a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.regionServerComponent";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.model.regionServers.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "dashboard.services.hbase.regionServers";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></td>\n        </tr>\n        <!--hbase master Web UI-->\n        <tr>\n          <td>\n            ");
    stack1 = depth0;
    stack2 = "view.activeMaster";
    stack3 = helpers['if'];
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(8, program8, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          </td>\n        </tr>\n      </table>\n    </div>\n\n    <div class=\"link-button\">\n      ");
    stack1 = depth0;
    stack2 = "view.model.quickLinks.length";
    stack3 = helpers['if'];
    tmp1 = self.program(10, program10, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </div>\n\n  </li>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/widgets/hdfs_links", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "App.QuickViewLinks";
    stack3 = {};
    stack4 = "view.model";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <div class=\"btn-group\">\n            <a class=\"btn btn-mini dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">\n              ");
    stack1 = depth0;
    stack2 = "common.more";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n              <span class=\"caret\"></span>\n            </a>\n            <ul class=\"dropdown-menu\">\n              ");
    stack1 = depth0;
    stack2 = "view.quickLinks";
    stack3 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            </ul>\n          </div>\n        ");
    return buffer;}
  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                  <li><a ");
    stack1 = {};
    stack2 = "url";
    stack1['href'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " target=\"_blank\">");
    stack1 = depth0;
    stack2 = "label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"links\">\n  <li class=\"thumbnail row\">\n    <a class=\"corner-icon span1\" href=\"#\" ");
    stack1 = depth0;
    stack2 = "deleteWidget";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <i class=\"icon-remove-sign icon-large\"></i>\n    </a>\n    <div class=\"caption span10\"> ");
    stack1 = depth0;
    stack2 = "view.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n\n    <div class=\"widget-content\" >\n      <table>\n        <!--NameNode-->\n        <tr>\n          <td><a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.model.nameNode";
    stack3 = depth0;
    stack4 = "showDetails";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "dashboard.services.hdfs.nanmenode";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></td>\n        </tr>\n        <!--SecondaryNameNode-->\n        <tr>\n          <td><a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.model.snameNode";
    stack3 = depth0;
    stack4 = "showDetails";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "dashboard.services.hdfs.snanmenode";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></td>\n        </tr>\n        <!--Data Nodes-->\n        <tr>\n          <td>\n              <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.dataNodeComponent";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.model.dataNodes.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "dashboard.services.hdfs.datanodes";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n          </td>\n        </tr>\n      </table>\n    </div>\n\n    <div class=\"link-button\">\n      ");
    stack1 = depth0;
    stack2 = "view.model.quickLinks.length";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </div>\n  </li>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/widgets/mapreduce_links", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "App.QuickViewLinks";
    stack3 = {};
    stack4 = "view.model";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <div class=\"btn-group\">\n            <a class=\"btn btn-mini dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">\n              ");
    stack1 = depth0;
    stack2 = "common.more";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n              <span class=\"caret\"></span>\n            </a>\n          <ul class=\"dropdown-menu\">\n            ");
    stack1 = depth0;
    stack2 = "view.quickLinks";
    stack3 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            </ul>\n          </div>\n        ");
    return buffer;}
  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              <li><a ");
    stack1 = {};
    stack2 = "url";
    stack1['href'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " target=\"_blank\">");
    stack1 = depth0;
    stack2 = "label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"links\">\n  <li class=\"thumbnail row\">\n    <a class=\"corner-icon span1\" href=\"#\" ");
    stack1 = depth0;
    stack2 = "deleteWidget";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <i class=\"icon-remove-sign icon-large\"></i>\n    </a>\n    <div class=\"caption span10\"> ");
    stack1 = depth0;
    stack2 = "view.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n\n    <div class=\"widget-content\" >\n      <table>\n        <!--jobTracker-->\n        <tr>\n          <td><a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.model.jobTracker";
    stack3 = depth0;
    stack4 = "showDetails";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "services.service.summary.jobTracker";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></td>\n        </tr>\n        <!--taskTrackers-->\n        <tr>\n          <td><a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.taskTrackerComponent";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.model.taskTrackers.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "dashboard.services.mapreduce.taskTrackers";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></td>\n        </tr>\n        <!--jobTracker Web UI-->\n        <tr>\n          <td><a ");
    stack1 = {};
    stack2 = "view.jobTrackerWebUrl";
    stack1['href'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " target=\"_blank\">");
    stack1 = depth0;
    stack2 = "services.service.summary.jobTrackerWebUI";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></td>\n        </tr>\n      </table>\n    </div>\n\n    <div class=\"link-button\">\n      ");
    stack1 = depth0;
    stack2 = "view.model.quickLinks.length";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </div>\n  </li>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/widgets/mapreduce_slots", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <tr><td>");
    stack1 = depth0;
    stack2 = "line";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td></tr>");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <div class=\"widget-content row-fluid\" id=\"map-reduce-slots-text\" >\n        <ul class=\"span12\">\n          <div class=\"span3\"> ");
    stack1 = depth0;
    stack2 = "dashboard.widgets.mapSlots";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n          <div class=\"progress span5\" id=\"map-reduce-slots-bar1\">\n            <div class=\"bar bar-success\" ");
    stack1 = {};
    stack2 = "view.map_occupied";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n            <div class=\"bar bar-warning\" ");
    stack1 = {};
    stack2 = "view.map_reserved";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n            </div>\n          <div class=\"span3\" id=\"map-reduce-slots-num1\"> ");
    stack1 = depth0;
    stack2 = "view.map_display_text";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n        </ul>\n        <ul class=\"span12\">\n          <div class=\"span3\"> ");
    stack1 = depth0;
    stack2 = "dashboard.widgets.reduceSlots";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n          <div class=\"progress span5\" id=\"map-reduce-slots-bar2\">\n            <div class=\"bar bar-success\" ");
    stack1 = {};
    stack2 = "view.reduce_occupied";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n            <div class=\"bar bar-warning\" ");
    stack1 = {};
    stack2 = "view.reduce_reserved";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n            </div>\n          <div class=\"span3\" id=\"map-reduce-slots-num2\"> ");
    stack1 = depth0;
    stack2 = "view.reduce_display_text";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n        </ul>\n      </div>\n    ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <div class=\"widget-content-isNA slots-content-isNA\" >");
    stack1 = depth0;
    stack2 = "services.service.summary.notAvailable";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n    ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"has-hidden-info\">\n  <li class=\"thumbnail row\" >\n    <a class=\"corner-icon span1\" href=\"#\" ");
    stack1 = depth0;
    stack2 = "deleteWidget";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><i class=\"icon-remove-sign icon-large\"></i></a>\n    <div class=\"caption span10 slots-caption\"> ");
    stack1 = depth0;
    stack2 = "view.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n\n    <div class=\"hidden-info\">\n      <table align=\"center\">\n        ");
    stack1 = depth0;
    stack2 = "view.hiddenInfo";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "line";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </table>\n    </div>\n\n    ");
    stack1 = depth0;
    stack2 = "view.isViewExist";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(5, program5, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </li>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/widgets/pie_chart", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            <tr><td>");
    stack1 = depth0;
    stack2 = "line";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td></tr>\n        ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n      <div class=\"widget-content\" >\n        ");
    stack1 = depth0;
    stack2 = "view.content";
    stack3 = {};
    stack4 = "view.model";
    stack3['modelBinding'] = stack4;
    stack4 = "view.thresh1";
    stack3['thresh1Binding'] = stack4;
    stack4 = "view.thresh2";
    stack3['thresh2Binding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </div>\n    ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <div class=\"widget-content-isNA\" >");
    stack1 = depth0;
    stack2 = "services.service.summary.notAvailable";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n    ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"has-hidden-info\">\n  <li class=\"thumbnail row\">\n    <a class=\"corner-icon span1\" href=\"#\" ");
    stack1 = depth0;
    stack2 = "deleteWidget";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <i class=\"icon-remove-sign icon-large\"></i>\n    </a>\n    <div class=\"caption span10\">");
    stack1 = depth0;
    stack2 = "view.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n    <a class=\"corner-icon span1\" href=\"#\" ");
    stack1 = depth0;
    stack2 = "editWidget";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <i class=\"icon-edit\"></i>\n    </a>\n\n    <div class=\"hidden-info\">\n      <table align=\"center\">\n        ");
    stack1 = depth0;
    stack2 = "view.hiddenInfo";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "line";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </table>\n    </div>\n\n    ");
    stack1 = depth0;
    stack2 = "view.isPieExist";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(5, program5, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </li>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/widgets/simple_text", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <tr><td>");
    stack1 = depth0;
    stack2 = "line";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td></tr>\n        ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"has-hidden-info\">\n  <li class=\"thumbnail row\" >\n    <a class=\"corner-icon span1\" href=\"#\" ");
    stack1 = depth0;
    stack2 = "deleteWidget";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <i class=\"icon-remove-sign icon-large\"></i>\n    </a>\n    <div class=\"caption span10\"> ");
    stack1 = depth0;
    stack2 = "view.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n    <a class=\"corner-icon span1\" href=\"#\" ");
    stack1 = depth0;
    stack2 = "editWidget";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <i class=\"icon-edit\"></i>\n    </a>\n\n    <div ");
    stack1 = {};
    stack2 = "view.hiddenInfoClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <table align=\"center\">\n        ");
    stack1 = depth0;
    stack2 = "view.hiddenInfo";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "line";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </table>\n    </div>\n\n    <div ");
    stack1 = {};
    stack2 = ":widget-content view.hoverContentTopClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.content";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n  </li>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/dashboard/widgets/uptime", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <tr>\n            <td>\n              ");
    stack1 = depth0;
    stack2 = "line";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            </td>\n          </tr>\n        ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <div class=\"widget-content-isNA uptime-content-isNA\" >");
    stack1 = depth0;
    stack2 = "services.service.summary.notAvailable";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n    ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <div class=\"widget-content uptime-content\" >\n        ");
    stack1 = depth0;
    stack2 = "view.content";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </div>\n    ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"has-hidden-info\">\n  <li class=\"thumbnail row\" >\n    <a class=\"corner-icon span1\" href=\"#\" ");
    stack1 = depth0;
    stack2 = "deleteWidget";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <i class=\"icon-remove-sign icon-large\"></i>\n    </a>\n    <div class=\"caption span11\"> ");
    stack1 = depth0;
    stack2 = "view.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " </div>\n    <div ");
    stack1 = {};
    stack2 = "view.hiddenInfoClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <table align=\"center\">\n        ");
    stack1 = depth0;
    stack2 = "view.hiddenInfo";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "line";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </table>\n    </div>\n\n    ");
    stack1 = depth0;
    stack2 = "view.isNA";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(5, program5, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </li>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/host", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "view.categories";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "category";
    stack7 = helpers.each;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "category.isVisible";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    return buffer;}
  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n            |\n            <span ");
    stack1 = {};
    stack2 = "category.itemClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n            ");
    stack1 = depth0;
    stack2 = "category.alerts";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(6, program6, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n              <a ");
    stack1 = depth0;
    stack2 = "category";
    stack3 = depth0;
    stack4 = "selectCategory";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"#\">\n                ");
    stack1 = depth0;
    stack2 = "category.label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n              </a>\n            </span>\n          ");
    return buffer;}
  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                <span class=\"label label-important\">");
    stack1 = depth0;
    stack2 = "hosts.host.alerts.st";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</span>\n            ");
    return buffer;}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2;
    data.buffer.push("\n                <span ");
    stack1 = {};
    stack2 = "category.healthStatusValue";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "> &nbsp;&nbsp;&nbsp; </span>\n            ");
    return buffer;}

  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <div class=\"pull-right\">\n      <button class=\"btn btn-inverse add-host-button\" ");
    stack1 = depth0;
    stack2 = "addHost";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        <i class=\"icon-plus icon-white\"></i>\n        ");
    stack1 = depth0;
    stack2 = "hosts.host.add";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n      </button>\n    </div>\n    ");
    return buffer;}

  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <th class=\"first\"> </th>\n          ");
    stack1 = depth0;
    stack2 = "view.parentView.nameSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "view.parentView.ipSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "view.parentView.cpuSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "view.parentView.memorySort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "view.parentView.diskUsageSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "view.parentView.loadAvgSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          <th>");
    stack1 = depth0;
    stack2 = "common.components";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n        ");
    return buffer;}

  function program12(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "view.pageContent";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "host";
    stack7 = helpers.each;
    tmp1 = self.program(13, program13, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    return buffer;}
  function program13(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "view.HostView";
    stack3 = {};
    stack4 = "host";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(14, program14, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    return buffer;}
  function program14(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n\n      <td class=\"first\">\n        <span rel=\"HealthTooltip\" ");
    stack1 = {};
    stack2 = "host.healthClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = {};
    stack2 = "host.healthToolTip";
    stack1['data-original-title'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></span>\n      </td>\n\n      <td class=\"name\">\n        <a title=\"");
    stack1 = depth0;
    stack2 = "host.publicHostName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\" href=\"#\" ");
    stack1 = depth0;
    stack2 = "host";
    stack3 = depth0;
    stack4 = "showDetails";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "host.publicHostNameFormatted";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n        ");
    stack1 = depth0;
    stack2 = "host.criticalAlertsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(15, program15, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </td>\n      <td>");
    stack1 = depth0;
    stack2 = "host.ip";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "host.cpu";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "host.memoryFormatted";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n\n      <td>\n        <div class=\"progress progress-info\" title=\"");
    stack1 = depth0;
    stack2 = "host.diskInfoBar";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\" rel=\"UsageTooltip\">\n          <div class=\"bar\" ");
    stack1 = {};
    stack2 = "view.usageStyle";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n        </div>\n      </td>\n\n      <td>");
    stack1 = depth0;
    stack2 = "host.loadAvg";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>\n        <span title=\"");
    stack1 = depth0;
    stack2 = "view.labels";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\">");
    stack1 = depth0;
    stack2 = "view.shortLabels";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n      </td>\n    ");
    return buffer;}
  function program15(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n          <span class=\"label label-important alerts-count\" ");
    stack1 = depth0;
    stack2 = "host";
    stack3 = depth0;
    stack4 = "showAlertsPopup";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "host.criticalAlertsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n        ");
    return buffer;}

  function program17(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <tr>\n        <td class=\"first\"></td>\n        <td colspan=\"7\">\n            ");
    stack1 = depth0;
    stack2 = "hosts.table.noHosts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        </td>\n    </tr>\n    ");
    return buffer;}

    data.buffer.push("\n\n<div id=\"hosts\">\n\n  <div class=\"box-header row\">\n    <div class=\"health-status-bar pull-left\">\n      <div class=\"pull-left\"><span ");
    stack1 = {};
    stack2 = "view.filtersUsed::active";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a ");
    stack1 = depth0;
    stack2 = "clearFilters";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"#\">");
    stack1 = depth0;
    stack2 = "common.all";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " (");
    stack1 = depth0;
    stack2 = "content.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ")</a></span>&nbsp;</div>\n      ");
    stack1 = depth0;
    stack2 = "view.alertFilter";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      ");
    stack1 = depth0;
    stack2 = "view.statusFilter";
    stack3 = {};
    stack4 = "view.categories";
    stack3['categoriesBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </div>\n\n    ");
    stack1 = depth0;
    stack2 = "App.isAdmin";
    stack3 = helpers['if'];
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n\n  <table class=\"datatable table table-bordered table-striped\" id=\"hosts-table\">\n    <thead>\n    <tr>\n        ");
    stack1 = depth0;
    stack2 = "view.sortView";
    stack3 = {};
    stack4 = "view.filteredContent";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(10, program10, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </tr>\n    <tr>\n      <th class=\"first\"> </th>\n      <th>");
    stack1 = depth0;
    stack2 = "view.nameFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th>");
    stack1 = depth0;
    stack2 = "view.ipFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th>");
    stack1 = depth0;
    stack2 = "view.cpuFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th>");
    stack1 = depth0;
    stack2 = "view.ramFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th></th>\n      <th>");
    stack1 = depth0;
    stack2 = "view.loadAvgFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th>");
    stack1 = depth0;
    stack2 = "view.componentsFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n    </tr>\n    </thead>\n    <tbody>\n    ");
    stack1 = depth0;
    stack2 = "view.pageContent";
    stack3 = helpers['if'];
    tmp1 = self.program(12, program12, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(17, program17, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </tbody>\n  </table>\n\n  <div class=\"page-bar\">\n    <div class=\"items-on-page\">\n      <label>");
    stack1 = depth0;
    stack2 = "common.show";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": ");
    stack1 = depth0;
    stack2 = "view.rowsPerPageSelectView";
    stack3 = {};
    stack4 = "view.displayLength";
    stack3['selectionBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</label>\n    </div>\n    <div class=\"info\">");
    stack1 = depth0;
    stack2 = "view.paginationInfo";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n    <div class=\"paging_two_button\">\n      ");
    stack1 = depth0;
    stack2 = "view.paginationLeft";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      ");
    stack1 = depth0;
    stack2 = "view.paginationRight";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </div>\n  </div>\n</div>\n\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/host/add", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;


    data.buffer.push("\n\n<div class=\"wizard\">\n  <div class=\"container\">\n    <div class=\"container-fluid\">\n\n      <!--<a class=\"btn back\" ");
    stack1 = depth0;
    stack2 = "backToHostsList";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">鈫?Back to Hosts</a>-->\n\n      <div class=\"row-fluid\">\n        <div class=\"span3\">\n          <!--Sidebar content-->\n          <div class=\"well\">\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li class=\"nav-header\">");
    stack1 = depth0;
    stack2 = "hosts.add.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</li>\n              <li ");
    stack1 = {};
    stack2 = "isStep1:active view.isStep1Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep1";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step2.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep2:active view.isStep2Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep2";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step3.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep3:active view.isStep3Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep3";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step5.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep4:active view.isStep4Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep4";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step6.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep5:active view.isStep5Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep5";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step8.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep6:active view.isStep6Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep6";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step9.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep7:active view.isStep7Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep7";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step10.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n            </ul>\n          </div>\n        </div>\n        <div class=\"wizard-content well span9\">\n          ");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/host/alerts_popup", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n<ul id='summary-alerts-list' class=\"alerts\">\n  ");
    stack1 = depth0;
    stack2 = "view.hostAlerts";
    stack3 = helpers.each;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</ul>\n");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "App.AlertItemView";
    stack3 = {};
    stack4 = "this";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    return buffer;}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "hosts.host.alert.noAlerts.message";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.hostAlerts.length";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(4, program4, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/host/component_filter", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n                            <li>\n                                <label class=\"checkbox\">\n                                    ");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "component.checkedForHostFilter";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "component.displayName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                                </label>\n                            </li>\n                        ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n                            <li>\n                                <label class=\"checkbox\">\n                                    ");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "component.checkedForHostFilter";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "component.displayName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                                </label>\n                            </li>\n                        ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n                            <li>\n                                <label class=\"checkbox\">\n                                    ");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "component.checkedForHostFilter";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "component.displayName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                                </label>\n                            </li>\n                        ");
    return buffer;}

    data.buffer.push("\n\n    <button class=\"btn btn-info single-btn-group\" ");
    stack1 = depth0;
    stack2 = "clickFilterButton";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        ");
    stack1 = depth0;
    stack2 = "common.components";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " <span class=\"caret\"></span>\n    </button>\n    <ul class=\"dropdown-menu filter-components\">\n        <li>\n            <ul>\n                <li>\n                    <label class=\"checkbox\">\n                        ");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "view.masterComponentsChecked";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "host.host.componentFilter.master";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":\n                    </label>\n                    <ul>\n                        ");
    stack1 = depth0;
    stack2 = "masterComponents";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "component";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                    </ul>\n                </li>\n                <li>\n                    <label class=\"checkbox\">\n                        ");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "view.slaveComponentsChecked";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "host.host.componentFilter.slave";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":\n                    </label>\n                    <ul>\n                        ");
    stack1 = depth0;
    stack2 = "slaveComponents";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "component";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                    </ul>\n                </li>\n                <li>\n                    <label class=\"checkbox\">\n                        ");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "view.clientComponentsChecked";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "host.host.componentFilter.client";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":\n                    </label>\n                    <ul>\n                        ");
    stack1 = depth0;
    stack2 = "clientComponents";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "component";
    stack7 = helpers.each;
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                    </ul>\n                </li>\n            </ul>\n        </li>\n        <li>\n            <button class=\"btn\" ");
    stack1 = depth0;
    stack2 = "closeFilter";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.cancel";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n            <button class=\"btn btn-primary\" ");
    stack1 = depth0;
    stack2 = "applyFilter";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.apply";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</button>\n        </li>\n    </ul>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/host/configs", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;


    data.buffer.push("\n\n<div class=\"row-fluid\">\n  <div id=\"services-menu\" class=\"well span2\" style=\"padding: 8px 0\">\n    ");
    stack1 = depth0;
    stack2 = "App.MainHostServiceMenuView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n  <div class=\"span10\">\n    ");
    stack1 = depth0;
    stack2 = "service_config_outlet";
    foundHelper = helpers.outlet;
    stack3 = foundHelper || depth0.outlet;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "outlet", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/host/configs_service", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <div class=\"pull-right\">\n      ");
    stack1 = depth0;
    stack2 = "App.FilterComboboxView";
    stack3 = {};
    stack4 = "controller.filter";
    stack3['filterBinding'] = stack4;
    stack4 = "controller.filterColumns";
    stack3['columnsBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </div>\n    <div class=\"clearfix\"></div>\n    ");
    stack1 = depth0;
    stack2 = "App.ServiceConfigView";
    stack3 = {};
    stack4 = "view.isConfigsEditable";
    stack3['canEditBinding'] = stack4;
    stack4 = "controller.filter";
    stack3['filterBinding'] = stack4;
    stack4 = "controller.filterColumns";
    stack3['columnsBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    return buffer;}

  function program3(depth0,data) {
    
    
    data.buffer.push("\n    <div class=\"spinner\"></div>\n  ");}

    data.buffer.push("\n\n<div id=\"serviceConfig\">\n  ");
    stack1 = depth0;
    stack2 = "dataIsLoaded";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(3, program3, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/host/details", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n    <span class=\"label label-important alerts-count\" ");
    stack1 = depth0;
    stack2 = "content";
    stack3 = depth0;
    stack4 = "showAlertsPopup";
    stack5 = {};
    stack6 = "App.router.mainHostController";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.content.criticalAlertsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n  ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n    <span class=\"label label-success alerts-count\" ");
    stack1 = depth0;
    stack2 = "content";
    stack3 = depth0;
    stack4 = "showAlertsPopup";
    stack5 = {};
    stack6 = "App.router.mainHostController";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "hosts.host.alert.noAlerts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</span>\n  ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push(" -->\n<!--   <div class=\"host-maintenance\"> -->\n<!--     <div class=\"host-maintenance-btn btn-group display-inline-block\"> -->\n<!--       <a class=\"btn dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\"> -->\n<!--         ");
    stack1 = depth0;
    stack2 = "services.service.actions.maintenance";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " -->\n<!--         <span class=\"caret\"></span> -->\n<!--       </a> -->\n<!--       <ul class=\"dropdown-menu\"> -->\n<!--       dropdown menu links -->\n<!--         ");
    stack1 = depth0;
    stack2 = "view.maintenance";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "option";
    stack7 = helpers.each;
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push(" -->\n<!--       </ul> -->\n<!--     </div> -->\n<!--   </div> -->\n<!--   ");
    return buffer;}
  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push(" -->\n<!--         <li> -->\n<!--         <a ");
    stack1 = depth0;
    stack2 = "validateDeletion";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"#\">");
    stack1 = depth0;
    stack2 = "option.label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a> -->\n<!--         </li> -->\n<!--         ");
    return buffer;}

    data.buffer.push("\n\n<div id=\"host-details\">\n  <span rel=\"HealthTooltip\" ");
    stack1 = {};
    stack2 = "view.content.healthClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = {};
    stack2 = "view.content.healthToolTip";
    stack1['data-original-title'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></span><span class='host-title'>");
    stack1 = depth0;
    stack2 = "view.content.publicHostName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n  ");
    stack1 = depth0;
    stack2 = "view.content.criticalAlertsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(3, program3, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  <div><a href=\"javascript:void(null)\" data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><i class=\"icon-arrow-left\"></i>&nbsp;");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></div>\n<!--   ");
    stack1 = depth0;
    stack2 = "App.isAdmin";
    stack3 = helpers['if'];
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push(" -->\n  <div class=\"content\">\n    ");
    stack1 = depth0;
    stack2 = "App.MainHostMenuView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    ");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/host/metrics", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<div class=\"host-metrics\">\n    <table class=\"graphs\">\n        <tr>\n            <td>\n              ");
    stack1 = depth0;
    stack2 = "App.ChartHostMetricsCPU";
    stack3 = {};
    stack4 = "view.content";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            </td>\n            <td>\n              ");
    stack1 = depth0;
    stack2 = "App.ChartHostMetricsDisk";
    stack3 = {};
    stack4 = "view.content";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            </td>\n        </tr>\n        <tr>\n            <td>\n              ");
    stack1 = depth0;
    stack2 = "App.ChartHostMetricsLoad";
    stack3 = {};
    stack4 = "view.content";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            </td>\n            <td>\n              ");
    stack1 = depth0;
    stack2 = "App.ChartHostMetricsMemory";
    stack3 = {};
    stack4 = "view.content";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            </td>\n        </tr>\n        <tr>\n            <td>\n              ");
    stack1 = depth0;
    stack2 = "App.ChartHostMetricsNetwork";
    stack3 = {};
    stack4 = "view.content";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            </td>\n            <td>\n              ");
    stack1 = depth0;
    stack2 = "App.ChartHostMetricsProcesses";
    stack3 = {};
    stack4 = "view.content";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            </td>\n        </tr>\n    </table>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/host/summary", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n        <div class=\"host-components\">\n          ");
    stack1 = depth0;
    stack2 = "view.sortedComponents";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "component";
    stack7 = helpers.each;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          ");
    data.buffer.push("\n          <div class=\"clients row-fluid\">\n            <div class=\"span7 row\">\n              ");
    stack1 = depth0;
    stack2 = "view.clients.length";
    stack3 = helpers['if'];
    tmp1 = self.program(23, program23, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            </div>\n            <div class=\"span5 row\">\n              ");
    stack1 = depth0;
    stack2 = "view.isAddComponent";
    stack3 = helpers['if'];
    tmp1 = self.program(29, program29, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            </div>\n          </div>\n        </div>\n        ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n          <div class=\"row-fluid\">\n          ");
    stack1 = depth0;
    stack2 = "view.ComponentView";
    stack3 = {};
    stack4 = "component";
    stack3['contentBinding'] = stack4;
    stack4 = "view.decommissionDataNodeHostNames";
    stack3['decommissionDataNodeHostNamesBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          </div>\n          ");
    return buffer;}
  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n            <div class=\"span7\">\n              ");
    stack1 = depth0;
    stack2 = "view.isUpgradeFailed";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(7, program7, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n              ");
    stack1 = depth0;
    stack2 = "component.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "&nbsp;/&nbsp;\n              <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "component.service";
    stack3 = depth0;
    stack4 = "routeToService";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "component.service.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n            </div>\n            <div class=\"span5\">\n              ");
    stack1 = depth0;
    stack2 = "App.isAdmin";
    stack3 = helpers['if'];
    tmp1 = self.program(9, program9, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            </div>\n          ");
    return buffer;}
  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                ");
    stack1 = depth0;
    stack2 = "App.isAdmin";
    stack3 = helpers['if'];
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n              ");
    return buffer;}
  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n                  <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.content";
    stack3 = depth0;
    stack4 = "upgradeComponent";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " >\n                    <i title=\"Component upgrade failed\" class=\"components-health icon-arrow-up\"></i>\n                  </a>\n                ");
    return buffer;}

  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2;
    data.buffer.push("\n                <span ");
    stack1 = {};
    stack2 = "view.statusClass :components-health";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></span>&nbsp;\n              ");
    return buffer;}

  function program9(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              <div class=\"btn-group\">\n                <a ");
    stack1 = {};
    stack2 = ":btn :dropdown-toggle";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " data-toggle=\"dropdown\">\n                  ");
    stack1 = depth0;
    stack2 = "common.action";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                  <span class=\"caret pull-right\"></span>\n                </a>\n                <ul class=\"dropdown-menu\">\n                   <li>\n                      <div class=\"component-text-status\">\n                       ");
    stack1 = depth0;
    stack2 = "view.componentTextStatus";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                      </div>\n                    </li>\n                  ");
    stack1 = depth0;
    stack2 = "view.isDataNode";
    stack3 = helpers['if'];
    tmp1 = self.program(10, program10, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                  ");
    stack1 = depth0;
    stack2 = "view.isStart";
    stack3 = helpers['if'];
    tmp1 = self.program(15, program15, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                  ");
    stack1 = depth0;
    stack2 = "view.isStart";
    stack3 = helpers.unless;
    tmp1 = self.program(17, program17, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                  ");
    stack1 = depth0;
    stack2 = "view.isUpgradeFailed";
    stack3 = helpers['if'];
    tmp1 = self.program(19, program19, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                  ");
    stack1 = depth0;
    stack2 = "view.isInstallFailed";
    stack3 = helpers['if'];
    tmp1 = self.program(21, program21, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                </ul>\n              </div>\n              ");
    return buffer;}
  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                    ");
    stack1 = depth0;
    stack2 = "view.isDataNodeDecommissionAvailable";
    stack3 = helpers['if'];
    tmp1 = self.program(11, program11, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                    ");
    stack1 = depth0;
    stack2 = "view.isDataNodeRecommissionAvailable";
    stack3 = helpers['if'];
    tmp1 = self.program(13, program13, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                  ");
    return buffer;}
  function program11(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n                      <li ");
    stack1 = {};
    stack2 = "view.noActionAvailable";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                        <a href=\"javascript:void(null)\" data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "view.content";
    stack3 = depth0;
    stack4 = "decommission";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                          ");
    stack1 = depth0;
    stack2 = "common.decommission";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                        </a>\n                      </li>\n                    ");
    return buffer;}

  function program13(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n                      <li ");
    stack1 = {};
    stack2 = "view.noActionAvailable";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                        <a href=\"javascript:void(null)\" data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "view.content";
    stack3 = depth0;
    stack4 = "recommission";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                          ");
    stack1 = depth0;
    stack2 = "common.recommission";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                        </a>\n                      </li>\n                    ");
    return buffer;}

  function program15(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n                    <li ");
    stack1 = {};
    stack2 = " view.isDecommissioning:hidden view.noActionAvailable";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                      <a href=\"javascript:void(null)\" data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "view.content";
    stack3 = depth0;
    stack4 = "stopComponent";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                        ");
    stack1 = depth0;
    stack2 = "common.stop";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                      </a>\n                    </li>\n                  ");
    return buffer;}

  function program17(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n                    <li ");
    stack1 = {};
    stack2 = "view.isUpgradeFailed:hidden view.isInstallFailed:hidden view.isDecommissioning:hidden view.noActionAvailable";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                      <a href=\"javascript:void(null)\" data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "view.content";
    stack3 = depth0;
    stack4 = "startComponent";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                        ");
    stack1 = depth0;
    stack2 = "common.start";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                      </a>\n                    </li>\n                  ");
    return buffer;}

  function program19(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n                    <li ");
    stack1 = {};
    stack2 = "view.noActionAvailable";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                      <a href=\"javascript:void(null)\" data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "view.content";
    stack3 = depth0;
    stack4 = "upgradeComponent";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                        ");
    stack1 = depth0;
    stack2 = "common.reUpgrade";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                      </a>\n                    </li>\n                  ");
    return buffer;}

  function program21(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n                    <li ");
    stack1 = {};
    stack2 = "view.noActionAvailable";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                      <a href=\"javascript:void(null)\" data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "view.content";
    stack3 = depth0;
    stack4 = "installComponent";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                        ");
    stack1 = depth0;
    stack2 = "common.reinstall";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                      </a>\n                    </li>\n                  ");
    return buffer;}

  function program23(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n                <div class=\"span2\">");
    stack1 = depth0;
    stack2 = "common.clients";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "&nbsp;/&nbsp;</div>\n                  <div class=\"span8\">\n                    ");
    stack1 = depth0;
    stack2 = "view.clients";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "component";
    stack7 = helpers.each;
    tmp1 = self.program(24, program24, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                </div>\n              ");
    return buffer;}
  function program24(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                      ");
    stack1 = depth0;
    stack2 = "component.isLast";
    stack3 = helpers['if'];
    tmp1 = self.program(25, program25, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(27, program27, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                    ");
    return buffer;}
  function program25(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                        ");
    stack1 = depth0;
    stack2 = "component.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                        ");
    return buffer;}

  function program27(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                        ");
    stack1 = depth0;
    stack2 = "component.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ",\n                      ");
    return buffer;}

  function program29(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                ");
    stack1 = depth0;
    stack2 = "view.addableComponents.length";
    stack3 = helpers['if'];
    tmp1 = self.program(30, program30, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n              ");
    return buffer;}
  function program30(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n                    <div class=\"btn-group\">\n                        <button id=\"add_component\" class=\"btn btn-info dropdown-toggle\" data-toggle=\"dropdown\">\n                          ");
    stack1 = depth0;
    stack2 = "common.addComponent";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                            <span class=\"caret pull-right\"></span>\n                        </button>\n                        <ul class=\"dropdown-menu\">\n                          ");
    stack1 = depth0;
    stack2 = "view.addableComponents";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "component";
    stack7 = helpers.each;
    tmp1 = self.program(31, program31, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                        </ul>\n                    </div>\n                ");
    return buffer;}
  function program31(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n                              <li>\n                                  <a href=\"javascript:void(null)\" data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "component";
    stack3 = depth0;
    stack4 = "addComponent";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                                    ");
    stack1 = depth0;
    stack2 = "component.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                                  </a>\n                              </li>\n                          ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"row-fluid\">\n  <div class=\"span12\">\n  <div class=\"span6\">\n  <div class=\"host-configuration\">\n    <div class=\"box\">\n		  <div class=\"box-header\">\n		    <h4>");
    stack1 = depth0;
    stack2 = "hosts.host.summary.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h4>\n		  </div>\n		  <div class=\"host-summary-content\">\n		    <dl class=\"dl-horizontal\">\n          <dt>");
    stack1 = depth0;
    stack2 = "hosts.host.summary.hostname";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":</dt><dd>&nbsp;");
    stack1 = depth0;
    stack2 = "view.content.publicHostName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</dd>\n		      <dt>");
    stack1 = depth0;
    stack2 = "common.ipAddress";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":</dt><dd>&nbsp;");
    stack1 = depth0;
    stack2 = "view.content.ip";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</dd>\n          <dt>");
    stack1 = depth0;
    stack2 = "common.os";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":</dt><dd>&nbsp;");
    stack1 = depth0;
    stack2 = "view.content.osType";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "&nbsp;(");
    stack1 = depth0;
    stack2 = "view.content.osArch";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ")</dd>\n		      <dt>");
    stack1 = depth0;
    stack2 = "common.cpu";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":</dt><dd>&nbsp;");
    stack1 = depth0;
    stack2 = "view.content.cpu";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</dd>\n          <dt>");
    stack1 = depth0;
    stack2 = "common.disk";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":</dt><dd>&nbsp;");
    stack1 = depth0;
    stack2 = "view.content.diskInfoBar";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</dd>\n          <dt>");
    stack1 = depth0;
    stack2 = "common.memory";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":</dt><dd>&nbsp;");
    stack1 = depth0;
    stack2 = "view.content.memoryFormatted";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</dd>\n		      <dt>");
    stack1 = depth0;
    stack2 = "common.loadAvg";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":</dt><dd>&nbsp;");
    stack1 = depth0;
    stack2 = "view.content.loadAvg";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</dd>\n		      <dt>");
    stack1 = depth0;
    stack2 = "hosts.host.summary.agentHeartbeat";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":</dt><dd>");
    stack1 = depth0;
    stack2 = "view.timeSinceHeartBeat";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</dd>\n		    </dl>\n		  </div>\n	  </div>\n  </div>\n    ");
    data.buffer.push("\n      <div class=\"box\">\n        <div class=\"box-header\">\n          <h4>Components</h4>\n        </div>\n        ");
    stack1 = depth0;
    stack2 = "view.sortedComponents.length";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </div>\n    </div>\n  ");
    data.buffer.push("\n <div class=\"span6\">\n    <div class=\"box\">\n      <div class=\"box-header\">\n        <h4>");
    stack1 = depth0;
    stack2 = "hosts.host.summary.hostMetrics";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h4>\n        <div class=\"btn-group\">\n          <a class=\"btn\" rel=\"tooltip\" title=\"Go to Ganglia\" ");
    stack1 = depth0;
    stack2 = "showGangliaCharts";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><i class=\"icon-link\"></i></a>\n        </div>\n      </div>\n      <div>\n	     ");
    stack1 = depth0;
    stack2 = "App.MainHostMetricsView";
    stack3 = {};
    stack4 = "view.content";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n	    </div>\n	  </div>\n  </div>\n</div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/menu", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n    <li ");
    stack1 = {};
    stack2 = "active";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ><a ");
    stack1 = depth0;
    stack2 = "routing";
    stack3 = depth0;
    stack4 = "navigate";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"#\">");
    stack1 = depth0;
    stack2 = "label";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n    ");
    return buffer;}

    data.buffer.push("\n\n<ul class=\"nav nav-tabs\">\n    ");
    stack1 = depth0;
    stack2 = "view.items";
    stack3 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</ul>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/menu_item", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <span class=\"label label-important alerts-count\">\n      ");
    stack1 = depth0;
    stack2 = "view.alertsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </span>\n  ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("-->\n    <!--<span class=\"label operations-count\" ");
    stack1 = depth0;
    stack2 = "showBackgroundOperationsPopup";
    stack3 = {};
    stack4 = "App.router.mainHostDetailsController";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">-->\n      <!--");
    stack1 = depth0;
    stack2 = "view.hostDetailsOperationsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "-->\n    <!--</span>-->\n  <!--");
    return buffer;}

    data.buffer.push("\n\n<a href=\"#/main/");
    stack1 = depth0;
    stack2 = "view.content.routing";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\">\n  ");
    stack1 = depth0;
    stack2 = "view.content.label";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    stack1 = depth0;
    stack2 = "view.alertsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  <!--");
    stack1 = depth0;
    stack2 = "view.hostDetailsOperationsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("-->\n</a>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/mirroring", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n\n  ");
    stack1 = depth0;
    stack2 = "App.MainDatasetsView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/mirroring/addTargetCluster", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1));
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/mirroring/dataset", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <div class=\"pull-right dataset-delete\">\n        <a ");
    stack1 = depth0;
    stack2 = "deleteDatasetClick";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"btn btn-danger\">");
    stack1 = depth0;
    stack2 = "common.delete";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n    </div>\n");
    return buffer;}

    data.buffer.push("\n<div class=\"pull-left dataset-form\" autocomplete=\"off\">\n    <form class=\"form-horizontal\">\n        <div class=\"add-data-set\">\n            <table>\n                <tr ");
    stack1 = {};
    stack2 = "model.isNameError:error";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                    <td class=\"percent25\" colspan=\"1\">\n                      ");
    stack1 = depth0;
    stack2 = "mirroring.dataset.name";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                    </td>\n                    <td colspan=\"2\" style=\"text-align: left\">\n                      ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "model.newDataSet.name";
    stack3['valueBinding'] = stack4;
    stack4 = "span4";
    stack3['class'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                        <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "nameErrorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                    </td>\n                </tr>\n                <tr>\n                    <td class=\"spacer\" colspan=\"3\"></td>\n                </tr>\n                <tr ");
    stack1 = {};
    stack2 = "model.isSourceDirError:error";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                    <td colspan=\"1\">\n                      ");
    stack1 = depth0;
    stack2 = "mirroring.dataset.sourceDir";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                    </td>\n                    <td colspan=\"2\" style=\"text-align: left\">\n                      ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "model.newDataSet.sourceDir";
    stack3['valueBinding'] = stack4;
    stack4 = "span4";
    stack3['class'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                        <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "sourceDirErrorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                    </td>\n                </tr>\n                <tr>\n                    <td class=\"spacer\" colspan=\"3\"></td>\n                </tr>\n                <tr ");
    stack1 = {};
    stack2 = "model.isTargetClusterError:error";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                    <td colspan=\"1\">\n                      ");
    stack1 = depth0;
    stack2 = "mirroring.dataset.target";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                    </td>\n                    <td colspan=\"2\" style=\"text-align: left\">\n                      ");
    stack1 = depth0;
    stack2 = "view.targetClusterSelect";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                        <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "targetClusterErrorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                    </td>\n                </tr>\n                <tr>\n                    <td class=\"spacer\" colspan=\"3\"></td>\n                </tr>\n                <tr ");
    stack1 = {};
    stack2 = "model.isTargetDirError:error";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                    <td class=\"spacer\" colspan=\"1\">\n                      ");
    stack1 = depth0;
    stack2 = "mirroring.dataset.targetDir";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                    </td>\n                    <td colspan=\"2\" style=\"text-align: left\">\n                      ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "model.newDataSet.targetDir";
    stack3['valueBinding'] = stack4;
    stack4 = "span4";
    stack3['class'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                        <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "targetDirErrorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                    </td>\n                </tr>\n                <tr>\n                    <td class=\"spacer\" colspan=\"3\"></td>\n                </tr>\n                <tr>\n                    <td colspan=\"1\"> ");
    stack1 = depth0;
    stack2 = "mirroring.dataset.schedule";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " </td>\n                    <td colspan=\"2\" style=\"text-align: left\">\n                        <div ");
    stack1 = {};
    stack2 = "model.isStartDateError:error";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                          ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "model.newDataSet.schedule.startDate";
    stack3['valueBinding'] = stack4;
    stack4 = "input-small datepicker";
    stack3['class'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                          ");
    stack1 = depth0;
    stack2 = "Ember.Select";
    stack3 = {};
    stack4 = "view.hourOptions.content";
    stack3['contentBinding'] = stack4;
    stack4 = "view.hourOptions.selectedForStart";
    stack3['selectionBinding'] = stack4;
    stack4 = "input-mini";
    stack3['class'] = stack4;
    stack4 = "content.value";
    stack3['optionLabelPath'] = stack4;
    stack4 = "content.value";
    stack3['optionValuePath'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                          ");
    stack1 = depth0;
    stack2 = "Ember.Select";
    stack3 = {};
    stack4 = "view.minuteOptions.content";
    stack3['contentBinding'] = stack4;
    stack4 = "view.minuteOptions.selectedForStart";
    stack3['selectionBinding'] = stack4;
    stack4 = "input-mini";
    stack3['class'] = stack4;
    stack4 = "content.value";
    stack3['optionLabelPath'] = stack4;
    stack4 = "content.value";
    stack3['optionValuePath'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                          ");
    stack1 = depth0;
    stack2 = "Ember.Select";
    stack3 = {};
    stack4 = "view.dayOrNightOptions.content";
    stack3['contentBinding'] = stack4;
    stack4 = "view.dayOrNightOptions.selectedForStart";
    stack3['selectionBinding'] = stack4;
    stack4 = "input-mini";
    stack3['class'] = stack4;
    stack4 = "content.name";
    stack3['optionLabelPath'] = stack4;
    stack4 = "content.name";
    stack3['optionValuePath'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                            <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "startDateErrorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                        </div>\n                        <div>\n                          ");
    stack1 = depth0;
    stack2 = "mirroring.dataset.schedule.to";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                        </div>\n                        <div ");
    stack1 = {};
    stack2 = "model.isEndDateError:error";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                          ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "model.newDataSet.schedule.endDate";
    stack3['valueBinding'] = stack4;
    stack4 = "input-small datepicker";
    stack3['class'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                          ");
    stack1 = depth0;
    stack2 = "Ember.Select";
    stack3 = {};
    stack4 = "view.hourOptions.content";
    stack3['contentBinding'] = stack4;
    stack4 = "view.hourOptions.selectedForEnd";
    stack3['selectionBinding'] = stack4;
    stack4 = "input-mini";
    stack3['class'] = stack4;
    stack4 = "content.value";
    stack3['optionLabelPath'] = stack4;
    stack4 = "content.value";
    stack3['optionValuePath'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                          ");
    stack1 = depth0;
    stack2 = "Ember.Select";
    stack3 = {};
    stack4 = "view.minuteOptions.content";
    stack3['contentBinding'] = stack4;
    stack4 = "view.minuteOptions.selectedForEnd";
    stack3['selectionBinding'] = stack4;
    stack4 = "input-mini";
    stack3['class'] = stack4;
    stack4 = "content.value";
    stack3['optionLabelPath'] = stack4;
    stack4 = "content.value";
    stack3['optionValuePath'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                          ");
    stack1 = depth0;
    stack2 = "Ember.Select";
    stack3 = {};
    stack4 = "view.dayOrNightOptions.content";
    stack3['contentBinding'] = stack4;
    stack4 = "view.dayOrNightOptions.selectedForEnd";
    stack3['selectionBinding'] = stack4;
    stack4 = "input-mini";
    stack3['class'] = stack4;
    stack4 = "content.name";
    stack3['optionLabelPath'] = stack4;
    stack4 = "content.name";
    stack3['optionValuePath'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                            <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "endDateErrorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                        </div>\n\n                        <div ");
    stack1 = {};
    stack2 = " :each-row model.isFrequencyError:error";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                          ");
    stack1 = depth0;
    stack2 = "mirroring.dataset.schedule.repeatEvery";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                          ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "view.repeatNumberSelected";
    stack3['valueBinding'] = stack4;
    stack4 = "input-mini";
    stack3['class'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                          ");
    stack1 = depth0;
    stack2 = "Ember.Select";
    stack3 = {};
    stack4 = "view.repeatOptions.content";
    stack3['contentBinding'] = stack4;
    stack4 = "view.repeatOptions.repeatOptionSelected";
    stack3['selectionBinding'] = stack4;
    stack4 = "input-small";
    stack3['class'] = stack4;
    stack4 = "content.value";
    stack3['optionLabelPath'] = stack4;
    stack4 = "content.value";
    stack3['optionValuePath'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                            <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "frequencyErrorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                        </div>\n                    </td>\n                </tr>\n            </table>\n        </div>\n    </form>\n</div>\n");
    stack1 = depth0;
    stack2 = "isPopupForEdit";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/mirroring/datasets", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <div class=\"mirroring-top-nav button-section pull-right\">\n        <button class=\"btn btn-inverse add-host-button\" ");
    stack1 = depth0;
    stack2 = "addNewDataset";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n            <i class=\"icon-plus icon-white\"></i>\n          ");
    stack1 = depth0;
    stack2 = "mirroring.dataset.createNewDataset";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        </button>\n    </div>\n");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n        <li><a href=\"#\" ");
    stack1 = depth0;
    stack2 = "job.dataset";
    stack3 = depth0;
    stack4 = "gotoShowJobs";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "job.dataset.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a><br />");
    stack1 = depth0;
    stack2 = "job.startDateFormatted";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</li>\n      ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n        <li><a ");
    stack1 = depth0;
    stack2 = "cluster";
    stack3 = depth0;
    stack4 = "editTargetCluster";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "cluster.clusterName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n      ");
    return buffer;}

  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            <th class=\"first\"> </th>\n            ");
    stack1 = depth0;
    stack2 = "view.parentView.nameSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    stack1 = depth0;
    stack2 = "view.parentView.dataSetSourceSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    stack1 = depth0;
    stack2 = "view.parentView.lastSuccessSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    stack1 = depth0;
    stack2 = "view.parentView.lastFailSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    stack1 = depth0;
    stack2 = "view.parentView.lastDurationSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    stack1 = depth0;
    stack2 = "view.parentView.avgDataSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    return buffer;}

  function program9(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n        ");
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "datasets";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "dataset";
    stack7 = helpers.each;
    tmp1 = self.program(10, program10, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    return buffer;}
  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "view.DatasetView";
    stack3 = {};
    stack4 = "dataset";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(11, program11, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          ");
    return buffer;}
  function program11(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n\n              <td class=\"first\">\n              </td>\n\n              <td class=\"name\">\n                <a title=\"");
    stack1 = depth0;
    stack2 = "dataset.name";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\" href=\"#\" ");
    stack1 = depth0;
    stack2 = "dataset";
    stack3 = depth0;
    stack4 = "gotoShowJobs";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "dataset.name";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n              </td>\n              <td>");
    stack1 = depth0;
    stack2 = "dataset.sourceDir";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n              <td>");
    stack1 = depth0;
    stack2 = "view.lastSucceededDateFormatted";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n              <td>");
    stack1 = depth0;
    stack2 = "view.lastFailedDateFormatted";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n\n              <td>\n                ");
    stack1 = depth0;
    stack2 = "view.lastDurationFormatted";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n              </td>\n\n              <td>");
    stack1 = depth0;
    stack2 = "dataset.avgData";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n            ");
    return buffer;}

  function program13(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <tr>\n            <td class=\"first\"></td>\n            <td colspan=\"6\">\n              ");
    stack1 = depth0;
    stack2 = "mirroring.table.noDatasets";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n            </td>\n          </tr>\n        ");
    return buffer;}

    data.buffer.push("\n<div>\n    <div class=\"top-portion\">\n        <ul class=\"breadcrumb\">\n            <li><a href=\"#/main/mirroring\">");
    stack1 = depth0;
    stack2 = "mirroring.dataset.AllDataSets";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a> </li>\n        </ul>\n    </div>\n");
    stack1 = depth0;
    stack2 = "App.isAdmin";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</div>\n\n<div class=\"row-fluid\">\n  <div class=\"span2 mirroring-sidebar\">\n    <h5>");
    stack1 = depth0;
    stack2 = "mirroring.sidebar.header.history";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h5>\n    <hr />\n    <ul>\n      ");
    stack1 = depth0;
    stack2 = "view.jobs";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "job";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </ul>\n    <h5>");
    stack1 = depth0;
    stack2 = "mirroring.sidebar.header.clusters";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " <span class=\"pull-right\"><a ");
    stack1 = depth0;
    stack2 = "controller.name";
    stack3 = depth0;
    stack4 = "addTargetCluster";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "  href=\"#\">");
    stack1 = depth0;
    stack2 = "add";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></span></h5>\n    <hr />\n    <ul>\n      ");
    stack1 = depth0;
    stack2 = "view.targetClusters";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "cluster";
    stack7 = helpers.each;
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </ul>\n  </div>\n  <div class=\"span10\">\n    <div id=\"mirroring\">\n      <table class=\"table table-bordered table-striped\">\n        <thead>\n        <tr>\n          ");
    stack1 = depth0;
    stack2 = "view.sortView";
    stack3 = {};
    stack4 = "view.filteredContent";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(7, program7, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </tr>\n        <tr>\n          <th class=\"first\"> </th>\n          <th>");
    stack1 = depth0;
    stack2 = "view.nameFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n          <th>");
    stack1 = depth0;
    stack2 = "view.datasetSourceFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n          <th>");
    stack1 = depth0;
    stack2 = "view.lastSuccessFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n          <th>");
    stack1 = depth0;
    stack2 = "view.lastFailFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n          <th>");
    stack1 = depth0;
    stack2 = "view.lastDurationFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n          <th>");
    stack1 = depth0;
    stack2 = "view.avgDataFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n        </tr>\n        </thead>\n        <tbody>\n        ");
    stack1 = depth0;
    stack2 = "view.pageContent";
    stack3 = helpers['if'];
    tmp1 = self.program(9, program9, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(13, program13, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </tbody>\n      </table>\n\n      <div class=\"page-bar\">\n        <div class=\"items-on-page\">\n          <label>");
    stack1 = depth0;
    stack2 = "common.show";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": ");
    stack1 = depth0;
    stack2 = "view.rowsPerPageSelectView";
    stack3 = {};
    stack4 = "view.displayLength";
    stack3['selectionBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</label>\n        </div>\n        <div class=\"info\">");
    stack1 = depth0;
    stack2 = "view.paginationInfo";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n        <div class=\"paging_two_button\">\n          ");
    stack1 = depth0;
    stack2 = "view.paginationLeft";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "view.paginationRight";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        </div>\n      </div>\n    </div>\n  </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/mirroring/dropdown", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n          <li ");
    data.buffer.push("><a\n                  href=\"#\" ");
    stack1 = depth0;
    stack2 = "";
    stack3 = depth0;
    stack4 = "select";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = "click";
    stack5['on'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n      ");
    return buffer;}

    data.buffer.push("\n<div class=\"btn-group\">\n    <a class=\"btn dropdown-toggle targetClusterDD\" data-toggle=\"dropdown\" href=\"#\">\n      ");
    stack1 = depth0;
    stack2 = "view.selected.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        <span class=\"caret\"></span>\n    </a>\n    <ul class=\"dropdown-menu\">\n      ");
    stack1 = depth0;
    stack2 = "view.listOfOptions";
    stack3 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </ul>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/mirroring/jobs", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <div class=\"mirroring-top-nav button-section pull-right\">\n            ");
    stack1 = depth0;
    stack2 = "isScheduled";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(4, program4, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          </div>\n      ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n                <span class=\"label label-success\">");
    stack1 = depth0;
    stack2 = "content.status";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                <a href=\"javascript:void(null)\" data-toggle=\"modal\"\n                   class=\"btn btn-danger\" ");
    stack1 = depth0;
    stack2 = "suspend";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                    <i class=\"icon-pause\"></i>\n                  ");
    stack1 = depth0;
    stack2 = "actionDesc";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                </a>\n            ");
    return buffer;}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n                <span class=\"label label-important\">");
    stack1 = depth0;
    stack2 = "content.status";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                <a href=\"javascript:void(null)\" data-toggle=\"modal\"\n                   class=\"btn btn-success\" ");
    stack1 = depth0;
    stack2 = "schedule";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                    <i class=\"icon-play\"></i>\n                  ");
    stack1 = depth0;
    stack2 = "actionDesc";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                </a>\n            ");
    return buffer;}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                      <th class=\"first\"></th>\n                    ");
    stack1 = depth0;
    stack2 = "view.parentView.idSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                    ");
    stack1 = depth0;
    stack2 = "view.parentView.startSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                    ");
    stack1 = depth0;
    stack2 = "view.parentView.endSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                    ");
    stack1 = depth0;
    stack2 = "view.parentView.durationSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                    ");
    stack1 = depth0;
    stack2 = "view.parentView.dataSort";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                      <th>\n                        ");
    stack1 = depth0;
    stack2 = "common.status";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                      </th>\n\n                  ");
    return buffer;}

  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n                    ");
    stack1 = depth0;
    stack2 = "view.pageContent";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "job";
    stack7 = helpers.each;
    tmp1 = self.program(9, program9, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                  ");
    return buffer;}
  function program9(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n                      ");
    stack1 = depth0;
    stack2 = "view.JobView";
    stack3 = {};
    stack4 = "job";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(10, program10, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                    ");
    return buffer;}
  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n\n                      <td class=\"first\">\n                      </td>\n\n                      <td>");
    stack1 = depth0;
    stack2 = "job.id";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n                      <td>");
    stack1 = depth0;
    stack2 = "view.startFormatted";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n                      <td>");
    stack1 = depth0;
    stack2 = "view.endFormatted";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n\n                      <td>\n                        ");
    stack1 = depth0;
    stack2 = "view.durationFormatted";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                      </td>\n\n                      <td>");
    stack1 = depth0;
    stack2 = "job.data";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n                      <td>\n\n                        ");
    stack1 = depth0;
    stack2 = "view.canActionBeTaken";
    stack3 = helpers['if'];
    tmp1 = self.program(11, program11, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(14, program14, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                      </td>\n                      ");
    return buffer;}
  function program11(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                            <div class=\"btn-group\">\n                                <a ");
    stack1 = {};
    stack2 = "view.statusClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " data-toggle=\"dropdown\" href=\"#\">\n                                  ");
    stack1 = depth0;
    stack2 = "view.content.status";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                                    <span class=\"caret\"></span>\n                                </a>\n                                <ul class=\"dropdown-menu\">\n                                  ");
    stack1 = depth0;
    stack2 = "view.listOfOptions";
    stack3 = helpers.each;
    tmp1 = self.program(12, program12, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                                </ul>\n                            </div>\n                        ");
    return buffer;}
  function program12(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n                                      <li>\n                                          <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "";
    stack3 = depth0;
    stack4 = "changeStatus";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = "click";
    stack5['on'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n                                      </li>\n                                  ");
    return buffer;}

  function program14(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                          ");
    stack1 = depth0;
    stack2 = "view.isKilled";
    stack3 = helpers['if'];
    tmp1 = self.program(15, program15, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(17, program17, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                        ");
    return buffer;}
  function program15(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                              <span class=\"label label-important\">");
    stack1 = depth0;
    stack2 = "view.content.status";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                          ");
    return buffer;}

  function program17(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                              <span class=\"label label-info\">");
    stack1 = depth0;
    stack2 = "view.content.status";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                          ");
    return buffer;}

  function program19(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                  <tr>\n                      <td class=\"first\"></td>\n                      <td colspan=\"6\">\n                        ");
    stack1 = depth0;
    stack2 = "mirroring.table.noJobs";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                      </td>\n                  </tr>\n                  ");
    return buffer;}

    data.buffer.push("\n<div class=\"row-fluid\">\n    <div class=\"top-portion\">\n        <ul class=\"breadcrumb\">\n            <li><a href=\"#/main/mirroring\">");
    stack1 = depth0;
    stack2 = "mirroring.dataset.AllDataSets";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a> <span class=\"divider\">/</span></li>\n            <li class=\"active\">");
    stack1 = depth0;
    stack2 = "view.dataset.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</li>\n        </ul>\n      ");
    stack1 = depth0;
    stack2 = "App.isAdmin";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n    </div>\n    <div class=\"jobs-sidebar\">\n        <h5>");
    stack1 = depth0;
    stack2 = "common.details";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " <span class=\"pull-right\"><a\n                href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.dataset";
    stack3 = depth0;
    stack4 = "gotoEditDataset";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.edit";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></span></h5>\n        <hr/>\n        <p>");
    stack1 = depth0;
    stack2 = "mirroring.dataset.source";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": <span class=\"pull-right\">");
    stack1 = depth0;
    stack2 = "view.dataset.sourceClusterName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span></p>\n\n        <p>");
    stack1 = depth0;
    stack2 = "mirroring.dataset.target";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": <span class=\"pull-right\">");
    stack1 = depth0;
    stack2 = "view.dataset.targetClusterName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span></p>\n        <h5>");
    stack1 = depth0;
    stack2 = "common.stats";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h5>\n        <hr/>\n        <p>");
    stack1 = depth0;
    stack2 = "mirroring.dataset.avgData";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": <span class=\"pull-right\">");
    stack1 = depth0;
    stack2 = "view.dataset.avgData";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span></p>\n\n        <p>");
    stack1 = depth0;
    stack2 = "mirroring.dataset.dateCreated";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": <span class=\"pull-right\">");
    stack1 = depth0;
    stack2 = "view.dataset.createdDate";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span></p>\n    </div>\n    <div class=\"jobs-middleportion\">\n        <div id=\"mirroring\">\n            <table class=\"table table-bordered table-striped\">\n                <thead>\n                <tr>\n                  ");
    stack1 = depth0;
    stack2 = "view.sortView";
    stack3 = {};
    stack4 = "view.filteredContent";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(6, program6, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                </tr>\n                <tr>\n                    <th class=\"first\"></th>\n                    <th>");
    stack1 = depth0;
    stack2 = "view.idFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n                    <th>");
    stack1 = depth0;
    stack2 = "view.startFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n                    <th>");
    stack1 = depth0;
    stack2 = "view.endFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n                    <th>");
    stack1 = depth0;
    stack2 = "view.durationFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n                    <th>");
    stack1 = depth0;
    stack2 = "view.dataFilterView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n                </tr>\n                </thead>\n                <tbody>\n                  ");
    stack1 = depth0;
    stack2 = "view.pageContent";
    stack3 = helpers['if'];
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(19, program19, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                </tbody>\n            </table>\n\n            <div class=\"page-bar\">\n                <div class=\"items-on-page\">\n                    <label>");
    stack1 = depth0;
    stack2 = "common.show";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                        : ");
    stack1 = depth0;
    stack2 = "view.rowsPerPageSelectView";
    stack3 = {};
    stack4 = "view.displayLength";
    stack3['selectionBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</label>\n                </div>\n                <div class=\"info\">");
    stack1 = depth0;
    stack2 = "view.paginationInfo";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n                <div class=\"paging_two_button\">\n                  ");
    stack1 = depth0;
    stack2 = "view.paginationLeft";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                  ");
    stack1 = depth0;
    stack2 = "view.paginationRight";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                </div>\n            </div>\n        </div>\n    </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/mirroring/testConnection", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n          <div class=\"add-cluster-1-3\">\n              <div class=\"each-row pull-right\">\n                  <a ");
    stack1 = depth0;
    stack2 = "deleteTargetCluster";
    stack3 = {};
    stack4 = "view.parentView.parentView.controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                          class=\"btn btn-danger\">");
    stack1 = depth0;
    stack2 = "common.delete";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n              </div>\n          </div>\n      ");
    return buffer;}

    data.buffer.push("\n\n<form class=\"form-horizontal\" autocomplete=\"off\">\n    <div class=\"add-cluster-1\">\n        <div class=\"add-cluster-1-1\">\n            <h4>Enter the URLs for the following</h4>\n\n            <div ");
    stack1 = {};
    stack2 = " :each-row content.isNameNodeWebUrlError:error";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n              ");
    stack1 = depth0;
    stack2 = "mirroring.targetcluster.nameNodeWebUrl";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n            </div>\n            <div ");
    stack1 = {};
    stack2 = " :each-row content.isNameNodeWebUrlError:error";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n              ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "content.targetCluster.nameNodeWebUrl";
    stack3['valueBinding'] = stack4;
    stack4 = "span4";
    stack3['class'] = stack4;
    stack4 = "http://[NameNode Web UI Server]:50070";
    stack3['placeholder'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "content.nameNodeWebUrlErrorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n            </div>\n\n            <div ");
    stack1 = {};
    stack2 = " :each-row content.isNameNodeRpcUrlError:error";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n              ");
    stack1 = depth0;
    stack2 = "mirroring.targetcluster.nameNodeRpcUrl";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n            </div>\n            <div ");
    stack1 = {};
    stack2 = " :each-row content.isNameNodeRpcUrlError:error";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n              ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "content.targetCluster.nameNodeRpcUrl";
    stack3['valueBinding'] = stack4;
    stack4 = "span4";
    stack3['class'] = stack4;
    stack4 = "http://[NameNode RPC Server]:8020";
    stack3['placeholder'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "content.nameNodeRpcUrlErrorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n            </div>\n            <div ");
    stack1 = {};
    stack2 = " :each-row content.isOozieServerUrlError:error";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n              ");
    stack1 = depth0;
    stack2 = "mirroring.targetcluster.oozieServerUrl";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n            </div>\n            <div ");
    stack1 = {};
    stack2 = " :each-row content.isOozieServerUrlError:error";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n              ");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "content.targetCluster.oozieServerUrl";
    stack3['valueBinding'] = stack4;
    stack4 = "span4";
    stack3['class'] = stack4;
    stack4 = "http://[Oozie server]:11000";
    stack3['placeholder'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "content.oozieServerUrlErrorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n            </div>\n        </div>\n      ");
    stack1 = depth0;
    stack2 = "view.parentView.parentView.controller.model.isPopupForEdit";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n    </div>\n</form>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/mirroring/testConnectionResults", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    
    data.buffer.push("\n                      <i class=\"icon-ok\"></i>\n                  ");}

  function program3(depth0,data) {
    
    
    data.buffer.push("\n                      Connecting...\n                  ");}

  function program5(depth0,data) {
    
    
    data.buffer.push("\n                      <i class=\"icon-ok\"></i>\n                  ");}

  function program7(depth0,data) {
    
    
    data.buffer.push("\n                      Connecting...\n                  ");}

  function program9(depth0,data) {
    
    
    data.buffer.push("\n                      <i class=\"icon-ok\"></i>\n                  ");}

  function program11(depth0,data) {
    
    
    data.buffer.push("\n                      Connecting...\n                  ");}

    data.buffer.push("\n\n<form class=\"form-horizontal\" autocomplete=\"off\">\n    <div class=\"add-cluster-2\">\n\n        <table>\n            <tr>\n                <td>NameNode Web UI..50070</td>\n                <td>\n                  ");
    stack1 = depth0;
    stack2 = "isNameNodeWebUIConnected";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(3, program3, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                </td>\n            </tr>\n            <tr class=\"spacer\">\n                <td colspan=\"2\"/>\n            </tr>\n            <tr>\n                <td>NameNode RPC..8020</td>\n                <td>\n                  ");
    stack1 = depth0;
    stack2 = "isNameNodeRpcConnected";
    stack3 = helpers['if'];
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(7, program7, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                </td>\n            </tr>\n            <tr class=\"spacer\">\n                <td colspan=\"2\"/>\n            </tr>\n            <tr>\n                <td>Oozie server..11000</td>\n                <td>\n                  ");
    stack1 = depth0;
    stack2 = "isOozieServerConnected";
    stack3 = helpers['if'];
    tmp1 = self.program(9, program9, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(11, program11, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                </td>\n            </tr>\n            <tr class=\"spacer\">\n                <td colspan=\"2\"/>\n            </tr>\n            <tr ");
    stack1 = {};
    stack2 = "content.isClusterNameError:error";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                <td>");
    stack1 = depth0;
    stack2 = "mirroring.targetcluster.enterClusterName";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n                <td>");
    stack1 = depth0;
    stack2 = "Ember.TextField";
    stack3 = {};
    stack4 = "content.targetCluster.clusterName";
    stack3['valueBinding'] = stack4;
    stack4 = "shouldBeDisabled";
    stack3['disabledBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                    <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "content.clusterNameErrorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                </td>\n            </tr>\n            <tr class=\"spacer\">\n                <td colspan=\"2\"></td>\n            </tr>\n        </table>\n    </div>\n\n</form>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "App.supports.addServices";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "App.supports.startStopAllServices";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <div class=\"add-service-button\">\n      <a class=\"btn\" ");
    stack1 = depth0;
    stack2 = "addService";
    stack3 = {};
    stack4 = "true";
    stack3['href'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        <i class=\"icon-plus\"></i>\n        ");
    stack1 = depth0;
    stack2 = "services.service.add";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n      </a>\n    </div>\n    ");
    return buffer;}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n      <div class=\"start-stop-all-service-button\">\n        <a href=\"javascript:void(null)\" ");
    stack1 = {};
    stack2 = ":btn controller.isStartAllDisabled:disabled:btn-success";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n           data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "startAllService";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n          <i class=\"icon-play\"></i>\n          ");
    stack1 = depth0;
    stack2 = "services.service.startAll";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        </a>\n      </div>\n      <div class=\"start-stop-all-service-button\">\n        <a href=\"javascript:void(null)\" ");
    stack1 = {};
    stack2 = ":btn controller.isStopAllDisabled:disabled:btn-danger";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n           data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "stopAllService";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n          <i class=\"icon-stop icon-white\"></i>\n          ");
    stack1 = depth0;
    stack2 = "services.service.stopAll";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        </a>\n      </div>\n    ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"row-fluid\">\n  <div class=\"services-menu well span2\" style=\"padding: 8px 0\">\n    ");
    stack1 = depth0;
    stack2 = "App.MainServiceMenuView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    ");
    stack1 = depth0;
    stack2 = "App.isAdmin";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n  <div class=\"span10\">\n    ");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/add", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;


    data.buffer.push("\n\n<div class=\"wizard\">\n  <div class=\"container\">\n    <div class=\"container-fluid\">\n\n      <!--<a class=\"btn back\" ");
    stack1 = depth0;
    stack2 = "backToServices";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">鈫?Back to Services</a>-->\n\n      <div class=\"row-fluid\">\n        <div class=\"span3\">\n          <!--Sidebar content-->\n          <div class=\"well\">\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li class=\"nav-header\">");
    stack1 = depth0;
    stack2 = "services.add.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</li>\n              <li ");
    stack1 = {};
    stack2 = "isStep1:active view.isStep1Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep1";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step4.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep2:active view.isStep2Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep2";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step5.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep3:active view.isStep3Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep3";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step6.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep4:active view.isStep4Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep4";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step7.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep5:active view.isStep5Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep5";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step8.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep6:active view.isStep6Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep6";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step9.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep7:active view.isStep7Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep7";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step10.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n            </ul>\n          </div>\n        </div>\n        <div class=\"wizard-content well span9\">\n          ");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/info/configs", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "App.supports.hostOverrides";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    <div class=\"clearfix\"></div>\n    ");
    stack1 = depth0;
    stack2 = "App.ServiceConfigView";
    stack3 = {};
    stack4 = "controller.filter";
    stack3['filterBinding'] = stack4;
    stack4 = "controller.filterColumns";
    stack3['columnsBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    ");
    stack1 = depth0;
    stack2 = "App.isAdmin";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n	    <div class=\"pull-right\">\n	      ");
    stack1 = depth0;
    stack2 = "App.FilterComboboxView";
    stack3 = {};
    stack4 = "controller.filter";
    stack3['filterBinding'] = stack4;
    stack4 = "controller.filterColumns";
    stack3['columnsBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n	    </div>\n	  ");
    return buffer;}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n      <p class=\"pull-right\">\n        <!--<input class=\"btn btn-primary\" type=\"button\" value=\"Save\" ");
    data.buffer.push(" />-->\n        <a class=\"btn\" ");
    stack1 = depth0;
    stack2 = "doCancel";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.cancel";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n        <a class=\"btn btn-primary\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "restartServicePopup";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.save";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n      </p>\n    ");
    return buffer;}

  function program6(depth0,data) {
    
    
    data.buffer.push("\n    <div class=\"spinner\"></div>\n  ");}

    data.buffer.push("\n\n<div id=\"serviceConfig\">\n  ");
    stack1 = depth0;
    stack2 = "dataIsLoaded";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(6, program6, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/info/configs_save_popup", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n  <div class=\"pre-scrollable\" style=\"max-height: 250px;\">\n    <ul>\n    ");
    stack1 = depth0;
    stack2 = "view.getDisplayMessage";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "val";
    stack7 = helpers.each;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </ul>\n  </div>\n");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <li>\n        ");
    stack1 = depth0;
    stack2 = "val";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </li>\n    ");
    return buffer;}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n  <i class=\"icon-warning-sign\"></i>  ");
    stack1 = depth0;
    stack2 = "view.runningHostsMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  <table class=\"table-striped running-host-components-table\">\n    <tr><th>");
    stack1 = depth0;
    stack2 = "common.host";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th><th>");
    stack1 = depth0;
    stack2 = "common.components";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th></tr>\n    ");
    stack1 = depth0;
    stack2 = "view.runningHosts";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "host";
    stack7 = helpers.each;
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </table>\n");
    return buffer;}
  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <tr><td>");
    stack1 = depth0;
    stack2 = "host.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td><td>");
    stack1 = depth0;
    stack2 = "host.components";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td></tr>\n    ");
    return buffer;}

  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n  <i class=\"icon-warning-sign\"></i>  ");
    stack1 = depth0;
    stack2 = "view.unknownHostsMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  <table class=\"table-striped running-host-components-table\">\n    <tr><th>");
    stack1 = depth0;
    stack2 = "common.host";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th><th>");
    stack1 = depth0;
    stack2 = "common.components";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th></tr>\n    ");
    stack1 = depth0;
    stack2 = "view.unknownHosts";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "host";
    stack7 = helpers.each;
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </table>\n");
    return buffer;}
  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <tr><td>");
    stack1 = depth0;
    stack2 = "host.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td><td>");
    stack1 = depth0;
    stack2 = "host.components";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td></tr>\n    ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"");
    stack1 = depth0;
    stack2 = "view.messageClass";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\">");
    stack1 = depth0;
    stack2 = "view.message";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n");
    stack1 = depth0;
    stack2 = "view.flag";
    stack3 = helpers.unless;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "view.runningHosts";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "view.unknownHosts";
    stack3 = helpers['if'];
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/info/summary", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "App.QuickViewLinks";
    stack3 = {};
    stack4 = "view.service";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n<ul class=\"nav nav-pills move\">\n  <li class=\"dropdown\">\n    <a class=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">");
    stack1 = depth0;
    stack2 = "common.quickLinks";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "<b class=\"caret\"></b></a>\n    <ul class=\"dropdown-menu\">\n     ");
    stack1 = depth0;
    stack2 = "view.quickLinks";
    stack3 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </ul>\n  </li>\n</ul>\n");
    return buffer;}
  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <a ");
    stack1 = {};
    stack2 = "url";
    stack1['href'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = {};
    stack2 = "view.linkTarget";
    stack1['target'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n      ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "view.components";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "component";
    stack7 = helpers.each;
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    return buffer;}
  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "component.isMaster";
    stack3 = helpers['if'];
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(9, program9, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          ");
    return buffer;}
  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n             ");
    stack1 = depth0;
    stack2 = "view.sumMasterComponentView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    return buffer;}

  function program9(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n              <tr>\n                <td class=\"summary-label\">");
    stack1 = depth0;
    stack2 = "component.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1));
    stack1 = depth0;
    stack2 = "view.hasManyClients";
    stack3 = helpers['if'];
    tmp1 = self.program(10, program10, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("</td>\n                <td>\n                  <span class=\"green-live\">");
    stack1 = depth0;
    stack2 = "view.clients.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n                  ");
    stack1 = depth0;
    stack2 = "component.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "view.hasManyClients";
    stack3 = helpers['if'];
    tmp1 = self.program(12, program12, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push(" ");
    stack1 = depth0;
    stack2 = "common.installed";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                  <div class=\"summary-view-host\">\n                    <a ");
    stack1 = depth0;
    stack2 = "component";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"javascript:void(null)>");
    stack1 = depth0;
    stack2 = "view.clientsHostText";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n                  </div>\n                </td>\n              </tr>\n            ");
    return buffer;}
  function program10(depth0,data) {
    
    
    data.buffer.push("s");}

  function program12(depth0,data) {
    
    
    data.buffer.push("s");}

  function program14(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "App.MainDashboardServiceHdfsView";
    stack3 = {};
    stack4 = true;
    stack3['showOnlyRows'] = stack4;
    stack4 = "view.service";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    return buffer;}

  function program16(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "App.MainDashboardServiceMapreduceView";
    stack3 = {};
    stack4 = true;
    stack3['showOnlyRows'] = stack4;
    stack4 = "view.service";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    return buffer;}

  function program18(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "templates/main/service/info/summary/mapreduce2";
    stack3 = helpers.template;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    return buffer;}

  function program20(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "App.MainDashboardServiceHbaseView";
    stack3 = {};
    stack4 = true;
    stack3['showOnlyRows'] = stack4;
    stack4 = "view.service";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    return buffer;}

  function program22(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "templates/main/service/info/summary/zookeeper";
    stack3 = helpers.template;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    return buffer;}

  function program24(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "templates/main/service/info/summary/oozie";
    stack3 = helpers.template;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    return buffer;}

  function program26(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "templates/main/service/info/summary/ganglia";
    stack3 = helpers.template;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    return buffer;}

  function program28(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "templates/main/service/info/summary/hive";
    stack3 = helpers.template;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    return buffer;}

  function program30(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "templates/main/service/info/summary/hue";
    stack3 = helpers.template;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    return buffer;}

  function program32(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "App.MainDashboardServiceFlumeView";
    stack3 = {};
    stack4 = true;
    stack3['showOnlyRows'] = stack4;
    stack4 = "view.service";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    return buffer;}

  function program34(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n				");
    stack1 = depth0;
    stack2 = "controller.alerts";
    stack3 = helpers.each;
    tmp1 = self.program(35, program35, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n			");
    return buffer;}
  function program35(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "App.AlertItemView";
    stack3 = {};
    stack4 = "this";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n				");
    return buffer;}

  function program37(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n		    ");
    stack1 = depth0;
    stack2 = "controller.isNagiosInstalled";
    stack3 = helpers['if'];
    tmp1 = self.program(38, program38, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(40, program40, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n			");
    return buffer;}
  function program38(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n			    <div class=\"alert alert-info\">\n			      ");
    stack1 = depth0;
    stack2 = "services.service.info.summary.nagios.noAlerts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n			    </div>\n			  ");
    return buffer;}

  function program40(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n			    <div class=\"alert\">\n			      ");
    stack1 = depth0;
    stack2 = "services.service.info.summary.nagios.alerts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n			    </div>\n			  ");
    return buffer;}

  function program42(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n<div class=\"row-fluid\">\n  <div class=\"span12\">\n    <div class=\"box\">\n      <div class=\"box-header\">\n        <h4>");
    stack1 = depth0;
    stack2 = "controller.content.label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "common.metrics";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h4>\n        <div class=\"btn-group\">\n          <a class=\"btn\" target=\"_blank\" rel=\"tooltip\" title=\"Go to Ganglia\" ");
    stack1 = {};
    stack2 = "view.gangliaUrl";
    stack1['href'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><i class=\"icon-link\"></i></a>\n        </div>\n      </div>\n      \n      <div class=\"\">\n        <table class=\"graphs\">\n          ");
    stack1 = depth0;
    stack2 = "view.serviceMetricGraphs";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "graphs";
    stack7 = helpers.each;
    tmp1 = self.program(43, program43, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </table>\n      </div>\n      \n    </div>\n  </div>\n</div>\n");
    return buffer;}
  function program43(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n            <tr>\n              ");
    stack1 = depth0;
    stack2 = "graphs";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "graph";
    stack7 = helpers.each;
    tmp1 = self.program(44, program44, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            </tr>\n          ");
    return buffer;}
  function program44(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                <td>\n                  <div class=\"\">\n                    ");
    stack1 = depth0;
    stack2 = "graph";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                  </div>\n                </td>\n              ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"row-fluid service-block\">\n<div class=\"span6\">\n");
    stack1 = depth0;
    stack2 = "view.service.quickLinks.length";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n<div class=\"box\">\n  <div class=\"box-header\">\n    <h4>");
    stack1 = depth0;
    stack2 = "controller.content.label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "services.service.info.menu.summary";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h4>\n  </div>\n  <div class=\"service-content\">\n    <table id=\"summary-info\" class=\"table no-borders table-condensed\">\n      <tbody>\n        ");
    stack1 = depth0;
    stack2 = "view.noTemplateService";
    stack3 = helpers['if'];
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "view.serviceStatus.hdfs";
    stack3 = helpers['if'];
    tmp1 = self.program(14, program14, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "view.serviceStatus.mapreduce";
    stack3 = helpers['if'];
    tmp1 = self.program(16, program16, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "view.serviceStatus.mapreduce2";
    stack3 = helpers['if'];
    tmp1 = self.program(18, program18, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "view.serviceStatus.hbase";
    stack3 = helpers['if'];
    tmp1 = self.program(20, program20, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "view.serviceStatus.zookeeper";
    stack3 = helpers['if'];
    tmp1 = self.program(22, program22, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "view.serviceStatus.oozie";
    stack3 = helpers['if'];
    tmp1 = self.program(24, program24, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "view.serviceStatus.ganglia";
    stack3 = helpers['if'];
    tmp1 = self.program(26, program26, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "view.serviceStatus.hive";
    stack3 = helpers['if'];
    tmp1 = self.program(28, program28, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "view.serviceStatus.hue";
    stack3 = helpers['if'];
    tmp1 = self.program(30, program30, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "view.serviceStatus.flume";
    stack3 = helpers['if'];
    tmp1 = self.program(32, program32, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </tbody>\n    </table>\n    ");
    data.buffer.push("\n  </div>\n  ");
    data.buffer.push("\n</div>\n</div>\n<div class=\"span6\">\n	<div class=\"box\">\n		<div class=\"box-header\">\n			<h4>");
    stack1 = depth0;
    stack2 = "services.alerts.headingOfList";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h4>\n			<div class=\"btn-group\">\n        <a class=\"btn\" target=\"_blank\" rel=\"tooltip\" title=\"Go to Nagios\" ");
    stack1 = {};
    stack2 = "controller.nagiosUrl";
    stack1['href'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><i class=\"icon-link\"></i></a>\n			</div>\n		</div>\n		<ul id='summary-alerts-list' class=\"alerts\">\n		  ");
    stack1 = depth0;
    stack2 = "controller.alerts.length";
    stack3 = helpers['if'];
    tmp1 = self.program(34, program34, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(37, program37, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n		</ul>\n	</div>\n</div>\n</div>\n");
    stack1 = depth0;
    stack2 = "view.serviceMetricGraphs.length";
    stack3 = helpers['if'];
    tmp1 = self.program(42, program42, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/info/summary/ganglia", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;


    data.buffer.push("\n\n\n\n");
    stack1 = depth0;
    stack2 = "view.sumMasterComponentView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n\n<tr>\n  <td class=\"summary-label\">");
    stack1 = depth0;
    stack2 = "services.ganglia.monitors";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n  <td>\n    <span class=\"green-live\">");
    stack1 = depth0;
    stack2 = "view.monitors";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " </span>");
    stack1 = depth0;
    stack2 = "services.service.summary.GangliaMonitorsLIVE";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n    <div class=\"summary-view-host\">\n       <a ");
    stack1 = depth0;
    stack2 = "view.monitorsObj";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"javascript:void(null)\" >");
    stack1 = depth0;
    stack2 = "view.hasManyMonitors";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n    </div>\n  </td>\n</tr>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/info/summary/hive", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    
    data.buffer.push("s");}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.sumMasterComponentView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n\n<tr>\n  <td class=\"summary-label\">");
    stack1 = depth0;
    stack2 = "services.hive.clients";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n  <td>\n    <span class=\"green-live\">");
    stack1 = depth0;
    stack2 = "view.clients.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " </span>");
    stack1 = depth0;
    stack2 = "services.hive.client";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1));
    stack1 = depth0;
    stack2 = "view.hasManyClients";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push(" ");
    stack1 = depth0;
    stack2 = "common.installed";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n    <div class=\"summary-view-host\">\n      <a ");
    stack1 = depth0;
    stack2 = "view.clientObj";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"javascript:void(null)\" >");
    stack1 = depth0;
    stack2 = "view.clientsHostText";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n    </div>\n  </td>\n</tr>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/info/summary/hue", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n\n");
    stack1 = depth0;
    stack2 = "view.sumMasterComponentView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/info/summary/mapreduce2", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "component.isMaster";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n<tr>\n  <td class=\"summary-label\">");
    stack1 = depth0;
    stack2 = "component.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n  <td>\n      <a ");
    stack1 = depth0;
    stack2 = "component.host";
    stack3 = depth0;
    stack4 = "selectHost";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"javascript:void(null)\">");
    stack1 = depth0;
    stack2 = "component.host.publicHostName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n  </td>\n</tr>\n  ");
    return buffer;}

  function program4(depth0,data) {
    
    
    data.buffer.push("s");}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.components";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "component";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n<tr>\n  <td class=\"summary-label\">");
    stack1 = depth0;
    stack2 = "common.clients";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n  <td>\n      <a ");
    stack1 = depth0;
    stack2 = "view.clientObj";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"javascript:void(null)\">");
    stack1 = depth0;
    stack2 = "view.clients.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " MapReduce2 client");
    stack1 = depth0;
    stack2 = "view.hasManyClients";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("</a>\n  </td>\n</tr>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/info/summary/master_components", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n  <tr>\n   <td>");
    stack1 = depth0;
    stack2 = "masterComp.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n   <td>\n     <span ");
    stack1 = {};
    stack2 = "masterComp.workStatus";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></span>\n     ");
    stack1 = depth0;
    stack2 = "masterComp.componentTextStatus";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n     <div class=\"summary-view-host\">\n       <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "masterComp.host";
    stack3 = depth0;
    stack4 = "showDetails";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "services.service.summary.viewHost";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n     </div>\n   </td>\n  </tr>\n");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.mastersComp";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "masterComp";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/info/summary/oozie", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    
    data.buffer.push("s");}

    data.buffer.push("\n\n\n");
    stack1 = depth0;
    stack2 = "view.sumMasterComponentView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n\n<tr>\n  <td class=\"summary-label\">");
    stack1 = depth0;
    stack2 = "services.oozie.clients";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n  <td>\n    <span class=\"green-live\">");
    stack1 = depth0;
    stack2 = "view.clients.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " </span>");
    stack1 = depth0;
    stack2 = "services.oozie.client";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1));
    stack1 = depth0;
    stack2 = "view.hasManyClients";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push(" ");
    stack1 = depth0;
    stack2 = "common.installed";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n    <div class=\"summary-view-host\">\n       <a ");
    stack1 = depth0;
    stack2 = "view.clientObj";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"javascript:void(null)\" >");
    stack1 = depth0;
    stack2 = "view.clientsHostText";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n    </div>\n  </td>\n</tr>\n\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/info/summary/zookeeper", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    
    data.buffer.push("s");}

    data.buffer.push("\n\n\n\n");
    stack1 = depth0;
    stack2 = "view.sumMasterComponentView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n<td class=\"summary-label\">");
    stack1 = depth0;
    stack2 = "services.zookeeper.client";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</td>\n  <td>\n    <span class=\"green-live\">");
    stack1 = depth0;
    stack2 = "view.clients.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " </span>");
    stack1 = depth0;
    stack2 = "services.zookeeper.client";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1));
    stack1 = depth0;
    stack2 = "view.hasManyClients";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push(" ");
    stack1 = depth0;
    stack2 = "common.installed";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n    <div class=\"summary-view-host\">\n       <a ");
    stack1 = depth0;
    stack2 = "view.clientObj";
    stack3 = depth0;
    stack4 = "filterHosts";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"javascript:void(null)\" >");
    stack1 = depth0;
    stack2 = "view.clientsHostText";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n    </div>\n  </td>\n</tr>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/info/summary_alert", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    
    data.buffer.push("\n              <i class=\"icon-ok icon-large\"></i>\n          ");}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n	          ");
    stack1 = depth0;
    stack2 = "isWarning";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(6, program6, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          ");
    return buffer;}
  function program4(depth0,data) {
    
    
    data.buffer.push("\n	              <i class=\"icon-warning-sign icon-large\"></i>\n	          ");}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              ");
    stack1 = depth0;
    stack2 = "isCritical";
    stack3 = helpers['if'];
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(9, program9, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n	          ");
    return buffer;}
  function program7(depth0,data) {
    
    
    data.buffer.push("\n                  <i class=\"icon-remove icon-large\"></i>\n              ");}

  function program9(depth0,data) {
    
    
    data.buffer.push("\n                  <i class=\"icon-question-sign icon-large\"></i>\n              ");}

    data.buffer.push("\n\n<div class=\"container-fluid\">\n    <div class=\"row-fluid\">\n        <div class=\"span1 status-icon\">\n          ");
    stack1 = depth0;
    stack2 = "isOk";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(3, program3, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </div>\n        <div class=\"span11\">\n            <div class=\"row-fluid\">\n                <div class=\"span7 title\">");
    stack1 = depth0;
    stack2 = "title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                </div>\n                <div rel=\"tooltip\" ");
    stack1 = {};
    stack2 = "timeSinceAlertDetails";
    stack1['data-title'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " data-placement=\"right\" class=\"span5 date-time\">");
    stack1 = depth0;
    stack2 = "timeSinceAlert";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n            </div>\n            <div class=\"row-fluid message\">");
    stack1 = depth0;
    stack2 = "message";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n        </div>\n    </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/item", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n<div class=\"service-button\">\n  ");
    stack1 = depth0;
    stack2 = "view.isMaintenanceActive";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "controller.isServiceRestartable";
    stack3 = helpers['if'];
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(7, program7, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </span>\n</div>\n");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n    <div class=\"btn-group display-inline-block\">\n      <a class=\"btn dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">\n        ");
    stack1 = depth0;
    stack2 = "services.service.actions.maintenance";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        <span class=\"caret\"></span>\n      </a>\n      <ul class=\"dropdown-menu\">\n        <!-- dropdown menu links -->\n        ");
    stack1 = depth0;
    stack2 = "view.maintenance";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "option";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </ul>\n    </div>\n  ");
    return buffer;}
  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n        <li ");
    stack1 = {};
    stack2 = "controller.isStopDisabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n          <a ");
    stack1 = depth0;
    stack2 = "option";
    stack3 = depth0;
    stack4 = "doAction";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = true;
    stack5['href'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "option.label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n        </li>\n        ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n	  <a href=\"javascript:void(null)\" ");
    stack1 = {};
    stack2 = ":btn controller.isStartDisabled:disabled:btn-success";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n	     data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "startService";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n	    <i class=\"icon-play\"></i>\n	    ");
    stack1 = depth0;
    stack2 = "services.service.start";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n	  </a>\n	  <a href=\"javascript:void(null)\" ");
    stack1 = {};
    stack2 = ":btn controller.isStopDisabled:disabled:btn-danger";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n	     data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "stopService";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n	    <i class=\"icon-stop icon-white\"></i>\n	    ");
    stack1 = depth0;
    stack2 = "services.service.stop";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n	  </a>\n	");
    return buffer;}

  function program7(depth0,data) {
    
    
    data.buffer.push("\n	  <span>&nbsp;</span>\n	");}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "App.MainServiceInfoMenuView";
    stack3 = {};
    stack4 = "view.hasConfigTab";
    stack3['configTabBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n");
    stack1 = depth0;
    stack2 = "App.isAdmin";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1));
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/menu_item", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <span class=\"label operations-count\">\n      ");
    stack1 = depth0;
    stack2 = "view.alertsCount";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </span>\n  ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n	  ");
    stack1 = depth0;
    stack2 = "view.content.isRestartRequired";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n	");
    return buffer;}
  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n	    <i class=\"icon-refresh restart-required-service\" rel=\"tooltip\" title=\"");
    stack1 = depth0;
    stack2 = "view.content.restartRequiredMessage";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\"></i>\n	  ");
    return buffer;}

    data.buffer.push("\n\n<a href=\"#/main/services/");
    stack1 = depth0;
    stack2 = "view.content.id";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "/summary\">\n  ");
    stack1 = depth0;
    stack2 = "App.MainDashboardServiceHealthView";
    stack3 = {};
    stack4 = "service-health";
    stack3['class'] = stack4;
    stack4 = "view.content";
    stack3['serviceBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "&nbsp;\n  <span>");
    stack1 = depth0;
    stack2 = "view.content.displayName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n  ");
    stack1 = depth0;
    stack2 = "view.alertsCount";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "App.supports.hostOverrides";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</a>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/reassign", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<div class=\"wizard\">\n  <div class=\"container\">\n    <div class=\"container-fluid\">\n      <div class=\"row-fluid\">\n        <div class=\"span3\">\n          <!--Sidebar content-->\n          <div class=\"well\">\n            <ul class=\"nav nav-pills nav-stacked\">\n              <li class=\"nav-header\">");
    stack1 = depth0;
    stack2 = "services.reassign.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</li>\n              <li ");
    stack1 = {};
    stack2 = "isStep1:active view.isStep1Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep1";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step11.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep2:active view.isStep2Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep2";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step5.reassign.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep3:active view.isStep3Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep3";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step12.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep4:active view.isStep4Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep4";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step8.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n              <li ");
    stack1 = {};
    stack2 = "isStep5:active view.isStep5Disabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><a href=\"javascript:void(null);\"  ");
    stack1 = depth0;
    stack2 = "gotoStep5";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "installer.step9.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a></li>\n            </ul>\n          </div>\n        </div>\n        <div class=\"wizard-content well span9\">\n          ");
    stack1 = depth0;
    stack2 = "outlet";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/main/service/reconfigure", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <tr>\n      <td>\n      ");
    stack1 = depth0;
    stack2 = "App.StageLabelView";
    stack3 = {};
    stack4 = "stage";
    stack3['stageBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </td>\n      <td>\n          ");
    stack1 = depth0;
    stack2 = "stage.isCompleted";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(10, program10, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </td>\n      <td>\n        ");
    stack1 = depth0;
    stack2 = "stage.isError";
    stack3 = helpers['if'];
    tmp1 = self.program(14, program14, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </td>\n    </tr>\n    ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <p ");
    stack1 = {};
    stack2 = "view.isStarted::faintText";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "stage.label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</p>\n      ");
    return buffer;}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "stage.isSuccess";
    stack3 = helpers['if'];
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(7, program7, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          ");
    return buffer;}
  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              ");
    stack1 = depth0;
    stack2 = "App.StageSuccessView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    return buffer;}

  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              ");
    stack1 = depth0;
    stack2 = "stage.isError";
    stack3 = helpers['if'];
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            ");
    return buffer;}
  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                ");
    stack1 = depth0;
    stack2 = "App.StageFailureView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n              ");
    return buffer;}

  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "stage.isStarted";
    stack3 = helpers['if'];
    tmp1 = self.program(11, program11, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          ");
    return buffer;}
  function program11(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              ");
    stack1 = depth0;
    stack2 = "stage.isPolling";
    stack3 = helpers['if'];
    tmp1 = self.program(12, program12, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            ");
    return buffer;}
  function program12(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n                <div class=\"progress-bar pull-left\">\n                  ");
    stack1 = depth0;
    stack2 = "App.StageInProgressView";
    stack3 = {};
    foundHelper = helpers.stage;
    stack4 = foundHelper || depth0.stage;
    stack3['stageBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                </div>\n                <div class=\"progress-percentage pull-left\">");
    stack1 = depth0;
    stack2 = "stage.progress";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "%</div>\n              ");
    return buffer;}

  function program14(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n          <a class=\"btn btn-primary\"\n             href=\"javascript:void(null)\" ");
    stack1 = depth0;
    stack2 = "retry";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><i class=\"icon-repeat icon-white\"></i>\n            ");
    stack1 = depth0;
    stack2 = "common.retry";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          </a>\n        ");
    return buffer;}

    data.buffer.push("\n\n<table id=\"security-stages\" class=\"table no-borders\">\n  <tbody>\n    ");
    stack1 = depth0;
    stack2 = "controller.stages";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "stage";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </tbody>\n</table>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/master_hosts", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "installer.noHostsAssigned";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "value";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n  <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "showHosts";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "value.firstObject";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "and";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "view.otherLength";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.hasNoHosts";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "view.hasOneHost";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "view.hasMultipleHosts";
    stack3 = helpers['if'];
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/master_hosts_popup", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <li>");
    stack1 = depth0;
    stack2 = "host";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</li>\n  ");
    return buffer;}

    data.buffer.push("\n\n<ul>\n  ");
    stack1 = depth0;
    stack2 = "view.serviceConfig.value";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "host";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</ul>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/slave_component_hosts", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n");
    stack1 = depth0;
    stack2 = "none";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " -\n<a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.serviceConfig.category";
    stack3 = depth0;
    stack4 = "showEditSlaveComponentGroups";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n  ");
    stack1 = depth0;
    stack2 = "installer.slaveComponentHosts.selectHosts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n</a>\n");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n<a href=\"#\" ");
    stack1 = depth0;
    stack2 = "view.serviceConfig.category";
    stack3 = depth0;
    stack4 = "showEditSlaveComponentGroups";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n  ");
    stack1 = depth0;
    stack2 = "view.hasMultipleHosts";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(6, program6, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</a>\n  ");
    return buffer;}
  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "view.hosts.firstObject.hostName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "and";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "view.otherLength";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    return buffer;}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "view.hosts.firstObject.hostName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.hasNoHosts";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(3, program3, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/slave_component_hosts_popup", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <tr>\n      <td>\n        <label>");
    stack1 = depth0;
    stack2 = "host.hostName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</label>\n      </td>\n      <td>\n        ");
    stack1 = depth0;
    stack2 = "App.SlaveComponentDropDownGroupView";
    stack3 = {};
    stack4 = "host";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </td>\n    </tr>\n  ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n        <select ");
    stack1 = depth0;
    stack2 = "changeGroup";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = "change";
    stack3['on'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n          ");
    stack1 = depth0;
    stack2 = "controller.getGroupsForDropDown";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "groupName";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </select>\n        ");
    return buffer;}
  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "view.optionTag";
    stack3 = {};
    stack4 = "groupName";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(4, program4, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          ");
    return buffer;}
  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              <option value=\"");
    stack1 = depth0;
    stack2 = "groupName";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\" ");
    stack1 = {};
    stack2 = "view.selected";
    stack1['selected'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                ");
    stack1 = depth0;
    stack2 = "groupName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n              </option>\n            ");
    return buffer;}

    data.buffer.push("\n\n<div id=\"slave-hosts-popup\" class=\"alert alert-info\">");
    stack1 = depth0;
    stack2 = "header";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n<table class=\"table table-striped\">\n  <thead>\n    <tr>\n      <th>");
    stack1 = depth0;
    stack2 = "common.host";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th>");
    stack1 = depth0;
    stack2 = "common.group";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n    </tr>\n  </thead>\n  <tbody>\n  ");
    stack1 = depth0;
    stack2 = "hosts";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "host";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </tbody>\n</table>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/slave_hosts", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "installer.noHostsAssigned";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  ");
    stack1 = depth0;
    stack2 = "view.hasMultipleHosts";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(6, program6, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n");
    return buffer;}
  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "showHosts";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "value.firstObject";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "and";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "view.otherLength";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n  ");
    return buffer;}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "view.value.0";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    return buffer;}

    data.buffer.push("\n\n");
    stack1 = depth0;
    stack2 = "view.hasNoHosts";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(3, program3, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/stack_upgrade/step1", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "service.isHidden";
    stack3 = helpers.unless;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <tr>\n            <td>");
    stack1 = depth0;
    stack2 = "service.displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n            <td>");
    stack1 = depth0;
    stack2 = "service.version";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n            <td>");
    stack1 = depth0;
    stack2 = "service.newVersion";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n            <td>");
    stack1 = depth0;
    stack2 = "service.description";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n          </tr>\n        ");
    return buffer;}

    data.buffer.push("\n\n<div class=\"box alert-info\">\n  <div>\n  ");
    stack1 = depth0;
    stack2 = "installer.stackUpgrade.step1.description";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n  <br/>\n  <div>\n    <div>");
    stack1 = depth0;
    stack2 = "installer.stackUpgrade.step1.installedStackVersion";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": ");
    stack1 = depth0;
    stack2 = "App.currentStackVersion";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n    <div>");
    stack1 = depth0;
    stack2 = "installer.stackUpgrade.step1.upgradeStackVersion";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": ");
    stack1 = depth0;
    stack2 = "content.upgradeVersion";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n  </div>\n</div>\n<div>\n    <table class=\"table table-bordered table-striped\">\n      <thead>\n      <tr>\n        <th>");
    stack1 = depth0;
    stack2 = "common.service";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n        <th>");
    stack1 = depth0;
    stack2 = "installer.stackUpgrade.step1.installedVersion";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n        <th>");
    stack1 = depth0;
    stack2 = "installer.stackUpgrade.step1.newVersion";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n        <th>");
    stack1 = depth0;
    stack2 = "common.description";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n      </tr>\n      </thead>\n      <tbody>\n        ");
    stack1 = depth0;
    stack2 = "content.servicesInfo";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "service";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </tbody>\n    </table>\n</div>\n<div class=\"btn-area\">\n  <a class=\"btn pull-left\" ");
    stack1 = depth0;
    stack2 = "backToCluster";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.cancel";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n  <a class=\"btn btn-success pull-right\" ");
    stack1 = depth0;
    stack2 = "next";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.next";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n</div>\n\n\n\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/stack_upgrade/step2", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<div class=\"box alert-info\">\n  <div>\n  ");
    stack1 = depth0;
    stack2 = "installer.stackUpgrade.step2.notice.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n  <br/>\n  <ul class=\"unstyled\">\n      <li>1&#41;&nbsp;");
    stack1 = depth0;
    stack2 = "installer.stackUpgrade.step2.notice.first";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</li>\n      <li>2&#41;&nbsp;");
    stack1 = depth0;
    stack2 = "installer.stackUpgrade.step2.notice.second";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</li>\n      <li>3&#41;&nbsp;");
    stack1 = depth0;
    stack2 = "installer.stackUpgrade.step2.notice.third";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</li>\n  </ul>\n  <div>\n      <strong>");
    stack1 = depth0;
    stack2 = "installer.stackUpgrade.step2.notice.complete";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</strong>\n  </div>\n</div>\n<div class=\"control-group\">\n    <label><strong>\n      ");
    stack1 = depth0;
    stack2 = "installer.stackUpgrade.step2.advancedOption";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n      <i href=\"javascript:void(null)\" class=\"icon-question-sign\"\n         rel=\"popover\"\n         ");
    stack1 = {};
    stack2 = "installer.step2.localRepo.tooltip.title";
    stack1['title'] = stack2;
    stack2 = "installer.step2.localRepo.tooltip.content";
    stack1['data-content'] = stack2;
    foundHelper = helpers.translateAttr;
    stack2 = foundHelper || depth0.translateAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, tmp1); }
    else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "translateAttr", tmp1); }
    else { stack1 = stack2; }
    data.buffer.push(escapeExpression(stack1) + ">\n      </i>\n    </strong></label>\n    <label class=\"checkbox\">\n      ");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "content.upgradeOptions.localRepo";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      ");
    stack1 = depth0;
    stack2 = "installer.stackUpgrade.step2.localRepository";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n    </label>\n</div>\n<div class=\"btn-area\">\n  <a class=\"btn pull-left\" ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n  <a class=\"btn btn-success pull-right\" ");
    stack1 = depth0;
    stack2 = "upgradeAction";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.upgrade";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/stack_upgrade/step3", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "view.processView";
    stack3 = {};
    stack4 = "process";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n            <div class=\"item\">\n                <i ");
    stack1 = {};
    stack2 = "view.icon view.iconColor";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></i>\n                <a href=\"javascript:void(0)\" ");
    stack1 = depth0;
    stack2 = "process.name";
    stack3 = depth0;
    stack4 = "hostsLogPopup";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.status";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n            </div>\n          ");
    stack1 = depth0;
    stack2 = "process.isRetry";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            <div ");
    stack1 = {};
    stack2 = "view.inProgress::hide :row :span12";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                <div class=\"progress-bar span4\">\n                    <div ");
    stack1 = {};
    stack2 = "view.isProcessCompleted::progress-striped view.isProcessCompleted::active view.barColor :progress";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                        <div class=\"bar\" ");
    stack1 = {};
    stack2 = "view.barWidth";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n                    </div>\n                </div>\n                <div class=\"span1\">");
    stack1 = depth0;
    stack2 = "process.progress";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "&#37;</div>\n                <div class=\"span7\">");
    stack1 = depth0;
    stack2 = "process.message";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n            </div>\n        ");
    return buffer;}
  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n              <a class=\"btn btn-primary\" ");
    stack1 = depth0;
    stack2 = "process.name";
    stack3 = depth0;
    stack4 = "retry";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = "true";
    stack5['href'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                  <i class=\"icon-repeat icon-white\"></i>\n                ");
    stack1 = depth0;
    stack2 = "view.retryMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n              </a>\n          ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <a class=\"btn btn-success pull-right\" ");
    stack1 = depth0;
    stack2 = "finish";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "submitButton";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n      ");
    return buffer;}

    data.buffer.push("\n<div id=\"deploy\">\n    <div ");
    stack1 = {};
    stack2 = "view.statusClass :alert";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.overallStatus";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n    <div class=\"service\">\n      ");
    stack1 = depth0;
    stack2 = "processes";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "process";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </div>\n    <div class=\"btn-area\">\n      ");
    stack1 = depth0;
    stack2 = "submitButton";
    stack3 = helpers['if'];
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step0", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<h2>");
    stack1 = depth0;
    stack2 = "installer.step0.body.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n<p class=\"alert alert-info\">\n  ");
    stack1 = depth0;
    stack2 = "installer.step0.body";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n</p>\n<div ");
    stack1 = {};
    stack2 = "view.onError:error :control-group";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n  <label class=\"control-label\" for=\"cluster-name\">");
    stack1 = depth0;
    stack2 = "installer.step0.clusterName";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n    <a href=\"javascript:void(null)\"\n       rel=\"popover\"\n      ");
    stack1 = {};
    stack2 = "installer.step0.clusterName.tooltip.title";
    stack1['title'] = stack2;
    stack2 = "installer.step0.clusterName.tooltip.content";
    stack1['data-content'] = stack2;
    foundHelper = helpers.translateAttr;
    stack2 = foundHelper || depth0.translateAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, tmp1); }
    else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "translateAttr", tmp1); }
    else { stack1 = stack2; }
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.learnMore";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n  </label>\n\n  <div class=\"controls\">\n    ");
    stack1 = depth0;
    stack2 = "App.WizardStep0ViewClusterNameInput";
    stack3 = {};
    stack4 = "content.cluster.name";
    stack3['valueBinding'] = stack4;
    stack4 = "cluster name";
    stack3['placeholder'] = stack4;
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    <p class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "clusterNameError";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</p>\n  </div>\n</div>\n\n<div class=\"btn-area\">\n  <a class=\"btn btn-success pull-right\" ");
    stack1 = {};
    stack2 = "invalidClusterName";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "submit";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.next";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n</div>\n\n\n\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step1", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <label class=\"radio\">");
    stack1 = depth0;
    stack2 = "view.stackRadioButton";
    stack3 = {};
    stack4 = "stack";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "stack.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</label>\n  ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n<div class=\"accordion\" id=\"advancedRepoAccordion\">\n  <div class=\"accordion-group\">\n    <div class=\"accordion-heading\">\n      <a class=\"accordion-toggle\" data-toggle=\"collapse\" data-parent=\"#advancedRepoAccordion\" href=\"#collapseOne\">\n        ");
    stack1 = depth0;
    stack2 = "installer.step1.advancedRepo.title";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n      </a>\n    </div>\n    <div id=\"collapseOne\" class=\"accordion-body collapse\">\n      <div class=\"accordion-inner\">\n        <div class=\"alert alert-info\">\n          ");
    stack1 = depth0;
    stack2 = "installer.step1.advancedRepo.message";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        </div>\n        <table class=\"table table-striped\">\n          <thead>\n            <tr>\n              <th class=\"os\">");
    stack1 = depth0;
    stack2 = "common.os";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n              <th class=\"baseUrl\">");
    stack1 = depth0;
    stack2 = "installer.step1.advancedRepo.localRepo.column.baseUrl";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n              <th class=\"actions\"></th>\n            </tr>\n          </thead>\n          <tbody>\n          ");
    stack1 = depth0;
    stack2 = "view.localRepositories";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "localRepo";
    stack7 = helpers.each;
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          </tbody>\n        </table>\n        <a ");
    stack1 = {};
    stack2 = ":btn :pull-right view.isAddOSDisabled:disabled";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "addLocalRepository";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><i class=\"icon-plus\"></i> Add OS</a>\n      </div>\n    </div>\n  </div>\n</div>\n");
    return buffer;}
  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n            <tr>\n              <td>");
    stack1 = depth0;
    stack2 = "localRepo.osType";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n              <td>");
    stack1 = depth0;
    stack2 = "localRepo.baseUrl";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n              <td>\n                <a class=\"action\" ");
    stack1 = depth0;
    stack2 = "localRepo";
    stack3 = depth0;
    stack4 = "removeLocalRepository";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " >\n                  <i class=\"icon-minus-sign\"></i>");
    stack1 = depth0;
    stack2 = "common.remove";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                </a>\n              </td>\n            </tr>\n          ");
    return buffer;}

    data.buffer.push("\n<h2>");
    stack1 = depth0;
    stack2 = "installer.step1.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n<p class=\"alert alert-info\">\n  ");
    stack1 = depth0;
    stack2 = "installer.step1.body";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n</p>\n<p><b>");
    stack1 = depth0;
    stack2 = "common.stacks";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</b></p>\n<form autocomplete=\"off\">\n  ");
    stack1 = depth0;
    stack2 = "view.stacks";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "stack";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</form>\n\n");
    stack1 = depth0;
    stack2 = "App.supports.localRepositories";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n<a class=\"btn pull-left\" ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">&larr; ");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n<a class=\"btn btn-success pull-right\" ");
    stack1 = depth0;
    stack2 = "next";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.next";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step10", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  <div class=\"alert alert-danger\">\n    ");
    stack1 = depth0;
    stack2 = "installer.step10.nagiosRestartRequired";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n  <ul>\n    <span ");
    stack1 = {};
    stack2 = "item.color";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "item.displayStatement";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n    ");
    stack1 = depth0;
    stack2 = "item.status";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "status";
    stack7 = helpers.each;
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </ul>\n  ");
    return buffer;}
  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n    <ul>\n      <span ");
    stack1 = {};
    stack2 = "status.color";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "status.displayStatement";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n      ");
    stack1 = depth0;
    stack2 = "status.statements";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "statement";
    stack7 = helpers.each;
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </ul>\n    ");
    return buffer;}
  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <ul>\n        <span ");
    stack1 = {};
    stack2 = "status.color";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "statement.displayStatement";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n      </ul>\n      ");
    return buffer;}

    data.buffer.push("\n\n<h2>");
    stack1 = depth0;
    stack2 = "installer.step10.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n");
    stack1 = depth0;
    stack2 = "isNagiosRestartRequired";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n<div class=\"alert alert-info\">\n  ");
    stack1 = depth0;
    stack2 = "installer.step10.body";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n</div>\n<div id=\"step10-content\" class=\"well pre-scrollable\">\n  ");
    stack1 = depth0;
    stack2 = "clusterInfo";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "item";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</div>\n<div class=\"btn-area\">\n  <a class=\"btn pull-left\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">&larr; ");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n  <a class=\"btn btn-success pull-right\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "complete";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.complete";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step11", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<h2>");
    stack1 = depth0;
    stack2 = "installer.step11.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n<div class=\"btn-area\">\n  <a class=\"btn btn-success pull-right\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "next";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.next";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step12", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "App.ServiceConfigView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "app.loadingPlaceholder";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    return buffer;}

    data.buffer.push("\n\n<div id=\"serviceConfig\">\n  <h2>");
    stack1 = depth0;
    stack2 = "installer.step12.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n\n  ");
    stack1 = depth0;
    stack2 = "controller.dataIsLoaded";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(3, program3, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n  <div class=\"btn-area\">\n    <a class=\"btn\" ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">&larr; ");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n\n    <a\n            class=\"btn btn-success pull-right\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    stack1 = depth0;
    stack2 = "submit";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.next";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n  </div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step13", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("<p><b>");
    stack1 = depth0;
    stack2 = "installer.step13.changes";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</b></p>");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <div>\n      <ul><em> <b>");
    stack1 = depth0;
    stack2 = "item.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</b></em>\n\n        <div>\n          <ul>");
    stack1 = depth0;
    stack2 = "installer.step13.oldValue";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": &nbsp;<span class=\"text text-info\">");
    stack1 = depth0;
    stack2 = "item.oldValue";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span></ul>\n          <ul>");
    stack1 = depth0;
    stack2 = "installer.step13.newValue";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ": <span class=\"text text-info\">");
    stack1 = depth0;
    stack2 = "item.value";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span></ul>\n        </div>\n\n      </ul>\n    </div>\n    ");
    return buffer;}

    data.buffer.push("\n\n<h2>");
    stack1 = depth0;
    stack2 = "installer.step13.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n\n<div class=\"alert alert-info\">\n  ");
    stack1 = depth0;
    stack2 = "installer.step13.body";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n</div>\n\n<div id=\"step8-content\" class=\"well pre-scrollable\">\n  <div id=\"printReview\">\n    <a class=\"btn btn-info pull-right\" ");
    stack1 = depth0;
    stack2 = "printReview";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.print";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a> <br/>\n  </div>\n  <div id=\"step8-info\">\n    <p><b>");
    stack1 = depth0;
    stack2 = "installer.step13.component";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</b> ");
    stack1 = depth0;
    stack2 = "controller.content.reassign.display_name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</p>\n\n    <p><b>");
    stack1 = depth0;
    stack2 = "installer.step13.sourceHost";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</b> ");
    stack1 = depth0;
    stack2 = "view.sourceHost";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</p>\n\n    <p><b>");
    stack1 = depth0;
    stack2 = "installer.step13.targetHost";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</b> ");
    stack1 = depth0;
    stack2 = "view.targetHost";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</p>\n\n    ");
    stack1 = depth0;
    stack2 = "view.changes";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "view.changes";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "item";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n</div>\n<div class=\"btn-area\">\n  <a class=\"btn pull-left\" ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = {};
    stack4 = "true";
    stack3['href'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">&larr; ");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n  <a class=\"btn btn-success pull-right\"\n     id=\"spinner\" ");
    stack1 = {};
    stack2 = "controller.isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "next";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.deploy";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step14", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <p>");
    stack1 = depth0;
    stack2 = "installer.step14.retry";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</p>\n      <a ");
    stack1 = depth0;
    stack2 = "retry";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"btn btn-primary\">\n        <i class=\"icon-repeat icon-white\"></i>\n        ");
    stack1 = depth0;
    stack2 = "common.retry";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n      </a>\n      <a ");
    stack1 = depth0;
    stack2 = "abort";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"btn btn-warning\">\n        <i class=\"icon-remove icon-white\"></i>\n        ");
    stack1 = depth0;
    stack2 = "common.abort";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n      </a>\n    ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n      ");
    stack1 = depth0;
    stack2 = "view.taskView";
    stack3 = {};
    stack4 = "task";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(4, program4, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    return buffer;}
  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n        <div class=\"item\">\n          <i ");
    stack1 = {};
    stack2 = "view.icon view.iconColor";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></i>\n          <a href=\"javascript:void(0)\">");
    stack1 = depth0;
    stack2 = "task.message";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n        </div>\n        <div ");
    stack1 = {};
    stack2 = "view.inProgress::hide :row :span12";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n          <div class=\"progress-bar span4\">\n            <div class=\"progress-striped active progress-info progress\">\n              <div class=\"bar\" ");
    stack1 = {};
    stack2 = "view.barWidth";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></div>\n            </div>\n          </div>\n          <div class=\"span1\">");
    stack1 = depth0;
    stack2 = "task.progress";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "&#37;</div>\n        </div>\n      ");
    return buffer;}

    data.buffer.push("\n<div id=\"step14\">\n  <div ");
    stack1 = {};
    stack2 = "view.statusClass :alert";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n    <p>");
    stack1 = depth0;
    stack2 = "view.statusMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</p>\n    ");
    stack1 = depth0;
    stack2 = "controller.showRetry";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n    ");
    stack1 = depth0;
    stack2 = "view.tasks";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "task";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n  <div class=\"btn-area\">\n    <a class=\"btn btn-success pull-right\" ");
    stack1 = {};
    stack2 = "controller.isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "complete";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.complete";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step1_addLocalRepository", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n					    <li>\n  					    <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "os";
    stack3 = depth0;
    stack4 = "selectOS";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                  ");
    stack1 = depth0;
    stack2 = "os.osType";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                </a>\n              </li>\n				    ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n	    <div class=\"alert\">\n			  <strong>");
    stack1 = depth0;
    stack2 = "common.warning";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</strong>  ");
    stack1 = depth0;
    stack2 = "view.errorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n			</div>\n	  ");
    return buffer;}

  function program5(depth0,data) {
    
    
    data.buffer.push("\n	    <div class=\"alert alert-info\">\n        Provide location of the local repository for the selected OS\n      </div>\n		");}

    data.buffer.push("\n  <form class=\"form-horizontal\" id=\"addLocalRepositoryPopup\" autocomplete=\"off\">\n    <div class=\"each-row\">\n      <label class=\"control-label\">");
    stack1 = depth0;
    stack2 = "installer.step1.advancedRepo.localRepo.label.os";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</label>\n      <div class=\"controls\">\n        <div class=\"btn-group\">\n				  <a class=\"btn dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">\n				    ");
    stack1 = depth0;
    stack2 = "view.selectedOS.osType";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n				    <span class=\"caret\"></span>\n				  </a>\n				  <ul class=\"dropdown-menu\">\n  				  ");
    stack1 = depth0;
    stack2 = "view.oses";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "os";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n				  </ul>\n				</div>\n      </div>\n    </div>\n    <div class=\"each-row\">\n      <label class=\"control-label\">");
    stack1 = depth0;
    stack2 = "installer.step1.advancedRepo.localRepo.label.baseUrl";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</label>\n      <div class=\"controls\">\n        ");
    stack1 = depth0;
    stack2 = "Em.TextField";
    stack3 = {};
    stack4 = "view.enteredUrl";
    stack3['valueBinding'] = stack4;
    stack4 = "span6";
    stack3['classNames'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </div>\n    </div>\n    <div class=\"each-row\">\n      <label class=\"control-label\">");
    stack1 = depth0;
    stack2 = "installer.step1.advancedRepo.localRepo.label.stack";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</label>\n      <div class=\"controls\">\n        ");
    stack1 = depth0;
    stack2 = "view.stackName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n      </div>\n    </div>\n    <div style=\"height:100px;\"></div>\n    ");
    stack1 = depth0;
    stack2 = "view.errorMessage";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(5, program5, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </form>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step2", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n        <p class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "hostsError";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</p>\n        ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "App.SshKeyFileUploader";
    stack3 = {};
    stack4 = "view.sshKeyState";
    stack3['disabledBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "sshKeyError";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n            ");
    return buffer;}

  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                <span class=\"help-inline\">");
    stack1 = depth0;
    stack2 = "sshUserError";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n            ");
    return buffer;}

  function program9(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <label ");
    stack1 = {};
    stack2 = ":checkbox";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      ");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "content.installOptions.localRepo";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n\n      ");
    stack1 = depth0;
    stack2 = "installer.step2.localRepo.label_use";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n\n      <a href=\"javascript:void(null)\"\n         rel=\"popover\"\n        ");
    stack1 = {};
    stack2 = "installer.step2.localRepo.tooltip.title";
    stack1['title'] = stack2;
    stack2 = "installer.step2.localRepo.tooltip.content";
    stack1['data-content'] = stack2;
    foundHelper = helpers.translateAttr;
    stack2 = foundHelper || depth0.translateAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, tmp1); }
    else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "translateAttr", tmp1); }
    else { stack1 = stack2; }
    data.buffer.push(escapeExpression(stack1) + ">\n        ");
    stack1 = depth0;
    stack2 = "installer.step2.localRepo.tooltip.title";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n      ");
    stack1 = depth0;
    stack2 = "installer.step2.localRepo.label_instead";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n    </label>\n    ");
    return buffer;}

  function program11(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <label ");
    stack1 = {};
    stack2 = ":checkbox";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <div class=\"java-home\">\n      ");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "content.installOptions.isJavaHome";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    stack1 = depth0;
    stack2 = "installer.step2.javaHome.label";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        <a href=\"javascript:void(null)\"\n           rel=\"popover\"\n          ");
    stack1 = {};
    stack2 = "installer.step2.javaHome.tooltip.title";
    stack1['title'] = stack2;
    stack2 = "installer.step2.javaHome.tooltip.content";
    stack1['data-content'] = stack2;
    foundHelper = helpers.translateAttr;
    stack2 = foundHelper || depth0.translateAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, tmp1); }
    else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "translateAttr", tmp1); }
    else { stack1 = stack2; }
    data.buffer.push(escapeExpression(stack1) + ">\n            ");
    stack1 = depth0;
    stack2 = "installer.step2.javaHome.tooltip.title";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n      </div>\n    </label>\n    <label class=\"checkbox\">\n      ");
    stack1 = depth0;
    stack2 = "view.textFieldView";
    stack3 = {};
    stack4 = "content.installOptions.javaHome";
    stack3['valueBinding'] = stack4;
    stack4 = "content.installOptions.isJavaHome";
    stack3['isEnabledBinding'] = stack4;
    stack4 = "installer.step2.javaHome.tooltip.placeholder";
    stack3['placeholderName'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </label>\n    ");
    return buffer;}

  function program13(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <a class=\"btn pull-left\" ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">&larr; ");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n    ");
    return buffer;}

    data.buffer.push("\n\n<div id=\"installOptions\">\n  <h2>");
    stack1 = depth0;
    stack2 = "installer.step2.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n\n  <p class=\"alert alert-info\">");
    stack1 = depth0;
    stack2 = "installer.step2.body";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</p>\n\n  <div id=\"targetHosts\">\n    <h5>");
    stack1 = depth0;
    stack2 = "installer.step2.targetHosts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h5>\n\n    <div ");
    stack1 = {};
    stack2 = "hostsError:error :control-group :target-hosts-input";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <p>");
    stack1 = depth0;
    stack2 = "installer.step2.targetHosts.info";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ". ");
    stack1 = depth0;
    stack2 = "installer.step2.orUse";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        <a href=\"javascript:void(null)\"\n           rel=\"popover\"\n          ");
    stack1 = {};
    stack2 = "installer.step2.hostPattern.tooltip.title";
    stack1['title'] = stack2;
    stack2 = "installer.step2.hostPattern.tooltip.content";
    stack1['data-content'] = stack2;
    foundHelper = helpers.translateAttr;
    stack2 = foundHelper || depth0.translateAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, tmp1); }
    else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "translateAttr", tmp1); }
    else { stack1 = stack2; }
    data.buffer.push(escapeExpression(stack1) + ">\n          ");
    stack1 = depth0;
    stack2 = "installer.step2.hostPattern.tooltip.title";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        </a>\n      </p>\n\n      <div class=\"controls\">\n        ");
    stack1 = depth0;
    stack2 = "Ember.TextArea";
    stack3 = {};
    stack4 = "span6";
    stack3['class'] = stack4;
    stack4 = "content.installOptions.hostNames";
    stack3['valueBinding'] = stack4;
    stack4 = "5";
    stack3['rows'] = stack4;
    stack4 = "host names";
    stack3['placeholder'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    stack1 = depth0;
    stack2 = "hostsError";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </div>\n    </div>\n  </div>\n\n  <div id=\"hostConnectivity\">\n    <div class=\"ambari-agents\">\n      <h5>");
    stack1 = depth0;
    stack2 = "installer.step2.sshKey";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h5>\n\n      <label class=\"radio\">\n        ");
    stack1 = depth0;
    stack2 = "view.providingSSHKeyRadioButton";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    stack1 = depth0;
    stack2 = "installer.step2.useSsh.provide";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          <a href=\"javascript:void(null)\"\n             rel=\"popover\"\n            ");
    stack1 = {};
    stack2 = "installer.step2.useSsh.tooltip.title";
    stack1['title'] = stack2;
    stack2 = "installer.step2.useSsh.tooltip.content";
    stack1['data-content'] = stack2;
    foundHelper = helpers.translateAttr;
    stack2 = foundHelper || depth0.translateAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, tmp1); }
    else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "translateAttr", tmp1); }
    else { stack1 = stack2; }
    data.buffer.push(escapeExpression(stack1) + ">\n            ");
    stack1 = depth0;
    stack2 = "installer.step2.useSsh.tooltip.title";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n        ");
    stack1 = depth0;
    stack2 = "installer.step2.useSsh.provide_id_rsa";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n      </label>\n      <div class=\"ssh-key-input\">\n        ");
    stack1 = depth0;
    stack2 = "view.isFileApi";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        <div ");
    stack1 = {};
    stack2 = "sshKeyError:error :controls :control-group";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n            ");
    stack1 = depth0;
    stack2 = "Ember.TextArea";
    stack3 = {};
    stack4 = "span6";
    stack3['class'] = stack4;
    stack4 = "3";
    stack3['rows'] = stack4;
    stack4 = "sshKey";
    stack3['id'] = stack4;
    stack4 = "ssh private key";
    stack3['placeholder'] = stack4;
    stack4 = "view.sshKeyState";
    stack3['disabledBinding'] = stack4;
    stack4 = "content.installOptions.sshKey";
    stack3['valueBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    stack1 = depth0;
    stack2 = "sshKeyError";
    stack3 = helpers['if'];
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </div>\n        <div>\n            <label class=\"ssh-user pull-left\">\n              ");
    stack1 = depth0;
    stack2 = "installer.step2.sshUser";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                <a href=\"javascript:void(null)\"\n                   rel=\"popover\"\n                  ");
    stack1 = {};
    stack2 = "installer.step2.sshUser.link";
    stack1['title'] = stack2;
    stack2 = "installer.step2.sshUser.toolTip";
    stack1['data-content'] = stack2;
    foundHelper = helpers.translateAttr;
    stack2 = foundHelper || depth0.translateAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, tmp1); }
    else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "translateAttr", tmp1); }
    else { stack1 = stack2; }
    data.buffer.push(escapeExpression(stack1) + ">\n                  ");
    stack1 = depth0;
    stack2 = "installer.step2.sshUser.link";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n              ");
    stack1 = depth0;
    stack2 = "installer.step2.sshUser.account";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n            </label>\n          <div ");
    stack1 = {};
    stack2 = "sshUserError:error :control-group";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n            ");
    stack1 = depth0;
    stack2 = "view.textFieldView";
    stack3 = {};
    stack4 = "content.installOptions.sshUser";
    stack3['valueBinding'] = stack4;
    stack4 = "content.installOptions.useSsh";
    stack3['isEnabledBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            ");
    stack1 = depth0;
    stack2 = "sshUserError";
    stack3 = helpers['if'];
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          </div>\n        </div>\n      </div>\n\n      <label class=\"radio\">\n        ");
    stack1 = depth0;
    stack2 = "view.manualRegistrationRadioButton";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        ");
    stack1 = depth0;
    stack2 = "installer.step2.manualInstall.perform";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          <a href=\"javascript:void(null)\"\n             rel=\"popover\"\n            ");
    stack1 = {};
    stack2 = "installer.step2.manualInstall.tooltip.title";
    stack1['title'] = stack2;
    stack2 = "installer.step2.manualInstall.tooltip.content";
    stack1['data-content'] = stack2;
    foundHelper = helpers.translateAttr;
    stack2 = foundHelper || depth0.translateAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    if(typeof stack2 === functionType) { stack1 = stack2.call(depth0, tmp1); }
    else if(stack2=== undef) { stack1 = helperMissing.call(depth0, "translateAttr", tmp1); }
    else { stack1 = stack2; }
    data.buffer.push(escapeExpression(stack1) + ">\n            ");
    stack1 = depth0;
    stack2 = "installer.step2.manualInstall.tooltip.title";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n        ");
    stack1 = depth0;
    stack2 = "installer.step2.manualInstall.perform_on_hosts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n      </label>\n\n    </div>\n  </div>\n\n  <div class=\"advancedOptions\">\n    <h5>");
    stack1 = depth0;
    stack2 = "installer.step2.advancedOptions.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h5>\n\n    ");
    stack1 = depth0;
    stack2 = "App.supports.localRepositories";
    stack3 = helpers.unless;
    tmp1 = self.program(9, program9, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    \n    ");
    stack1 = depth0;
    stack2 = "isInstaller";
    stack3 = helpers['if'];
    tmp1 = self.program(11, program11, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n  <div class=\"btn-area\">\n    ");
    stack1 = depth0;
    stack2 = "view.parentView.controller.hideBackButton";
    stack3 = helpers.unless;
    tmp1 = self.program(13, program13, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    <a class=\"btn btn-success pull-right\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "evaluateStep";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      ");
    stack1 = depth0;
    stack2 = "installer.step2.registerAndConfirm";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n  </div>\n\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step2ManualInstallPopup", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<p>");
    stack1 = depth0;
    stack2 = "installer.step2.manualInstall.popup.body";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</p>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step3", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n        <a class=\"btn btn-primary decommission\"\n           href=\"#\" ");
    stack1 = depth0;
    stack2 = "retrySelectedHosts";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><i\n          class=\"icon-repeat icon-white\"></i>\n          ");
    stack1 = depth0;
    stack2 = "installer.step3.retryFailed";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        </a>\n        ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n              <li ");
    stack1 = {};
    stack2 = "category.itemClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                <a ");
    stack1 = depth0;
    stack2 = "category";
    stack3 = depth0;
    stack4 = "selectCategory";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"#\">\n                  ");
    stack1 = depth0;
    stack2 = "category.label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                </a>\n              </li>\n              ");
    stack1 = depth0;
    stack2 = "category.last";
    stack3 = helpers.unless;
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            ");
    return buffer;}
  function program4(depth0,data) {
    
    
    data.buffer.push("\n                <li>|</li>\n              ");}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "visibleHosts";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "host";
    stack7 = helpers.each;
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    return buffer;}
  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "App.WizardHostView";
    stack3 = {};
    stack4 = "controller.category";
    stack3['categoryBinding'] = stack4;
    stack4 = "host";
    stack3['hostInfoBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(8, program8, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    return buffer;}
  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n        <td>\n          ");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "host.isChecked";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        </td>\n        <td>\n          ");
    stack1 = depth0;
    stack2 = "host.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        </td>\n        <td>\n          <div ");
    stack1 = {};
    stack2 = "host.bootBarColor host.isBootDone::progress-striped host.isBootDone::active :progress";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n            <div class=\"bar\" style=\"width:100%\">\n            </div>\n          </div>\n        </td>\n        <td>\n          <a href=\"javascript:void(null)\"\n             data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "host";
    stack3 = depth0;
    stack4 = "hostLogPopup";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><span  ");
    stack1 = {};
    stack2 = "host.bootStatusColor";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "host.bootStatusForDisplay";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span></a>\n        </td>\n        <td>\n          ");
    stack1 = depth0;
    stack2 = "view.isRemovable";
    stack3 = helpers['if'];
    tmp1 = self.program(9, program9, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "view.isRetryable";
    stack3 = helpers['if'];
    tmp1 = self.program(11, program11, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </td>\n        ");
    return buffer;}
  function program9(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("<a class=\"btn btn-mini\" ");
    stack1 = depth0;
    stack2 = "remove";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><i class=\"icon-trash\"></i>\n          ");
    stack1 = depth0;
    stack2 = "common.remove";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>");
    return buffer;}

  function program11(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("<a class=\"btn btn-mini\" ");
    stack1 = depth0;
    stack2 = "retry";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><i class=\"icon-repeat\"></i>\n          ");
    stack1 = depth0;
    stack2 = "common.retry";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>");
    return buffer;}

  function program13(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n        <tr>\n            <td colspan=\"5\"><p>");
    stack1 = depth0;
    stack2 = "installer.step3.hosts.noHosts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</p></td>\n        </tr>\n        ");
    return buffer;}

  function program15(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n      <div ");
    stack1 = {};
    stack2 = ":alert view.status";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n        ");
    stack1 = depth0;
    stack2 = "view.message";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "warnings";
    stack3 = depth0;
    stack4 = "hostWarningsPopup";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.linkText";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n      </div>\n    ");
    return buffer;}

    data.buffer.push("\n\n<div id=\"confirm-hosts\">\n  <h2>");
    stack1 = depth0;
    stack2 = "installer.step3.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n\n  <p class=\"alert alert-info\">");
    stack1 = depth0;
    stack2 = "installer.step3.body";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</p>\n  <div class=\"box\">\n    <div class=\"box-header\">\n      <div class=\"button-section\">\n        <a class=\"btn btn-primary\" ");
    stack1 = {};
    stack2 = "noHostsSelected";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n           href=\"#\" ");
    stack1 = depth0;
    stack2 = "removeSelectedHosts";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><i\n                class=\"icon-trash icon-white\"></i>\n          ");
    stack1 = depth0;
    stack2 = "installer.step3.removeSelected";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        </a>\n        ");
    stack1 = depth0;
    stack2 = "isRetryDisabled";
    stack3 = helpers.unless;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n        <div id=\"host-filter\" class=\"pull-right\">\n          <ul class=\"clearfix\">\n            <li class=\"first\">");
    stack1 = depth0;
    stack2 = "common.show";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":</li>\n            ");
    stack1 = depth0;
    stack2 = "controller.categories";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "category";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          </ul>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"pre-scrollable\" style=\"max-height: 440px;\">\n      <table class=\"table table-bordered table-striped\">\n        <thead>\n        <tr>\n          <th class=\"span1\">");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "allChecked";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n          <th class=\"span3\">");
    stack1 = depth0;
    stack2 = "common.host";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n          <!-- retrieved from local storage initially -->\n          <th class=\"span3\">");
    stack1 = depth0;
    stack2 = "common.progress";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n          <th class=\"span2\">");
    stack1 = depth0;
    stack2 = "common.status";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n          <!-- given by the parsing function that parses data from bootstrap call, dynamically assign the color -->\n          <th class=\"span3\">");
    stack1 = depth0;
    stack2 = "common.action";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n          <!-- trash icon -->\n          <!-- retry icon -->\n        </tr>\n        </thead>\n\n        <tbody>\n        ");
    stack1 = depth0;
    stack2 = "visibleHosts.length";
    stack3 = helpers['if'];
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(13, program13, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n        </tbody>\n\n      </table>\n    </div>\n    <div class=\"box-footer\">\n      <hr/>\n      <div class=\"footer-pagination\">\n      </div>\n    </div>\n  </div>\n    ");
    stack1 = depth0;
    stack2 = "isWarningsBoxVisible";
    stack3 = helpers['if'];
    tmp1 = self.program(15, program15, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  <div class=\"btn-area\">\n    <a class=\"btn pull-left\" ");
    stack1 = {};
    stack2 = "isInstallInProgress";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">&larr; ");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n    <a class=\"btn btn-success pull-right\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "submit";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.next";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n  </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step3_host_log_popup", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <div>\n      ");
    stack1 = depth0;
    stack2 = "view.textArea";
    stack3 = {};
    stack4 = "view.host.bootLog";
    stack3['contentBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </div>\n    ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <pre class=\"bootLog\">");
    stack1 = depth0;
    stack2 = "view.host.bootLog";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</pre>\n    ");
    return buffer;}

    data.buffer.push("\n\n\n<div id=\"host-log\">\n  <div class=\"content-area\">\n      <div class=\"textTrigger\">");
    stack1 = depth0;
    stack2 = "popup.highlight";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n    ");
    stack1 = depth0;
    stack2 = "view.isTextArea";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(3, program3, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step3_host_warnings_popup", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n    <div class=\"accordion-group block\">\n      <div class=\"accordion-heading\">\n        <i ");
    stack1 = {};
    stack2 = ":pull-left :accordion-toggle category.isCollapsed:icon-caret-right:icon-caret-down";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></i>\n        ");
    stack1 = depth0;
    stack2 = "category.warnings.length";
    stack3 = helpers['if'];
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(4, program4, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        <a class=\"accordion-toggle\" ");
    stack1 = depth0;
    stack2 = "category";
    stack3 = depth0;
    stack4 = "onToggleBlock";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n          ");
    stack1 = depth0;
    stack2 = "category.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " (");
    stack1 = depth0;
    stack2 = "category.warnings.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ")\n        </a>\n      </div>\n      <div id=\"");
    stack1 = depth0;
    stack2 = "category.category";
    stack3 = helpers.unbound;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\" class=\"accordion-body collapse in\">\n        <div class=\"accordion-inner\">\n          ");
    stack1 = depth0;
    stack2 = "category.warnings.length";
    stack3 = helpers['if'];
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(12, program12, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </div>\n      </div>\n    </div>\n    ");
    return buffer;}
  function program2(depth0,data) {
    
    
    data.buffer.push("\n        <i class=\"pull-right accordion-toggle icon-warning-sign\"></i>\n        ");}

  function program4(depth0,data) {
    
    
    data.buffer.push("\n        <i class=\"pull-right accordion-toggle icon-ok\"></i>\n        ");}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n          <table>\n            <thead>\n            <tr>\n              <th colspan=\"2\">");
    stack1 = depth0;
    stack2 = "category.message";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</th>\n            </tr>\n            <tr>\n              <th colspan=\"2\"><b>");
    stack1 = depth0;
    stack2 = "category.type";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</b></th>\n            </tr>\n            </thead>\n            <tbody>\n            ");
    stack1 = depth0;
    stack2 = "category.warnings";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "warning";
    stack7 = helpers.each;
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            </tbody>\n          </table>\n          ");
    return buffer;}
  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n            <tr>\n              <td class=\"warning-name\" ");
    stack1 = {};
    stack2 = "warning.command";
    stack1['data-original-title'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " >");
    stack1 = depth0;
    stack2 = "warning.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n              <td>");
    stack1 = depth0;
    stack2 = "category.action";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                <a href=\"javascript:void(null);\" rel='HostsListTooltip' ");
    stack1 = {};
    stack2 = "warning.hostsList";
    stack1['data-original-title'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "warning.hosts";
    stack3 = depth0;
    stack4 = "showHostsPopup";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n                  ");
    stack1 = depth0;
    stack2 = "warning.hosts.length";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                  ");
    stack1 = depth0;
    stack2 = "warning.onSingleHost";
    stack3 = helpers['if'];
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(10, program10, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                </a>\n              </td>\n            </tr>\n            ");
    return buffer;}
  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                  ");
    stack1 = depth0;
    stack2 = "installer.step3.hostWarningsPopup.host";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                  ");
    return buffer;}

  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                  ");
    stack1 = depth0;
    stack2 = "installer.step3.hostWarningsPopup.hosts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n                  ");
    return buffer;}

  function program12(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "installer.step3.hostWarningsPopup.emptyMessage";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "category.emptyName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    return buffer;}

    data.buffer.push("\n\n\n<div id=\"host-warnings\">\n  <div class=\"notice\">\n    <!-- \n    <span>");
    stack1 = depth0;
    stack2 = "installer.step3.hostWarningsPopup.checks";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " <b>");
    stack1 = depth0;
    stack2 = "view.warningsNotice";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</b>.<br>");
    stack1 = depth0;
    stack2 = "installer.step3.hostWarningsPopup.notice";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</span>\n    -->\n    <span>");
    stack1 = depth0;
    stack2 = "installer.step3.hostWarningsPopup.notice";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</span>\n  </div>\n  <div class=\"row-fluid\">\n    <div class=\"span7\">\n      ");
    stack1 = depth0;
    stack2 = "common.hosts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "&nbsp;");
    stack1 = depth0;
    stack2 = "Ember.Select";
    stack3 = {};
    stack4 = "view.categories";
    stack3['contentBinding'] = stack4;
    stack4 = "view.category";
    stack3['selectionBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </div>\n    <div class=\"span3 offset2\">\n      <a href=\"javascript.void(0)\" title=\"Show Details\" ");
    stack1 = depth0;
    stack2 = "openWarningsInDialog";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n         class=\"task-detail-open-dialog\"><i\n              class=\"icon-external-link\"></i> ");
    stack1 = depth0;
    stack2 = "installer.step3.hostWarningsPopup.report";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n    </div>\n  </div>\n  <div class=\"accordion warnings-list\" id=\"accordion2\">\n    ");
    stack1 = depth0;
    stack2 = "view.content";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "category";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step4", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "isHidden";
    stack3 = helpers.unless;
    tmp1 = self.program(2, program2, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    return buffer;}
  function program2(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n    <tr ");
    stack1 = {};
    stack2 = "isSelected:success:";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <td><label\n        class=\"checkbox\">");
    stack1 = depth0;
    stack2 = "Ember.Checkbox";
    stack3 = {};
    stack4 = "isDisabled";
    stack3['disabledBinding'] = stack4;
    stack4 = "isSelected";
    stack3['checkedBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1));
    stack1 = depth0;
    stack2 = "displayName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</label>\n      </td>\n      <td>");
    stack1 = depth0;
    stack2 = "version";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n      <td>");
    stack1 = depth0;
    stack2 = "description";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</td>\n    </tr>\n    ");
    return buffer;}

  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <a class=\"btn pull-left\" ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">&larr; ");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n    </a>\n    ");
    return buffer;}

    data.buffer.push("\n\n<div id=\"step4\">\n  <h2>");
    stack1 = depth0;
    stack2 = "installer.step4.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n\n  <div class=\"alert alert-info\">\n    ");
    stack1 = depth0;
    stack2 = "installer.step4.body";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n  <table class=\"table table-striped\">\n    <thead>\n    <tr>\n      <th class=\"span3\">");
    stack1 = depth0;
    stack2 = "common.service";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        <span style=\"margin-left:10px\">\n          <a href=\"#\" ");
    stack1 = depth0;
    stack2 = "selectAll";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = {};
    stack2 = "isAll:selected:deselected";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "all";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n                |\n                <a\n                  href=\"#\" ");
    stack1 = depth0;
    stack2 = "selectMinimum";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = {};
    stack2 = "isMinimum:selected:deselected";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "minimum";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n        </span>\n      </th>\n      <th>");
    stack1 = depth0;
    stack2 = "common.version";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n      <th>");
    stack1 = depth0;
    stack2 = "common.description";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n    </tr>\n    </thead>\n    <tbody>\n    ");
    stack1 = depth0;
    stack2 = "controller";
    stack3 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </tbody>\n  </table>\n\n  <div class=\"btn-area\">\n    ");
    stack1 = depth0;
    stack2 = "view.parentView.controller.hideBackButton";
    stack3 = helpers.unless;
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    <a class=\"btn btn-success pull-right\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "submit";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "> ");
    stack1 = depth0;
    stack2 = "common.next";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n  </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step5", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <br>\n    ");
    stack1 = depth0;
    stack2 = "installer.step5.body.hive";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <div class=\"control-group\">\n        <label class=\"control-label\">\n          ");
    stack1 = depth0;
    stack2 = "controller.isReassignHive";
    stack3 = helpers['if'];
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(6, program6, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </label>\n        ");
    stack1 = depth0;
    stack2 = "isHiveCoHost";
    stack3 = helpers['if'];
    tmp1 = self.program(8, program8, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(10, program10, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </div>\n      ");
    return buffer;}
  function program4(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "installer.step5.hiveGroup";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    return buffer;}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "display_name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ":\n          ");
    return buffer;}

  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <label class=\"host-name\">");
    stack1 = depth0;
    stack2 = "selectedHost";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "<i class=\"icon-asterisks\">&#10037</i></label>\n        ");
    return buffer;}

  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n        <div class=\"controls\">\n          ");
    stack1 = depth0;
    stack2 = "App.SelectHostView";
    stack3 = {};
    stack4 = "availableHosts";
    stack3['contentBinding'] = stack4;
    stack4 = "content.host_name";
    stack3['optionValuePath'] = stack4;
    stack4 = "content.host_info";
    stack3['optionLabelPath'] = stack4;
    stack4 = "selectedHost";
    stack3['selectedHostBinding'] = stack4;
    stack4 = "component_name";
    stack3['componentNameBinding'] = stack4;
    stack4 = "zId";
    stack3['zIdBinding'] = stack4;
    stack4 = "isInstalled";
    stack3['disabledBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "showAddControl";
    stack3 = helpers['if'];
    tmp1 = self.program(11, program11, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          ");
    stack1 = depth0;
    stack2 = "showRemoveControl";
    stack3 = helpers['if'];
    tmp1 = self.program(13, program13, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </div>\n        ");
    return buffer;}
  function program11(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "App.AddControlView";
    stack3 = {};
    stack4 = "component_name";
    stack3['componentNameBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    return buffer;}

  function program13(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "App.RemoveControlView";
    stack3 = {};
    stack4 = "component_name";
    stack3['componentNameBinding'] = stack4;
    stack4 = "zId";
    stack3['zIdBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    return buffer;}

  function program15(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <div class=\"mapping-box round-corners well\">\n      <div class=\"hostString\"><span>");
    stack1 = depth0;
    stack2 = "hostInfo";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span></div>\n      ");
    stack1 = depth0;
    stack2 = "masterServices";
    stack3 = helpers.each;
    tmp1 = self.program(16, program16, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </div>\n    ");
    return buffer;}
  function program16(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <span class=\"assignedService round-corners\">");
    stack1 = depth0;
    stack2 = "display_name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n      ");
    return buffer;}

  function program18(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <div class=\"remaining-hosts round-corners well\">\n      <span><strong>");
    stack1 = depth0;
    stack2 = "remainingHosts";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</strong> ");
    stack1 = depth0;
    stack2 = "installer.step5.attention";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</span></div>\n    ");
    return buffer;}

    data.buffer.push("\n\n<h2>");
    stack1 = depth0;
    stack2 = "title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</h2>\n<div class=\"alert alert-info\">\n  ");
    stack1 = depth0;
    stack2 = "installer.step5.body";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n  ");
    stack1 = depth0;
    stack2 = "hasHiveServer";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n</div>\n<div class=\"assign-masters\">\n  <div class=\"select-hosts\">\n    <form class=\"form-horizontal\" autocomplete=\"off\">\n      <!-- View for array controller -->\n      ");
    stack1 = depth0;
    stack2 = "servicesMasters";
    stack3 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    </form>\n  </div>\n\n  <div class=\"host-assignments\">\n    ");
    stack1 = depth0;
    stack2 = "masterHostMapping";
    stack3 = helpers.each;
    tmp1 = self.program(15, program15, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n    ");
    stack1 = depth0;
    stack2 = "remainingHosts";
    stack3 = helpers['if'];
    tmp1 = self.program(18, program18, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n  <div style=\"clear: both;\"></div>\n</div>\n<div class=\"btn-area\">\n  <a class=\"btn pull-left\" ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = {};
    stack4 = "true";
    stack3['href'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">&larr; ");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n  <a class=\"btn btn-success pull-right\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "submit";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.next";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step6", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <div class=\"alert alert-error\">");
    stack1 = depth0;
    stack2 = "errorMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n  ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n\n              <th>\n                <a href=\"#\" ");
    stack1 = {};
    stack2 = "header.allChecked:selected:deselected";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                  ");
    stack1 = depth0;
    stack2 = "header";
    stack3 = depth0;
    stack4 = "selectAllNodes";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "all";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a> |\n\n                <a href=\"#\" ");
    stack1 = {};
    stack2 = "header.noChecked:selected:deselected";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                  ");
    stack1 = depth0;
    stack2 = "header";
    stack3 = depth0;
    stack4 = "deselectAllNodes";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "none";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n              </th>\n\n          ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n          <tr>\n            ");
    stack1 = depth0;
    stack2 = "App.WizardStep6HostView";
    stack3 = {};
    stack4 = "host";
    stack3['hostBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(6, program6, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            ");
    stack1 = depth0;
    stack2 = "host.checkboxes";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "checkbox";
    stack7 = helpers.each;
    tmp1 = self.program(9, program9, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          </tr>\n        ");
    return buffer;}
  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n              ");
    stack1 = depth0;
    stack2 = "host.hostName";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n              ");
    stack1 = depth0;
    stack2 = "host.isMaster";
    stack3 = helpers['if'];
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n            ");
    return buffer;}
  function program7(depth0,data) {
    
    
    data.buffer.push("\n                <i class=icon-asterisks>&#10037</i>\n              ");}

  function program9(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n              <td>\n                  <label class=\"checkbox\">");
    stack1 = depth0;
    stack2 = "App.WizardStep6CheckboxView";
    stack3 = {};
    stack4 = "checkbox";
    stack3['checkboxBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</label>\n              </td>\n            ");
    return buffer;}

    data.buffer.push("\n\n<div id=\"step6\">\n  <h2>");
    stack1 = depth0;
    stack2 = "view.title";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</h2>\n  <div class=\"alert alert-info\">");
    stack1 = depth0;
    stack2 = "view.label";
    stack3 = {};
    stack4 = "true";
    stack3['unescaped'] = stack4;
    stack4 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("</div>\n  ");
    stack1 = depth0;
    stack2 = "errorMessage";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n  <div class=\"pre-scrollable\">\n    <table class=\"table table-striped\">\n      <thead>\n        <tr>\n          <th>");
    stack1 = depth0;
    stack2 = "common.host";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n          ");
    stack1 = depth0;
    stack2 = "controller.headers";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "header";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </tr>\n      </thead>\n      <tbody>\n        ");
    stack1 = depth0;
    stack2 = "hosts";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "host";
    stack7 = helpers.each;
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </tbody>\n    </table>\n  </div>\n  <div class=\"btn-area\">\n    <a class=\"btn\" ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">&larr; ");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n    <a class=\"btn btn-success pull-right\" ");
    stack1 = depth0;
    stack2 = "next";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.next";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n  </div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step7", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;


    data.buffer.push("\n\n<div id=\"serviceConfig\">\n    <h2>");
    stack1 = depth0;
    stack2 = "installer.step7.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n\n    <div class=\"alert alert-info\">\n      ");
    stack1 = depth0;
    stack2 = "installer.step7.body";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n    </div>\n\n    ");
    stack1 = depth0;
    stack2 = "App.ServicesConfigView";
    stack3 = helpers.view;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n\n    <div class=\"btn-area\">\n        <a class=\"btn\" ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">&larr; ");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n\n        <a\n                class=\"btn btn-success pull-right\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          ");
    stack1 = depth0;
    stack2 = "submit";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.next";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n    </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step8", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, functionType="function", helperMissing=helpers.helperMissing, undef=void 0, escapeExpression=this.escapeExpression;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n  <div class=\"alert alert-error\">\n    ");
    stack1 = depth0;
    stack2 = "installer.step8.securityWarning";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n  </div>\n");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n          <p>\n              <b>");
    stack1 = depth0;
    stack2 = "item.display_name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</b> : ");
    stack1 = depth0;
    stack2 = "item.config_value";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n          </p>\n      ");
    return buffer;}

  function program5(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n              <div>\n                  <ul><em><b>");
    stack1 = depth0;
    stack2 = "display_name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</b></em>\n\n                      <div>\n                        ");
    stack1 = depth0;
    stack2 = "service_components";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "component";
    stack7 = helpers.each;
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n                      </div>\n                  </ul>\n              </div>\n          ");
    return buffer;}
  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n                            <ul><span class=\"text text-info\">");
    stack1 = depth0;
    stack2 = "component.display_name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n                                : </span>");
    stack1 = depth0;
    stack2 = "component.component_value";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</ul>\n                        ");
    return buffer;}

    data.buffer.push("\n\n<h2>");
    stack1 = depth0;
    stack2 = "installer.step8.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n\n<div class=\"alert alert-info\">\n  ");
    stack1 = depth0;
    stack2 = "installer.step8.body";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n</div>\n\n");
    stack1 = depth0;
    stack2 = "controller.securityEnabled";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n<div id=\"step8-content\" class=\"well pre-scrollable\">\n    <div id=\"printReview\">\n        <a class=\"btn btn-info pull-right\" ");
    stack1 = depth0;
    stack2 = "printReview";
    stack3 = {};
    stack4 = "view";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.print";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a> <br/>\n    </div>\n    <div id=\"step8-info\">\n      ");
    stack1 = depth0;
    stack2 = "controller.clusterInfo";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "item";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n        <div>\n            <p><b>");
    stack1 = depth0;
    stack2 = "menu.item.services";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</b></p>\n          ");
    stack1 = depth0;
    stack2 = "controller.services";
    stack3 = helpers.each;
    tmp1 = self.program(5, program5, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </div>\n    </div>\n</div>\n<div class=\"btn-area\">\n    <a class=\"btn pull-left\" ");
    stack1 = depth0;
    stack2 = "back";
    stack3 = {};
    stack4 = "true";
    stack3['href'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">&larr; ");
    stack1 = depth0;
    stack2 = "common.back";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n    <a class=\"btn btn-success pull-right\"\n       id=\"spinner\" ");
    stack1 = {};
    stack2 = "controller.isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "submit";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.deploy";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step8_log_popup", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression;


    data.buffer.push("\n<p>");
    stack1 = depth0;
    stack2 = "view.message";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</p>\n<div class=\"progress\">\n    <div class=\"bar\" ");
    stack1 = {};
    stack2 = "view.barWidth";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n    </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step9", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n        <a class=\"btn btn-primary\"\n           href=\"#\" ");
    stack1 = depth0;
    stack2 = "retry";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "><i class=\"icon-repeat icon-white\"></i>\n          ");
    stack1 = depth0;
    stack2 = "common.retry";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n        </a>\n        ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n            <li ");
    stack1 = {};
    stack2 = "category.itemClass";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n              <a ");
    stack1 = depth0;
    stack2 = "category";
    stack3 = depth0;
    stack4 = "selectCategory";
    stack5 = {};
    stack6 = "controller";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " href=\"#\">\n                ");
    stack1 = depth0;
    stack2 = "category.label";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n              </a>\n            </li>\n            ");
    stack1 = depth0;
    stack2 = "category.last";
    stack3 = helpers.unless;
    tmp1 = self.program(4, program4, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n          ");
    return buffer;}
  function program4(depth0,data) {
    
    
    data.buffer.push("\n              <li>|</li>\n            ");}

  function program6(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7;
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "controller.visibleHosts";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "host";
    stack7 = helpers.each;
    tmp1 = self.program(7, program7, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    return buffer;}
  function program7(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4;
    data.buffer.push("\n        ");
    stack1 = depth0;
    stack2 = "App.HostStatusView";
    stack3 = {};
    stack4 = "host";
    stack3['objBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = self.program(8, program8, data);
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        ");
    return buffer;}
  function program8(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6;
    data.buffer.push("\n        <td>\n          ");
    stack1 = depth0;
    stack2 = "host.name";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        </td>\n        <td>\n          <div class=\"progress-bar pull-left\">\n            <div ");
    stack1 = {};
    stack2 = "view.isHostCompleted::progress-striped view.isHostCompleted::active view.barColor :progress";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n              <div class=\"bar\" ");
    stack1 = {};
    stack2 = "view.barWidth";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n              </div>\n            </div>\n          </div>\n          <div class=\"progress-percentage pull-left\">");
    stack1 = depth0;
    stack2 = "host.progress";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "%</div>\n        </td>\n        <td>\n          <a ");
    stack1 = {};
    stack2 = "view.isFailed:text-error view.isSuccess:text-success view.isWarning:text-warning";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n            href=\"javascript:void(null)\"\n            data-toggle=\"modal\" ");
    stack1 = depth0;
    stack2 = "host";
    stack3 = depth0;
    stack4 = "hostLogPopup";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "host.message";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</a>\n        </td>\n\n        ");
    return buffer;}

  function program10(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n        <tr>\n            <td colspan=\"3\"><p>");
    stack1 = depth0;
    stack2 = "installer.step3.hosts.noHosts";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</p></td>\n        </tr>\n        ");
    return buffer;}

  function program12(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n    <p ");
    stack1 = {};
    stack2 = "view.resultMsgColor :alert";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "view.resultMsg";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</p>\n    ");
    return buffer;}

    data.buffer.push("\n\n<div id=\"deploy\">\n\n  <h2>");
    stack1 = depth0;
    stack2 = "installer.step9.header";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</h2>\n\n  <p class=\"alert alert-info\">");
    stack1 = depth0;
    stack2 = "installer.step9.body";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</p>\n\n  <div id=\"overallProgress\">\n    ");
    stack1 = depth0;
    stack2 = "view.isStepCompleted";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    <div class=\"row-fluid\">\n      <div class=\"span10\">\n        <div ");
    stack1 = {};
    stack2 = "isStepCompleted::progress-striped isStepCompleted::active view.barColor :progress";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n          <div class=\"bar\" ");
    stack1 = {};
    stack2 = "view.barWidth";
    stack1['style'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n          </div>\n        </div>\n      </div>\n      <div class=\"span2\">");
    stack1 = depth0;
    stack2 = "view.progressMessage";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</div>\n    </div>\n  </div>\n\n  <div class=\"box\">\n    <div class=\"box-header\">\n      <div class=\"pull-left\">\n        ");
    stack1 = depth0;
    stack2 = "controller.showRetry";
    stack3 = helpers['if'];
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n      </div>\n      <!-- filter by host level -->\n      <div id=\"host-filter\" class=\"pull-right\">\n        <ul class=\"clearfix\">\n          <li class=\"first\">");
    stack1 = depth0;
    stack2 = "common.show";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":</li>\n          ");
    stack1 = depth0;
    stack2 = "controller.categories";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "category";
    stack7 = helpers.each;
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n        </ul>\n      </div>\n    </div>\n    <div class=\"pre-scrollable\" style=\"max-height: 750px;\">\n      <table id=\"deploy-status-by-host\" class=\"table table-bordered table-striped\">\n        <thead>\n        <tr>\n          <th class=\"host\">\n            ");
    stack1 = depth0;
    stack2 = "common.host";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n          </th>\n          <th class=\"status\">");
    stack1 = depth0;
    stack2 = "common.status";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n          <!--  given by the parsing function that parses data from bootstrap call -->\n          <th class=\"message\">");
    stack1 = depth0;
    stack2 = "common.message";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</th>\n          <!-- retrieved from local storage initially -->\n        </tr>\n        </thead>\n\n        <tbody>\n        ");
    stack1 = depth0;
    stack2 = "controller.visibleHosts.length";
    stack3 = helpers['if'];
    tmp1 = self.program(6, program6, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.program(10, program10, data);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n\n        </tbody>\n      </table>\n    </div>\n    <div class=\"box-footer\">\n      <hr/>\n      <div class=\"footer-pagination\">\n      </div>\n    </div>\n  </div>\n\n  <div>\n    ");
    stack1 = depth0;
    stack2 = "view.resultMsg";
    stack3 = helpers['if'];
    tmp1 = self.program(12, program12, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    <div class=\"btn-area\">\n      <a class=\"btn btn-success pull-right\" ");
    stack1 = {};
    stack2 = "isSubmitDisabled";
    stack1['disabled'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ");
    stack1 = depth0;
    stack2 = "submit";
    stack3 = {};
    stack4 = "controller";
    stack3['target'] = stack4;
    stack4 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">");
    stack1 = depth0;
    stack2 = "common.next";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + " &rarr;</a>\n    </div>\n  </div>\n\n</div>\n</div>\n");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("templates/wizard/step9HostTasksLogPopup", function(exports, require, module) {
  Ember.TEMPLATES[module.id] = Ember.Handlebars.template(function anonymous(Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Ember.Handlebars.helpers;
    var buffer = '', stack1, stack2, stack3, stack4, stack5, stack6, stack7, foundHelper, tmp1, self=this, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, undef=void 0;

  function program1(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3, stack4, stack5;
    data.buffer.push("\n    <div ");
    stack1 = {};
    stack2 = "taskInfo.isVisible::hidden :log-list-wrap";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n      <div ");
    stack1 = depth0;
    stack2 = "taskInfo";
    stack3 = depth0;
    stack4 = "toggleTaskLog";
    stack5 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack5.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"task-list-line-cursor\">\n        <i ");
    stack1 = {};
    stack2 = "taskInfo.status taskInfo.icon";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + "></i>\n        <a href=\"#\" class=\"\" >\n          ");
    stack1 = depth0;
    stack2 = "taskInfo.role";
    stack3 = {};
    stack4 = "true";
    stack3['unescaped'] = stack4;
    stack4 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push(" ");
    stack1 = depth0;
    stack2 = "taskInfo.command";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n        </a>\n        <div class=\"show-details\"><i class=\"icon-caret-right\"></i></div>\n      </div>\n    </div>\n    ");
    return buffer;}

  function program3(depth0,data) {
    
    var buffer = '', stack1, stack2, stack3;
    data.buffer.push("\n      <div class=\"log-list-wrap\">");
    stack1 = depth0;
    stack2 = "installer.step9.hostLog.popup.noTasksToShow";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</div>\n    ");
    return buffer;}

    data.buffer.push("\n<div ");
    stack1 = {};
    stack2 = "view.isLogWrapHidden::hidden :task-list-main-warp";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n  <div class=\"task-top-wrap\">\n     ");
    stack1 = depth0;
    stack2 = "common.tasks";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "\n    <div class=\"select-wrap\">\n      ");
    stack1 = depth0;
    stack2 = "common.show";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + ":\n      ");
    stack1 = depth0;
    stack2 = "Ember.Select";
    stack3 = {};
    stack4 = "view.categories";
    stack3['contentBinding'] = stack4;
    stack4 = "content.value";
    stack3['optionValuePath'] = stack4;
    stack4 = "content.label";
    stack3['optionLabelPath'] = stack4;
    stack4 = "view.category";
    stack3['selectionBinding'] = stack4;
    stack4 = helpers.view;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "\n    </div>\n  </div>\n  <div id=\"host-log\">\n    ");
    stack1 = depth0;
    stack2 = "view.tasks";
    stack3 = depth0;
    stack4 = "in";
    stack5 = depth0;
    stack6 = "taskInfo";
    stack7 = helpers.each;
    tmp1 = self.program(1, program1, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack5);
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack7.call(depth0, stack6, stack4, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n    ");
    stack1 = depth0;
    stack2 = "view.isEmptyList";
    stack3 = helpers['if'];
    tmp1 = self.program(3, program3, data);
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.fn = tmp1;
    tmp1.inverse = self.noop;
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push("\n  </div>\n</div>\n\n<div ");
    stack1 = {};
    stack2 = "view.isLogWrapHidden:hidden :task-detail-info";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + ">\n  <div class=\"task-top-wrap\">\n    <a class=\"task-detail-back\" href=\"javascript:void(null)\" ");
    stack1 = depth0;
    stack2 = "backToTaskList";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " ><i class=\"icon-arrow-left\"></i>&nbsp;");
    stack1 = depth0;
    stack2 = "common.tasks";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n    <div>\n      <!--<img src=\"data:image/png;base64,R0lGODlhFAAUAIAAAP///wAAACH5BAEAAAAALAAAAAAUABQAAAIRhI+py+0Po5y02ouz3rz7rxUAOw==\" class=\"task-detail-status-ico\" />-->\n      <i ");
    stack1 = {};
    stack2 = "view.openedTask.status :task-detail-status-ico view.openedTask.icon";
    stack1['class'] = stack2;
    stack2 = helpers.bindAttr;
    tmp1 = {};
    tmp1.hash = stack1;
    tmp1.contexts = [];
    tmp1.data = data;
    stack1 = stack2.call(depth0, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"task-detail-status-ico\"></i>\n      <span class=\"task-detail-log-rolename\" >");
    stack1 = depth0;
    stack2 = "view.openedTask.role";
    stack3 = {};
    stack4 = "true";
    stack3['unescaped'] = stack4;
    stack4 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = stack3;
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack4.call(depth0, stack2, tmp1);
    if(stack1 || stack1 === 0) { data.buffer.push(stack1); }
    data.buffer.push(" ");
    stack1 = depth0;
    stack2 = "view.openedTask.command";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</span>\n    </div>\n    <div class=\"task-detail-ico-wrap\">\n      <a title=\"Click to Copy\" ");
    stack1 = depth0;
    stack2 = "taskInfo";
    stack3 = depth0;
    stack4 = "textTrigger";
    stack5 = {};
    stack6 = "view";
    stack5['target'] = stack6;
    stack6 = helpers.action;
    tmp1 = {};
    tmp1.hash = stack5;
    tmp1.contexts = [];
    tmp1.contexts.push(stack3);
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack6.call(depth0, stack4, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"task-detail-copy\"><i class=\"icon-copy\"></i> ");
    stack1 = depth0;
    stack2 = "common.copy";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n      <a title=\"Open in New Window\" ");
    stack1 = depth0;
    stack2 = "openTaskLogInDialog";
    stack3 = helpers.action;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + " class=\"task-detail-open-dialog\"><i class=\"icon-external-link\"></i> ");
    stack1 = depth0;
    stack2 = "common.open";
    foundHelper = helpers['t'];
    stack3 = foundHelper || depth0['t'];
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    if(typeof stack3 === functionType) { stack1 = stack3.call(depth0, stack2, tmp1); }
    else if(stack3=== undef) { stack1 = helperMissing.call(depth0, "t", stack2, tmp1); }
    else { stack1 = stack3; }
    data.buffer.push(escapeExpression(stack1) + "</a>\n    </div>\n  </div>\n  <div class=\"task-detail-log-info\">\n    <div class=\"content-area\" >\n      <div class=\"task-detail-log-clipboard-wrap\" ></div>\n      <div class=\"task-detail-log-maintext\">\n        <h5>stderr:</h5>\n        <pre class=\"stderr\">");
    stack1 = depth0;
    stack2 = "view.openedTask.stderr";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</pre>\n        <h5>stdout:</h5>\n        <pre class=\"stdout\">");
    stack1 = depth0;
    stack2 = "view.openedTask.stdout";
    stack3 = helpers._triageMustache;
    tmp1 = {};
    tmp1.hash = {};
    tmp1.contexts = [];
    tmp1.contexts.push(stack1);
    tmp1.data = data;
    stack1 = stack3.call(depth0, stack2, tmp1);
    data.buffer.push(escapeExpression(stack1) + "</pre>\n      </div>\n    </div>\n  </div>\n</div>");
    return buffer;
  });
  module.exports = module.id;
});
window.require.register("utils/ajax", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var App = require('app');

  /**
   * Config for each ajax-request
   *
   * Fields example:
   *  mock - testMode url
   *  real - real url (without API prefix)
   *  type - request type (also may be defined in the format method)
   *  format - function for processing ajax params after default formatRequest. Return ajax-params object
   *  testInProduction - can this request be executed on production tests (used only in tests)
   *
   * @type {Object}
   */
  var urls = {
    'background_operations': {
      'real': '/clusters/{clusterName}/requests/?fields=tasks/*',
      'mock': '/data/background_operations/list_on_start.json',
      'testInProduction': true
    },
    'background_operations.update_task': {
      'real': '/clusters/{clusterName}/requests/{requestId}/tasks/{taskId}',
      'mock': '/data/background_operations/one_task.json',
      'testInProduction': true
    },
    'background_operations.get_most_recent': {
      'real': '/clusters/{clusterName}/requests?to=end&page_size=10&fields=*,tasks/Tasks/*',
      'mock': '/data/background_operations/list_on_start.json',
      'testInProduction': true
    },
    'service.item.start_stop': {
      'real': '/clusters/{clusterName}/services/{serviceName}?params/run_smoke_test=true',
      'mock': '/data/wizard/deploy/poll_1.json',
      'format': function (data, opt) {
        return {
          type: 'PUT',
          data: JSON.stringify({
            RequestInfo: {
              "context": data.requestInfo
            },
            Body: {
              ServiceInfo: {
                state: data.state
              }
            }
          })
        };
      }
    },
    'service.item.smoke': {
      'real': '/clusters/{clusterName}/services/{serviceName}/actions/{actionName}',
      'mock': '/data/wizard/deploy/poll_1.json',
      'format': function (data) {
        return {
          'type': 'POST',
          data: JSON.stringify({
            RequestInfo: {
              "context": data.displayName + " Smoke Test"
            }
          })
        };
      }
    },
    'reassign.stop_service': {
      'mock': '/data/wizard/reassign/request_id.json',
      'real': '/clusters/{clusterName}/services/{serviceName}',
      'type': 'PUT',
      'format': function (data) {
        return {
          data: JSON.stringify({
            RequestInfo: {
              "context": "Stop service " + data.displayName
            },
            Body: {
              ServiceInfo: {
                "state": "INSTALLED"
              }
            }
          })
        }
      }
    },
    'reassign.create_master': {
      'real': '/clusters/{clusterName}/hosts?Hosts/host_name={hostName}',
      'type': 'POST',
      'format': function (data) {
        return {
          data: JSON.stringify({
            "host_components": [
              {
                "HostRoles": {
                  "component_name": data.componentName
                }
              }
            ]
          })
        }
      }
    },
    'reassign.maintenance_mode': {
      'real': '/clusters/{clusterName}/hosts/{hostName}/host_components/{componentName}',
      'type': 'PUT',
      'format': function () {
        return {
          data: JSON.stringify(
            {
              "HostRoles": {
                "state": "MAINTENANCE"
              }
            }
          )
        }
      }
    },
    'reassign.install_component': {
      'mock': '/data/wizard/reassign/request_id.json',
      'real': '/clusters/{clusterName}/hosts/{hostName}/host_components/{componentName}',
      'type': 'PUT',
      'format': function (data) {
        return {
          data: JSON.stringify({
            RequestInfo: {
              "context": "Install " + data.displayName
            },
            Body: {
              "HostRoles": {
                "state": "INSTALLED"
              }
            }
          })
        }
      }
    },
    'reassign.start_components': {
      'mock': '/data/wizard/reassign/request_id.json',
      'real': '/clusters/{clusterName}/services/{serviceName}',
      'type': 'PUT',
      'format': function (data) {
        return {
          data: JSON.stringify({
            RequestInfo: {
              "context": "Start service " + data.displayName
            },
            Body: {
              ServiceInfo: {
                "state": "STARTED"
              }
            }
          })
        }
      }
    },
    'reassign.remove_component': {
      'real': '/clusters/{clusterName}/hosts/{hostName}/host_components/{componentName}',
      'type': 'DELETE'
    },
    'reassign.get_logs': {
      'real': '/clusters/{clusterName}/requests/{requestId}?fields=tasks/*',
      'mock': '/data/wizard/reassign/step14PolledData/tasks_poll{pollCounter}.json',
      'type': 'GET'

    },
    'reassign.create_configs': {
      'real': '/clusters/{clusterName}/configurations',
      'type': 'POST',
      'format': function (data) {
        return {
          data: JSON.stringify(data.configs),
          configs: data.configs
        }
      }
    },
    'reassign.check_configs': {
      'real': '/clusters/{clusterName}/services/{serviceName}',
      'type': 'GET'
    },
    'reassign.apply_configs': {
      'real': '/clusters/{clusterName}/services/{serviceName}',
      'type': 'PUT',
      'format': function (data) {
        return {
          data: JSON.stringify(data.configs)
        }
      }
    },
    'config.advanced': {
      'real': '{stack2VersionUrl}/stackServices/{serviceName}/configurations?fields=*',
      'mock': '/data/wizard/stack/hdp/version{stackVersion}/{serviceName}.json',
      'format': function (data) {
        return {
          async: false
        };
      }
    },
    'config.advanced.global': {
      'real': '{stack2VersionUrl}/stackServices?fields=configurations/StackConfigurations/type',
      'mock': '/data/wizard/stack/hdp/version1.3.0/global.json',
      'format': function (data) {
        return {
          async: false
        };
      }
    },
    'config.tags': {
      'real': '/clusters/{clusterName}',
      'mock': '/data/clusters/cluster.json'
    },
    'config.on_site': {
      'real': '/clusters/{clusterName}/configurations?{params}',
      'mock': '/data/configurations/cluster_level_configs.json?{params}',
      'format': function (data) {
        return {
          async: false
        };
      }
    },
    'config.host_overrides': {
      'real': '/clusters/{clusterName}/configurations?{params}',
      'mock': '/data/configurations/host_level_overrides_configs.json?{params}',
      'format': function (data) {
        return {
          async: false
        };
      }
    },
    'service.metrics.flume.channel_fill_percent': {
      'real': '/clusters/{clusterName}/services/FLUME/components/FLUME_SERVER?fields=host_components/metrics/flume/flume/CHANNEL/*/ChannelFillPercentage[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/flume/channelFillPct.json',
      'testInProduction': true
    },
    'service.metrics.flume.channel_size': {
      'real': '/clusters/{clusterName}/services/FLUME/components/FLUME_SERVER?fields=host_components/metrics/flume/flume/CHANNEL/*/ChannelSize[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/flume/channelSize.json',
      'testInProduction': true
    },
    'service.metrics.flume.sink_drain_success': {
      'real': '/clusters/{clusterName}/services/FLUME/components/FLUME_SERVER?fields=host_components/metrics/flume/flume/SINK/*/EventDrainSuccessCount[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/flume/sinkDrainSuccessCount.json',
      'testInProduction': true
    },
    'service.metrics.flume.sink_connection_failed': {
      'real': '/clusters/{clusterName}/services/FLUME/components/FLUME_SERVER?fields=host_components/metrics/flume/flume/SINK/*/ConnectionFailedCount[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/flume/sinkConnectionFailedCount.json',
      'testInProduction': true
    },
    'service.metrics.flume.gc': {
      'real': '/clusters/{clusterName}/services/FLUME/components/FLUME_SERVER?fields=host_components/metrics/jvm/gcTimeMillis[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/flume/jvmGcTime.json',
      'testInProduction': true
    },
    'service.metrics.flume.jvm_heap_used': {
      'real': '/clusters/{clusterName}/services/FLUME/components/FLUME_SERVER?fields=host_components/metrics/jvm/memHeapUsedM[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/flume/jvmMemHeapUsedM.json',
      'testInProduction': true
    },
    'service.metrics.flume.jvm_threads_runnable': {
      'real': '/clusters/{clusterName}/services/FLUME/components/FLUME_SERVER?fields=host_components/metrics/jvm/threadsRunnable[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/flume/jvmThreadsRunnable.json',
      'testInProduction': true
    },
    'service.metrics.flume.cpu_user': {
      'real': '/clusters/{clusterName}/services/FLUME/components/FLUME_SERVER?fields=host_components/metrics/cpu/cpu_user[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '',
      'testInProduction': true
    },
    'service.metrics.flume.source_accepted': {
      'real': '/clusters/{clusterName}/services/FLUME/components/FLUME_SERVER?fields=host_components/metrics/flume/flume/SOURCE/*/EventAcceptedCount[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/flume/sourceEventAccepted.json',
      'testInProduction': true
    },
    'service.metrics.hbase.cluster_requests': {
      'real': '/clusters/{clusterName}/services/HBASE/components/HBASE_MASTER?fields=metrics/hbase/master/cluster_requests[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/hbase/cluster_requests.json',
      'testInProduction': true
    },
    'service.metrics.hbase.hlog_split_size': {
      'real': '/clusters/{clusterName}/services/HBASE/components/HBASE_MASTER?fields=metrics/hbase/master/splitSize_avg_time[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/hbase/hlog_split_size.json',
      'testInProduction': true
    },
    'service.metrics.hbase.hlog_split_time': {
      'real': '/clusters/{clusterName}/services/HBASE/components/HBASE_MASTER?fields=metrics/hbase/master/splitTime_avg_time[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/hbase/hlog_split_time.json',
      'testInProduction': true
    },
    'service.metrics.hbase.regionserver_queuesize': {
      'real': '/clusters/{clusterName}/services/HBASE/components/HBASE_REGIONSERVER?fields=metrics/hbase/regionserver/flushQueueSize[{fromSeconds},{toSeconds},{stepSeconds}],metrics/hbase/regionserver/compactionQueueSize[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/hbase/regionserver_queuesize.json',
      'testInProduction': true
    },
    'service.metrics.hbase.regionserver_regions': {
      'real': '/clusters/{clusterName}/services/HBASE/components/HBASE_REGIONSERVER?fields=metrics/hbase/regionserver/regions[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/hbase/regionserver_regions.json',
      'testInProduction': true
    },
    'service.metrics.hbase.regionserver_rw_requests': {
      'real': '/clusters/{clusterName}/services/HBASE/components/HBASE_REGIONSERVER?fields=metrics/hbase/regionserver/readRequestsCount[{fromSeconds},{toSeconds},{stepSeconds}],metrics/hbase/regionserver/writeRequestsCount[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/hbase/regionserver_rw_requests.json',
      'testInProduction': true
    },
    'service.metrics.mapreduce.gc': {
      'real': '/clusters/{clusterName}/hosts/{jobTrackerNode}/host_components/JOBTRACKER?fields=metrics/jvm/gcTimeMillis[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/mapreduce/gc.json',
      'testInProduction': true
    },
    'service.metrics.mapreduce.jobs_status': {
      'real': '/clusters/{clusterName}/services/MAPREDUCE/components/JOBTRACKER?fields=metrics/mapred/jobtracker/jobs_completed[{fromSeconds},{toSeconds},{stepSeconds}],metrics/mapred/jobtracker/jobs_preparing[{fromSeconds},{toSeconds},{stepSeconds}],metrics/mapred/jobtracker/jobs_failed[{fromSeconds},{toSeconds},{stepSeconds}],metrics/mapred/jobtracker/jobs_submitted[{fromSeconds},{toSeconds},{stepSeconds}],metrics/mapred/jobtracker/jobs_failed[{fromSeconds},{toSeconds},{stepSeconds}],metrics/mapred/jobtracker/jobs_running[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/mapreduce/jobs_status.json',
      'testInProduction': true
    },
    'service.metrics.mapreduce.jobs_heap': {
      'real': '/clusters/{clusterName}/hosts/{jobTrackerNode}/host_components/JOBTRACKER?fields=metrics/jvm/memNonHeapUsedM[{fromSeconds},{toSeconds},{stepSeconds}],metrics/jvm/memNonHeapCommittedM[{fromSeconds},{toSeconds},{stepSeconds}],metrics/jvm/memHeapUsedM[{fromSeconds},{toSeconds},{stepSeconds}],metrics/jvm/memHeapCommittedM[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/mapreduce/jvm_heap.json',
      'testInProduction': true
    },
    'service.metrics.mapreduce.jobs_threads': {
      'real': '/clusters/{clusterName}/hosts/{jobTrackerNode}/host_components/JOBTRACKER?fields=metrics/jvm/threadsRunnable[{fromSeconds},{toSeconds},{stepSeconds}],metrics/jvm/threadsBlocked[{fromSeconds},{toSeconds},{stepSeconds}],metrics/jvm/threadsWaiting[{fromSeconds},{toSeconds},{stepSeconds}],metrics/jvm/threadsTimedWaiting[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/mapreduce/jvm_threads.json',
      'testInProduction': true
    },
    'service.metrics.mapreduce.map_slots': {
      'real': '/clusters/{clusterName}/services/MAPREDUCE/components/JOBTRACKER?fields=metrics/mapred/jobtracker/occupied_map_slots[{fromSeconds},{toSeconds},{stepSeconds}],metrics/mapred/jobtracker/reserved_map_slots[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/mapreduce/map_slots.json',
      'testInProduction': true
    },
    'service.metrics.mapreduce.reduce_slots': {
      'real': '/clusters/{clusterName}/services/MAPREDUCE/components/JOBTRACKER?fields=metrics/mapred/jobtracker/occupied_reduce_slots[{fromSeconds},{toSeconds},{stepSeconds}],metrics/mapred/jobtracker/reserved_reduce_slots[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/mapreduce/reduce_slots.json',
      'testInProduction': true
    },
    'service.metrics.mapreduce.rpc': {
      'real': '/clusters/{clusterName}/hosts/{jobTrackerNode}/host_components/JOBTRACKER?fields=metrics/rpc/RpcQueueTime_avg_time[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/mapreduce/rpc.json',
      'testInProduction': true
    },
    'service.metrics.mapreduce.tasks_running_waiting': {
      'real': '/clusters/{clusterName}/services/MAPREDUCE/components/JOBTRACKER?fields=metrics/mapred/jobtracker/running_maps[{fromSeconds},{toSeconds},{stepSeconds}],metrics/mapred/jobtracker/running_reduces[{fromSeconds},{toSeconds},{stepSeconds}],metrics/mapred/jobtracker/waiting_maps[{fromSeconds},{toSeconds},{stepSeconds}],metrics/mapred/jobtracker/waiting_reduces[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/mapreduce/tasks_running_waiting.json',
      'testInProduction': true
    },
    'service.metrics.hdfs.block_status': {
      'real': '/clusters/{clusterName}/hosts/{nameNodeName}/host_components/NAMENODE?fields=metrics/dfs/FSNamesystem/PendingReplicationBlocks[{fromSeconds},{toSeconds},{stepSeconds}],metrics/dfs/FSNamesystem/UnderReplicatedBlocks[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/hdfs/block_status.json',
      'testInProduction': true
    },
    'service.metrics.hdfs.file_operations': {
      'real': '/clusters/{clusterName}/hosts/{nameNodeName}/host_components/NAMENODE?fields=metrics/dfs/namenode/FileInfoOps[{fromSeconds},{toSeconds},{stepSeconds}],metrics/dfs/namenode/CreateFileOps[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/hdfs/file_operations.json',
      'testInProduction': true
    },
    'service.metrics.hdfs.gc': {
      'real': '/clusters/{clusterName}/hosts/{nameNodeName}/host_components/NAMENODE?fields=metrics/jvm/gcTimeMillis[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/hdfs/gc.json',
      'testInProduction': true
    },
    'service.metrics.hdfs.io': {
      'real': '/clusters/{clusterName}/services/HDFS/components/DATANODE?fields=metrics/dfs/datanode/bytes_written[{fromSeconds},{toSeconds},{stepSeconds}],metrics/dfs/datanode/bytes_read[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/hdfs/io.json',
      'testInProduction': true
    },
    'service.metrics.hdfs.jvm_heap': {
      'real': '/clusters/{clusterName}/hosts/{nameNodeName}/host_components/NAMENODE?fields=metrics/jvm/memNonHeapUsedM[{fromSeconds},{toSeconds},{stepSeconds}],metrics/jvm/memNonHeapCommittedM[{fromSeconds},{toSeconds},{stepSeconds}],metrics/jvm/memHeapUsedM[{fromSeconds},{toSeconds},{stepSeconds}],metrics/jvm/memHeapCommittedM[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/hdfs/jvm_heap.json',
      'testInProduction': true
    },
    'service.metrics.hdfs.jvm_threads': {
      'real': '/clusters/{clusterName}/hosts/{nameNodeName}/host_components/NAMENODE?fields=metrics/jvm/threadsRunnable[{fromSeconds},{toSeconds},{stepSeconds}],metrics/jvm/threadsBlocked[{fromSeconds},{toSeconds},{stepSeconds}],metrics/jvm/threadsWaiting[{fromSeconds},{toSeconds},{stepSeconds}],metrics/jvm/threadsTimedWaiting[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/hdfs/jvm_threads.json',
      'testInProduction': true
    },
    'service.metrics.hdfs.rpc': {
      'real': '/clusters/{clusterName}/hosts/{nameNodeName}/host_components/NAMENODE?fields=metrics/rpc/RpcQueueTime_avg_time[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/hdfs/rpc.json',
      'testInProduction': true
    },
    'service.metrics.hdfs.space_utilization': {
      'real': '/clusters/{clusterName}/hosts/{nameNodeName}/host_components/NAMENODE?fields=metrics/dfs/FSNamesystem/CapacityRemainingGB[{fromSeconds},{toSeconds},{stepSeconds}],metrics/dfs/FSNamesystem/CapacityUsedGB[{fromSeconds},{toSeconds},{stepSeconds}],metrics/dfs/FSNamesystem/CapacityTotalGB[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/services/metrics/hdfs/space_utilization.json',
      'testInProduction': true
    },
    'service.start_stop': {
      'real': '/clusters/{clusterName}/services?ServiceInfo',
      'mock': '/data/mirroring/poll/poll_6.json',
      'format': function (data, opt) {
        return {
          type: 'PUT',
          async: false,
          data: data.data
        };
      }
    },
    'dashboard.cluster_metrics.cpu': {
      'real': '/clusters/{clusterName}/?fields=metrics/cpu[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/cluster_metrics/cpu_1hr.json',
      'testInProduction': true
    },
    'dashboard.cluster_metrics.load': {
      'real': '/clusters/{clusterName}/?fields=metrics/load[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/cluster_metrics/load_1hr.json',
      'testInProduction': true
    },
    'dashboard.cluster_metrics.memory': {
      'real': '/clusters/{clusterName}/?fields=metrics/memory[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/cluster_metrics/memory_1hr.json',
      'testInProduction': true
    },
    'dashboard.cluster_metrics.network': {
      'real': '/clusters/{clusterName}/?fields=metrics/network[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/cluster_metrics/network_1hr.json',
      'testInProduction': true
    },
    'host.metrics.cpu': {
      'real': '/clusters/{clusterName}/hosts/{hostName}?fields=metrics/cpu/cpu_user[{fromSeconds},{toSeconds},{stepSeconds}],metrics/cpu/cpu_wio[{fromSeconds},{toSeconds},{stepSeconds}],metrics/cpu/cpu_nice[{fromSeconds},{toSeconds},{stepSeconds}],metrics/cpu/cpu_aidle[{fromSeconds},{toSeconds},{stepSeconds}],metrics/cpu/cpu_system[{fromSeconds},{toSeconds},{stepSeconds}],metrics/cpu/cpu_idle[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/hosts/metrics/cpu.json',
      'testInProduction': true
    },
    'host.metrics.disk': {
      'real': '/clusters/{clusterName}/hosts/{hostName}?fields=metrics/disk/disk_total[{fromSeconds},{toSeconds},{stepSeconds}],metrics/disk/disk_free[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/hosts/metrics/disk.json',
      'testInProduction': true
    },
    'host.metrics.load': {
      'real': '/clusters/{clusterName}/hosts/{hostName}?fields=metrics/load/load_fifteen[{fromSeconds},{toSeconds},{stepSeconds}],metrics/load/load_one[{fromSeconds},{toSeconds},{stepSeconds}],metrics/load/load_five[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/hosts/metrics/load.json',
      'testInProduction': true
    },
    'host.metrics.memory': {
      'real': '/clusters/{clusterName}/hosts/{hostName}?fields=metrics/memory/swap_free[{fromSeconds},{toSeconds},{stepSeconds}],metrics/memory/mem_shared[{fromSeconds},{toSeconds},{stepSeconds}],metrics/memory/mem_free[{fromSeconds},{toSeconds},{stepSeconds}],metrics/memory/mem_cached[{fromSeconds},{toSeconds},{stepSeconds}],metrics/memory/mem_buffers[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/hosts/metrics/memory.json',
      'testInProduction': true
    },
    'host.metrics.network': {
      'real': '/clusters/{clusterName}/hosts/{hostName}?fields=metrics/network/bytes_in[{fromSeconds},{toSeconds},{stepSeconds}],metrics/network/bytes_out[{fromSeconds},{toSeconds},{stepSeconds}],metrics/network/pkts_in[{fromSeconds},{toSeconds},{stepSeconds}],metrics/network/pkts_out[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/hosts/metrics/network.json',
      'testInProduction': true
    },
    'host.metrics.processes': {
      'real': '/clusters/{clusterName}/hosts/{hostName}?fields=metrics/process/proc_total[{fromSeconds},{toSeconds},{stepSeconds}],metrics/process/proc_run[{fromSeconds},{toSeconds},{stepSeconds}]',
      'mock': '/data/hosts/metrics/processes.json',
      'testInProduction': true
    },
    'host.service_config_hosts_overrides': {
      'real': '/clusters/{clusterName}/configurations?{urlParams}',
      'format': function (data, opt) {
        return {
          async: false,
          timeout: 10000
        };
      }
    },
    'admin.service_config': {
      'real': '/clusters/{clusterName}/configurations/?type={siteName}&tag={tagName}',
      'format': function (data, opt) {
        return {
          timeout: 10000,
          async: false
        };
      }
    },
    'admin.security_status': {
      'real': '/clusters/{clusterName}',
      'format': function (data, opt) {
        return {
          async: false,
          timeout: 10000
        };
      }
    },
    'cluster.load_cluster_name': {
      'real': '/clusters',
      'mock': '/data/clusters/info.json',
      'format': function (data, opt) {
        return {
          async: false
        };
      }
    },
    'cluster.update_upgrade_version': {
      'real': '/stacks2/HDP/versions?fields=stackServices/StackServices,Versions',
      'mock': '/data/wizard/stack/stacks.json',
      'format': function (data, opt) {
        return {
          async: false
        };
      }
    },
    'admin.security.cluster_configs': {
      'real': '/clusters/{clusterName}',
      'format': function (data, opt) {
        return {
          timeout: 10000
        };
      }
    },
    'admin.security.all_configurations': {
      'real': '/clusters/{clusterName}/configurations?{urlParams}',
      'format': function (data, opt) {
        return {
          timeout: 10000
        };
      }
    },
    'admin.security.apply_configuration': {
      'real': '/clusters/{clusterName}',
      'format': function (data, opt) {
        return {
          type: 'PUT',
          async: false,
          timeout: 5000,
          data: JSON.stringify(data.clusterData)
        };
      }
    },
    'admin.security.add.cluster_configs': {
      'real': '/clusters/{clusterName}',
      'format': function (data, opt) {
        return {
          timeout: 10000
        };
      }
    },
    'admin.stack_upgrade.run_upgrade': {
      'real': '/clusters/{clusterName}',
      'format': function (data, opt) {
        return {
          type: 'PUT',
          async: false,
          data: data.data
        };
      }
    },
    'admin.stack_upgrade.stop_services': {
      'real': '/clusters/{clusterName}/services?ServiceInfo/state=STARTED',
      'format': function (data, opt) {
        return {
          type: 'PUT',
          async: false,
          data: data.data
        };
      }
    },
    'admin.stack_upgrade.do_poll': {
      'real': '/clusters/{cluster}/requests/{requestId}?fields=tasks/*',
      'mock': '/data/wizard/{mock}'
    },
    'wizard.install_services.add_host_controller.is_retry': {
      'real': '/clusters/{cluster}/host_components',
      'format': function (data, opt) {
        return {
          type: 'PUT',
          async: false,
          data: data.data
        };
      }
    },
    'wizard.install_services.add_host_controller.not_is_retry': {
      'real': '/clusters/{cluster}/host_components',
      'format': function (data, opt) {
        return {
          type: 'PUT',
          async: false,
          data: data.data
        };
      }
    },
    'wizard.install_services.installer_controller.is_retry': {
      'real': '/clusters/{cluster}/host_components?HostRoles/state=INSTALLED',
      'mock': '/data/wizard/deploy/2_hosts/poll_1.json',
      'type': 'PUT',
      'format': function (data, opt) {
        return {
          async: false,
          data: data.data
        };
      }
    },
    'wizard.install_services.installer_controller.not_is_retry': {
      'real': '/clusters/{cluster}/services?ServiceInfo/state=INIT',
      'mock': '/data/wizard/deploy/2_hosts/poll_1.json',
      'type': 'PUT',
      'format': function (data, opt) {
        return {
          async: false,
          data: data.data
        };
      }
    },
    'wizard.service_components': {
      'real': '{stackUrl}/stackServices?fields=StackServices',
      'mock': '/data/wizard/stack/hdp/version/{stackVersion}.json',
      'format': function (data, opt) {
        return {
          timeout: 10000,
          async: false
        };
      }
    },
    'wizard.step9.installer.launch_start_services': {
      'real': '/clusters/{cluster}/services?ServiceInfo/state=INSTALLED&params/run_smoke_test=true&params/reconfigure_client=false',
      'mock': '/data/wizard/deploy/5_hosts/poll_6.json',
      'format': function (data, opt) {
        var data = {
          type: 'PUT',
          async: false,
          data: data.data
        };
        if (App.testMode) {
          data.type = 'GET';
        }
        return data;
      }
    },
    'wizard.step9.add_host.launch_start_services': {
      'real': '/clusters/{cluster}/host_components',
      'mock': '/data/wizard/deploy/5_hosts/poll_6.json',
      'format': function (data, opt) {
        return {
          type: 'PUT',
          async: false,
          data: data.data
        };
      }
    },
    'wizard.step8.delete_cluster': {
      'real': '/clusters/{name}',
      'format': function (data, opt) {
        return {
          type: 'DELETE',
          async: false
        };
      }
    },
    'wizard.step8.existing_cluster_names': {
      'real': '/clusters',
      'format': function (data, opt) {
        return {
          async: false
        };
      }
    },
    'wizard.step3.host_info': {
      'real': '/hosts?fields=Hosts/total_mem,Hosts/cpu_count,Hosts/disk_info,Hosts/last_agent_env,Hosts/host_name',
      'mock': '/data/wizard/bootstrap/two_hosts_information.json',
      'format': function (data, opt) {
        return {
          contentType: 'application/json'
        };
      }
    },
    'wizard.step3.rerun_checks': {
      'real': '/hosts?fields=Hosts/last_agent_env',
      'mock': '/data/wizard/bootstrap/two_hosts_information.json',
      'format': function (data, opt) {
        return {
          contentType: 'application/json'
        };
      }
    },
    'wizard.step3.bootstrap': {
      'real': '/bootstrap/{bootRequestId}',
      'mock': '/data/wizard/bootstrap/poll_{numPolls}.json'
    },
    'wizard.step3.is_hosts_registered': {
      'real': '/hosts',
      'mock': '/data/wizard/bootstrap/single_host_registration.json'
    },
    'wizard.stacks': {
      'real': '/stacks2',
      'mock': '/data/wizard/stack/stacks2.json',
      'format': function (data) {
        return {
          async: false
        };
      }
    },
    'wizard.stacks_versions': {
      'real': '/stacks2/{stackName}/versions?fields=Versions,operatingSystems/repositories/Repositories',
      'mock': '/data/wizard/stack/{stackName}_versions.json',
      'format': function (data) {
        return {
          async: false
        };
      }
    },
    'wizard.launch_bootstrap': {
      'real': '/bootstrap',
      'mock': '/data/wizard/bootstrap/bootstrap.json',
      'type': 'POST',
      'format': function (data) {
        return {
          async: false,
          contentType: 'application/json',
          data: data.bootStrapData
        }
      }
    },
    'router.login': {
      'real': '/users/{loginName}',
      'mock': '/data/users/user_{usr}.json',
      'format': function (data, opt) {
        var statusCode = jQuery.extend({}, require('data/statusCodes'));
        statusCode['403'] = function () {
          console.log("Error code 403: Forbidden.");
        }
        return {
          statusCode: statusCode
        };
      }
    },
    'router.login2': {
      'real': '/clusters',
      'mock': '/data/clusters/info.json'
    },
    'router.logoff': {
      'real': '/logout'
    },
    'router.set_ambari_stacks': {
      'real': '/stacks',
      'mock': '/data/wizard/stack/stacks.json',
      'format': function (data, opt) {
        return {
          async: false
        };
      }
    },
    'router.authentication': {
      'real': '/clusters',
      'mock': '/data/clusters/info.json',
      'format': function (data, opt) {
        return {
          async: false
        };
      }
    }
  };
  /**
   * Replace data-placeholders to its values
   *
   * @param {String} url
   * @param {Object} data
   * @return {String}
   */
  var formatUrl = function (url, data) {
    var keys = url.match(/\{\w+\}/g);
    keys = (keys === null) ? [] : keys;
    if (keys) {
      keys.forEach(function (key) {
        var raw_key = key.substr(1, key.length - 2);
        var replace;
        if (!data[raw_key]) {
          replace = '';
        }
        else {
          replace = data[raw_key];
        }
        url = url.replace(new RegExp(key, 'g'), replace);
      });
    }
    return url;
  };

  /**
   * this = object from config
   * @return {Object}
   */
  var formatRequest = function (data) {
    var opt = {
      type: this.type || 'GET',
      timeout: App.timeout,
      dataType: 'json',
      statusCode: require('data/statusCodes')
    };
    if (App.testMode) {
      opt.url = formatUrl(this.mock, data);
      opt.type = 'GET';
    }
    else {
      opt.url = App.apiPrefix + formatUrl(this.real, data);
    }

    if (this.format) {
      jQuery.extend(opt, this.format(data, opt));
    }
    return opt;
  };

  /**
   * Wrapper for all ajax requests
   *
   * @type {Object}
   */
  App.ajax = {
    /**
     * Send ajax request
     *
     * @param {Object} config
     * @return Object jquery ajax object
     *
     * config fields:
     *  name - url-key in the urls-object *required*
     *  sender - object that send request (need for proper callback initialization) *required*
     *  data - object with data for url-format
     *  beforeSend - method-name for ajax beforeSend response callback
     *  success - method-name for ajax success response callback
     *  error - method-name for ajax error response callback
     *  callback - callback from <code>App.updater.run</code> library
     */
    send: function (config) {

      console.warn('============== ajax ==============', config.name, config.data);

      if (!config.sender) {
        console.warn('Ajax sender should be defined!');
        return null;
      }

      // default parameters
      var params = {
        clusterName: App.get('clusterName')
      };

      // extend default parameters with provided
      if (config.data) {
        jQuery.extend(params, config.data);
      }

      var opt = {};
      opt = formatRequest.call(urls[config.name], params);

      // object sender should be provided for processing beforeSend, success and error responses
      opt.beforeSend = function (xhr) {
        if (config.beforeSend) {
          config.sender[config.beforeSend](opt, xhr, params);
        }
      };
      opt.success = function (data) {
        console.log("TRACE: The url is: " + opt.url);
        if (config.success) {
          config.sender[config.success](data, opt, params);
        }
      };
      opt.error = function (request, ajaxOptions, error) {
        if (config.error) {
          config.sender[config.error](request, ajaxOptions, error, opt);
        }
      };
      opt.complete = function () {
        if (config.callback) {
          config.callback();
        }
      };
      if ($.mocho) {
        opt.url = 'http://' + $.hostName + opt.url;
      }
      return $.ajax(opt);
    }
  }
  
});
window.require.register("utils/base64", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  (function () {

    var
      object = typeof window != 'undefined' ? window : exports,
      chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
      INVALID_CHARACTER_ERR = (function () {
        // fabricate a suitable error object
        try {
          document.createElement('$');
        }
        catch (error) {
          return error;
        }
      }());

    // encoder
    // [https://gist.github.com/999166] by [https://github.com/nignag]
    object.btoa || (
      object.btoa = function (input) {
        for (
          // initialize result and counter
          var block, charCode, idx = 0, map = chars, output = '';
          // if the next input index does not exist:
          // change the mapping table to "="
          // check if d has no fractional digits
          input.charAt(idx | 0) || (map = '=', idx % 1);
          // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
          output += map.charAt(63 & block >> 8 - idx % 1 * 8)
          ) {
          charCode = input.charCodeAt(idx += 3 / 4);
          if (charCode > 0xFF) throw INVALID_CHARACTER_ERR;
          block = block << 8 | charCode;
        }
        return output;
      });

    // decoder
    // [https://gist.github.com/1020396] by [https://github.com/atk]
    object.atob || (
      object.atob = function (input) {
        input = input.replace(/=+$/, '')
        if (input.length % 4 == 1) throw INVALID_CHARACTER_ERR;
        for (
          // initialize result and counters
          var bc = 0, bs, buffer, idx = 0, output = '';
          // get next character
          buffer = input.charAt(idx++);
          // character found in table? initialize bit storage and add its ascii value;
          ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
            // and if not first of each 4 characters,
            // convert the first 8 bits to one ascii character
            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
          ) {
          // try to find character in table (0-63, not found => -1)
          buffer = chars.indexOf(buffer);
        }
        return output;
      });

  }());
});
window.require.register("utils/component", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Here will be stored slave functions related to components
   * @type {Object}
   */
  module.exports = {

    /**
     * Return list of installed components. Syntax is:
     *
     * [{
     *    id : 'DATANODE',
     *    displayName : 'DataNode',
     *    isMaster : true,
     *    isSlave : false,
     *    isClient : false
     * }]
     *
     */
    getInstalledComponents : function(){
      var components = App.HostComponent.find();
      var names = components.mapProperty('componentName').uniq();
      var result = [];

      names.forEach(function(componentName){
        var component = components.findProperty('componentName', componentName);
        result.push(Ember.Object.create({
          id: componentName,
          isMaster: component.get('isMaster'),
          isSlave: component.get('isSlave'),
          isClient: component.get('isClient'),
          displayName: component.get('displayName')
        }));
      });

      return result;
    }
  };
  
});
window.require.register("utils/config", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var stringUtils = require('utils/string_utils');

  var serviceComponents = {};
  var configGroupsByTag = [];
  var globalPropertyToServicesMap = null;

  App.config = Em.Object.create({

    preDefinedServiceConfigs: function(){
      var configs = this.get('preDefinedConfigProperties');
      var services = [];
      require('data/service_configs').forEach(function(service){
        service.configs = configs.filterProperty('serviceName', service.serviceName);
        services.push(service);
      });
      return services;
    }.property('preDefinedConfigProperties'),
    configMapping: function() {
        if (stringUtils.compareVersions(App.get('currentStackVersionNumber'), "2.0") === 1 ||
          stringUtils.compareVersions(App.get('currentStackVersionNumber'), "2.0") === 0) {
          return require('data/HDP2/config_mapping');
        }
      return require('data/config_mapping');
    }.property('App.currentStackVersionNumber'),
    preDefinedConfigProperties: function() {
      if (stringUtils.compareVersions(App.get('currentStackVersionNumber'), "2.0") === 1 ||
        stringUtils.compareVersions(App.get('currentStackVersionNumber'), "2.0") === 0) {
        return require('data/HDP2/config_properties').configProperties;
      }
      return require('data/config_properties').configProperties;
    }.property('App.currentStackVersionNumber'),
    preDefinedCustomConfigs: require('data/custom_configs'),
    //categories which contain custom configs
    categoriesWithCustom: ['CapacityScheduler'],
    //configs with these filenames go to appropriate category not in Advanced
    customFileNames: function() {
      if (App.supports.capacitySchedulerUi) {
        return ['capacity-scheduler.xml', 'mapred-queue-acls.xml'];
      } else {
        return [];
      }
    }.property(''),
    /**
     * Cache of loaded configurations. This is useful in not loading
     * same configuration multiple times. It is populated in multiple
     * places.
     *
     * Example:
     * {
     *  'global_version1': {...},
     *  'global_version2': {...},
     *  'hdfs-site_version3': {...},
     * }
     */
    loadedConfigurationsCache: {},

    /**
     * Array of global "service/desired_tag/actual_tag" strings which
     * indicate different configurations. We cache these so that 
     * we dont have to recalculate if two tags are difference.
     */
    differentGlobalTagsCache:[],
    
    identifyCategory: function(config){
      var category = null;
      var serviceConfigMetaData = this.get('preDefinedServiceConfigs').findProperty('serviceName', config.serviceName);
      if (serviceConfigMetaData) {
        serviceConfigMetaData.configCategories.forEach(function (_category) {
          if (_category.siteFileNames && Array.isArray(_category.siteFileNames) && _category.siteFileNames.contains(config.filename)) {
            category = _category;
          }
        });
        category = (category == null) ? serviceConfigMetaData.configCategories.findProperty('siteFileName', config.filename) : category;
      }
      return category;
    },
    /**
     * additional handling for special properties such as
     * checkbox and digital which values with 'm' at the end
     * @param config
     */
    handleSpecialProperties: function(config){
      if (config.displayType === 'int' && /\d+m$/.test(config.value)) {
        config.value = config.value.slice(0, config.value.length - 1);
        config.defaultValue = config.value;
      }
      if (config.displayType === 'checkbox') {
        config.value = (config.value === 'true') ? config.defaultValue = true : config.defaultValue = false;
      }
    },
    /**
     * calculate config properties:
     * category, filename, isRequired, isUserProperty
     * @param config
     * @param isAdvanced
     * @param advancedConfigs
     */
    calculateConfigProperties: function(config, isAdvanced, advancedConfigs){
      if (!isAdvanced || this.get('customFileNames').contains(config.filename)) {
        var categoryMetaData = this.identifyCategory(config);
        if (categoryMetaData != null) {
          config.category = categoryMetaData.get('name');
          if(!isAdvanced) config.isUserProperty = true;
        }
      } else {
        config.category = 'Advanced';
        config.filename = isAdvanced && advancedConfigs.findProperty('name', config.name).filename;
        config.isRequired = true;
      }
    },
    /**
     * return:
     *   configs,
     *   globalConfigs,
     *   mappingConfigs
     *
     * @param configGroups
     * @param advancedConfigs
     * @param tags
     * @param serviceName
     * @return {object}
     */
    mergePreDefinedWithLoaded: function (configGroups, advancedConfigs, tags, serviceName) {
      var configs = [];
      var globalConfigs = [];
      var preDefinedConfigs = this.get('preDefinedConfigProperties');
      var mappingConfigs = [];

      tags.forEach(function (_tag) {
        var isAdvanced = null;
        var properties = configGroups.filter(function (serviceConfigProperties) {
          return _tag.tagName === serviceConfigProperties.tag && _tag.siteName === serviceConfigProperties.type;
        });

        properties = (properties.length) ? properties.objectAt(0).properties : {};
        for (var index in properties) {
          var configsPropertyDef = preDefinedConfigs.findProperty('name', index) || null;
          var serviceConfigObj = App.ServiceConfig.create({
            name: index,
            value: properties[index],
            defaultValue: properties[index],
            filename: _tag.siteName + ".xml",
            isUserProperty: false,
            isOverridable: true,
            serviceName: serviceName,
            belongsToService: []
          });

          if (configsPropertyDef) {
            serviceConfigObj.displayType = configsPropertyDef.displayType;
            serviceConfigObj.isRequired = (configsPropertyDef.isRequired !== undefined) ? configsPropertyDef.isRequired : true;
            serviceConfigObj.isReconfigurable = (configsPropertyDef.isReconfigurable !== undefined) ? configsPropertyDef.isReconfigurable : true;
            serviceConfigObj.isVisible = (configsPropertyDef.isVisible !== undefined) ? configsPropertyDef.isVisible : true;
            serviceConfigObj.unit = (configsPropertyDef.unit !== undefined) ? configsPropertyDef.unit : undefined;
            serviceConfigObj.description = (configsPropertyDef.description !== undefined) ? configsPropertyDef.description : undefined;
            serviceConfigObj.isOverridable = configsPropertyDef.isOverridable === undefined ? true : configsPropertyDef.isOverridable;
            serviceConfigObj.serviceName = configsPropertyDef ? configsPropertyDef.serviceName : null;
            serviceConfigObj.index = configsPropertyDef.index;
            serviceConfigObj.isSecureConfig = configsPropertyDef.isSecureConfig === undefined ? false : configsPropertyDef.isSecureConfig;
            serviceConfigObj.belongsToService = configsPropertyDef.belongsToService;
          }
          // MAPREDUCE contains core-site properties but doesn't show them
          if(serviceConfigObj.serviceName === 'MAPREDUCE' && serviceConfigObj.filename === 'core-site.xml'){
            serviceConfigObj.isVisible = false;
          }
          if (_tag.siteName === 'global') {
            if (configsPropertyDef) {
              this.handleSpecialProperties(serviceConfigObj);
            } else {
              serviceConfigObj.isVisible = false;  // if the global property is not defined on ui metadata config_properties.js then it shouldn't be a part of errorCount
            }
            serviceConfigObj.id = 'puppet var';
            serviceConfigObj.displayName = configsPropertyDef ? configsPropertyDef.displayName : null;
            serviceConfigObj.category = configsPropertyDef ? configsPropertyDef.category : null;
            serviceConfigObj.options = configsPropertyDef ? configsPropertyDef.options : null;
            globalConfigs.push(serviceConfigObj);
          } else if (!this.get('configMapping').computed().someProperty('name', index)) {
            isAdvanced = advancedConfigs.someProperty('name', index);
            serviceConfigObj.id = 'site property';
            serviceConfigObj.displayType = stringUtils.isSingleLine(serviceConfigObj.value) ? 'advanced' : 'multiLine';
            serviceConfigObj.displayName = configsPropertyDef ? configsPropertyDef.displayName : index;
            this.calculateConfigProperties(serviceConfigObj, isAdvanced, advancedConfigs);
            configs.push(serviceConfigObj);
          } else {
            mappingConfigs.push(serviceConfigObj);
          }
        }
      }, this);
      return {
        configs: configs,
        globalConfigs: globalConfigs,
        mappingConfigs: mappingConfigs
      }
    },

    /**
     * merge stored configs with pre-defined
     * @param storedConfigs
     * @param advancedConfigs
     * @return {*}
     */
    mergePreDefinedWithStored: function (storedConfigs, advancedConfigs) {
      var mergedConfigs = [];
      var preDefinedConfigs = $.extend(true, [], this.get('preDefinedConfigProperties'));
      var preDefinedNames = [];
      var storedNames = [];
      var names = [];
      var categoryMetaData = null;
      storedConfigs = (storedConfigs) ? storedConfigs : [];

      preDefinedNames = this.get('preDefinedConfigProperties').mapProperty('name');
      storedNames = storedConfigs.mapProperty('name');
      names = preDefinedNames.concat(storedNames).uniq();
      names.forEach(function (name) {
        var stored = storedConfigs.findProperty('name', name);
        var preDefined = preDefinedConfigs.findProperty('name', name);
        var configData = {};
        var isAdvanced = advancedConfigs.someProperty('name', name);
        if (preDefined && stored) {
          configData = preDefined;
          configData.value = stored.value;
          configData.overrides = stored.overrides;
        } else if (!preDefined && stored) {
          configData = {
            id: stored.id,
            name: stored.name,
            displayName: stored.name,
            serviceName: stored.serviceName,
            value: stored.value,
            defaultValue: stored.defaultValue,
            displayType: stringUtils.isSingleLine(stored.value) ? 'advanced' : 'multiLine',
            filename: stored.filename,
            category: 'Advanced',
            isUserProperty: stored.isUserProperty === true,
            isOverridable: true,
            overrides: stored.overrides,
            isRequired: true
          };
          this.calculateConfigProperties(configData, isAdvanced, advancedConfigs);
        } else if (preDefined && !stored) {
          configData = preDefined;
          if (isAdvanced) {
            configData.filename = advancedConfigs.findProperty('name', configData.name).filename;
          }
        }
        mergedConfigs.push(configData);
      }, this);
      return mergedConfigs;
    },
    /**
     * look over advanced configs and add missing configs to serviceConfigs
     * filter fetched configs by service if passed
     * @param serviceConfigs
     * @param advancedConfigs
     * @param serviceName
     */
    addAdvancedConfigs: function (serviceConfigs, advancedConfigs, serviceName) {
      var configsToVerifying = (serviceName) ? serviceConfigs.filterProperty('serviceName', serviceName) : serviceConfigs;
      advancedConfigs.forEach(function (_config) {
        var configCategory = 'Advanced';
        var categoryMetaData = null;
        if (_config) {
          if (this.get('configMapping').computed().someProperty('name', _config.name)) {
          } else if (!(configsToVerifying.someProperty('name', _config.name))) {
            if(this.get('customFileNames').contains(_config.filename)){
              categoryMetaData = this.identifyCategory(_config);
              if (categoryMetaData != null) {
                configCategory = categoryMetaData.get('name');
              }
            }
            _config.id = "site property";
            _config.category = configCategory;
            _config.displayName = _config.name;
            _config.defaultValue = _config.value;
            // make all advanced configs optional and populated by default
            /*
             * if (/\${.*}/.test(_config.value) || (service.serviceName !==
             * 'OOZIE' && service.serviceName !== 'HBASE')) { _config.isRequired =
             * false; _config.value = ''; } else if
             * (/^\s+$/.test(_config.value)) { _config.isRequired = false; }
             */
            _config.isRequired = true;
            _config.displayType = stringUtils.isSingleLine(_config.value) ? 'advanced' : 'multiLine';
            serviceConfigs.push(_config);
          }
        }
      }, this);
    },
    /**
     * Render a custom conf-site box for entering properties that will be written in *-site.xml files of the services
     */
    addCustomConfigs: function (configs) {
      var preDefinedCustomConfigs = $.extend(true, [], this.get('preDefinedCustomConfigs'));
      var stored = configs.filter(function (_config) {
        if (this.get('categoriesWithCustom').contains(_config.category)) return true;
      }, this);
      var queueProperties = stored.filter(function (_config) {
        if ((_config.name.indexOf('mapred.capacity-scheduler.queue.') !== -1) ||
          (/mapred.queue.[a-z]([\_\-a-z0-9]{0,50}).acl-administer-jobs/i.test(_config.name)) ||
          (/mapred.queue.[a-z]([\_\-a-z0-9]{0,50}).acl-submit-job/i.test(_config.name))) {
          return true;
        }
      });
      if (queueProperties.length) {
        queueProperties.setEach('isQueue', true);
      } else {
        queueProperties = preDefinedCustomConfigs.filterProperty('isQueue');
        queueProperties.forEach(function (customConfig) {
          this.setDefaultQueue(customConfig, 'default');
          configs.push(customConfig);
        }, this);
      }
    },
    /**
     * set values to properties of queue
     * @param customConfig
     * @param queueName
     */
    setDefaultQueue: function (customConfig, queueName) {
      customConfig.name = customConfig.name.replace(/<queue-name>/, queueName);
      //default values of queue
      switch (customConfig.name) {
        case 'mapred.capacity-scheduler.queue.' + queueName + '.capacity':
          customConfig.value = '100';
          break;
        case 'mapred.capacity-scheduler.queue.' + queueName + '.maximum-capacity':
          customConfig.value = '100';
          break;
        case 'mapred.capacity-scheduler.queue.' + queueName + '.minimum-user-limit-percent':
          customConfig.value = '100';
          break;
        case 'mapred.capacity-scheduler.queue.' + queueName + '.user-limit-factor':
          customConfig.value = '1';
          break;
        case 'mapred.capacity-scheduler.queue.' + queueName + '.maximum-initialized-active-tasks':
          customConfig.value = '200000';
          break;
        case 'mapred.capacity-scheduler.queue.' + queueName + '.maximum-initialized-active-tasks-per-user':
          customConfig.value = '100000';
          break;
        case 'mapred.capacity-scheduler.queue.' + queueName + '.init-accept-jobs-factor':
          customConfig.value = '10';
          break;
        case 'mapred.capacity-scheduler.queue.' + queueName + '.supports-priority':
          customConfig.value = 'false';
          break;
        case 'mapred.queue.' + queueName + '.acl-submit-job':
          customConfig.value = '*';
          break;
        case 'mapred.queue.' + queueName + '.acl-administer-jobs':
          customConfig.value = '*';
          break;
      }
    },

    miscConfigVisibleProperty: function (configs, serviceToShow) {
      configs.forEach(function(item) {
        item.set("isVisible", item.belongsToService.some(function(cur){return serviceToShow.contains(cur)}));
      });
      return configs;
    },

    /**
     * render configs, distribute them by service
     * and wrap each in ServiceConfigProperty object
     * @param configs
     * @param allInstalledServiceNames
     * @param selectedServiceNames
     * @return {Array}
     */
    renderConfigs: function (configs, storedConfigs, allInstalledServiceNames, selectedServiceNames) {
      var renderedServiceConfigs = [];
      var localDB = {
        hosts: App.db.getHosts(),
        masterComponentHosts: App.db.getMasterComponentHosts(),
        slaveComponentHosts: App.db.getSlaveComponentHosts()
      };
      var services = [];

      this.get('preDefinedServiceConfigs').forEach(function (serviceConfig) {
        if (allInstalledServiceNames.contains(serviceConfig.serviceName) || serviceConfig.serviceName === 'MISC') {
          console.log('pushing ' + serviceConfig.serviceName, serviceConfig);
          if (selectedServiceNames.contains(serviceConfig.serviceName) || serviceConfig.serviceName === 'MISC') {
            serviceConfig.showConfig = true;
          }
          services.push(serviceConfig);
        }
      });
      services.forEach(function (service) {
        var serviceConfig = {};
        var configsByService = [];
        var serviceConfigs = configs.filterProperty('serviceName', service.serviceName);
        serviceConfigs.forEach(function (_config) {
          var serviceConfigProperty = {};
          _config.isOverridable = (_config.isOverridable === undefined) ? true : _config.isOverridable;
          serviceConfigProperty = App.ServiceConfigProperty.create(_config);
          this.updateHostOverrides(serviceConfigProperty, _config);
          if (!storedConfigs) {
            serviceConfigProperty.initialValue(localDB);
          }
          this.tweakDynamicDefaults(localDB, serviceConfigProperty, _config);
          serviceConfigProperty.validate();
          configsByService.pushObject(serviceConfigProperty);
        }, this);
        serviceConfig = this.createServiceConfig(service.serviceName);
        serviceConfig.set('showConfig', service.showConfig);
        serviceConfig.set('configs', configsByService);
        renderedServiceConfigs.push(serviceConfig);
      }, this);
      return renderedServiceConfigs;
    },
    /**
    Takes care of the "dynamic defaults" for the HCFS configs.  Sets
    some of the config defaults to previously user-entered data.
    **/ 
    tweakDynamicDefaults: function (localDB, serviceConfigProperty, config) {
      console.log("Step7: Tweaking Dynamic defaults");
      var firstHost = null;
      for(var host in localDB.hosts) {
        firstHost = host;
        break;
      }
      try {
        if (typeof(config == "string") && config.defaultValue.indexOf("{firstHost}") >= 0) {
          serviceConfigProperty.set('value', serviceConfigProperty.value.replace(new RegExp("{firstHost}"), firstHost));
          serviceConfigProperty.set('defaultValue', serviceConfigProperty.defaultValue.replace(new RegExp("{firstHost}"), firstHost));
        } 
      } catch (err) {
        // Nothing to worry about here, most likely trying indexOf on a non-string
      }
    },  
    /**
     * create new child configs from overrides, attach them to parent config
     * override - value of config, related to particular host(s)
     * @param configProperty
     * @param storedConfigProperty
     */
    updateHostOverrides: function (configProperty, storedConfigProperty) {
      if (storedConfigProperty.overrides != null && storedConfigProperty.overrides.length > 0) {
        var overrides = [];
        storedConfigProperty.overrides.forEach(function (overrideEntry) {
          // create new override with new value
          var newSCP = App.ServiceConfigProperty.create(configProperty);
          newSCP.set('value', overrideEntry.value);
          newSCP.set('isOriginalSCP', false); // indicated this is overridden value,
          newSCP.set('parentSCP', configProperty);
          var hostsArray = Ember.A([]);
          overrideEntry.hosts.forEach(function (host) {
            hostsArray.push(host);
          });
          newSCP.set('selectedHostOptions', hostsArray);
          overrides.pushObject(newSCP);
        });
        configProperty.set('overrides', overrides);
      }
    },
    /**
     * create new ServiceConfig object by service name
     * @param serviceName
     */
    createServiceConfig: function (serviceName) {
      var preDefinedServiceConfig = App.config.get('preDefinedServiceConfigs').findProperty('serviceName', serviceName);
      var serviceConfig = App.ServiceConfig.create({
        filename: preDefinedServiceConfig.filename,
        serviceName: preDefinedServiceConfig.serviceName,
        displayName: preDefinedServiceConfig.displayName,
        configCategories: preDefinedServiceConfig.configCategories,
        configs: []
      });
      serviceConfig.configCategories.filterProperty('isCustomView', true).forEach(function (category) {
        switch (category.name) {
          case 'CapacityScheduler':
            category.set('customView', App.ServiceConfigCapacityScheduler);
            break;
        }
      }, this);
      return serviceConfig;
    },
    /**
     * GETs all cluster level sites in one call.
     *
     * @return Array of all site configs
     */
    loadConfigsByTags: function (tags) {
      var urlParams = [];
      tags.forEach(function (_tag) {
        urlParams.push('(type=' + _tag.siteName + '&tag=' + _tag.tagName + ')');
      });
      var params = urlParams.join('|');
      App.ajax.send({
        name: 'config.on_site',
        sender: this,
        data: {
          params: params
        },
        success: 'loadConfigsByTagsSuccess'
      });
      return configGroupsByTag;
    },

    loadConfigsByTagsSuccess: function (data) {
      if (data.items) {
        configGroupsByTag = [];
        data.items.forEach(function (item) {
          this.loadedConfigurationsCache[item.type + "_" + item.tag] = item.properties;
          configGroupsByTag.push(item);
        }, this);
      }
    },
    /**
     * Generate serviceProperties save it to localDB
     * called form stepController step6WizardController
     *
     * @param serviceName
     * @return {*}
     */
    loadAdvancedConfig: function (serviceName) {
      App.ajax.send({
        name: 'config.advanced',
        sender: this,
        data: {
          serviceName: serviceName,
          stack2VersionUrl: App.get('stack2VersionURL'),
          stackVersion: App.get('currentStackVersionNumber')
        },
        success: 'loadAdvancedConfigSuccess'
      });
      return serviceComponents[serviceName];
      //TODO clean serviceComponents
    },

    loadAdvancedConfigSuccess: function (data, opt, params) {
      console.log("TRACE: In success function for the loadAdvancedConfig; url is ", opt.url);
      var properties = [];
      if (data.items.length) {
        data.items.forEach(function (item) {
          item = item.StackConfigurations;
          item.isVisible = item.type !== 'global.xml';
          properties.push({
            serviceName: item.service_name,
            name: item.property_name,
            value: item.property_value,
            description: item.property_description,
            isVisible: item.isVisible,
            filename: item.filename || item.type
          });
        }, this);
        serviceComponents[data.items[0].StackConfigurations.service_name] = properties;
      }
    },

    /**
     * Determine the map which shows which services
     * each global property effects.
     *
     * @return {*}
     * Example:
     * {
     *  'hive_pid_dir': ['HIVE'],
     *  ...
     * }
     */
    loadGlobalPropertyToServicesMap: function () {
      if (globalPropertyToServicesMap == null) {
        App.ajax.send({
          name: 'config.advanced.global',
          sender: this,
          data: {
            stack2VersionUrl: App.get('stack2VersionURL')
          },
          success: 'loadGlobalPropertyToServicesMapSuccess'
        });
      }
      return globalPropertyToServicesMap;
    },
    
    loadGlobalPropertyToServicesMapSuccess: function (data) {
      globalPropertyToServicesMap = {};
      if(data.items!=null){
        data.items.forEach(function(service){
          service.configurations.forEach(function(config){
            if("global.xml" === config.StackConfigurations.type){
              if(!(config.StackConfigurations.property_name in globalPropertyToServicesMap)){
                globalPropertyToServicesMap[config.StackConfigurations.property_name] = [];
              }
              globalPropertyToServicesMap[config.StackConfigurations.property_name].push(service.StackServices.service_name);
            }
          });
        });
      }
    },
    
    /**
     * When global configuration changes, not all services are effected
     * by all properties. This method determines if a given service
     * is effected by the difference in desired and actual configs.
     * 
     * This method might make a call to server to determine the actual
     * key/value pairs involved.
     */
    isServiceEffectedByGlobalChange: function (service, desiredTag, actualTag) {
      var effected = false;
      if (service != null && desiredTag != null && actualTag != null) {
        if(this.differentGlobalTagsCache.indexOf(service+"/"+desiredTag+"/"+actualTag) < 0){
          this.loadGlobalPropertyToServicesMap();
          var desiredConfigs = this.loadedConfigurationsCache['global_' + desiredTag];
          var actualConfigs = this.loadedConfigurationsCache['global_' + actualTag];
          var requestTags = [];
          if (!desiredConfigs) {
            requestTags.push({
              siteName: 'global',
              tagName: desiredTag
            });
          }
          if (!actualConfigs) {
            requestTags.push({
              siteName: 'global',
              tagName: actualTag
            });
          }
          if (requestTags.length > 0) {
            this.loadConfigsByTags(requestTags);
            desiredConfigs = this.loadedConfigurationsCache['global_' + desiredTag];
            actualConfigs = this.loadedConfigurationsCache['global_' + actualTag];
          }
          if (desiredConfigs != null && actualConfigs != null) {
            for ( var property in desiredConfigs) {
              if (!effected) {
                var dpv = desiredConfigs[property];
                var apv = actualConfigs[property];
                if (dpv !== apv && globalPropertyToServicesMap[property] != null) {
                  effected = globalPropertyToServicesMap[property].indexOf(service) > -1;
                  if(effected){
                    this.differentGlobalTagsCache.push(service+"/"+desiredTag+"/"+actualTag);
                  }
                }
              }
            }
          }
        }else{
          effected = true; // We already know they are different
        }
      }
      return effected;
    },

    /**
     * Hosts can override service configurations per property. This method GETs
     * the overriden configurations and sets only the changed properties into
     * the 'overrides' of serviceConfig.
     *
     *
     */
    loadServiceConfigHostsOverrides: function (serviceConfigs, loadedHostToOverrideSiteToTagMap) {
      var configKeyToConfigMap = {};
      serviceConfigs.forEach(function (item) {
        configKeyToConfigMap[item.name] = item;
      });
      var typeTagToHostMap = {};
      var urlParams = [];
      for (var hostname in loadedHostToOverrideSiteToTagMap) {
        var overrideTypeTags = loadedHostToOverrideSiteToTagMap[hostname];
        for (var type in overrideTypeTags) {
          var tag = overrideTypeTags[type];
          typeTagToHostMap[type + "///" + tag] = hostname;
          urlParams.push('(type=' + type + '&tag=' + tag + ')');
        }
      }
      var params = urlParams.join('|');
      if (urlParams.length) {
        App.ajax.send({
          name: 'config.host_overrides',
          sender: this,
          data: {
            params: params,
            configKeyToConfigMap: configKeyToConfigMap,
            typeTagToHostMap: typeTagToHostMap
          },
          success: 'loadServiceConfigHostsOverridesSuccess'
        });
      }
    },
    loadServiceConfigHostsOverridesSuccess: function (data, opt, params) {
      console.debug("loadServiceConfigHostsOverrides: Data=", data);
      data.items.forEach(function (config) {
        App.config.loadedConfigurationsCache[config.type + "_" + config.tag] = config.properties;
        var hostname = params.typeTagToHostMap[config.type + "///" + config.tag];
        var properties = config.properties;
        for (var prop in properties) {
          var serviceConfig = params.configKeyToConfigMap[prop];
          var hostOverrideValue = properties[prop];
          if (serviceConfig && serviceConfig.displayType === 'int') {
            if (/\d+m$/.test(hostOverrideValue)) {
              hostOverrideValue = hostOverrideValue.slice(0, hostOverrideValue.length - 1);
            }
          } else if (serviceConfig && serviceConfig.displayType === 'checkbox') {
            switch (hostOverrideValue) {
              case 'true':
                hostOverrideValue = true;
                break;
              case 'false':
                hostOverrideValue = false;
                break;
            }
          }
          if (serviceConfig) {
            // Value of this property is different for this host.
            var overrides = 'overrides';
            if (!(overrides in serviceConfig)) {
              serviceConfig.overrides = {};
            }
            if (!(hostOverrideValue in serviceConfig.overrides)) {
              serviceConfig.overrides[hostOverrideValue] = [];
            }
            console.log("loadServiceConfigHostsOverrides(): [" + hostname + "] OVERRODE(" + serviceConfig.name + "): " + serviceConfig.value + " -> " + hostOverrideValue);
            serviceConfig.overrides[hostOverrideValue].push(hostname);
          }
        }
      });
      console.log("loadServiceConfigHostsOverrides(): Finished loading.");
    },

    /**
     * Set all site property that are derived from other site-properties
     */
    setConfigValue: function (mappedConfigs, allConfigs, config, globalConfigs) {
      var globalValue;
      if (config.value == null) {
        return;
      }
      var fkValue = config.value.match(/<(foreignKey.*?)>/g);
      var fkName = config.name.match(/<(foreignKey.*?)>/g);
      var templateValue = config.value.match(/<(templateName.*?)>/g);
      if (fkValue) {
        fkValue.forEach(function (_fkValue) {
          var index = parseInt(_fkValue.match(/\[([\d]*)(?=\])/)[1]);
          if (mappedConfigs.someProperty('name', config.foreignKey[index])) {
            globalValue = mappedConfigs.findProperty('name', config.foreignKey[index]).value;
            config.value = config.value.replace(_fkValue, globalValue);
          } else if (allConfigs.someProperty('name', config.foreignKey[index])) {
            if (allConfigs.findProperty('name', config.foreignKey[index]).value === '') {
              globalValue = allConfigs.findProperty('name', config.foreignKey[index]).defaultValue;
            } else {
              globalValue = allConfigs.findProperty('name', config.foreignKey[index]).value;
            }
            config.value = config.value.replace(_fkValue, globalValue);
          }
        }, this);
      }

      // config._name - formatted name from original config name
      if (fkName) {
        fkName.forEach(function (_fkName) {
          var index = parseInt(_fkName.match(/\[([\d]*)(?=\])/)[1]);
          if (mappedConfigs.someProperty('name', config.foreignKey[index])) {
            globalValue = mappedConfigs.findProperty('name', config.foreignKey[index]).value;
            config._name = config.name.replace(_fkName, globalValue);
          } else if (allConfigs.someProperty('name', config.foreignKey[index])) {
            if (allConfigs.findProperty('name', config.foreignKey[index]).value === '') {
              globalValue = allConfigs.findProperty('name', config.foreignKey[index]).defaultValue;
            } else {
              globalValue = allConfigs.findProperty('name', config.foreignKey[index]).value;
            }
            config._name = config.name.replace(_fkName, globalValue);
          }
        }, this);
      }

      //For properties in the configMapping file having foreignKey and templateName properties.
      if (templateValue) {
        templateValue.forEach(function (_value) {
          var index = parseInt(_value.match(/\[([\d]*)(?=\])/)[1]);
          if (globalConfigs.someProperty('name', config.templateName[index])) {
            var globalValue = globalConfigs.findProperty('name', config.templateName[index]).value;
            config.value = config.value.replace(_value, globalValue);
          } else {
            config.value = null;
          }
        }, this);
      }
    }

  });
});
window.require.register("utils/date", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var validator = require('utils/validator');

  module.exports = {
    dateMonths:['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    dateDays:['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    dateFormatZeroFirst:function (time) {
      if (time < 10) return '0' + time;
      return time;
    },
    /**
     * Convert timestamp to date-string 'DAY_OF_THE_WEEK, MONTH DAY, YEAR HOURS:MINUTES'
     * @param timestamp
     * @return string date
     */
    dateFormat:function (timestamp) {
      if (!validator.isValidInt(timestamp)) return timestamp;
      var date = new Date(timestamp * 1);
      var months = this.dateMonths;
      var days = this.dateDays;
      return days[date.getDay()] + ', ' + months[date.getMonth()] + ' ' + this.dateFormatZeroFirst(date.getDate()) + ', ' + date.getFullYear() + ' ' + this.dateFormatZeroFirst(date.getHours()) + ':' + this.dateFormatZeroFirst(date.getMinutes());
    },
    /**
     * Convert timestamp to date-string 'DAY_OF_THE_WEEK MONTH DAY YEAR'
     * @param timestamp
     * @return {*}
     */
    dateFormatShort: function(timestamp) {
      if (!validator.isValidInt(timestamp)) return timestamp;

      var date = new Date(timestamp*1);
      var today = new Date();
      if (date.toDateString() === today.toDateString()) {
        return 'Today ' + date.toLocaleTimeString();
      }
      return date.toDateString();
    },
    /**
     * Convert time in mseconds to
     * 30 ms = 30 ms
     * 300 ms = 300 ms
     * 999 ms = 999 ms
     * 1000 ms = 1.00 secs
     * 3000 ms = 3.00 secs
     * 35000 ms = 35.00 secs
     * 350000 ms = 350.00 secs
     * 999999 ms = 999.99 secs
     * 1000000 ms = 16.66 mins
     * 3500000 secs = 58.33 mins
     * @param time
     * @return string formatted date
     */
    timingFormat:function (time) {
      var intTime  = parseInt(time);
      if (!intTime) return null;
      var timeStr = intTime.toString();
      var lengthOfNumber = timeStr.length;
      var oneMinMs = 60000;
      var oneHourMs = 3600000;
      var oneDayMs = 86400000;

      if (lengthOfNumber < 4) {
        return time + ' ms';
      } else if (lengthOfNumber < 7) {
        time = (time / 1000).toFixed(2);
        return time + ' 秒';
      } else if (time < oneHourMs) {
        time = (time / oneMinMs).toFixed(2);
        return time + ' 分';
      } else if (time < oneDayMs) {
        time = (time / oneHourMs).toFixed(2);
        return time + ' 小时';
      } else {
        time = (time / oneDayMs).toFixed(2);
        return time + ' 天';
      }
    }
  }
});
window.require.register("utils/db", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var App = require('app');
  App.db = {};

  if (typeof Storage !== 'undefined') {
    Storage.prototype.setObject = function (key, value) {
      this.setItem(key, JSON.stringify(value));
    };

    Storage.prototype.getObject = function (key) {
      var value = this.getItem(key);
      return value && JSON.parse(value);
    };
  } else {
    // stub for unit testing purposes
    window.localStorage = {};
    localStorage.setItem = function (key, val) {
      this[key] = val;
    };
    localStorage.getItem = function (key) {
      return this[key];
    };
    window.localStorage.setObject = function (key, value) {
      this[key] = value;
    };
    window.localStorage.getObject = function (key, value) {
      return this[key];
    };
  }

  App.db.cleanUp = function () {
    console.log('TRACE: Entering db:cleanup function');
    App.db.data = {
      'app': {
        'loginName': '',
        'authenticated': false,
        'tables': {
          'filterConditions': {},
          'displayLength': {},
          'startIndex': {},
          'sortingConditions': {}
        }
      },

      'Installer' : {},
      'AddHost' : {},
      'AddService' : {},
      'StackUpgrade' : {},
      'ReassignMaster' : {},
      'AddSecurity': {}

    };
    console.log("In cleanup./..");
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.updateStorage = function() {
    App.db.data = localStorage.getObject('ambari');
    if (App.db.data && App.db.data.app && App.db.data.app.tables) {
      return true;
    }
    console.warn("local storage is deprecated!");
    App.db.cleanUp();
    return false;
  };
  // called whenever user logs in
  if (localStorage.getObject('ambari') == null) {
    console.log('doing a cleanup');
    App.db.cleanUp();
  }

  /*
   * setter methods
   */

  App.db.setLoginName = function (name) {
    console.log('TRACE: Entering db:setLoginName function');
    App.db.data = localStorage.getObject('ambari');
    App.db.data.app.loginName = name;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setAmbariStacks = function (stacks) {
    console.log('TRACE: Entering db:setAmbariStacks function');
    App.db.data = localStorage.getObject('ambari');
    App.db.data.app.stacks = stacks;
    localStorage.setObject('ambari', App.db.data);
  };

  /**
   * Set user model to db
   * @param user
   */
  App.db.setUser = function (user) {
    console.log('TRACE: Entering db:setUser function');
    App.db.data = localStorage.getObject('ambari');
    App.db.data.app.user = user;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setAuthenticated = function (authenticated) {
    console.log('TRACE: Entering db:setAuthenticated function');

    App.db.data = localStorage.getObject('ambari');
    console.log('present value of authentication is: ' + App.db.data.app.authenticated);
    console.log('desired value of authentication is: ' + authenticated);
    App.db.data.app.authenticated = authenticated;
    localStorage.setObject('ambari', App.db.data);
    App.db.data = localStorage.getObject('ambari');
    console.log('Now present value of authentication is: ' + App.db.data.app.authenticated);
  };

  App.db.setFilterConditions = function(name, filterConditions) {
    console.log('TRACE: Entering db:setFilterConditions function');
    App.db.data = localStorage.getObject('ambari');
    if (!App.db.data.app.tables.filterConditions) {
      App.db.data.app.tables.filterConditions = {};
    }
    App.db.data.app.tables.filterConditions[name] = filterConditions;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setDisplayLength = function(name, displayLength) {
    console.log('TRACE: Entering db:setDisplayLength function');
    App.db.data = localStorage.getObject('ambari');
    if (!App.db.data.app.tables.displayLength) {
      App.db.data.app.tables.displayLength = {};
    }
    App.db.data.app.tables.displayLength[name] = displayLength;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setStartIndex = function(name, startIndex) {
    console.log('TRACE: Entering db:setStartIndex function');
    App.db.data = localStorage.getObject('ambari');
    if (!App.db.data.app.tables.startIndex) {
      App.db.data.app.tables.startIndex = {};
    }
    App.db.data.app.tables.startIndex[name] = startIndex;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setSortingStatuses = function(name, sortingConditions) {
    console.log('TRACE: Entering db:setSortingConditions function');
    App.db.data = localStorage.getObject('ambari');
    if (!App.db.data.app.tables.sortingConditions) {
      App.db.data.app.tables.sortingConditions = {};
    }
    App.db.data.app.tables.sortingConditions[name] = sortingConditions;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setAllHostNames = function (hostNames) {
    console.log('TRACE: Entering db:setAllHostNames function');
    App.db.data = localStorage.getObject('ambari');
    App.db.data.Installer.hostNames = hostNames;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setAllHostNamesPattern = function (hostNames) {
    console.log('TRACE: Entering db:setAllHostNamesPattern function');
    App.db.data = localStorage.getObject('ambari');
    App.db.data.Installer.hostNamesPattern = hostNames;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setHosts = function (hostInfo) {
    console.log('TRACE: Entering db:setHosts function');
    App.db.data = localStorage.getObject('ambari');
    App.db.data.Installer.hostInfo = hostInfo;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setInstallOptions = function (installOptions) {
    console.log('TRACE: Entering db:setInstallOptions function');
    App.db.data = localStorage.getObject('ambari');
    App.db.data.Installer.installOptions = installOptions;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setBootStatus = function (status) {
    console.log('TRACE: Entering db:setBootStatus function');
    App.db.data = localStorage.getObject('ambari');
    App.db.data.Installer.bootStatus = status;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.removeHosts = function (hostInfo) {
    console.log('TRACE: Entering db:setSoftRepo function');
    var hostList = App.db.getHosts();
    hostInfo.forEach(function (_hostInfo) {
      var host = _hostInfo.hostName;
      delete hostList[host];
    });
    App.db.setHosts(hostList);
  };

  App.db.setService = function (serviceInfo) {
    App.db.data = localStorage.getObject('ambari');
    App.db.data.Installer.serviceInfo = serviceInfo;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setSelectedServiceNames = function (serviceNames) {
    App.db.data = localStorage.getObject('ambari');
    App.db.data.Installer.selectedServiceNames = serviceNames;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setClientsForSelectedServices = function (clientInfo) {
    App.db.data = localStorage.getObject('ambari');
    App.db.data.Installer.clientInfo = clientInfo;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setMasterComponentHosts = function (masterComponentHosts) {
    App.db.data = localStorage.getObject('ambari');
    App.db.data.Installer.masterComponentHosts = masterComponentHosts;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setSlaveComponentHosts = function (slaveComponentHosts) {
    App.db.data = localStorage.getObject('ambari');
    App.db.data.Installer.slaveComponentHosts = slaveComponentHosts;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setServiceConfigs = function (serviceConfigs) {
    App.db.data = localStorage.getObject('ambari');
    App.db.data.Installer.serviceConfigs = serviceConfigs;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setAdvancedServiceConfig = function (serviceConfigs) {
    App.db.data = localStorage.getObject('ambari');
    App.db.data.Installer.advanceServiceConfigs = serviceConfigs;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setServiceConfigProperties = function (configProperties) {
    App.db.data = localStorage.getObject('ambari');
    App.db.data.Installer.configProperties = configProperties;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setCluster = function (status) {
    App.db.data = localStorage.getObject('ambari');
    App.db.data.Installer.clusterStatus = status;
    console.log('db.setClusterStatus called: ' + JSON.stringify(status));
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setUpgradeOptions = function (upgradeOptions) {
    App.db.data = localStorage.getObject('ambari');
    App.db.data.StackUpgrade.upgradeOptions = upgradeOptions;
    console.log('db.setUpgradeOptions called: ' + JSON.stringify(upgradeOptions));
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setMasterToReassign = function (masterComponent) {
    App.db.data = localStorage.getObject('ambari');
    App.db.data.ReassignMaster.masterComponent = masterComponent;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setReassignTasksStatuses = function (tasksStatuses) {
    App.db.data = localStorage.getObject('ambari');
    App.db.data.ReassignMaster.tasksStatuses = tasksStatuses;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setStacks = function (stacks) {
    App.db.data = localStorage.getObject('ambari');
    App.db.data.app.stacksVersions = stacks;
    localStorage.setObject('ambari', App.db.data);
  };

  /**
   * Set current step value for specified Wizard Type
   * @param wizardType
   * @param currentStep
   */
  App.db.setWizardCurrentStep = function (wizardType, currentStep) {
    console.log('TRACE: Entering db:setWizardCurrentStep function');

    App.db.data[wizardType.capitalize()].currentStep = currentStep;

    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setSecurityWizardStatus = function (status) {
    App.db.data = localStorage.getObject('ambari');
    if (!App.db.data.AddSecurity) {
      App.db.data.AddSecurity = {};
    }
    App.db.data.AddSecurity.status = status;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setDisableSecurityStatus = function (status) {
    App.db.data = localStorage.getObject('ambari');
    if (!App.db.data.AddSecurity) {
      App.db.data.AddSecurity = {};
    }
    App.db.data.AddSecurity.disableSecurityStatus = status;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setSecurityDeployStages = function (securityStages) {
    App.db.data = localStorage.getObject('ambari');
    if (!App.db.data.AddSecurity) {
      App.db.data.AddSecurity = {};
    }
    App.db.data.AddSecurity.securityDeployStages = securityStages;
    localStorage.setObject('ambari', App.db.data);
  };

  App.db.setSecureConfigProperties  = function (secureConfigs) {
    App.db.data = localStorage.getObject('ambari');
    if (!App.db.data.AddSecurity) {
      App.db.data.AddSecurity = {};
    }
    App.db.data.AddSecurity.secureConfigProperties = secureConfigs;
    localStorage.setObject('ambari', App.db.data);
  };


  /*
   *  getter methods
   */

  /**
   * Get user model from db
   * @return {*}
   */
  App.db.getUser = function () {
    console.log('TRACE: Entering db:getUser function');
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.app.user;
  };

  App.db.getLoginName = function () {
    console.log('Trace: Entering db:getLoginName function');
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.app.loginName;
  };

  App.db.getAuthenticated = function () {
    console.log('Trace: Entering db:getAuthenticated function');
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.app.authenticated;
  };

  App.db.getAmbariStacks = function () {
    console.log('TRACE: Entering db:setAmbariStacks function');
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.app.stacks;
  };

  App.db.getFilterConditions = function(name) {
    console.log('TRACE: Entering db:getFilterConditions function');
    App.db.data = localStorage.getObject('ambari');
    if (App.db.data.app.tables.filterConditions[name]) {
      return App.db.data.app.tables.filterConditions[name];
    }
    return null;
  };

  App.db.getDisplayLength = function(name) {
    console.log('TRACE: Entering db:getDisplayLength function');
    App.db.data = localStorage.getObject('ambari');
    if (App.db.data.app.tables.displayLength[name]) {
      return App.db.data.app.tables.displayLength[name];
    }
    return null;
  };

  App.db.getStartIndex = function(name) {
    console.log('TRACE: Entering db:getStartIndex function');
    App.db.data = localStorage.getObject('ambari');
    if (App.db.data.app.tables.startIndex[name]) {
      return App.db.data.app.tables.startIndex[name];
    }
    return null;
  };

  App.db.getSortingStatuses = function(name) {
    console.log('TRACE: Entering db:getSortingConditions function');
    App.db.data = localStorage.getObject('ambari');
    if (App.db.data.app.tables.sortingConditions[name]) {
      return App.db.data.app.tables.sortingConditions[name];
    }
    return null;
  };

  /**
   * Return current step for specified Wizard Type
   * @param wizardType
   * @return {*}
   */
  App.db.getWizardCurrentStep = function (wizardType) {
    console.log('Trace: Entering db:getWizardCurrentStep function for ', wizardType);
    if (App.db.data[wizardType.capitalize()]) {
      return App.db.data[wizardType.capitalize()].currentStep;
    }
    return 0;
  };

  App.db.getAllHostNames = function () {
    console.log('TRACE: Entering db:getHostNames function');
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.hostNames;
  };

  App.db.getAllHostNamesPattern = function () {
    console.log('TRACE: Entering db:getHostNamesPattern function');
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.hostNamesPattern;
  };
  App.db.getInstallOptions = function () {
    console.log('TRACE: Entering db:getInstallOptions function');
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.installOptions;
  };

  App.db.isCompleted = function () {
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.completed;
  };

  App.db.getHosts = function () {
    console.log('TRACE: Entering db:getHosts function');
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.hostInfo;
  };

  App.db.getBootStatus = function () {
    console.log('TRACE: Entering db:getBootStatus function');
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.bootStatus;
  };

  App.db.getService = function () {
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.serviceInfo;
  };

  App.db.getSelectedServiceNames = function () {
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.selectedServiceNames;
  };

  App.db.getClientsForSelectedServices = function () {
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.clientInfo;
  };

  App.db.getMasterComponentHosts = function () {
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.masterComponentHosts;
  };

  App.db.getSlaveComponentHosts = function () {
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.slaveComponentHosts;
  };

  App.db.getServiceConfigs = function () {
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.serviceConfigs;
  };

  App.db.getAdvancedServiceConfig = function () {
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.advanceServiceConfigs;
  };

  App.db.getServiceConfigProperties = function () {
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.configProperties;
  };

  App.db.getCluster = function () {
    console.log('TRACE: Entering db:getClusterStatus function');
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.Installer.clusterStatus;
  };

  App.db.getMasterToReassign = function () {
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.ReassignMaster.masterComponent;
  };

  App.db.getReassignTasksStatuses = function () {
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.ReassignMaster.tasksStatuses;
  };

  App.db.getUpgradeOptions = function () {
    console.log('TRACE: Entering db:getUpgradeOptions function');
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.StackUpgrade.upgradeOptions;
  };

  App.db.getSecurityWizardStatus = function () {
    App.db.data = localStorage.getObject('ambari');
    if (!App.db.data.AddSecurity) {
      App.db.data.AddSecurity = {};
    }
    return App.db.data.AddSecurity.status;
  };

  App.db.getDisableSecurityStatus = function () {
    App.db.data = localStorage.getObject('ambari');
    if (!App.db.data.AddSecurity) {
      App.db.data.AddSecurity = {};
    }
    return App.db.data.AddSecurity.disableSecurityStatus;
  };

  App.db.getSecurityDeployStages = function () {
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.AddSecurity.securityDeployStages;
  };

  App.db.getSecureConfigProperties = function () {
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.AddSecurity.secureConfigProperties;
  };

  App.db.getStacks = function () {
    App.db.data = localStorage.getObject('ambari');
    return App.db.data.app.stacksVersions;
  };

  module.exports = App.db;
  
});
window.require.register("utils/graph", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  module.exports = {
    durationFormatter:function(d) {
        if (d==0) { return "0" }
        var seconds = Math.floor(parseInt(d) / 1000);
        if ( seconds < 60 )
          return seconds + "秒";
        var minutes = Math.floor(seconds / 60);
        if ( minutes < 60 ) {
          var x = seconds - 60*minutes;
          return minutes + "分" + (x==0 ? "" : " " + x + "秒");
        }
        var hours = Math.floor(minutes / 60);
        if ( hours < 24 ) {
          var x = minutes - 60*hours;
          return hours + "小时" + (x==0 ? "" : " " + x + "分");
        }
        var days = Math.floor(hours / 24);
        if ( days < 7 ) {
          var x = hours - 24*days;
          return days + "天 " + (x==0 ? "" : " " + x + "小时");
        }
        var weeks = Math.floor(days / 7);
        var x = days - 7*weeks;
        return weeks + "周 " + (x==0 ? "" : " " + x + "天");
    },
    bytesFormatter:function(y) {
      if (y >= 1125899906842624)  { return Math.floor(10 * y / 1125899906842624)/10 + " PB" }
      else if (y >= 1099511627776){ return Math.floor(10 * y / 1099511627776)/10 + " TB" }
      else if (y >= 1073741824)   { return Math.floor(10 * y / 1073741824)/10 + " GB" }
      else if (y >= 1048576)      { return Math.floor(10 * y / 1048576)/10 + " MB" }
      else if (y >= 1024)         { return Math.floor(10 * y / 1024)/10 + " KB" }
      else                        { return y + " B"}
    },
    addSeries:function(svgg,series,color,xscale,yscale,margin,startTime,dotInfo) {
      if (series.length==0) return;
      var self = this;
      var g = svgg.append("svg:g").selectAll("g")
        .data(series)
        .enter().append("svg:g")
        .attr("transform", "translate(0,"+margin+")");
      g.append("svg:circle")
        .attr("r",function(d) {return d.r;})
        .attr("cx",function(d) {return xscale(d.x);})
        .attr("cy",function(d) {return yscale(d.y);})
        .style("fill",color)
        .style("fill-opacity",0.8)
        .style("stroke",d3.interpolateRgb(color, 'black')(0.125))
        .append("title")
        .text(function(d) { return dotInfo[Math.round(xscale(d.x))][Math.round(yscale(d.y))]; });
      g.append("svg:line")
        .attr("x1", function(d) { return xscale(d.x)+d.r; } )
        .attr("x2", function(d) { return xscale(d.x+d.y); } )
        .attr("y1", function(d) { return yscale(d.y); } )
        .attr("y2", function(d) { return yscale(d.y); } )
        .style("stroke",d3.interpolateRgb(color, 'black')(0.125))
        .style("stroke-width",2)
        .append("title")
        .text(function(d) { return dotInfo[Math.round(xscale(d.x))][Math.round(yscale(d.y))]; });
    },
    /**
     *
     * @param mapNodeLocal
     * @param mapRackLocal
     * @param mapOffSwitch
     * @param reduceOffSwitch
     * @param startTime
     * @param endTime
     * @param w
     * @param h
     * @param element
     */
    drawJobTasks:function (mapNodeLocal, mapRackLocal, mapOffSwitch, reduceOffSwitch, startTime, endTime, svgw, svgh, element) {
      var rmax = 24; // default value
      var axisHeight = 24;
      var margin = {"vertical":10, "horizontal":50};
      var w = svgw - 2*margin.horizontal;
      var h = svgh - 2*margin.vertical;
      var x = d3.time.scale.utc()
        .domain([startTime, endTime])
        .range([0, w]);
      var xrel = d3.time.scale()
        .domain([0, endTime-startTime])
        .range([0, w]);
      // create axes
      var topAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom");
      var self = this;
      var bottomAxis = d3.svg.axis()
        .scale(xrel)
        .orient("bottom")
        .tickFormat(function(d) {return self.durationFormatter(d.getTime())});

      var svg = d3.select("div#" + element).append("svg:svg")
        .attr("width", svgw+"px")
        .attr("height", svgh+"px");
      var svgg = svg.append("g")
        .attr("transform", "translate("+margin.horizontal+","+margin.vertical+")");

      svgg.append("g")
        .attr("class", "x axis top")
        .call(topAxis);
      svgg.append("g")
        .attr("class", "x axis bottom")
        .call(bottomAxis)
        .attr("transform", "translate(0,"+(h-axisHeight)+")");

      var ymax = 0;
      if (mapNodeLocal.length > 0)
        ymax = Math.max(ymax, d3.max(mapNodeLocal, function(d) { return d.y; } ));
      if (mapRackLocal.length > 0)
        ymax = Math.max(ymax, d3.max(mapRackLocal, function(d) { return d.y; } ));
      if (mapOffSwitch.length > 0)
        ymax = Math.max(ymax, d3.max(mapOffSwitch, function(d) { return d.y; } ));
      if (reduceOffSwitch.length > 0)
        ymax = Math.max(ymax, d3.max(reduceOffSwitch, function(d) { return d.y; } ));

      var y = d3.scale.linear()
        .domain([0, ymax])
        .range([h-2*axisHeight-rmax, 0]);

      var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left")
        .tickFormat(self.durationFormatter);
   
      svgg.append("svg:g")
        .attr("class", "y axis")
        .call(yAxis)
        .attr("transform", "translate(0,"+(axisHeight+rmax)+")")
        .append("text")
        .attr("transform", "rotate(-90)")
        .attr("x", -(h-2*axisHeight-rmax)/2)
        .attr("y", -margin.horizontal + 11)
        .attr("class", "axislabel")
        .text("Task Attempt Duration");


      var dotInfo = new Array();
      var mapDotInfo = function(d) {
        var thisx = Math.round(x(d.x));
        var thisy = Math.round(y(d.y));
        if (!(thisx in dotInfo))
          dotInfo[thisx] = new Array();
        var existing = dotInfo[thisx][thisy];
        var newInfo = d.label + "  \n" +
            'Run-time: ' + self.durationFormatter(d.y) + '  \nWait-time: ' + self.durationFormatter(d.x-startTime) +
            '  \nI/O: ' + self.bytesFormatter(d.io) + '  \nStatus: ' + d.status;
        if (existing)
          dotInfo[thisx][thisy] = existing + "  \n" + newInfo;
        else
          dotInfo[thisx][thisy] = newInfo;
      };

      mapNodeLocal.forEach(mapDotInfo);
      mapRackLocal.forEach(mapDotInfo);
      mapOffSwitch.forEach(mapDotInfo);
      reduceOffSwitch.forEach(mapDotInfo);

      this.addSeries(svgg, mapNodeLocal, "green", x, y, axisHeight+rmax, startTime, dotInfo);
      this.addSeries(svgg, mapRackLocal,'#66B366', x, y, axisHeight+rmax, startTime, dotInfo);
      this.addSeries(svgg, mapOffSwitch, 'brown', x, y, axisHeight+rmax, startTime, dotInfo);
      this.addSeries(svgg, reduceOffSwitch, 'steelblue', x, y, axisHeight+rmax, startTime, dotInfo);
    }
  }
  
});
window.require.register("utils/helper", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  String.prototype.trim = function () {
    return this.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
  };

  String.prototype.endsWith = function(suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
  };

  /**
   * convert ip address string to long int
   * @return {*}
   */
  String.prototype.ip2long = function () {
    // *     example 1: ip2long('192.0.34.166');
    // *     returns 1: 3221234342
    // *     example 2: ip2long('0.0xABCDEF');
    // *     returns 2: 11259375
    // *     example 3: ip2long('255.255.255.256');
    // *     returns 3: false
    var i = 0;
    // PHP allows decimal, octal, and hexadecimal IP components.
    // PHP allows between 1 (e.g. 127) to 4 (e.g 127.0.0.1) components.
    var IP = this.match(/^([1-9]\d*|0[0-7]*|0x[\da-f]+)(?:\.([1-9]\d*|0[0-7]*|0x[\da-f]+))?(?:\.([1-9]\d*|0[0-7]*|0x[\da-f]+))?(?:\.([1-9]\d*|0[0-7]*|0x[\da-f]+))?$/i); // Verify IP format.
    if (!IP) {
      return false; // Invalid format.
    }
    // Reuse IP variable for component counter.
    IP[0] = 0;
    for (i = 1; i < 5; i += 1) {
      IP[0] += !!((IP[i] || '').length);
      IP[i] = parseInt(IP[i]) || 0;
    }
    // Continue to use IP for overflow values.
    // PHP does not allow any component to overflow.
    IP.push(256, 256, 256, 256);
    // Recalculate overflow of last component supplied to make up for missing components.
    IP[4 + IP[0]] *= Math.pow(256, 4 - IP[0]);
    if (IP[1] >= IP[5] || IP[2] >= IP[6] || IP[3] >= IP[7] || IP[4] >= IP[8]) {
      return false;
    }
    return IP[1] * (IP[0] === 1 || 16777216) + IP[2] * (IP[0] <= 2 || 65536) + IP[3] * (IP[0] <= 3 || 256) + IP[4] * 1;
  };

  String.prototype.capitalize = function () {
    return this.charAt(0).toUpperCase() + this.slice(1);
  }

  Em.CoreObject.reopen({
    t:function (key, attrs) {
      return Em.I18n.t(key, attrs)
    }
  });

  Em.Handlebars.registerHelper('log', function (variable) {
    console.log(variable);
  });

  Em.Handlebars.registerHelper('warn', function (variable) {
    console.warn(variable);
  });

  Em.Handlebars.registerHelper('highlight', function (property, words, fn) {
    var context = (fn.contexts && fn.contexts[0]) || this;
    property = Em.Handlebars.getPath(context, property, fn);

    words = words.split(";");

  //  if (highlightTemplate == undefined) {
    var highlightTemplate = "<b>{0}</b>";
  //  }

    words.forEach(function (word) {
      var searchRegExp = new RegExp("\\b" + word + "\\b", "gi");
      property = property.replace(searchRegExp, function (found) {
        return highlightTemplate.format(found);
      });
    });

    return new Em.Handlebars.SafeString(property);
  })
  /**
   * Replace {i} with argument. where i is number of argument to replace with
   * @return {String}
   */
  String.prototype.format = function () {
    var args = arguments;
    return this.replace(/{(\d+)}/g, function (match, number) {
      return typeof args[number] != 'undefined' ? args[number] : match;
    });
  };

  String.prototype.highlight = function (words, highlightTemplate) {
    var self = this;
    if (highlightTemplate == undefined) {
      var highlightTemplate = "<b>{0}</b>";
    }

    words.forEach(function (word) {
      var searchRegExp = new RegExp("\\b" + word + "\\b", "gi");
      self = self.replace(searchRegExp, function (found) {
        return highlightTemplate.format(found);
      });
    });

    return self;
  };

  /**
   * Convert byte size to other metrics.
   * @param {Number} precision  Number to adjust precision of return value. Default is 0.
   * @param {String} parseType  JS method name for parse string to number. Default is "parseInt".
   * @remarks The parseType argument can be "parseInt" or "parseFloat".
   * @return {String) Returns converted value with abbreviation.
   */
  Number.prototype.bytesToSize = function (precision, parseType/* = 'parseInt' */) {
    if (arguments[1] === undefined) {
      parseType = 'parseInt';
    }

    var value = this;
    var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];
    var posttxt = 0;
    if (this == 0) return 'n/a';
    while (value >= 1024) {
      posttxt++;
      value = value / 1024;
    }
    var parsedValue = window[parseType](value);

    return parsedValue.toFixed(precision) + " " + sizes[posttxt];
  }

  Number.prototype.toDaysHoursMinutes = function () {
    var formatted = {},
      dateDiff = this,
      secK = 1000, //ms
      minK = 60 * secK, // sec
      hourK = 60 * minK, // sec
      dayK = 24 * hourK;

    dateDiff = parseInt(dateDiff);
    formatted.d = Math.floor(dateDiff / dayK);
    dateDiff -= formatted.d * dayK;
    formatted.h = Math.floor(dateDiff / hourK);
    dateDiff -= formatted.h * hourK;
    formatted.m = (dateDiff / minK).toFixed(2);

    return formatted;
  }

  Number.prototype.countPercentageRatio = function (maxValue) {
    var usedValue = this;
    return Math.round((usedValue / maxValue) * 100) + "%";
  }

  Number.prototype.long2ip = function () {
    // http://kevin.vanzonneveld.net
    // +   original by: Waldo Malqui Silva
    // *     example 1: long2ip( 3221234342 );
    // *     returns 1: '192.0.34.166'
    if (!isFinite(this))
      return false;

    return [this >>> 24, this >>> 16 & 0xFF, this >>> 8 & 0xFF, this & 0xFF].join('.');
  }

  /**
   * Formats the given URL template by replacing keys in 'substitutes'
   * with their values. If not in App.testMode, the testUrl is used.
   *
   * The substitution points in urlTemplate should be of format "...{key}..."
   * For example "http://apache.org/{projectName}".
   * The substitutes can then be{projectName: "Ambari"}.
   *
   * Keys which will be automatically taken care of are:
   * {
   *  hostName: App.test_hostname,
   *  fromSeconds: ..., // 1 hour back from now
   *  toSeconds: ..., // now
   *  stepSeconds: ..., // 15 seconds by default
   * }
   *
   * @param {String} urlTemplate  URL template on which substitutions are to be made
   * @param substitutes Object containing keys to be replaced with respective values
   * @param {String} testUrl  URL to be used if app is not in test mode (!App.testMode)
   * @return {String} Formatted URL
   */
  App = require('app');

  App.formatUrl = function (urlTemplate, substitutes, testUrl) {
    var formatted = urlTemplate;
    if (urlTemplate) {
      if (!App.testMode) {
        var toSeconds = Math.round(new Date().getTime() / 1000);
        var allSubstitutes = {
          toSeconds:toSeconds,
          fromSeconds:toSeconds - 3600, // 1 hour back
          stepSeconds:15, // 15 seconds
          hostName:App.test_hostname
        };
        jQuery.extend(allSubstitutes, substitutes);
        for (key in allSubstitutes) {
          var useKey = '{' + key + '}';
          formatted = formatted.replace(new RegExp(useKey, 'g'), allSubstitutes[key]);
        }
      } else {
        formatted = testUrl;
      }
    }
    return formatted;
  }

  /**
   * Certain variables can have JSON in string
   * format, or in JSON format itself.
   */
  App.parseJSON = function (value) {
    if (typeof value == "string") {
      return jQuery.parseJSON(value);
    }
    return value;
  };

  App.format = {
    role:function (role) {
      switch (role) {
        case 'ZOOKEEPER_SERVER':
          return 'ZooKeeper Server';
        case 'ZOOKEEPER_CLIENT':
          return 'ZooKeeper Client';
        case 'NAMENODE':
          return 'NameNode';
        case 'NAMENODE_SERVICE_CHECK':
          return 'NameNode Check';
        case 'DATANODE':
          return 'DataNode';
        case 'HDFS_SERVICE_CHECK':
          return 'HDFS Check';
        case 'SECONDARY_NAMENODE':
          return 'SNameNode';
        case 'HDFS_CLIENT':
          return 'HDFS Client';
        case 'HBASE_MASTER':
          return 'HBase Master';
        case 'HBASE_REGIONSERVER':
          return 'HBase RegionServer';
        case 'HBASE_CLIENT':
          return 'HBase Client';
        case 'JOBTRACKER':
          return 'JobTracker';
        case 'TASKTRACKER':
          return 'TaskTracker';
        case 'MAPREDUCE_CLIENT':
          return 'MapReduce Client';
        case 'HISTORYSERVER':
          return 'History Server';
        case 'NODEMANAGER':
          return 'Node Manager';
        case 'RESOURCEMANAGER':
          return 'Resource Manager';
        case 'TEZ_CLIENT':
          return 'Tez Client';
        case 'MAPREDUCE2_CLIENT':
          return 'MapReduce2 Client';
        case 'YARN_CLIENT':
          return 'YARN Client';
        case 'JAVA_JCE':
          return 'Java JCE';
        case 'KERBEROS_SERVER':
          return 'Kerberos Server';
        case 'KERBEROS_CLIENT':
          return 'Kerberos Client';
        case 'KERBEROS_ADMIN_CLIENT':
          return 'Kerberos Admin Client';
        case 'HADOOP_CLIENT':
          return 'Hadoop Client';
        case 'JOBTRACKER_SERVICE_CHECK':
          return 'JobTracker Check';
        case 'MAPREDUCE_SERVICE_CHECK':
          return 'MapReduce Check';
        case 'ZOOKEEPER_SERVICE_CHECK':
          return 'ZooKeeper Check';
        case 'ZOOKEEPER_QUORUM_SERVICE_CHECK':
          return 'ZK Quorum Check';
        case  'HBASE_SERVICE_CHECK':
          return 'HBase Check';
        case 'MYSQL_SERVER':
          return 'MySQL Server';
        case 'HIVE_SERVER':
          return 'HiveServer2';
        case 'HIVE_METASTORE':
          return 'Hive Metastore';
        case 'HIVE_CLIENT':
          return 'Hive Client';
        case 'HIVE_SERVICE_CHECK':
          return 'Hive Check';
        case 'HCAT':
          return 'HCat';
        case 'HCAT_SERVICE_CHECK':
          return 'HCat Check';
        case 'OOZIE_CLIENT':
          return 'Oozie Client';
        case 'OOZIE_SERVER':
          return 'Oozie Server';
        case 'OOZIE_SERVICE_CHECK':
          return 'Oozie Check';
        case 'PIG':
          return 'Pig';
        case 'PIG_SERVICE_CHECK':
          return 'Pig Check';
        case 'SQOOP':
          return 'Sqoop';
        case 'SQOOP_SERVICE_CHECK':
          return 'Sqoop Check';
        case 'WEBHCAT_SERVER':
          return 'WebHCat Server';
        case 'WEBHCAT_SERVICE_CHECK':
          return 'WebHCat Check';
        case 'NAGIOS_SERVER':
          return 'Nagios Server';
        case 'GANGLIA_SERVER':
          return 'Ganglia Server';
        case 'GANGLIA_MONITOR':
          return 'Ganglia Monitor';
        case 'GMOND_SERVICE_CHECK':
          return 'Gmond Check';
        case 'GMETAD_SERVICE_CHECK':
          return 'Gmetad Check';
        case 'DECOMMISSION_DATANODE':
          return 'Update Exclude File';
        case 'HUE_SERVER':
          return 'Hue Server';
        case 'HCFS_CLIENT':
          return 'HCFS Client';
        case 'HCFS_SERVICE_CHECK':
          return 'HCFS Service Check';
        case 'FLUME_SERVER':
          return 'Flume Agent';
      }
    },

    /**
     * PENDING - Not queued yet for a host
     * QUEUED - Queued for a host
     * IN_PROGRESS - Host reported it is working
     * COMPLETED - Host reported success
     * FAILED - Failed
     * TIMEDOUT - Host did not respond in time
     * ABORTED - Operation was abandoned
     */
    taskStatus:function (_taskStatus) {
      return _taskStatus.toLowerCase();
    }
  };
  
});
window.require.register("utils/host_progress_popup", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  /**
   * App.HostPopup is for the popup that shows up upon clicking already-performed or currently-in-progress operations
   */
  App.HostPopup = Em.Object.create({

    servicesInfo: null,
    hosts: null,
    inputData: null,
    serviceName: "",
    currentServiceId: null,
    popupHeaderName: "",
    serviceController: null,
    showServices: false,
    currentHostName: null,

    /**
     * Sort object array
     * @param array
     * @param p
     * @return {*}
     */
    sortArray: function (array, p) {
      return array.sort(function (a, b) {
        return (a[p] > b[p]) ? 1 : (a[p] < b[p]) ? -1 : 0;
      });
    },

    /**
     * Entering point of this component
     * @param serviceName
     * @param controller
     * @param showServices
     */
    initPopup: function (serviceName, controller, showServices) {
      this.set("serviceName", serviceName);
      this.set("serviceController", controller);
      if (!showServices) {
        this.set("popupHeaderName", serviceName);
      }
      this.set("showServices", showServices);
      this.set("inputData", this.get("serviceController.services"));
      if(this.get('showServices')){
        this.onServiceUpdate();
      } else {
        this.onHostUpdate();
      }
      return this.createPopup();
    },

    /**
     * Depending on tasks status
     * @param tasks
     * @return {Array} [Status, Icon type, Progressbar color, is IN_PROGRESS]
     */
    getStatus: function(tasks){
      var isCompleted = true;
      var status;
      var tasksLength = tasks.length;
      var isFailed = false;
      var isAborted = false;
      var isTimedout = false;
      var isInProgress = false;
      for (var i = 0; i < tasksLength; i++) {
        if (tasks[i].Tasks.status !== 'COMPLETED') {
          isCompleted = false;
        }
        if(tasks[i].Tasks.status === 'FAILED'){
          isFailed = true;
        }
        if (tasks[i].Tasks.status === 'ABORTED') {
          isAborted = true;
        }
        if (tasks[i].Tasks.status === 'TIMEDOUT') {
          isTimedout = true;
        }
        if (tasks[i].Tasks.status === 'IN_PROGRESS') {
          isInProgress = true;
        }
      }
      if (isFailed) {
        status = ['FAILED', 'icon-exclamation-sign', 'progress-danger', false];
      } else if (isAborted) {
        status = ['CANCELLED', 'icon-minus', 'progress-warning', false];
      } else if (isTimedout) {
        status = ['TIMEDOUT', 'icon-time', 'progress-warning', false];
      } else if (isInProgress) {
        status = ['IN_PROGRESS', 'icon-cogs', 'progress-info', true];
      }
      if(status){
        return status;
      } else if(isCompleted){
        return ['SUCCESS', 'icon-ok', 'progress-success', false];
      } else {
        return ['PENDING', 'icon-cog', 'progress-info', true];
      }
    },

    /**
     * Progress of host or service depending on tasks status
     * @param tasks
     * @return {Number} percent of completion
     */
    getProgress: function (tasks) {
      var completedActions = 0;
      var queuedActions = 0;
      var inProgressActions = 0;
      tasks.forEach(function(task){
        if(['COMPLETED', 'FAILED', 'ABORTED', 'TIMEDOUT'].contains(task.Tasks.status)){
          completedActions++;
        } else if(task.Tasks.status === 'QUEUED'){
          queuedActions++;
        } else if(task.Tasks.status === 'IN_PROGRESS'){
          inProgressActions++;
        }
      });
      return Math.ceil(((queuedActions * 0.09) + (inProgressActions * 0.35) + completedActions ) / tasks.length * 100);
    },
    /**
     * Count number of operations for select box options
     * @param obj
     * @param categories
     */
    setSelectCount: function (obj, categories) {
      if (!obj) return;
      var countAll = obj.length;
      var countPending = 0;
      var countInProgress = 0;
      var countFailed = 0;
      var countCompleted = 0;
      var countAborted = 0;
      var countTimedout = 0;
      obj.forEach(function(item){
        switch (item.status){
          case 'pending':
            countPending++;
            break;
          case 'queued':
            countPending++;
            break;
          case 'in_progress':
            countInProgress++;
            break;
          case 'failed':
            countFailed++;
            break;
          case 'success':
            countCompleted++;
            break;
          case 'completed':
            countCompleted++;
            break;
          case 'aborted':
            countAborted++;
            break;
          case 'timedout':
            countTimedout++;
            break;
        }
      }, this);

      categories.findProperty("value", 'all').set("count", countAll);
      categories.findProperty("value", 'pending').set("count", countPending);
      categories.findProperty("value", 'in_progress').set("count", countInProgress);
      categories.findProperty("value", 'failed').set("count", countFailed);
      categories.findProperty("value", 'completed').set("count", countCompleted);
      categories.findProperty("value", 'aborted').set("count", countAborted);
      categories.findProperty("value", 'timedout').set("count", countTimedout);
    },

    /**
     * For Background operation popup calculate number of running Operations, and set popup header
     */
    setBackgroundOperationHeader: function () {
      if (this.get("showServices")) {
        var allServices = this.get("servicesInfo");
        var numRunning = 0;
        numRunning = allServices.filterProperty("status", App.format.taskStatus("IN_PROGRESS")).length;
        numRunning += allServices.filterProperty("status", App.format.taskStatus("QUEUED")).length;
        numRunning += allServices.filterProperty("status", App.format.taskStatus("PENDING")).length;
        this.set("popupHeaderName", numRunning + Em.I18n.t('hostPopup.header.postFix'));
      }else{
        this.set("popupHeaderName", this.get("serviceName"));
      }
    },

    /**
     * Create services obj data structure for popup
     * Set data for services
     */
    onServiceUpdate: function () {
      if (this.get('showServices') && this.get("inputData")) {
        var self = this;
        var allNewServices = [];
        this.set("servicesInfo", null);
        this.get("inputData").forEach(function (service) {
          var newService = Ember.Object.create({
            id: service.id,
            displayName: service.displayName,
            detailMessage: service.detailMessage,
            message: service.message,
            progress: 0,
            status: App.format.taskStatus("PENDING"),
            name: service.name,
            isVisible: true,
            icon: 'icon-cog',
            barColor: 'progress-info',
            barWidth: 'width:0%;'
          });
          var allTasks = [];
          service.hosts.forEach(function (tasks) {
            tasks.logTasks.forEach(function (task) {
              allTasks.push(task);
            });
          });
          if (allTasks.length > 0) {
            var status = self.getStatus(allTasks);
            var progress = self.getProgress(allTasks);
            newService.set('status', App.format.taskStatus(status[0]));
            newService.set('icon', status[1]);
            newService.set('barColor', status[2]);
            newService.set('isInProgress', status[3]);
            newService.set('progress', progress);
            newService.set('barWidth', "width:" + progress + "%;");
          }
          allNewServices.push(newService);
        });
        self.set('servicesInfo', allNewServices);
        if (this.get("serviceName") == "") this.setBackgroundOperationHeader();
      }
    },

    /**
     * update icon of task depending on its status
     * @param taskInfo
     */
    updateTaskIcon: function(taskInfo){
      if (taskInfo.get('status') == 'pending' || taskInfo.get('status') == 'queued') {
        taskInfo.set('icon', 'icon-cog');
      } else if (taskInfo.get('status') == 'in_progress') {
        taskInfo.set('icon', 'icon-cogs');
      } else if (taskInfo.get('status') == 'completed') {
        taskInfo.set('icon', ' icon-ok');
      } else if (taskInfo.get('status') == 'failed') {
        taskInfo.set('icon', 'icon-exclamation-sign');
      } else if (taskInfo.get('status') == 'aborted') {
        taskInfo.set('icon', 'icon-minus');
      } else if (taskInfo.get('status') == 'timedout') {
        taskInfo.set('icon', 'icon-time');
      }
    },
    /**
     * Create hosts and tasks data structure for popup
     * Set data for hosts and tasks
     */
    onHostUpdate: function () {
      var self = this;
      if (this.get("inputData")) {
        var hostsArr = [];
        var hostsData = this.get("inputData");
        var hosts = [];
        if (this.get("showServices") && this.get("serviceName") == "") {
          hostsData.forEach(function (service) {
            var host = service.hosts;
            host.setEach("serviceName", service.name);
            hosts.push.apply(hosts, host);
          });
        } else {
          if (this.get("currentServiceId") != null) {
            hostsData = hostsData.findProperty("id", this.get("currentServiceId"));
          }
          else {
            hostsData = hostsData.findProperty("name", this.get("serviceName"));
          }

          if (hostsData && hostsData.hosts) {
            hosts = hostsData.hosts;
          }

          hosts.setEach("serviceName", this.get("serviceName"));
        }

        var existedHosts = self.get('hosts');

        if (hosts) {
          if (existedHosts && existedHosts.length === hosts.length) {
            existedHosts.forEach(function (host) {
              var newHostInfo = hosts.findProperty('name', host.get('name'));
              if (newHostInfo) {
                var hostStatus = self.getStatus(newHostInfo.logTasks);
                var hostProgress = self.getProgress(newHostInfo.logTasks);
                host.set('status', App.format.taskStatus(hostStatus[0]));
                host.set('icon', hostStatus[1]);
                host.set('barColor', hostStatus[2]);
                host.set('isInProgress', hostStatus[3]);
                host.set('progress', hostProgress);
                host.set('barWidth', "width:" + hostProgress + "%;");
                var existTasks = host.get('tasks');
                var newTasks = newHostInfo.logTasks;
                if (existTasks && newTasks && existTasks.length == newTasks.length) {
                  // Same number of source and destinations
                  var existTaskMap = {};
                  var newTaskMap = {};
                  host.get('tasks').forEach(function (taskInfo) {
                    var id = taskInfo.get('id');
                    existTaskMap[id] = taskInfo;
                  });
                  var newTasksArray = [];
                  newTasks.forEach(function (newTask) {
                    var existTask = existTaskMap[newTask.Tasks.id];
                    if (existTask) {
                      // reuse
                      existTask.set('status', App.format.taskStatus(newTask.Tasks.status));
                      existTask.set('stderr', newTask.Tasks.stderr);
                      existTask.set('stdout', newTask.Tasks.stdout);
                      self.updateTaskIcon(existTask);
                      delete existTaskMap[newTask.Tasks.id];
                    } else {
                      // create new
                      var taskInfo = Ember.Object.create({
                        id: newTask.Tasks.id,
                        hostName: newHostInfo.publicName,
                        command: newTask.Tasks.command.toLowerCase(),
                        status: App.format.taskStatus(newTask.Tasks.status),
                        role: App.format.role(newTask.Tasks.role),
                        stderr: newTask.Tasks.stderr,
                        stdout: newTask.Tasks.stdout,
                        isVisible: true,
                        icon: 'icon-cogs'
                      });
                      self.updateTaskIcon(taskInfo);
                      newTasksArray.push(taskInfo);
                    }
                  });
                  for (var id in existTaskMap) {
                    host.get('tasks').removeObject(existTaskMap[id]);
                  }
                  if (newTasksArray.length) {
                    host.get('tasks').pushObjects(newTasksArray);
                  }
                } else {
                  // Tasks have changed
                  var tasksArr = [];
                  newTasks.forEach(function (newTask) {
                    var taskInfo = Ember.Object.create({
                      id: newTask.Tasks.id,
                      hostName: newHostInfo.publicName,
                      command: newTask.Tasks.command.toLowerCase(),
                      status: App.format.taskStatus(newTask.Tasks.status),
                      role: App.format.role(newTask.Tasks.role),
                      stderr: newTask.Tasks.stderr,
                      stdout: newTask.Tasks.stdout,
                      isVisible: true,
                      icon: 'icon-cogs'
                    });
                    self.updateTaskIcon(taskInfo);
                    tasksArr.push(taskInfo);
                  });
                  host.set('tasks', tasksArr);
                }
              }
            }, this);
          } else {

            //sort hosts by name
            this.sortArray(hosts, "name");

            hosts.forEach(function (_host) {
              var tasks = _host.logTasks;
              var hostInfo = Ember.Object.create({
                name: _host.name,
                publicName: _host.publicName,
                progress: 0,
                status: App.format.taskStatus("PENDING"),
                serviceName: _host.serviceName,
                isVisible: true,
                icon: "icon-cog",
                barColor: "progress-info",
                barWidth: "width:0%;"
              });

              var tasksArr = [];

              if (tasks.length) {
                tasks = self.sortTasksById(tasks);
                var hostStatus = self.getStatus(tasks);
                var hostProgress = self.getProgress(tasks);
                hostInfo.set('status', App.format.taskStatus(hostStatus[0]));
                hostInfo.set('icon', hostStatus[1]);
                hostInfo.set('barColor', hostStatus[2]);
                hostInfo.set('isInProgress', hostStatus[3]);
                hostInfo.set('progress', hostProgress);
                hostInfo.set('barWidth', "width:" + hostProgress + "%;");

                tasks.forEach(function (_task) {
                  var taskInfo = Ember.Object.create({
                    id: _task.Tasks.id,
                    hostName: _host.publicName,
                    command: _task.Tasks.command.toLowerCase(),
                    status: App.format.taskStatus(_task.Tasks.status),
                    role: App.format.role(_task.Tasks.role),
                    stderr: _task.Tasks.stderr,
                    stdout: _task.Tasks.stdout,
                    isVisible: true,
                    icon: 'icon-cogs'
                  });
                  this.updateTaskIcon(taskInfo);
                  tasksArr.push(taskInfo);
                }, this);
              }

              hostInfo.set('tasks', tasksArr);
              hostsArr.push(hostInfo);
            }, this);
            self.set("hosts", hostsArr);
          }
        }
      }
    },

    /**
     * Sort tasks by it`s id
     * @param tasks
     * @return {Array}
     */
    sortTasksById: function (tasks) {
      return tasks.sort(function (a, b) {
        return (a.Tasks.id > b.Tasks.id) ? 1 : (a.Tasks.id < b.Tasks.id) ? -1 : 0;
      });
    },

    /**
     * Show popup
     * @return PopupObject For testing purposes
     */
    createPopup: function () {
      var self = this;
      var hostsInfo = this.get("hosts");
      var servicesInfo = this.get("servicesInfo");
      var showServices = this.get('showServices');
      var categoryObject = Em.Object.extend({
        value: '',
        count: 0,
        labelPath: '',
        label: function(){
          return Em.I18n.t(this.get('labelPath')).format(this.get('count'));
        }.property('count')
      });
      return App.ModalPopup.show({
        //no need to track is it loaded when popup contain only list of hosts
        isLoaded: !showServices,
        isOpen: false,
        didInsertElement: function(){
          this.set('isOpen', true);
        },
        headerClass: Ember.View.extend({
          controller: this,
          template: Ember.Handlebars.compile('{{popupHeaderName}}')
        }),
        classNames: ['sixty-percent-width-modal'],
        autoHeight: false,
        closeModelPopup: function () {
          this.set('isOpen', false);
          if(showServices){
            $(this.get('element')).detach();
          } else {
            this.hide();
          }
        },
        onPrimary: function () {
          this.closeModelPopup();
        },
        onClose: function () {
          this.closeModelPopup();
        },
        secondary: null,

        bodyClass: Ember.View.extend({
          templateName: require('templates/common/host_progress_popup'),
          isLogWrapHidden: true,
          isTaskListHidden: true,
          isHostListHidden: true,
          isServiceListHidden: false,
          showTextArea: false,
          isServiceEmptyList: true,
          isHostEmptyList: true,
          isTasksEmptyList: true,
          controller: this,
          hosts: self.get("hosts"),
          services: self.get('servicesInfo'),

          tasks: function () {
            if (!this.get('controller.currentHostName')) return [];
            if (this.get('hosts') && this.get('hosts').length) {
              var currentHost = this.get('hosts').findProperty('name', this.get('controller.currentHostName'));
              if (currentHost) {
                return currentHost.get('tasks');
              }
            }
            return [];
          }.property('hosts.@each.tasks', 'hosts.@each.tasks.@each.status'),

          didInsertElement: function () {
            this.setOnStart();
          },

          /**
           * Preset values on init
           */
          setOnStart: function () {
            if (this.get("controller.showServices")) {
              this.get('controller').setSelectCount(this.get("services"), this.get('categories'));
            } else {
              this.set("isHostListHidden", false);
              this.set("isServiceListHidden", true);
            }
          },

          /**
           * force popup to show list of operations
           */
          resetState: function(){
            if(this.get('parentView.isOpen')){
              this.set('isLogWrapHidden', true);
              this.set('isTaskListHidden', true);
              this.set('isHostListHidden', true);
              this.set('isServiceListHidden', false);
              this.get("controller").setBackgroundOperationHeader();
              this.setOnStart();
            }
          }.observes('parentView.isOpen'),

          /**
           * When popup is opened, and data after polling has changed, update this data in component
           */
          updateHostInfo: function () {
            if(!this.get('parentView.isOpen')) return;
            this.set('parentView.isLoaded', false);
            this.get("controller").set("inputData", this.get("controller.serviceController.services"));
            this.get("controller").onServiceUpdate();
            this.get("controller").onHostUpdate();
            this.set('parentView.isLoaded', true);
            this.set("hosts", this.get("controller.hosts"));
            this.set("services", this.get("controller.servicesInfo"));
          }.observes("controller.serviceController.serviceTimestamp"),

          /**
           * Depending on service filter, set which services should be shown
           */
          visibleServices: function () {
            if (this.get("services")) {
              this.set("isServiceEmptyList", true);
              if (this.get('serviceCategory.value')) {
                var filter = this.get('serviceCategory.value');
                var services = this.get('services');
                this.setVisability(filter, services);
                if (services.filterProperty("isVisible", true).length > 0) {
                  this.set("isServiceEmptyList", false);
                }
              }
            }
          }.observes('serviceCategory', 'services'),

          /**
           * Depending on hosts filter, set which hosts should be shown
           */
          visibleHosts: function () {
            this.set("isHostEmptyList", true);
            if (this.get('hostCategory.value') && this.get('hosts')) {
              var filter = this.get('hostCategory.value');
              var hosts = this.get('hosts');
              this.setVisability(filter, hosts);
              if (hosts.filterProperty("isVisible", true).length > 0) {
                this.set("isHostEmptyList", false);
              }
            }
          }.observes('hostCategory', 'hosts'),

          /**
           * Depending on tasks filter, set which tasks should be shown
           */
          visibleTasks: function () {
            this.set("isTasksEmptyList", true);
            if (this.get('taskCategory.value') && this.get('tasks')) {
              var filter = this.get('taskCategory.value');
              var tasks = this.get('tasks');
              this.setVisability(filter, tasks);
              if (tasks.filterProperty("isVisible", true).length > 0) {
                this.set("isTasksEmptyList", false);
              }
            }
          }.observes('taskCategory', 'tasks'),

          /**
           * Depending on selected filter type, set object visibility value
           * @param filter
           * @param obj
           */
          setVisability: function (filter, obj) {
            obj.setEach("isVisible", false);
            if (filter == "all") {
              obj.setEach("isVisible", true);
            }
            else if (filter == "pending") {
              obj.filterProperty("status", "pending").setEach("isVisible", true);
              obj.filterProperty("status", "queued").setEach("isVisible", true);
            }
            else if (filter == "in_progress") {
              obj.filterProperty("status", "in_progress").setEach("isVisible", true);
              obj.filterProperty("status", "upgrading").setEach("isVisible", true);
            }
            else if (filter == "failed") {
              obj.filterProperty("status", "failed").setEach("isVisible", true);
            }
            else if (filter == "completed") {
              obj.filterProperty("status", "completed").setEach("isVisible", true);
              obj.filterProperty("status", "success").setEach("isVisible", true);
            }
            else if (filter == "aborted") {
              obj.filterProperty("status", "aborted").setEach("isVisible", true);
            }
            else if (filter == "timedout") {
              obj.filterProperty("status", "timedout").setEach("isVisible", true);
            }
          },

          /**
           * Select box, display names and values
           */
          categories: [
            categoryObject.create({value: 'all', labelPath: 'hostPopup.status.category.all'}),
            categoryObject.create({value: 'pending', labelPath: 'hostPopup.status.category.pending'}),
            categoryObject.create({value: 'in_progress', labelPath: 'hostPopup.status.category.inProgress'}),
            categoryObject.create({value: 'failed', labelPath: 'hostPopup.status.category.failed'}),
            categoryObject.create({value: 'completed', labelPath: 'hostPopup.status.category.success'}),
            categoryObject.create({value: 'aborted', labelPath: 'hostPopup.status.category.aborted'}),
            categoryObject.create({value: 'timedout', labelPath: 'hostPopup.status.category.timedout'})
          ],

          /**
           * Selected option is binded to this values
           */
          serviceCategory: null,
          hostCategory: null,
          taskCategory: null,

          /**
           * Depending on currently viewed tab, call setSelectCount function
           */
          updateSelectView: function () {
            if (!this.get('isHostListHidden')) {
              this.get('controller').setSelectCount(this.get("hosts"), this.get('categories'));
            } else if (!this.get('isTaskListHidden')) {
              this.get('controller').setSelectCount(this.get("tasks"), this.get('categories'));
            } else if (!this.get('isServiceListHidden')) {
              this.get('controller').setSelectCount(this.get("services"), this.get('categories'));
            }
          }.observes('hosts', 'isTaskListHidden', 'isHostListHidden'),

          /**
           * Onclick handler for button <-Tasks
           * @param event
           * @param context
           */
          backToTaskList: function (event, context) {
            this.destroyClipBoard();
            this.set("openedTaskId", 0);
            this.set("isLogWrapHidden", true);
            this.set("isTaskListHidden", false);
          },

          /**
           * Onclick handler for button <-Hosts
           * @param event
           * @param context
           */
          backToHostList: function (event, context) {
            this.set("isHostListHidden", false);
            this.set("isTaskListHidden", true);
            this.set("tasks", null);
            this.get("controller").set("popupHeaderName", this.get("controller.serviceName"));
          },

          /**
           * Onclick handler for button <-Services
           * @param event
           * @param context
           */
          backToServiceList: function (event, context) {
            this.get("controller").set("serviceName", "");
            this.set("isHostListHidden", true);
            this.set("isServiceListHidden", false);
            this.set("isTaskListHidden", true);
            this.set("tasks", null);
            this.set("hosts", null);
            this.get("controller").setBackgroundOperationHeader();
          },

          /**
           * Onclick handler for selected Service
           * @param event
           * @param context
           */
          gotoHosts: function (event, context) {
            this.get("controller").set("serviceName", event.context.get("name"));
            this.get("controller").set("currentServiceId", event.context.get("id"));
            this.get("controller").onHostUpdate();
            var servicesInfo = this.get("controller.hosts");
            if (servicesInfo.length) {
              this.get("controller").set("popupHeaderName", event.context.get("name"));
            }
            this.set('hosts', servicesInfo);
            this.set("isServiceListHidden", true);
            this.set("isHostListHidden", false);
            $(".modal").scrollTop(0);
            $(".modal-body").scrollTop(0);
          },

          /**
           * Onclick handler for selected Host
           * @param event
           * @param context
           */
          gotoTasks: function (event, context) {
            var taskInfo = event.context.tasks;
            if (taskInfo.length) {
              this.get("controller").set("popupHeaderName", taskInfo.objectAt(0).hostName);
              this.get("controller").set("currentHostName", taskInfo.objectAt(0).hostName);
            }
            this.set('tasks', taskInfo);
            this.set("isHostListHidden", true);
            this.set("isTaskListHidden", false);
            $(".modal").scrollTop(0);
            $(".modal-body").scrollTop(0);
          },

          /**
           * Onclick handler for selected Task
           */
          openTaskLogInDialog: function () {
            var newWindow = window.open();
            var newDocument = newWindow.document;
            newDocument.write($(".task-detail-log-info").html());
            newDocument.close();
          },

          openedTaskId: 0,

          /**
           * Return task detail info of opened task
           */
          openedTask: function () {
            if (!this.get('openedTaskId')) {
              return Ember.Object.create();
            }
            return this.get('tasks').findProperty('id', this.get('openedTaskId'));
          }.property('tasks', 'tasks.@each.stderr', 'tasks.@each.stdout', 'openedTaskId'),

          /**
           * Onclick event for show task detail info
           * @param event
           * @param context
           */
          toggleTaskLog: function (event, context) {
            var taskInfo = event.context;
            this.set("isLogWrapHidden", false);
            this.set("isHostListHidden", true);
            this.set("isTaskListHidden", true);
            this.set('openedTaskId', taskInfo.id);
            $(".modal").scrollTop(0);
            $(".modal-body").scrollTop(0);
          },

          /**
           * Onclick event for copy to clipboard button
           * @param event
           */
          textTrigger: function (event) {
            if ($(".task-detail-log-clipboard").length > 0) {
              this.destroyClipBoard();
            } else {
              this.createClipBoard();
            }
          },

          /**
           * Create Clip Board
           */
          createClipBoard: function () {
            $(".task-detail-log-clipboard-wrap").html('<textarea class="task-detail-log-clipboard"></textarea>');
            $(".task-detail-log-clipboard")
              .html("stderr: \n" + $(".stderr").html() + "\n stdout:\n" + $(".stdout").html())
              .css("display", "block")
              .width($(".task-detail-log-maintext").width())
              .height($(".task-detail-log-maintext").height())
              .select();
            $(".task-detail-log-maintext").css("display", "none")
          },

          /**
           * Destroy Clip Board
           */
          destroyClipBoard: function () {
            $(".task-detail-log-clipboard").remove();
            $(".task-detail-log-maintext").css("display", "block");
          }
        })
      });
    }

  });

  
});
window.require.register("utils/http_client", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  /**
   * App.HttpClient perform an ajax request
   */
  App.HttpClient = Em.Object.create({

    /**
     *
     * @param jqXHR
     * @param textStatus
     * @param errorThrown
     */
    defaultErrorHandler: function (jqXHR, textStatus, errorThrown) {
      var json = $.parseJSON(jqXHR.responseText);
      if (json) {
        Em.assert("HttpClient:", json);
      } else {
        Em.assert("HttpClient:", errorThrown);
      }
    },

    emptyFunc: function () {
    },

    /**
     * @param {string} url
     * @param {Object} ajaxOptions
     * @param {App.ServerDataMapper} mapper - json processor
     * @param {function} errorHandler
     */
    request: function (url, ajaxOptions, mapper, errorHandler) {

      if (!errorHandler) {
        errorHandler = this.defaultErrorHandler;
      }

      var xhr = new XMLHttpRequest();
      var curTime = new Date().getTime();

      xhr.open('GET', url + (url.indexOf('?') >= 0 ? '&_=' : '?_=') + curTime, true);
      xhr.send(null);

      this.onReady(xhr, "", ajaxOptions, mapper, errorHandler);
    },

    /*
     This function checks if we get response from server
     Not using onreadystatechange cuz of possible closure
     */
    onReady: function (xhr, tm, tmp_val, mapper, errorHandler) {
      var self = this;
      clearTimeout(tm);
      var timeout = setTimeout(function () {
        if (xhr.readyState == 4) {
          if (xhr.status == 200) {
            try {
              App.store.commit();
            } catch (err) {}
            mapper.map($.parseJSON(xhr.responseText));
            tmp_val.complete.call(self);
            xhr.abort();
          } else {
            errorHandler(xhr , "error", xhr.statusText);
          }

          tmp_val = null;
          xhr = self.emptyFunc();
          clearTimeout(timeout);
          timeout = null;

        } else {
          self.onReady(xhr, timeout, tmp_val, mapper, errorHandler);
        }
      }, 10);
    },

    /**
     * @param {string} url
     * @param {App.ServerDataMapper} mapper - json processor
     * @param {Object} data - ajax data property
     * @param {function} errorHandler
     * @param {number} interval - frequency request
     */
    get: function (url, mapper, data, errorHandler, interval) {
      var eHandler = data.complete
      if (!errorHandler && data.error) {
        errorHandler = data.error;
      }
      var client = this;
      var request = function () {
        client.request(url, data, mapper, errorHandler);
        url=null;
        data=null;
        mapper=null;
        errorHandler=null;
      }

      interval = "" + interval;
      if (interval.match(/\d+/)) {
        $.periodic({period: interval}, request);
      } else {
        request();
      }
    },

    /**
     * @param {string} url
     * @param {Object} data - ajax data property
     * @param {App.ServerDataMapper} mapper - json processor
     * @param {function} errorHandler
     * @param {number} interval - frequecy request
     */
    post: function (url, data, mapper, errorHandler, interval) {
      this.get(url, data, mapper, errorHandler, interval);
    }
  });
  
});
window.require.register("utils/misc", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  module.exports = {
    /**
     * Convert value from bytes to appropriate measure
     */
    formatBandwidth: function (value) {
      if (value) {
        if (value < 1024) {
          value = '<1KB';
        } else {
          if (value < 1048576) {
            value = (value / 1024).toFixed(1) + 'KB';
          } else  if (value >= 1048576 && value < 1073741824){
            value = (value / 1048576).toFixed(1) + 'MB';
          } else {
            value = (value / 1073741824).toFixed(2) + 'GB';
          }
        }
      }
      return value;
    },
    /**
     * Convert ip address to integer
     * @param ip
     * @return integer
     */
    ipToInt: function(ip){
      // *     example 1: ipToInt('192.0.34.166');
      // *     returns 1: 3221234342
      // *     example 2: ipToInt('255.255.255.256');
      // *     returns 2: false
      // Verify IP format.
      if (!/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ip)) {
        return false; // Invalid format.
      }
      // Reuse ip variable for component counter.
      var d = ip.split('.');
      return ((((((+d[0])*256)+(+d[1]))*256)+(+d[2]))*256)+(+d[3]);
    }
  };
  
});
window.require.register("utils/polling", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  App.Poll = Em.Object.extend({
    name: '',
    stage: '',
    label: '',
    isStarted: false,
    isPolling: true,
    clusterName: null,
    requestId: undefined,
    temp: false,
    progress: 0,
    url: null,
    testUrl: null,
    data: null,
    isError: false,
    isSuccess: false,
    POLL_INTERVAL: 4000,
    polledData: [],
    numPolls: 0,
    mockDataPrefix: '/data/wizard/deploy/5_hosts',

    barWidth: function () {
      var barWidth = 'width: ' + this.get('progress') + '%;';
      return barWidth;
    }.property('progress'),

    isCompleted: function () {
      return (this.get('isError') || this.get('isSuccess'));
    }.property('isError', 'isSuccess'),

    showLink: function () {
      return (this.get('isPolling') === true && this.get('isStarted') === true);
    }.property('isPolling', 'isStarted'),

    start: function () {
      if (this.get('requestId') === undefined) {
        this.setRequestId();
      } else {
        this.startPolling();
      }
    },

    setRequestId: function () {
      if (App.testMode) {
        this.set('requestId', '1');
        this.doPolling();
        return;
      }
      var self = this;
      var url = this.get('url');
      var method = 'PUT';
      var data = this.get('data');

      $.ajax({
        type: method,
        url: url,
        async: false,
        data: data,
        dataType: 'text',
        timeout: App.timeout,
        success: function (data) {
          var jsonData = jQuery.parseJSON(data);
          console.log("TRACE: Polling -> value of the url is: " + url);
          console.log("TRACE: Polling-> value of the sent data is: " + self.get('data'));
          console.log("TRACE: Polling-> value of the received data is: " + jsonData);
          if (jsonData === null) {
            self.set('isSuccess', true);
            self.set('isError', false);
            self.set('requestId',undefined);
          } else {
            var requestId = jsonData.Requests.id;
            self.set('requestId', requestId);
            self.doPolling();
            console.log('requestId is: ' + requestId);
          }
        },

        error: function () {
          console.log("ERROR");
          self.set('isError', true);
          self.set('isSuccess', false);
        },

        statusCode: require('data/statusCodes')
      });
    },

    doPolling: function () {
      if (this.get('requestId')) {
        this.startPolling();
      }
    },

    startPolling: function () {
      if (!this.get('requestId')) {
        return;
      }
      var self = this;
      var url = App.apiPrefix + '/clusters/' + App.router.getClusterName() + '/requests/' + this.get('requestId') + '?fields=tasks/*';
      if (App.testMode) {
        this.set('POLL_INTERVAL', 1);
        this.numPolls++;
        url = this.get('mockDataPrefix') + '/poll_' + this.get('numPolls') + '.json';
      }

      $.ajax({
        type: 'GET',
        url: url,
        async: true,
        dataType: 'text',
        timeout: App.timeout,
        success: function (data) {
          console.log("TRACE: In success function for the GET logs data");
          console.log("TRACE: The value is: ", jQuery.parseJSON(data));
          var result = self.parseInfo(jQuery.parseJSON(data));
          if (result !== true) {
            window.setTimeout(function () {
              self.startPolling();
            }, self.POLL_INTERVAL);
          } else {
            self.set('requestId', undefined);
          }
        },

        error: function (request, ajaxOptions, error) {
          console.log("TRACE: In error function for the GET data");
          console.log("TRACE: value of the url is: " + url);
          console.log("TRACE: error code status is: " + request.status);
          if (!self.get('isSuccess')) {
            self.set('isError', true);
          }
        },

        statusCode: require('data/statusCodes')
      }).retry({times: App.maxRetries, timeout: App.timeout}).then(null,
        function () {
          App.showReloadPopup();
          console.log('Install services all retries failed');
        }
      );
    },

    stopPolling: function () {
      //this.set('isSuccess', true);
    },

    replacePolledData: function (polledData) {
      this.polledData.clear();
      this.set('polledData', polledData);
    },


    calculateProgressByTasks: function (tasksData) {
      var queuedTasks = tasksData.filterProperty('Tasks.status', 'QUEUED').length;
      var completedTasks = tasksData.filter(function (task) {
        return ['COMPLETED', 'FAILED', 'ABORTED', 'TIMEDOUT'].contains(task.Tasks.status);
      }).length;
      var inProgressTasks = tasksData.filterProperty('Tasks.status', 'IN_PROGRESS').length;
      return Math.ceil(((queuedTasks * 0.09) + (inProgressTasks * 0.35) + completedTasks ) / tasksData.length * 100)
    },

    isPollingFinished: function (polledData) {
      var runningTasks;
      runningTasks = polledData.filterProperty('Tasks.status', 'QUEUED').length;
      runningTasks += polledData.filterProperty('Tasks.status', 'IN_PROGRESS').length;
      runningTasks += polledData.filterProperty('Tasks.status', 'PENDING').length;
      if (runningTasks === 0) {
        if (polledData.everyProperty('Tasks.status', 'COMPLETED')) {
          this.set('isSuccess', true);
          this.set('isError', false);
        } else if (polledData.someProperty('Tasks.status', 'FAILED') || polledData.someProperty('Tasks.status', 'TIMEDOUT') || polledData.someProperty('Tasks.status', 'ABORTED')) {
          this.set('isSuccess', false);
          this.set('isError', true);
        }
        return true;
      } else {
        return false;
      }
    },


    parseInfo: function (polledData) {
      console.log('TRACE: Entering task info function');
      var self = this;
      var totalProgress = 0;
      var tasksData = polledData.tasks;
      console.log("The value of tasksData is: ", tasksData);
      if (!tasksData) {
        console.log("ERROR: NO tasks available to process");
      }
      var requestId = this.get('requestId');
      if (polledData.Requests && polledData.Requests.id && polledData.Requests.id != requestId) {
        // We dont want to use non-current requestId's tasks data to
        // determine the current install status.
        // Also, we dont want to keep polling if it is not the
        // current requestId.
        return false;
      }
      this.replacePolledData(tasksData);
      var totalProgress = this.calculateProgressByTasks(tasksData);
      this.set('progress', totalProgress.toString());
      console.log("INFO: right now the progress is: " + this.get('progress'));
      return this.isPollingFinished(tasksData);
    }

  });

  
});
window.require.register("utils/string_utils", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  module.exports = {

    pad: function(str, len, pad, dir) {

      var STR_PAD_LEFT = 1;
      var STR_PAD_RIGHT = 2;
      var STR_PAD_BOTH = 3;

      if (typeof(len) == "undefined") { var len = 0; }
      if (typeof(pad) == "undefined") { var pad = ' '; }
      if (typeof(dir) == "undefined") { var dir = STR_PAD_RIGHT; }

      if (len + 1 >= str.length) {

        switch (dir){

          case STR_PAD_LEFT:
            str = Array(len + 1 - str.length).join(pad) + str;
            break;

          case STR_PAD_BOTH:
            var right = Math.ceil((padlen = len - str.length) / 2);
            var left = padlen - right;
            str = Array(left+1).join(pad) + str + Array(right+1).join(pad);
            break;

          default:
            str = str + Array(len + 1 - str.length).join(pad);
            break;

        } // switch

      }
      return str;

    },
    underScoreToCamelCase: function(name){
      var new_name = name.replace(/_\w/g,replacer);
      function replacer(str, p1, p2, offset, s)
      {
        return str[1].toUpperCase();
      }
      return new_name;
    },
    /**
     * Compare two versions by following rules:
     * first higher than second then return 1
     * first lower than second then return -1
     * first equal to second then return 0
     * @param first {string}
     * @param second {string}
     * @return {number}
     */
    compareVersions: function(first, second){
      if (!(typeof first === 'string' && typeof second === 'string')) {
        return false;
      }
      var firstNumbers = first.split('.');
      var secondNumbers = second.split('.');
      var length = 0;
      var i = 0;
      var result = false;
      if(firstNumbers.length === secondNumbers.length) {
        length = firstNumbers.length;
      } else if(firstNumbers.length < secondNumbers.length){
        length = secondNumbers.length;
      } else {
        length = firstNumbers.length;
      }

      while(i < length && !result){
        firstNumbers[i] = (firstNumbers[i] === undefined) ? 0 : window.parseInt(firstNumbers[i]);
        secondNumbers[i] = (secondNumbers[i] === undefined) ? 0 : window.parseInt(secondNumbers[i]);
        if(firstNumbers[i] > secondNumbers[i]){
          result = 1;
          break;
        } else if(firstNumbers[i] === secondNumbers[i]){
          result = 0;
        } else if(firstNumbers[i] < secondNumbers[i]){
          result = -1;
          break;
        }
        i++;
      }
      return result;
    },

    isSingleLine: function(string){
      return string.trim().indexOf("\n") == -1;
    },
    /**
     * transform array of objects into CSV format content
     * @param array
     * @return {Array}
     */
    arrayToCSV: function(array){
      var content = "";
      array.forEach(function(item){
        var row = [];
        for(var i in item){
          if(item.hasOwnProperty(i)){
            row.push(item[i]);
          }
        }
        content += row.join(',') + '\n';
      });
      return content;
    },

    /**
     * Extracts filename from linux/unix path
     * @param String: path
     * @return {Sring}: filename
     */
    getFileFromPath: function(path) {
      return path.replace(/^.*[\/]/, '');
    }
  }
  
});
window.require.register("utils/ui_effects", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  module.exports = {
    /**
     *
     * @param node - DOM element which blinking
     * @param delay - overall time of blinking
     * @param callback
     * @param interval - change frequence of blinking
     */
    pulsate: function (node, delay, callback, interval) {
      var self = this;
      /**
       * execute single blink
       * @param interval - time of single blink
       * @param callback
       * @param opacity
       * @param iteration - current iteration(default amount of iterations: 10)
       * @param isReverse - flag, that mean opacity increase or decrease
       */
      var blink = function (interval, callback, opacity, iteration, isReverse) {
        var iterations = 10;
        opacity = opacity || 1;
        iteration = (iteration !== undefined) ? iteration : 10;
        if (iteration > 0) {
          iteration--;
          setTimeout(function () {
            isReverse = isReverse || (opacity <= 1 / (iterations / 2));
            opacity = (isReverse) ? opacity + (1 / (iterations / 2)) : opacity - (1 / (iterations / 2));
            node.css('opacity', opacity);
            blink(interval, callback, opacity, iteration, isReverse);
          }, interval / iterations);
        } else {
          node.css('opacity', 1);
          callback();
        }
      };
      interval = interval || 200;
      if (delay > 0) {
        delay -= interval;
        setTimeout(function () {
          blink(interval, function () {
            self.pulsate(node, delay, callback, interval);
          });
        }, interval);
      } else {
        callback();
      }
    }
  };
});
window.require.register("utils/updater", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var App = require('app');

  var states = {};

  function update(obj, name, isWorking, interval){
    if(typeof isWorking == 'string' && !obj.get(isWorking)){
      return false;
    }

    var state = states[name];

    if(!state){
      var callback = function(){
        update(obj, name, isWorking, interval);
      };
      states[name] = state = {
        timeout: null,
        func: function(){
          if(typeof isWorking == 'string' && !obj.get(isWorking)){
            return false;
          }
          obj[name](callback);
          return true;
        },
        callback: callback
      };
    }

    clearTimeout(state.timeout);

    state.timeout = setTimeout(state.func, interval);
    return true;
  };

  function rerun(name){
    var state = states[name];
    if(state){
      clearTimeout(state.timeout);
      state.func();
    }
  };

  App.updater = {

    /**
     * Run function periodically with <code>App.contentUpdateInterval</code> delay.
     * Example 1(wrong way, will not be working):
     *    var obj = {
     *      method: function(callback){
     *        //do something
     *      }
     *    };
     *    App.updater.run(obj, 'method');
     *
     * Will be called only once, because <code>callback</code> will never execute. Below is right way:
     *
     * Example 2:
     *    var obj = {
     *      method: function(callback){
     *        //do something
     *        callback();
     *      }
     *    };
     *    App.updater.run(obj, 'method');
     *
     * Method will always be called.
     *
     * Example 3:
     *    var obj = {
     *      method: function(callback){
     *          //do something
     *          callback();
     *      },
     *      isWorking: true
     *    };
     *    App.updater.run(obj, 'method', 'isWorking');
     *
     * <code>obj.method</code> will be called automatically.
     * Warning: You should call <code>callback</code> parameter when function finished iteration.
     * Otherwise nothing happened next time.
     * If <code>isWorking</code> provided, library will check <code>obj.isWorking</code> before iteration and
     * stop working when it equals to false. Otherwise method will always be called.
     *
     *
     *
     * @param obj Object
     * @param name Method name
     * @param isWorking Property, which will be checked as a rule for working
     * @param interval Interval between calls
     * @return {*}
     */
    run: function(obj, name, isWorking, interval){
      interval = interval || App.contentUpdateInterval;
      return update(obj, name, isWorking, interval);
    },

    /**
     * Immediate run function, which is periodically running using <code>run</code> method
     * Example:
     *    App.updater.run(obj, 'clickIt');
     *    App.updater.immediateRun('clickIt');
     *
     * <code>clickIt</code> will be executed immediately and proceed executing periodically
     *
     * @param name Method name, which was used as a parameter in <code>run</code> method
     * @return {*}
     */
    immediateRun: function(name){
      return rerun(name);
    }

  }
  
});
window.require.register("utils/validator", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  module.exports = {

    isValidEmail: function(value) {
      var emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
      return emailRegex.test(value);
    },

    isValidInt: function(value) {
      var intRegex = /^-?\d+$/;
      return intRegex.test(value);
    },

    isValidUNIXUser: function(value){
      var regex = /^[a-z_][a-z0-9_-]{0,31}$/;
      return regex.test(value);
    },

    isValidFloat: function(value) {
      if (typeof value === 'string' && value.trim() === '') {
        return false;
      }
      var floatRegex = /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/;
      return floatRegex.test(value);
    },
    /**
     * validate directory with slash at the start
     * @param value
     * @return {Boolean}
     */
    isValidDir: function(value){
      var floatRegex = /^\/[0-9a-z]*/;
      var dirs = value.replace(/,/g,' ').trim().split(new RegExp("\\s+", "g"));
      for(var i = 0; i < dirs.length; i++){
        if(!floatRegex.test(dirs[i])){
          return false;
        }
      }
      return true;
    },

    /**
     * validate ip address with port
     * @param value
     * @return {Boolean}
     */
    isIpAddress: function(value) {
      var ipRegex = /^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}(\:[0-9]{1,5})?$/;
      return ipRegex.test(value);
    },

    /**
     * validate hostname
     * @param value
     * @return {Boolean}
     */
    isHostname: function(value) {
      var regex = /(?=^.{3,254}$)(^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9]))*(\.[a-zA-Z]{1,62})$)/;
      return regex.test(value);
    },

    /**
     * validate domain name with port
     * @param value
     * @return {Boolean}
     */
    isDomainName: function(value) {
      var domainRegex = /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}$/;
      return domainRegex.test(value);
    },

    /**
     * validate username
     * @param value
     * @return {Boolean}
     */
    isValidUserName: function(value) {
      var usernameRegex = /^[a-z]([-a-z0-9]{0,30})$/;
      return usernameRegex.test(value);
    },

    /**
     * validate key of configurations
     * @param value
     * @return {Boolean}
     */
    isValidConfigKey: function(value) {
      var configKeyRegex = /^[0-9a-z_\-\.]+$/i;
      return configKeyRegex.test(value);
    },

    empty:function (e) {
      switch (e) {
        case "":
        case 0:
        case "0":
        case null:
        case false:
        case typeof this == "undefined":
          return true;
        default :
          return false;
      }
  }
  };
});
window.require.register("views", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  // load all views here

  require('views/application');
  require('views/common/chart');
  require('views/common/chart/pie');
  require('views/common/chart/linear');
  require('views/common/chart/linear_time');
  require('views/common/modal_popup');
  require('views/common/metric');
  require('views/common/time_range');
  require('views/common/form/field');
  require('views/common/quick_view_link_view');
  require('views/common/configs/services_config');
  require('views/common/configs/overriddenProperty_view');
  require('views/common/filter_combobox');
  require('views/common/table_view');
  require('views/login');
  require('views/main');
  require('views/main/menu');
  require('views/main/charts');
  require('views/main/host');
  require('views/main/host/details');
  require('views/main/host/menu');
  require('views/main/host/summary');
  require('views/main/host/configs');
  require('views/main/host/configs_service');
  require('views/main/host/configs_service_menu');
  require('views/main/host/metrics');
  require('views/main/host/add_view');
  require('views/main/host/metrics/cpu');
  require('views/main/host/metrics/disk');
  require('views/main/host/metrics/load');
  require('views/main/host/metrics/memory');
  require('views/main/host/metrics/network');
  require('views/main/host/metrics/processes');
  require('views/main/admin');
  require('views/main/admin/cluster');
  require('views/main/admin/misc_view');
  require('views/main/admin/stack_upgrade');
  require('views/main/admin/advanced');
  require('views/main/admin/advanced/password');
  require('views/main/admin/audit');
  require('views/main/admin/authentication');
  require('views/main/admin/menu');
  require('views/main/admin/user');
  require('views/main/admin/user/create');
  require('views/main/admin/user/edit');
  require('views/main/admin/user/row');
  require('views/main/admin/security');
  require('views/main/admin/security/disable');
  require('views/main/admin/security/add/menu');
  require('views/main/admin/security/add/step1');
  require('views/main/admin/security/add/step2');
  require('views/main/admin/security/add/step3');
  require('views/main/admin/security/add/step4');
  require('views/main/dashboard');
  require('views/main/dashboard/service');
  require('views/main/dashboard/service/hdfs');
  require('views/main/dashboard/service/mapreduce');
  require('views/main/dashboard/service/mapreduce2');
  require('views/main/dashboard/service/hbase');
  require('views/main/dashboard/service/hive');
  require('views/main/dashboard/service/zookeeper');
  require('views/main/dashboard/service/oozie');
  require('views/main/dashboard/service/flume');
  require('views/main/dashboard/cluster_metrics/cpu');
  require('views/main/dashboard/cluster_metrics/load');
  require('views/main/dashboard/cluster_metrics/memory');
  require('views/main/dashboard/cluster_metrics/network');

  require('views/main/dashboard/widget');
  require('views/main/dashboard/widgets/namenode_heap');
  require('views/main/dashboard/widgets/namenode_cpu');
  require('views/main/dashboard/widgets/hdfs_capacity');
  require('views/main/dashboard/widgets/jobtracker_heap');
  require('views/main/dashboard/widgets/jobtracker_cpu');
  require('views/main/dashboard/widgets/datanode_live');
  require('views/main/dashboard/widgets/tasktracker_live');
  require('views/main/dashboard/widgets/namenode_rpc');
  require('views/main/dashboard/widgets/jobtracker_rpc');
  require('views/main/dashboard/widgets/mapreduce_slots');
  require('views/main/dashboard/widgets/metrics_memory');
  require('views/main/dashboard/widgets/metrics_network');
  require('views/main/dashboard/widgets/metrics_cpu');
  require('views/main/dashboard/widgets/metrics_load');
  require('views/main/dashboard/widgets/namenode_uptime');
  require('views/main/dashboard/widgets/jobtracker_uptime');
  require('views/main/dashboard/widgets/hdfs_links');
  require('views/main/dashboard/widgets/mapreduce_links');
  require('views/main/dashboard/widgets/hbase_links');
  require('views/main/dashboard/widgets/hbase_master_heap');
  require('views/main/dashboard/widgets/hbase_average_load');
  require('views/main/dashboard/widgets/hbase_regions_in_transition');
  require('views/main/dashboard/widgets/hbase_master_uptime');

  require('views/main/service');
  require('views/main/service/menu');
  require('views/main/service/item');
  require('views/main/service/reconfigure');
  require('views/main/service/info/menu');
  require('views/main/service/info/summary');
  require('views/main/service/info/configs');
  require('views/main/service/info/metrics/hdfs/jvm_threads');
  require('views/main/service/info/metrics/hdfs/jvm_heap');
  require('views/main/service/info/metrics/hdfs/io');
  require('views/main/service/info/metrics/hdfs/rpc');
  require('views/main/service/info/metrics/hdfs/file_operations');
  require('views/main/service/info/metrics/hdfs/gc');
  require('views/main/service/info/metrics/hdfs/space_utilization');
  require('views/main/service/info/metrics/hdfs/block_status');
  require('views/main/service/info/metrics/mapreduce/gc');
  require('views/main/service/info/metrics/mapreduce/jvm_threads');
  require('views/main/service/info/metrics/mapreduce/jvm_heap');
  require('views/main/service/info/metrics/mapreduce/rpc');
  require('views/main/service/info/metrics/mapreduce/tasks_running_waiting');
  require('views/main/service/info/metrics/mapreduce/jobs_status');
  require('views/main/service/info/metrics/mapreduce/map_slots');
  require('views/main/service/info/metrics/mapreduce/reduce_slots');
  require('views/main/service/info/metrics/hbase/cluster_requests');
  require('views/main/service/info/metrics/hbase/regionserver_rw_requests');
  require('views/main/service/info/metrics/hbase/regionserver_regions');
  require('views/main/service/info/metrics/hbase/regionserver_queuesize');
  require('views/main/service/info/metrics/hbase/hlog_split_time');
  require('views/main/service/info/metrics/hbase/hlog_split_size');
  require('views/main/service/info/metrics/flume/channel_fill_pct');
  require('views/main/service/info/metrics/flume/channel_size');
  require('views/main/service/info/metrics/flume/sink_drain_success');
  require('views/main/service/info/metrics/flume/source_accepted');
  require('views/main/service/info/metrics/flume/sink_connection_failed');
  require('views/main/service/info/metrics/flume/gc');
  require('views/main/service/info/metrics/flume/jvm_heap');
  require('views/main/service/info/metrics/flume/jvm_threads_runnable');
  require('views/main/service/info/metrics/flume/cpu_user');
  require('views/main/service/add_view');
  require('views/main/service/reassign_view');
  require('views/main/charts/menu');
  require('views/main/charts/heatmap');
  require('views/main/charts/heatmap/heatmap_rack');
  require('views/main/charts/heatmap/heatmap_host');
  require('views/main/charts/heatmap/heatmap_host_detail');
  require('views/main/apps_view');
  require('views/main/apps/item_view');
  require('views/main/apps/item/bar_view');
  require('views/main/apps/item/dag_view');
  require('views/main/mirroring_view');
  require('views/main/mirroring/dropdown_view');
  require('views/main/mirroring/dataset_view');
  require('views/main/mirroring/datasets_view');
  require('views/main/mirroring/jobs_view');
  require('views/main/mirroring/targetClusterView');
  require('views/main/mirroring/testConnection_view');
  require('views/main/mirroring/testConnectionResults_view');
  require('views/installer');
  require('views/wizard/controls_view');
  require('views/wizard/step0_view');
  require('views/wizard/step1_view');
  require('views/wizard/step2_view');
  require('views/wizard/step3_view');
  require('views/wizard/step4_view');
  require('views/wizard/step5_view');
  require('views/wizard/step6_view');
  require('views/wizard/step7_view');
  require('views/wizard/step8_view');
  require('views/wizard/step9_view');
  require('views/wizard/step10_view');
  require('views/wizard/step11_view');
  require('views/wizard/step12_view');
  require('views/wizard/step13_view');
  require('views/wizard/step14_view');
  require('views/wizard/stack_upgrade/step1_view');
  require('views/wizard/stack_upgrade/step2_view');
  require('views/wizard/stack_upgrade/step3_view');
  require('views/loading');

  
});
window.require.register("views/application", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.ApplicationView = Em.View.extend({
      templateName: require('templates/application')
  });
});
window.require.register("views/common/chart", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.ChartView = Em.View.extend({
    dateFormat:'dd/mm/yy',
    timeFormat:'h:m',
    w:900,
    p:30, // axis padding
    shift:30,
    ticksCount:10,
    pointsLimit:300,
    areaHeight:30, // px
    axis:false,
    x:false,
    y:false,

    init:function () {
      this._super();
      var renderer = this;

      this.x = d3.time.scale().domain([renderer.getMinDate({}), renderer.getMaxDate({})]).range([0, this.get('w')]);
      this.y = d3.scale.linear().domain([0, 50]).range([this.get('h'), 0]);
      this.axis = d3.svg.axis().orient("top").scale(this.x).ticks(this.get('ticksCount'));
    },

    h: function(){
      return this.get('p') + this.get('nodeAttributes').length * this.get('areaHeight'); //default: 160
    }.property('nodeAttributes', 'p'),

    activeH: function(){
      return this.get('nodeAttributes').length * this.get('areaHeight'); // default 160;
    }.property('h'),

    ruleHeight: function(){
      return this.get('nodeAttributes').length * this.get('areaHeight');
    }.property('nodeAttributes'),

    updateY: function(){
      this.y = d3.scale.linear().domain([0, 50]).range([this.get('h'), 0]);
    }.observes('h'),

    getMinDate:function (data) {
      if (data.length)
        return new Date(Date.parse(data[0]['date']));

      return new Date();
    },

    getMaxDate:function (data) {
      if (data.length)
        return new Date(Date.parse(data[data.length - 1]['date']));

      return new Date();
    },

    area:function () {
      var renderer = this;
      var area = d3.svg.area().x(function (d) {
        return renderer.x(renderer.getDate(d));
      });

      area.y1(function (d) {
        return renderer.get('h') - (renderer.get('h') - renderer.y(d[$(this).attr("getter")])) / renderer.get('koef');
      });

      area.y0(function (d) {
        return renderer.get('h');
      });

      return area;
    },

    line:function () {
      var renderer = this;
      var area = d3.svg.line().x(function (d) {
        return renderer.x(renderer.getDate(d));
      })
        .interpolate("basis");

      area.y(function (d) {
        return renderer.get('h');
      });

      return area;
    },

    /**
     * @todo: calculate this
     * coefficient of compression
     * @param shift
     * @return {Number}
     */

    koef:function () {
      // max value divide on area height;
      return 2 * (this.get('nodeAttributes').length + 1);
    }.property('h'),

    getDate:function (d) {
      return new Date(Date.parse(d.date));
    },

    dateTimeToDateObject:function (string) {
      var ren = this;
      return new Date($.datepicker.parseDateTime(ren.dateFormat, ren.timeFormat, string));
    },

    getDefaultShift:function () {
      return  -1 * this.get('areaHeight') * (this.get('nodeAttributes').length - 1);
    },

    percentScaleXDefaultTranslate:function () {
      return this.w + 3
    },

    clearPlot: function(){
      d3.select(this.get('chartContainerSelector')).selectAll("*").remove();
    },

    drawPlot:function () {
      this.clearPlot();

      var renderer = this;
      this.x.domain([renderer.getMinDate({}), renderer.getMaxDate({})]);

      var rule = $('<div></div>').addClass("rule").css('height', renderer.get('ruleHeight')).mouseenter(function () { $(this).hide(); });
      $(this.get('chartContainerSelector')).prepend(rule);

      var vis = d3.select(this.get('chartContainerSelector'))
        .append("svg:svg")
        .attr("width", renderer.get('w') + 5)
        .attr("height", renderer.get('h'))
        .attr("rendererId", this.get('elementId'))
        .on("mousemove", function () {

          var area = d3.select(this).select("path.line");
          var d = area.data()[0];
          var x = d3.mouse(this)[0];

          var renderer = Em.View.views[d3.select(this).attr('rendererId')];
          var container = $(this).parent();
          var scale = renderer.x;

          // first move rule
          var rule = $(container).children("div.rule");
          rule.css("left", (168 + x) + "px"); // 168 - left container margin
          rule.show();

          x = x + 5; // some correction
          var selectedDate = scale.invert(x);

          // search date between this coordinates
          var prevVal = false;
          var nextVal = d[0];

          $.each(d, function (i, point) {
            if (renderer.getDate(point).getTime() <= selectedDate.getTime()) {
              prevVal = nextVal;
              nextVal = point;
            } else {
              return;
            }
          });

          var len1 = Math.abs(x - scale(renderer.getDate(prevVal)));
          var len2 = Math.abs(x - scale(renderer.getDate(nextVal)));

          var clearing = 5;
          var pointToShow = false;
          // if the first point if closer
          if ((len1 < len2) && (len1 <= clearing)) {
            pointToShow = prevVal;
          } else if (len2 <= clearing) { // the second point is closer
            pointToShow = nextVal;
          }

          $.each(renderer.get('nodeAttributes'), function (i, v) {
            var value = !pointToShow ? "" : pointToShow[v] + "%";
            $(rule).children("div." + v).html(value);
          });
        });

      vis.append("svg:g")
        .attr("class", "axis")
        .attr("transform", "translate(0," + this.get('p') + ")")
        .call(renderer.axis)

      $.each(this.get('nodeAttributes'), function (i, v) {
        var element = $('<div></div>').addClass(v).addClass("stateValue").html("");
        rule.append(element);
      });

      var shift = this.getDefaultShift();
      vis.append("svg:path")
        .attr("class", "horizontal-line")
        .data([
        {}
      ])
        .attr("transform", "translate(0," + (shift - this.get('areaHeight')) + ")")
        .attr("d", renderer.line())
        .style("stroke", "#000");

      $.each(this.get('nodeAttributes'), function (i, v) {
        vis.append("svg:path").data([
          {}
        ])
          .attr("class", "line")
          .attr("getter", v)
          .attr("transform", "translate(0, " + shift + ")")
          .attr("d", renderer.area())
          .style("fill", function () {
            return "#31a354";
          });

        vis.append("svg:path")
          .attr("class", "horizontal-line")
          .data([
          {}
        ])
          .attr("transform", "translate(0," + shift + ")")
          .attr("d", renderer.line())
          .style("stroke", "#000");

        shift += renderer.get('areaHeight');
      });
    },

    getData:function (containerId) {
      return (d3.select(containerId + " path.line").data())[0];
    },

    drawChart:function () {
      var containerSel = this.get('chartContainerSelector');
      var data = this.get('data');

      while (data.length > this.get('pointsLimit')) {
        data.shift();
      }

      var renderer = this;
      var minDate = this.getMinDate(data);
      var maxDate = this.getMaxDate(data);

      this.x.domain([minDate, maxDate]);

      var ticks = data.length > 10 ? 10 : data.length;
      this.axis.scale(renderer.x).ticks(ticks);

  //        remove dots axis
      $(containerSel + " svg g.axis g").remove();
      d3.select(containerSel + " svg g.axis")
        .call(this.axis);

      $.each(this.get('nodeAttributes'), function (i, v) {
        d3.select(containerSel + " path.line[getter='" + v + "']")
          .data([data])
          .transition()
          .attr("d", renderer.area());
      });

      // lines between charts
      $(containerSel + " path.horizontal-line").each(
        function (i, path) {
          d3.select(path).data([
            [
              {date:minDate},
              {date:maxDate}
            ]
          ]).attr("d", renderer.line());
        }
      );
    }
  });
});
window.require.register("views/common/chart/linear", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.ChartLinearView = Em.View.extend({
    w:90,
    h:90,
    margin:2,

    classNames: ['linear'],

    init:function () {
      this._super();

      this.x = d3.scale.linear().domain([0, this.get('data').length]).range([0 + this.get('margin'), this.get('w') - this.get('margin')]);
      this.y = d3.scale.linear().domain([0, d3.max(this.get('data'))]).range([0 + this.get('margin'), this.get('h') - this.get('margin')]);
      this.line = d3.svg.line().x(function (d, i) { return this.x(i); }).y(function (d) {return -1 * this.y(d); })
    },

    didInsertElement:function () {
      this._super();
      this.appendSvg();
    },

    selector:function () {
      return '#' + this.get('elementId');
    }.property('elementId'),

    appendSvg:function () {
      var thisChart = this;

      this.set('svg', d3.select(this.get('selector'))
        .append("svg:svg")
        .attr("width", thisChart.get('w'))
        .attr("height", thisChart.get('h')));

      this.set('g', thisChart.get('svg').append("svg:g").attr("transform", "translate(0, " + thisChart.get('h') + ")"));
      this.get('g').append("svg:path").attr("d", thisChart.line(thisChart.get('data')));


      // axis
      this.get('g').append("svg:line")
        .attr("x1", thisChart.x(0))
        .attr("y1", -1 * thisChart.y(0))
        .attr("x2", thisChart.x(this.get('data').length))
        .attr("y2", -1 * thisChart.y(0))

      this.get('g').append("svg:line")
        .attr("x1", thisChart.x(0))
        .attr("y1", -1 * thisChart.y(0))
        .attr("x2", thisChart.x(0))
        .attr("y2", -1 * thisChart.y(d3.max(thisChart.get('data'))))
    }
  });
});
window.require.register("views/common/chart/linear_time", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');
  var string_utils = require('utils/string_utils');

  /**
   * @class
   * 
   * This is a view which GETs data from a URL and shows it as a time based line
   * graph. Time is shown on the X axis with data series shown on Y axis. It
   * optionally also has the ability to auto refresh itself over a given time
   * interval.
   * 
   * This is an abstract class which is meant to be extended.
   * 
   * Extending classes should override the following:
   * <ul>
   * <li>url - from where the data can be retrieved
   * <li>title - Title to be displayed when showing the chart
   * <li>id - which uniquely identifies this chart in any page
   * <li>#transformToSeries(jsonData) - function to map server data into graph
   * series
   * </ul>
   * 
   * Extending classes could optionally override the following:
   * <ul>
   * <li>#colorForSeries(series) - function to get custom colors per series
   * </ul>
   * 
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartLinearTimeView = Ember.View.extend({
    templateName: require('templates/main/charts/linear_time'),

    /**
     * The URL from which data can be retrieved.
     *
     * This property must be provided for the graph to show properly.
     *
     * @type String
     * @default null
     */
    url: null,

    /**
     * A unique ID for this chart.
     *
     * @type String
     * @default null
     */
    id: null,

    /**
     * Title to be shown under the chart.
     *
     * @type String
     * @default null
     */
    title: null,

    /**
     * @private
     *
     * @type Rickshaw.Graph
     * @default null
     */
    _graph: null,

    _popupGraph: null,

    _seriesProperties: null,

    renderer: 'area',

    popupSuffix: '-popup',

    isPopup: false,

    isReady: false,

    isPopupReady: false,

    hasData: true,
    /**
     * Current cluster name
     */
    clusterName: function() {
      return App.router.get('clusterController.clusterName');
    }.property('App.router.clusterController.clusterName'),
    /**
     * Url prefix common for all child views
     */
    urlPrefix: function() {
      return App.apiPrefix + "/clusters/" + this.get('clusterName');
    }.property('clusterName'),

    /**
     * Color palette used for this chart
     *
     * @private
     * @type String[]
     */
     /*
    _paletteScheme: [ 'rgba(181,182,169,0.4)', 'rgba(133,135,114,0.4)',
        'rgba(120,95,67,0.4)', 'rgba(150,85,126,0.4)',
        'rgba(70,130,180,0.4)', 'rgba(0,255,204,0.4)',
        'rgba(255,105,180,0.4)', 'rgba(101,185,172,0.4)',
        'rgba(115,192,58,0.4)', 'rgba(203,81,58,0.4)' ].reverse(),
    */

    selector: function () {
      return '#' + this.get('elementId');
    }.property('elementId'),

    didInsertElement: function () {
      this.loadData();
      this.registerGraph();
    },
    registerGraph: function(){
      var graph = {
        name: this.get('title'),
        id: this.get('elementId'),
        popupId: this.get('id')
      };
      App.router.get('updateController.graphs').push(graph);
    },

    loadData: function() {
      App.ajax.send({
        name: this.get('ajaxIndex'),
        sender: this,
        data: this.getDataForAjaxRequest(),
        success: '_refreshGraph',
        error: 'loadDataErrorCallback'
      });
    },

    getDataForAjaxRequest: function() {
      var toSeconds = Math.round(new Date().getTime() / 1000);
      var hostName = (this.get('content')) ? this.get('content.hostName') : "";

      var HDFSService = App.HDFSService.find().objectAt(0);
      var nameNodeName = HDFSService ? HDFSService.get('nameNode.hostName') : "";
      var MapReduceService = App.MapReduceService.find().objectAt(0);
      var jobTrackerNode = MapReduceService ? MapReduceService.get('jobTracker.hostName') : "";
      var timeUnit = this.get('timeUnitSeconds');
      return {
        toSeconds: toSeconds,
        fromSeconds: toSeconds - timeUnit,
        stepSeconds: 15,
        hostName: hostName,
        nameNodeName: nameNodeName,
        jobTrackerNode: jobTrackerNode
      };
    },
    loadDataErrorCallback: function(xhr, textStatus, errorThrown){
      this.set('isReady', true);
      if (xhr.readyState == 4 && xhr.status) {
        textStatus = xhr.status + " " + textStatus;
      }
      this._showMessage('warn', this.t('graphs.error.title'), this.t('graphs.error.message').format(textStatus, errorThrown));
      this.set('isPopup', false);
      this.set('hasData', false);
    },

    /**
     * Shows a yellow warning message in place of the chart.
     *
     * @param type  Can be any of 'warn', 'error', 'info', 'success'
     * @param title Bolded title for the message
     * @param message String representing the message
     * @type: Function
     */
    _showMessage: function(type, title, message){
      var chartOverlay = '#' + this.id;
      var chartOverlayId = chartOverlay + '-chart';
      var chartOverlayY = chartOverlay + '-yaxis';
      var chartOverlayX = chartOverlay + '-xaxis';
      var chartOverlayLegend = chartOverlay + '-legend';
      var chartOverlayTimeline = chartOverlay + '-timeline';
      if (this.get('isPopup')) {
        chartOverlayId += this.get('popupSuffix');
        chartOverlayY += this.get('popupSuffix');
        chartOverlayX += this.get('popupSuffix');
        chartOverlayLegend += this.get('popupSuffix');
        chartOverlayTimeline += this.get('popupSuffix');
      }
      var typeClass;
      switch (type) {
        case 'error':
          typeClass = 'alert-error';
          break;
        case 'success':
          typeClass = 'alert-success';
          break;
        case 'info':
          typeClass = 'alert-info';
          break;
        default:
          typeClass = '';
          break;
      }
      $(chartOverlayId+', '+chartOverlayY+', '+chartOverlayX+', '+chartOverlayLegend+', '+chartOverlayTimeline).html('');
      $(chartOverlayId).append('<div class=\"alert '+typeClass+'\"><strong>'+title+'</strong> '+message+'</div>');
    },

    /**
     * Transforms the JSON data retrieved from the server into the series
     * format that Rickshaw.Graph understands.
     *
     * The series object is generally in the following format: [ { name :
     * "Series 1", data : [ { x : 0, y : 0 }, { x : 1, y : 1 } ] } ]
     *
     * Extending classes should override this method.
     *
     * @param seriesData
     *          Data retrieved from the server
     * @param displayName
     *          Graph title
     * @type: Function
     *
     */
    transformData: function (seriesData, displayName) {
      var seriesArray = [];
      if (seriesData) {
        // Is it a string?
        if ("string" == typeof seriesData) {
          seriesData = JSON.parse(seriesData);
        }
        // We have valid data
        var series = {};
        series.name = displayName;
        series.data = [];
        for ( var index = 0; index < seriesData.length; index++) {
          series.data.push({
            x: seriesData[index][1],
            y: seriesData[index][0]
          });
        }
        return series;
      }
    },

    /**
     * Provides the formatter to use in displaying Y axis.
     *
     * The default is Rickshaw.Fixtures.Number.formatKMBT which shows 10K,
     * 300M etc.
     *
     * @type Function
     */
    yAxisFormatter: function(y) {
      if(isNaN(y)){
        return 0;
      }
      var value = Rickshaw.Fixtures.Number.formatKMBT(y);
      if (value == '') return '0';
      value = String(value);
      var c = value[value.length - 1];
      if (!isNaN(parseInt(c))) {
        // c is digit
        value = parseFloat(value).toFixed(3).replace(/0+$/, '').replace(/\.$/, '');
      }
      else {
        // c in not digit
        value = parseFloat(value.substr(0, value.length - 1)).toFixed(3).replace(/0+$/, '').replace(/\.$/, '') + c;
      }
      return value;
    },

    /**
     * Provides the color (in any HTML color format) to use for a particular
     * series.
     *
     * @param series
     *          Series for which color is being requested
     * @return color String. Returning null allows this chart to pick a color
     *         from palette.
     * @default null
     * @type Function
     */
    colorForSeries: function (series) {
      return null;
    },

    /**
    * Check whether seriesData is correct data for chart drawing
    * @param seriesData
    * @return {Boolean}
    */
    checkSeries : function(seriesData){
      if(!seriesData || !seriesData.length){
        return false;
      }
      var result = true;
      seriesData.forEach(function(item){
        if(!item.data || !item.data.length || !item.data[0] || typeof item.data[0].x === 'undefined'){
          result = false;
        }
      });
      return result;
    },

    /**
     * @private
     *
     * Refreshes the graph with the latest JSON data.
     *
     * @type Function
     */
    _refreshGraph: function (jsonData) {
      if(this.get('isDestroyed')){
        return;
      }
      var seriesData = this.transformToSeries(jsonData);

        //if graph opened as modal popup
        var popup_path = $("#" + this.id + "-container" + this.get('popupSuffix'));
        var graph_container = $("#" + this.id + "-container");
        if(popup_path.length) {
          popup_path.children().each(function () {
            $(this).children().remove();
          });
          this.set('isPopup', true);
        }
        else {
          graph_container.children().each(function (index, value) {
            $(value).children().remove();
          });
        }
      if (this.checkSeries(seriesData)) {
        // Check container exists (may be not, if we go to another page and wait while graphs loading)
        if (graph_container.length) {
          this.draw(seriesData);
          this.set('hasData', true);
            //move yAxis value lower to make them fully visible
            if(!this.get('isPopup')) {
                $('svg.y_axis text').attr('y',8);
            }
        }
      }
      else {
        this.set('isReady', true);
        //if Axis X time interval is default(60 minutes)
        if(this.get('timeUnitSeconds') === 3600){
          this._showMessage('info', this.t('graphs.noData.title'), this.t('graphs.noData.message'));
          this.set('hasData', false);
        } else {
          this._showMessage('info', this.t('graphs.noData.title'), this.t('graphs.noDataAtTime.message'));
        }
        this.set('isPopup', false);
      }
    },

    /**
     * Returns a custom time unit, that depends on X axis interval length, for the graph's X axis.
     * This is needed as Rickshaw's default time X axis uses UTC time, which can be confusing
     * for users expecting locale specific time.
     *
     * If <code>null</code> is returned, Rickshaw's default time unit is used.
     *
     * @type Function
     * @return Rickshaw.Fixtures.Time
     */
    localeTimeUnit: function(timeUnitSeconds){
      var timeUnit = new Rickshaw.Fixtures.Time();
      switch (timeUnitSeconds){
        case 604800:
          timeUnit = timeUnit.unit('day');
          break;
        case 2592000:
          timeUnit = timeUnit.unit('week');
          break;
        case 31104000:
          timeUnit = timeUnit.unit('month');
          break;
        default:
          timeUnit = {
            name: timeUnitSeconds / 240 + ' minute',
            seconds: timeUnitSeconds / 4,
            formatter: function (d) {
              return d.toLocaleString().match(/(\d+:\d+):/)[1];
            }
          };
      }
      return timeUnit;
    },

    /**
     * @private
     *
     * When a graph is given a particular width and height,the lines are drawn
     * in a slightly bigger area thereby chopping off some of the UI. Hence
     * after the rendering, we adjust the SVGs size in the DOM to compensate.
     *
     * Opened https://github.com/shutterstock/rickshaw/issues/141
     *
     * @type Function
     */
    _adjustSVGHeight: function () {
      if (this._graph && this._graph.element
          && this._graph.element.firstChild) {
        var svgElement = this._graph.element.firstChild;
        svgElement.setAttribute('height', $(this._graph.element).height()
            + "px");
        svgElement.setAttribute('width', $(this._graph.element).width()
            + "px");
      }
    },
    /**
     * temporary fix for incoming data for graph
     * to shift data time to correct time point
     */
    dataShiftFix: function(data){
      var nowTime = Math.round(new Date().getTime() / 1000);
      data.forEach(function(series){
        var l = series.data.length;
        var shiftDiff = nowTime - series.data[l - 1].x;
        if(shiftDiff > 3600){
          for(var i = 0;i < l;i++){
            series.data[i].x = series.data[i].x + shiftDiff;
          }
          series.data.unshift({
            x: nowTime - this.get('timeUnitSeconds'),
            y: 0
          });
        }
      }, this);
    },

    draw: function(seriesData) {
      var isPopup = this.get('isPopup');
      var p = '';
      if (isPopup) {
        p = this.get('popupSuffix');
      }
      var palette = new Rickshaw.Color.Palette({ scheme: 'munin'});

      this.dataShiftFix(seriesData);

      // var palette = new Rickshaw.Color.Palette({
      //   scheme: this._paletteScheme
      // });

      var self = this;
      var series_min_length = 100000000;
      seriesData.forEach(function (series, index) {
        var seriesColor = self.colorForSeries(series);
        if (seriesColor == null) {
          seriesColor = palette.color();
        }
        series.color = seriesColor;
        series.stroke = 'rgba(0,0,0,0.3)';
        if (isPopup) {
          // calculate statistic data for popup legend
          var avg = 0;
          var min = Number.MAX_VALUE;
          var max = Number.MIN_VALUE;
          for (var i = 0; i < series.data.length; i++) {
            avg += series.data[i]['y'];
            if (series.data[i]['y'] < min) {
              min = series.data[i]['y'];
            }
            else {
              if (series.data[i]['y'] > max) {
                max = series.data[i]['y'];
              }
            }
          }
          series.name = string_utils.pad(series.name, 30, '&nbsp;', 2) + string_utils.pad('min', 5, '&nbsp;', 3) + string_utils.pad(this.get('yAxisFormatter')(min), 12, '&nbsp;', 3) + string_utils.pad('avg', 5, '&nbsp;', 3) + string_utils.pad(this.get('yAxisFormatter')(avg/series.data.length), 12, '&nbsp;', 3) + string_utils.pad('max', 12, '&nbsp;', 3) + string_utils.pad(this.get('yAxisFormatter')(max), 5, '&nbsp;', 3);
        }
        if (series.data.length < series_min_length) {
          series_min_length = series.data.length;
        }
      }.bind(this));
      seriesData.forEach(function(series, index) {
        if (series.data.length > series_min_length) {
          series.data.length = series_min_length;
        }
      });
      var chartId = "#" + this.id + "-chart" + p;
      var chartOverlayId = "#" + this.id + "-container" + p;
      var xaxisElementId = "#" + this.id + "-xaxis" + p;
      var yaxisElementId = "#" + this.id + "-yaxis" + p;
      var legendElementId = "#" + this.id + "-legend" + p;

      var chartElement = document.querySelector(chartId);
      var overlayElement = document.querySelector(chartOverlayId);
      var xaxisElement = document.querySelector(xaxisElementId);
      var yaxisElement = document.querySelector(yaxisElementId);
      var legendElement = document.querySelector(legendElementId);

      var strokeWidth = 1;
      if (this.get('renderer') != 'area') {
        strokeWidth = 2;
      }

      var height = 150;
      var diff = 32;
      if(this.get('inWidget')){
        height = 105; // for widgets view
        diff = 22;
      }
      var width = 400;
      if (isPopup) {
        height = 180;
        width = 670;
      } else {
        // If not in popup, the width could vary.
        // We determine width based on div's size.
        var thisElement = this.get('element');
        if (thisElement!=null) {
          var calculatedWidth = $(thisElement).width();
          if (calculatedWidth > diff) {
            width = calculatedWidth - diff;
          }
        }
      }
      var _graph = new Rickshaw.Graph({
        height: height,
        width: width,
        element: chartElement,
        series: seriesData,
        interpolation: 'step-after',
        stroke: true,
        renderer: this.get('renderer'),
        strokeWidth: strokeWidth
      });
      if (this.get('renderer') === 'area') {
        _graph.renderer.unstack = false;
      }

      xAxis = new Rickshaw.Graph.Axis.Time({
        graph: _graph,
        timeUnit: this.localeTimeUnit(this.get('timeUnitSeconds'))
      });

      var orientation = 'right';
      if (isPopup) {
        orientation = 'left';
      }
      yAxis = new Rickshaw.Graph.Axis.Y({
        tickFormat: this.yAxisFormatter,
        element: yaxisElement,
        orientation: orientation,
        graph: _graph
      });

      var legend = new Rickshaw.Graph.Legend({
        graph: _graph,
        element: legendElement
      });

      if (!isPopup) {
        overlayElement.addEventListener('mousemove', function () {
          $(xaxisElement).removeClass('hide');
          $(legendElement).removeClass('hide');
          $(chartElement).children("div").removeClass('hide');
        });
        overlayElement.addEventListener('mouseout', function () {
          $(legendElement).addClass('hide');
        });
        _graph.onUpdate(function () {
          $(legendElement).addClass('hide');
        });
      }

     var shelving = new Rickshaw.Graph.Behavior.Series.Toggle({
        graph: _graph,
        legend: legend
      });

      var order = new Rickshaw.Graph.Behavior.Series.Order({
        graph: _graph,
        legend: legend
      });
      //show the graph when it's loaded
      _graph.onUpdate(function(){
        self.set('isReady', true);
      });
      _graph.render();

      if (isPopup) {
        var self = this;
        var hoverDetail = new Rickshaw.Graph.HoverDetail({
          graph: _graph,
          yFormatter:function (y) {
            return self.yAxisFormatter(y);
          },
          xFormatter:function (x) {
            return (new Date(x * 1000)).toLocaleTimeString();
          },
          formatter:function (series, x, y, formattedX, formattedY, d) {
            return formattedY + '<br />' + formattedX;
          }
        });
      }

      if (isPopup) {
        var self = this;
        // In popup save selected metrics and show only them after data update
        _graph.series.forEach(function(series, index) {
          if (self.get('_seriesProperties') !== null && self.get('_seriesProperties')[index] !== null && self.get('_seriesProperties')[index] !== undefined ) {
            if(self.get('_seriesProperties')[self.get('_seriesProperties').length - index - 1].length > 1) {
              $('#'+self.get('id')+'-container'+self.get('popupSuffix')+' a.action:eq('+(self.get('_seriesProperties').length - index - 1)+')').parent('li').addClass('disabled');
              series.disable();
            }
          }
        });
        //show the graph when it's loaded
        _graph.onUpdate(function(){
          self.set('isPopupReady', true);
        });
        _graph.update();

        $('li.line').click(function() {
          var series = [];
          $('#'+self.get('id')+'-container'+self.get('popupSuffix')+' a.action').each(function(index, v) {
            series[index] = v.parentNode.classList;
          });
          self.set('_seriesProperties', series);
        });

        this.set('_popupGraph', _graph);
      }
      else {
        this.set('_graph', _graph);
      }
    },


    showGraphInPopup: function() {
      if(!this.get('hasData')){
        return;
      }

      this.set('isPopup', true);
      var self = this;
      App.ModalPopup.show({
        template: Ember.Handlebars.compile([
          '<div class="modal-backdrop"></div><div class="modal modal-graph-line" id="modal" tabindex="-1" role="dialog" aria-labelledby="modal-label" aria-hidden="true">',
          '<div class="modal-header">',
          '<a class="close" {{action onClose target="view"}}>x</a>',
          '<h3 id="modal-label">',
          '{{#if headerClass}}{{view headerClass}}',
          '{{else}}{{header}}{{/if}}',
          '</h3>',
          '</div>',
          '<div class="modal-body">',
          '{{#if bodyClass}}{{view bodyClass}}',
          '{{else}}',
            '<div class="screensaver no-borders chart-container" {{bindAttr class="view.isReady:hide"}} ></div>',
            '<div class="time-label" {{bindAttr class="view.isReady::hidden"}}>{{view.currentTimeState.name}}</div>',
            '{{#if view.isTimePagingEnable}}<div class="arrow-left" {{bindAttr class="view.leftArrowVisible:visibleArrow"}} {{action "switchTimeBack" target="view"}}></div>{{/if}}',
            '<div id="'+this.get('id')+'-container'+this.get('popupSuffix')+'" class="chart-container chart-container'+this.get('popupSuffix')+' hide" {{bindAttr class="view.isReady:show"}} >',
              '<div id="'+this.get('id')+'-yaxis'+this.get('popupSuffix')+'" class="'+this.get('id')+'-yaxis chart-y-axis"></div>',
              '<div id="'+this.get('id')+'-xaxis'+this.get('popupSuffix')+'" class="'+this.get('id')+'-xaxis chart-x-axis"></div>',
              '<div id="'+this.get('id')+'-legend'+this.get('popupSuffix')+'" class="'+this.get('id')+'-legend chart-legend"></div>',
              '<div id="'+this.get('id')+'-chart'+this.get('popupSuffix')+'" class="'+this.get('id')+'-chart chart"></div>',
              '<div id="'+this.get('id')+'-title'+this.get('popupSuffix')+'" class="'+this.get('id')+'-title chart-title">{{view.title}}</div>',
            '</div>',
          '{{#if view.isTimePagingEnable}}<div class="arrow-right" {{bindAttr class="view.rightArrowVisible:visibleArrow"}} {{action "switchTimeForward" "forward" target="view"}}></div>{{/if}}',
          '{{/if}}',
          '</div>',
          '<div class="modal-footer">',
          '{{#if view.primary}}<a class="btn btn-success" {{action onPrimary target="view"}}>{{view.primary}}</a>{{/if}}',
          '</div>',
          '</div>'
        ].join('\n')),

        header: this.get('title'),
        self: self,
        isReady: function(){
          return this.get('self.isPopupReady');
        }.property('self.isPopupReady'),
        primary: 'OK',
        onPrimary: function() {
          this.hide();
          self.set('isPopup', false);
          self.set('timeUnitSeconds', 3600);
        },
        onClose: function(){
          this.hide();
          self.set('isPopup', false);
          self.set('timeUnitSeconds', 3600);
        },
        /**
         * check is time paging feature is enable for graph
         */
        isTimePagingEnable: function(){
          return !self.get('isTimePagingDisable');
        }.property(),
        rightArrowVisible: function(){
          return (this.get('isReady') && (this.get('currentTimeIndex') != 0))? true : false;
        }.property('isReady', 'currentTimeIndex'),
        leftArrowVisible: function(){
          return (this.get('isReady') && (this.get('currentTimeIndex') != 7))? true : false;
        }.property('isReady', 'currentTimeIndex'),
        /**
         * move graph back by time
         * @param event
         */
        switchTimeBack: function(event){
          var index = this.get('currentTimeIndex');
          // 7 - number of last time state
          if(index < 7){
            this.reloadGraphByTime(++index);
          }
        },
        /**
         * move graph forward by time
         * @param event
         */
        switchTimeForward: function(event){
          var index = this.get('currentTimeIndex');
          if(index > 0){
            this.reloadGraphByTime(--index);
          }
        },
        /**
         * reload graph depending on the time
         * @param index
         */
        reloadGraphByTime: function(index){
          this.set('currentTimeIndex', index);
          self.set('timeUnitSeconds', this.get('timeStates')[index].seconds);
          self.loadData();
        },
        timeStates: [
          {name: Em.I18n.t('graphs.timeRange.hour'), seconds: 3600},
          {name: Em.I18n.t('graphs.timeRange.twoHours'), seconds: 7200},
          {name: Em.I18n.t('graphs.timeRange.fourHours'), seconds: 14400},
          {name: Em.I18n.t('graphs.timeRange.twelveHours'), seconds: 43200},
          {name: Em.I18n.t('graphs.timeRange.day'), seconds: 86400},
          {name: Em.I18n.t('graphs.timeRange.week'), seconds: 604800},
          {name: Em.I18n.t('graphs.timeRange.month'), seconds: 2592000},
          {name: Em.I18n.t('graphs.timeRange.year'), seconds: 31104000}
        ],
        currentTimeIndex: 0,
        currentTimeState: function(){
          return this.get('timeStates').objectAt(this.get('currentTimeIndex'));
        }.property('currentTimeIndex')
      });
      Ember.run.next(function() {
        self.loadData();
        self.set('isPopupReady', false);
      });
    },
    //60 minute interval on X axis.
    timeUnitSeconds: 3600
  });

  /**
   * A formatter which will turn a number into computer storage sizes of the
   * format '23 GB' etc.
   * 
   * @type Function
   */
  App.ChartLinearTimeView.BytesFormatter = function (y) {
    if (y == 0) return '0 B';
    var value = Rickshaw.Fixtures.Number.formatBase1024KMGTP(y);
    if (!y || y.length < 1) {
      value = '0 B';
    }
    else {
      if ("number" == typeof value) {
        value = String(value);
      }
      if ("string" == typeof value) {
        value = value.replace(/\.\d(\d+)/, function($0, $1){ // Remove only 1-digit after decimal part
          return $0.replace($1, '');
        }); 
        // Either it ends with digit or ends with character
        value = value.replace(/(\d$)/, '$1 '); // Ends with digit like '120'
        value = value.replace(/([a-zA-Z]$)/, ' $1'); // Ends with character like
        // '120M'
        value = value + 'B'; // Append B to make B, MB, GB etc.
      }
    }
    return value;
  };

  /**
   * A formatter which will turn a number into percentage display like '42%'
   * 
   * @type Function
   */
  App.ChartLinearTimeView.PercentageFormatter = function (percentage) {
    var value = percentage;
    if (!value || value.length < 1) {
      value = '0 %';
    } else {
      value = value.toFixed(3).replace(/0+$/, '').replace(/\.$/, '') + '%';
    }
    return value;
  };

  /**
   * A formatter which will turn elapsed time into display time like '50 ms',
   * '5s', '10 m', '3 hr' etc. Time is expected to be provided in milliseconds.
   * 
   * @type Function
   */
  App.ChartLinearTimeView.TimeElapsedFormatter = function (millis) {
    var value = millis;
    if (!value || value.length < 1) {
      value = '0 ms';
    } else if ("number" == typeof millis) {
      var seconds = millis > 1000 ? Math.round(millis / 1000) : 0;
      var minutes = seconds > 60 ? Math.round(seconds / 60) : 0;
      var hours = minutes > 60 ? Math.round(minutes / 60) : 0;
      var days = hours > 24 ? Math.round(hours / 24) : 0;
      if (days > 0) {
        value = days + ' 天';
      } else if (hours > 0) {
        value = hours + ' 小时';
      } else if (minutes > 0) {
        value = minutes + ' 分';
      } else if (seconds > 0) {
        value = seconds + ' 秒';
      } else if (millis > 0) {
        value = millis.toFixed(3).replace(/0+$/, '').replace(/\.$/, '') + ' 毫秒';
      } else {
        value = millis.toFixed(3).replace(/0+$/, '').replace(/\.$/, '') + ' 毫秒';
      }
    }
    return value;
  };
});
window.require.register("views/common/chart/pie", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.ChartPieView = Em.View.extend({
    w:90,
    h:90,
    data:[300, 500],
    id:null,
    palette: new Rickshaw.Color.Palette({ scheme: 'munin'}),
    stroke: 'black',
    strokeWidth: 2,
    donut:d3.layout.pie().sort(null),
    existCenterText: false,
    centerTextColor: 'black',

    r:function () {
      return Math.min(this.get('w'), this.get('h')) / 2 - this.get('strokeWidth');
    }.property('w', 'h'),

    outerR:function () {
      return this.get('r'); // - 10;
    }.property('r'),

    innerR:function () {
      return 0; // this.get('r') - 20;
    }.property('r'),

    arc:function () {
      return d3.svg.arc().innerRadius(this.get('innerR')).outerRadius(this.get('outerR'));
    }.property(),

    didInsertElement:function () {
      this._super();
      this.appendSvg();
    },

    selector:function () {
      return '#' + this.get('elementId');
    }.property('elementId'),

    appendSvg:function () {

      var thisChart = this;
      var svg = d3.select(thisChart.get('selector')).append("svg:svg")
        .attr("id", thisChart.get('id'))
        .attr("width", thisChart.get('w'))
        .attr("height", thisChart.get('h'))
        .attr("stroke", thisChart.get('stroke'))
        .attr("stroke-width", thisChart.get('strokeWidth'));

      // set percentage data in center if there exist a center text
      if(thisChart.get('existCenterText')){
        this.set('svg', svg
          .append("svg:g")
          .attr("render-order", 1)
          .append("svg:text")
          .attr("stroke", thisChart.get('centerTextColor'))
          .attr("font-size", 17)
          .attr("transform", "translate(" + thisChart.get('w') / 2 + "," + ((thisChart.get('h') / 2) + 3) + ")")
          .attr("text-anchor", "middle")
          .text(function(d) {
                   return thisChart.get('data')[0] + '%';
                })
           );
      }

      this.set('svg', svg
        .append("svg:g")
        .attr("transform", "translate(" + thisChart.get('w') / 2 + "," + thisChart.get('h') / 2 + ")"));

      this.set('arcs', thisChart.get('svg').selectAll("path")
        .data(thisChart.donut(thisChart.get('data')))
        .enter().append("svg:path")
        .attr("fill", function (d, i) {
          return thisChart.palette.color(i);
        })
        .attr("d", thisChart.get('arc'))

      );

    }

  });
});
window.require.register("views/common/configs/overriddenProperty_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */
  // SCP means ServiceConfigProperty

  var App = require('app');

  App.ServiceConfigView.SCPOverriddenRowsView = Ember.View.extend({
    templateName: require('templates/common/configs/overriddenProperty'),
    controllerBinding: 'App.router.mainServiceInfoConfigsController',
    serviceConfigProperty: null, // is passed dynamically at runtime where ever
    // we are declaring this from configs.hbs ( we are initializing this from UI )
    categoryConfigs: null, // just declared as viewClass need it
    
    showOverrideWindow: function (event) {
      // App.ServiceConfigsByCategoryView in which the current view is nested
      this.get('parentView').showOverrideWindow(event);
    },

    removeOverride: function (event) {
      // arg 1 SCP means ServiceConfigProperty
      var scpToBeRemoved = event.contexts[0];
      var overrides = this.get('serviceConfigProperty.overrides');
      overrides = overrides.without(scpToBeRemoved);
      this.set('serviceConfigProperty.overrides', overrides);
    },
    
    hostsCountView: Em.View.extend({
      classNames: ['overridden-hosts-view'],
      template: Ember.Handlebars.compile("<a class=\"action overriden-hosts-link\" href=\"#\" {{action showOverrideWindow overriddenSCP controller target=\"view.parentView\" }} rel=\"tooltip\" {{bindAttr data-original-title=\"view.hostsList\"}} >{{view.overriddenSCP.selectedHostOptions.length}} hosts </a>"),
      overriddenSCP: null,
      didInsertElement: function () {
        var links = $(".overriden-hosts-link");
        console.log(links);
        links.tooltip({html:true, placement:"right"});
      },
      /**
       * New line separated list of hosts
       * @type String
       */
      hostsList: function () {
        var tooltip = "<ul>";
        var hosts = this.get('overriddenSCP.selectedHostOptions');
        if (hosts != null) {
          hosts.forEach(function (host) {
            var hostObj = App.Host.find(host);
            if (hostObj != null) {
              host = hostObj.get('publicHostName');
            }
            tooltip += ("<li>" + host + "</li>");
          });
        }
        tooltip += "</ul>";
        return tooltip;
      }.property('overriddenSCP', 'overriddenSCP.selectedHostOptions')
    })
  });
  
});
window.require.register("views/common/configs/services_config", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var validator = require('utils/validator');
  var stringUtils = require('utils/string_utils');

  App.ServicesConfigView = Em.View.extend({
    templateName: require('templates/common/configs/services_config'),
    didInsertElement: function () {
      var controller = this.get('controller');
      controller.loadStep();
    }
  });

  App.ServiceConfigView = Em.View.extend({
    templateName: require('templates/common/configs/service_config'),
    isRestartMessageCollapsed: false,
    filter: '', //from template
    columns: [], //from template
    canEdit: true, // View is editable or read-only?
    toggleRestartMessageView: function () {
      this.$('.service-body').toggle('blind', 200);
      this.set('isRestartMessageCollapsed', !this.get('isRestartMessageCollapsed'));
    },
    didInsertElement: function () {
      this.$('.service-body').hide();
      $(".restart-required-property").tooltip({html: true});
      $(".icon-lock").tooltip({placement: 'right'});
    }
  });


  App.ServiceConfigsByCategoryView = Ember.View.extend({

    classNames: ['accordion-group', 'common-config-category'],
    classNameBindings: ['category.name', 'isShowBlock::hidden'],

    content: null,
    category: null,
    service: null,
    canEdit: true, // View is editable or read-only?
    serviceConfigs: null, // General, Advanced, NameNode, SNameNode, DataNode, etc.
    // total number of
    // hosts (by
    // default,
    // cacheable )
    categoryConfigs: function () {
      return this.get('serviceConfigs').filterProperty('category', this.get('category.name')).filterProperty('isVisible', true);
    }.property('serviceConfigs.@each', 'categoryConfigsAll.@each.isVisible').cacheable(),

    /**
     * This method provides all the properties which apply
     * to this category, irrespective of visibility. This
     * is helpful in Oozie/Hive database configuration, where
     * MySQL etc. database options don't show up, because
     * they were not visible initially.
     */
    categoryConfigsAll: function () {
      return this.get('serviceConfigs').filterProperty('category', this.get('category.name'));
    }.property('serviceConfigs.@each').cacheable(),

    /**
     * Warn/prompt user to adjust Service props when changing user/groups in Misc
     * Is triggered when user ended editing text field
     */
    miscConfigChange: function (manuallyChangedProperty) {
      var changedProperty;
      if(manuallyChangedProperty.get("id")){
        changedProperty = [manuallyChangedProperty];
      }else{
        changedProperty = this.get("serviceConfigs").filterProperty("editDone", true);
      }

      if (changedProperty.length > 0) {
        changedProperty = changedProperty.objectAt(0);
      } else {
        return;
      }
      if (this.get('controller.selectedService.serviceName') == 'MISC') {
        var newValue = changedProperty.get("value");
        var stepConfigs = this.get("controller.stepConfigs");
        this.affectedProperties = [];
        var curConfigs = "";
        if (changedProperty.get("name") == "hdfs_user") {
          curConfigs = stepConfigs.findProperty("serviceName", "HDFS").get("configs");
          if (newValue != curConfigs.findProperty("name", "dfs.permissions.supergroup").get("value")) {
            this.affectedProperties.push(
              {
                serviceName: "HDFS",
                propertyName: "dfs.permissions.supergroup",
                propertyDisplayName: "dfs.permissions.supergroup",
                newValue: newValue,
                curValue: curConfigs.findProperty("name", "dfs.permissions.supergroup").get("value"),
                changedPropertyName: "hdfs_user"
              }
            );
          }
          if ($.trim(newValue) != $.trim(curConfigs.findProperty("name", "dfs.cluster.administrators").get("value"))) {
            this.affectedProperties.push(
              {
                serviceName: "HDFS",
                propertyName: "dfs.cluster.administrators",
                propertyDisplayName: "dfs.cluster.administrators",
                newValue: " " + $.trim(newValue),
                curValue: curConfigs.findProperty("name", "dfs.cluster.administrators").get("value"),
                changedPropertyName: "hdfs_user"
              }
            );
          }
        } else if (changedProperty.get("name") == "hbase_user") {
          curConfigs = stepConfigs.findProperty("serviceName", "HDFS").get("configs");
          if (newValue != curConfigs.findProperty("name", "dfs_block_local_path_access_user").get("value")) {
            this.affectedProperties.push(
              {
                serviceName: "HDFS",
                propertyName: "dfs_block_local_path_access_user",
                propertyDisplayName: "dfs.block.local-path-access.user",
                newValue: newValue,
                curValue: curConfigs.findProperty("name", "dfs_block_local_path_access_user").get("value"),
                changedPropertyName: "hbase_user"
              }
            );
          }
          var hbaseCurConfigs = stepConfigs.findProperty("serviceName", "HBASE").get("configs");
          if (newValue != hbaseCurConfigs.findProperty("name", "hbase.superuser").get("value")) {
            this.affectedProperties.push(
              {
                serviceName: "HBASE",
                propertyName: "hbase.superuser",
                propertyDisplayName: "hbase.superuser",
                newValue: newValue,
                curValue: hbaseCurConfigs.findProperty("name", "hbase.superuser").get("value"),
                changedPropertyName: "hbase_user"
              }
            );
          }
        } else if (changedProperty.get("name") == "user_group") {
          if (!(this.get("controller.selectedServiceNames").indexOf("MAPREDUCE") >= 0)) {
            return;
          }
          curConfigs = stepConfigs.findProperty("serviceName", "MAPREDUCE").get("configs");
          if (newValue != curConfigs.findProperty("name", "mapreduce.tasktracker.group").get("value")) {
            this.affectedProperties.push(
              {
                serviceName: "MAPREDUCE",
                propertyName: "mapreduce.tasktracker.group",
                propertyDisplayName: "mapreduce.tasktracker.group",
                newValue: newValue,
                curValue: curConfigs.findProperty("name", "mapreduce.tasktracker.group").get("value"),
                changedPropertyName: "user_group"
              }
            )
          }
          if ($.trim(newValue) != $.trim(curConfigs.findProperty("name", "mapreduce.cluster.administrators").get("value"))) {
            this.affectedProperties.push(
              {
                serviceName: "MAPREDUCE",
                propertyName: "mapreduce.cluster.administrators",
                propertyDisplayName: "mapreduce.cluster.administrators",
                newValue: " " + $.trim(newValue),
                curValue: curConfigs.findProperty("name", "mapreduce.cluster.administrators").get("value"),
                changedPropertyName: "user_group"
              }
            );
          }
        }
        if (this.affectedProperties.length > 0 && !this.get("controller.miscModalVisible")) {
          this.newAffectedProperties = this.affectedProperties;
          var self = this;
          return App.ModalPopup.show({
            classNames: ['modal-690px-width'],
            showCloseButton: false,
            header: "Warning: you must also change these Service properties",
            onApply: function () {
              self.get("newAffectedProperties").forEach(function (item) {
                self.get("controller.stepConfigs").findProperty("serviceName", item.serviceName).get("configs")
                  .findProperty("name", item.propertyName).set("value", item.newValue);
              });
              self.get("controller").set("miscModalVisible", false);
              this.hide();
            },
            onIgnore: function () {
              self.get("controller").set("miscModalVisible", false);
              this.hide();
            },
            onUndo: function () {
              var affected = self.get("newAffectedProperties").objectAt(0);
              self.get("controller.stepConfigs").findProperty("serviceName", "MISC").get("configs")
                .findProperty("name", affected.changedPropertyName).set("value", $.trim(affected.curValue));
              self.get("controller").set("miscModalVisible", false);
              this.hide();
            },
            footerClass: Ember.View.extend({
              classNames: ['modal-footer'],
              template: Ember.Handlebars.compile([
                '<div class="pull-right">',
                '<button class="btn" {{action onUndo target="view.parentView"}}>Cancel</button>',
                '<button class="btn btn-warning" {{action onIgnore target="view.parentView"}}>Ignore</button>',
                '<button class="btn btn-success" {{action onApply target="view.parentView"}}>Apply</button>',
                '</div>'
              ].join(''))
            }),
            bodyClass: Ember.View.extend({
              templateName: require('templates/common/configs/propertyDependence'),
              controller: this,
              propertyChange: self.get("newAffectedProperties"),
              didInsertElement: function () {
                self.get("controller").set("miscModalVisible", true);
              }
            })
          });
        }
      }
    }.observes('categoryConfigs.@each.editDone'),

    /**
     * When the view is in read-only mode, it marks
     * the properties as read-only.
     */
    updateReadOnlyFlags: function () {
      var configs = this.get('serviceConfigs');
      var canEdit = this.get('canEdit');
      if (!canEdit && configs) {
        configs.forEach(function (config) {
          config.set('isEditable', false);
        });
      }
    },

    /**
     * Filtered <code>categoryConfigs</code> array. Used to show filtered result
     */
    filteredCategoryConfigs: function () {
      var filter = this.get('parentView.filter').toLowerCase();
      var isOnlyModified = this.get('parentView.columns').length && this.get('parentView.columns')[1].get('selected');
      var isOnlyOverridden = this.get('parentView.columns').length && this.get('parentView.columns')[0].get('selected');
      var isOnlyRestartRequired = this.get('parentView.columns').length && this.get('parentView.columns')[2].get('selected');
      var filteredResult = this.get('categoryConfigs').filter(function (config) {

        if (isOnlyModified && !config.get('isNotDefaultValue')) {
          return false;
        }

        if (isOnlyOverridden && !config.get('isOverridden')) {
          return false;
        }

        if (isOnlyRestartRequired && !config.get('isRestartRequired')) {
          return false;
        }

        var searchString = config.get('defaultValue') + config.get('description') +
          config.get('displayName') + config.get('name');

        return searchString.toLowerCase().indexOf(filter) > -1;
      });
      filteredResult = this.sortByIndex(filteredResult);
      return filteredResult;
    }.property('categoryConfigs', 'parentView.filter', 'parentView.columns.@each.selected'),

    /**
     * sort configs in current category by index
     * @param configs
     * @return {*}
     */
    sortByIndex: function (configs) {
      var sortedConfigs = [];
      var unSorted = [];
      if (!configs.someProperty('index')) {
        return configs;
      }
      configs.forEach(function (config) {
        var index = config.get('index');
        if ((index !== null) && isFinite(index)) {
          sortedConfigs[index] ? sortedConfigs.splice(index, 0, config) : sortedConfigs[index] = config;
        } else {
          unSorted.push(config);
        }
      });
      // remove undefined elements from array
      sortedConfigs = sortedConfigs.filter(function (config) {
        if (config !== undefined) return true;
      });
      return sortedConfigs.concat(unSorted);
    },
    /**
     * Onclick handler for Config Group Header. Used to show/hide block
     */
    onToggleBlock: function () {
      this.$('.accordion-body').toggle('blind', 500);
      this.set('category.isCollapsed', !this.get('category.isCollapsed'));
    },

    /**
     * Should we show config group or not
     */
    isShowBlock: function () {
      return this.get('category.canAddProperty') || this.get('filteredCategoryConfigs').length > 0;
    }.property('category.canAddProperty', 'filteredCategoryConfigs.length'),

    didInsertElement: function () {
      var isCollapsed = (this.get('category.name').indexOf('Advanced') != -1);
      this.set('category.isCollapsed', isCollapsed);
      if (isCollapsed) {
        this.$('.accordion-body').hide();
      }
      this.updateReadOnlyFlags();
    },
    childView: App.ServiceConfigsOverridesView,
    changeFlag: Ember.Object.create({
      val: 1
    }),
    isOneOfAdvancedSections: function () {
      var category = this.get('category');
      return category.indexOf("Advanced") != -1;
    },
    showAddPropertyWindow: function (event) {
      var configsOfFile = this.get('service.configs').filterProperty('filename', this.get('category.siteFileName'));
      var serviceConfigObj = Ember.Object.create({
        name: '',
        value: '',
        defaultValue: null,
        filename: '',
        isUserProperty: true,
        isKeyError: false,
        errorMessage: "",
        observeAddPropertyValue: function () {
          var name = this.get('name');
          if (name.trim() != "") {
            if (validator.isValidConfigKey(name)) {
              var configMappingProperty = App.config.get('configMapping').all().findProperty('name', name);
              if ((configMappingProperty == null) && (!configsOfFile.findProperty('name', name))) {
                this.set("isKeyError", false);
                this.set("errorMessage", "");
              } else {
                this.set("isKeyError", true);
                this.set("errorMessage", Em.I18n.t('services.service.config.addPropertyWindow.error.derivedKey'));
              }
            } else {
              this.set("isKeyError", true);
              this.set("errorMessage", Em.I18n.t('form.validator.configKey'));
            }
          } else {
            this.set("isKeyError", true);
            this.set("errorMessage", Em.I18n.t('services.service.config.addPropertyWindow.errorMessage'));
          }
        }.observes("name")
      });

      var category = this.get('category');
      serviceConfigObj.displayType = "advanced";
      serviceConfigObj.category = category.get('name');

      var serviceName = this.get('service.serviceName');
      var serviceConfigsMetaData = App.config.get('preDefinedServiceConfigs');
      var serviceConfigMetaData = serviceConfigsMetaData.findProperty('serviceName', serviceName);
      var categoryMetaData = serviceConfigMetaData == null ? null : serviceConfigMetaData.configCategories.findProperty('name', category.get('name'));
      if (categoryMetaData != null) {
        serviceConfigObj.filename = categoryMetaData.siteFileName;
      }

      var self = this;
      App.ModalPopup.show({
        // classNames: ['big-modal'],
        classNames: [ 'sixty-percent-width-modal'],
        header: "添加属性",
        primary: '添加',
        secondary: '取消',
        onPrimary: function () {
          serviceConfigObj.observeAddPropertyValue();
          /**
           * For the first entrance use this if (serviceConfigObj.name.trim() != "")
           */
          if (!serviceConfigObj.isKeyError) {
            serviceConfigObj.displayName = serviceConfigObj.name;
            serviceConfigObj.id = 'site property';
            serviceConfigObj.serviceName = serviceName;
            serviceConfigObj.displayType = stringUtils.isSingleLine(serviceConfigObj.get('value')) ? 'advanced' : 'multiLine';
            var serviceConfigProperty = App.ServiceConfigProperty.create(serviceConfigObj);
            self.get('controller.secureConfigs').filterProperty('filename', self.get('category.siteFileName')).forEach(function (_secureConfig) {
              if (_secureConfig.name === serviceConfigProperty.get('name')) {
                serviceConfigProperty.set('isSecureConfig', true);
              }
            }, this);
            self.get('serviceConfigs').pushObject(serviceConfigProperty);
            this.hide();
          }
        },
        onSecondary: function () {
          this.hide();
        },
        bodyClass: Ember.View.extend({
          templateName: require('templates/common/configs/addPropertyWindow'),
          controllerBinding: 'App.router.mainServiceInfoConfigsController',
          serviceConfigProperty: serviceConfigObj
        })
      });

    },

    /**
     * Removes the top-level property from list of properties.
     * Should be only called on user properties.
     */
    removeProperty: function (event) {
      var serviceConfigProperty = event.contexts[0];
      this.get('serviceConfigs').removeObject(serviceConfigProperty);
    },

    /**
     * Restores given property's value to be its default value.
     * Does not update if there is no default value.
     */
    doRestoreDefaultValue: function (event) {
      var serviceConfigProperty = event.contexts[0];
      var value = serviceConfigProperty.get('value');
      var dValue = serviceConfigProperty.get('defaultValue');
      if (dValue != null) {
        if (serviceConfigProperty.get('displayType') === 'password') {
          serviceConfigProperty.set('retypedPassword', dValue);
        }
        serviceConfigProperty.set('value', dValue);
      }
      this.miscConfigChange(serviceConfigProperty);
    },

    createOverrideProperty: function (event) {
      var serviceConfigProperty = event.contexts[0];
      var overrides = serviceConfigProperty.get('overrides');
      if (!overrides) {
        overrides = [];
        serviceConfigProperty.set('overrides', overrides);
      }

      // create new override with new value
      var newSCP = App.ServiceConfigProperty.create(serviceConfigProperty);
      newSCP.set('value', '');
      newSCP.set('isOriginalSCP', false); // indicated this is overridden value,
      newSCP.set('parentSCP', serviceConfigProperty);
      newSCP.set('selectedHostOptions', Ember.A([]));
      console.debug("createOverrideProperty(): Added:", newSCP, " to main-property:", serviceConfigProperty);
      overrides.pushObject(newSCP);

      // Launch override window
      var dummyEvent = {contexts: [newSCP]};
      this.showOverrideWindow(dummyEvent);
    },

    showOverrideWindow: function (event) {
      // argument 1
      var serviceConfigProperty = event.contexts[0];
      var parentServiceConfigProperty = serviceConfigProperty.get('parentSCP');
      var alreadyOverriddenHosts = [];
      parentServiceConfigProperty.get('overrides').forEach(function (override) {
        if (override != null && override != serviceConfigProperty && override.get('selectedHostOptions') != null) {
          alreadyOverriddenHosts = alreadyOverriddenHosts.concat(override.get('selectedHostOptions'))
        }
      });
      var selectedHosts = serviceConfigProperty.get('selectedHostOptions');
      /**
       * Get all the hosts available for selection. Since data is dependent on
       * controller, we ask it, instead of doing regular Ember's App.Host.find().
       * This should be an array of App.Host.
       */
      var allHosts = this.get('controller.getAllHosts');
      var availableHosts = Ember.A([]);
      allHosts.forEach(function (host) {
        var hostId = host.get('id');
        if (alreadyOverriddenHosts.indexOf(hostId) < 0) {
          availableHosts.pushObject(Ember.Object.create({
            selected: selectedHosts.indexOf(hostId) > -1,
            host: host
          }));
        }
      });
      /**
       * From the currently selected service we want the service-components.
       * We only need an array of objects which have the 'componentName' and
       * 'displayName' properties. Since each controller has its own objects,
       * we ask for a normalized array back.
       */
      var validComponents = this.get('controller.getCurrentServiceComponents');
      App.ModalPopup.show({
        classNames: [ 'sixty-percent-width-modal' ],
        header: Em.I18n.t('hosts.selectHostsDialog.title'),
        primary: Em.I18n.t('ok'),
        secondary: Em.I18n.t('common.cancel'),
        warningMessage: null,
        onPrimary: function () {
          console.debug('serviceConfigProperty.(old-selectedHosts)=' + serviceConfigProperty.get('selectedHosts'));
          var arrayOfSelectedHosts = [];
          var selectedHosts = availableHosts.filterProperty('selected', true);
          selectedHosts.forEach(function (host) {
            arrayOfSelectedHosts.push(host.get('host.id'));
          });
          if (arrayOfSelectedHosts.length > 0) {
            this.set('warningMessage', null);
            serviceConfigProperty.set('selectedHostOptions', arrayOfSelectedHosts);
            serviceConfigProperty.validate();
            console.debug('serviceConfigProperty.(new-selectedHosts)=', arrayOfSelectedHosts);
            this.hide();
          } else {
            this.set('warningMessage', 'Atleast one host needs to be selected.');
          }
        },
        onSecondary: function () {
          // If property has no hosts already, then remove it from the parent.
          var hostCount = serviceConfigProperty.get('selectedHostOptions.length');
          if (hostCount < 1) {
            var parentSCP = serviceConfigProperty.get('parentSCP');
            var overrides = parentSCP.get('overrides');
            overrides.removeObject(serviceConfigProperty);
          }
          this.hide();
        },
        bodyClass: Ember.View.extend({
          templateName: require('templates/common/configs/overrideWindow'),
          controllerBinding: 'App.router.mainServiceInfoConfigsController',
          serviceConfigProperty: serviceConfigProperty,
          filterText: '',
          filterTextPlaceholder: Em.I18n.t('hosts.selectHostsDialog.filter.placeHolder'),
          availableHosts: availableHosts,
          filterColumn: Ember.Object.create({id: 'ip', name: 'IP Address', selected: false}),
          filterColumns: Ember.A([
            Ember.Object.create({id: 'ip', name: 'IP Address', selected: false}),
            Ember.Object.create({id: 'cpu', name: 'CPU', selected: false}),
            Ember.Object.create({id: 'memory', name: 'RAM', selected: false}),
            Ember.Object.create({id: 'diskUsage', name: 'Disk Usage', selected: false}),
            Ember.Object.create({id: 'loadAvg', name: 'Load Average', selected: false}),
            Ember.Object.create({id: 'osArch', name: 'OS Architecture', selected: false}),
            Ember.Object.create({id: 'osType', name: 'OS Type', selected: false})
          ]),
          showOnlySelectedHosts: false,
          filterComponents: validComponents,
          filterComponent: null,
          filteredHosts: function () {
            var hosts = this.get('availableHosts');
            var filterText = this.get('filterText');
            var showOnlySelectedHosts = this.get('showOnlySelectedHosts');
            var filteredHosts = Ember.A([]);
            var self = this;
            hosts.forEach(function (host) {
              var skip = false;
              var ahost = host.get('host');
              var filterColumn = self.get('filterColumn');
              if (filterColumn == null) {
                filterColumn = self.get('filterColumns').objectAt(0);
              }
              var value = ahost.get(filterColumn.id);
              host.set('filterColumnValue', value);
              if (filterText != null && filterText.length > 0) {
                if ((value == null || !value.match(filterText)) && !host.get('host.publicHostName').match(filterText)) {
                  skip = true;
                }
              }
              var filterComponent = self.get('filterComponent');
              if (!skip && filterComponent != null) {
                var componentFound = false;
                var fcn = filterComponent.get('componentName');
                var hcs = ahost.get('hostComponents');
                if (hcs != null) {
                  hcs.forEach(function (hc) {
                    if (fcn === hc.get('componentName')) {
                      componentFound = true;
                    }
                  });
                }
                if (!componentFound) {
                  skip = true;
                }
              }
              if (!skip && showOnlySelectedHosts && !host.get('selected')) {
                skip = true;
              }
              if (!skip) {
                filteredHosts.pushObject(host);
              }
            });
            return filteredHosts;
          }.property('availableHosts', 'filterText', 'filterColumn', 'filterComponent', 'filterComponent.componentName', 'showOnlySelectedHosts'),
          hostColumnValue: function (host, column) {
            return host.get(column.id);
          },
          hostSelectMessage: function () {
            var hosts = this.get('availableHosts');
            var selectedHosts = hosts.filterProperty('selected', true);
            return this.t('hosts.selectHostsDialog.selectedHostsLink').format(selectedHosts.get('length'), hosts.get('length'))
          }.property('availableHosts.@each.selected'),
          selectFilterColumn: function (event) {
            if (event != null && event.context != null && event.context.id != null) {
              var filterColumn = this.get('filterColumn');
              if (filterColumn != null) {
                filterColumn.set('selected', false);
              }
              event.context.set('selected', true);
              this.set('filterColumn', event.context);
            }
          },
          selectFilterComponent: function (event) {
            if (event != null && event.context != null && event.context.componentName != null) {
              var currentFilter = this.get('filterComponent');
              if (currentFilter != null) {
                currentFilter.set('selected', false);
              }
              if (currentFilter != null && currentFilter.componentName === event.context.componentName) {
                // selecting the same filter deselects it.
                this.set('filterComponent', null);
              } else {
                this.set('filterComponent', event.context);
                event.context.set('selected', true);
              }
            }
          },
          allHostsSelected: false,
          toggleSelectAllHosts: function (event) {
            if (this.get('allHostsSelected')) {
              // Select all hosts
              this.get('availableHosts').setEach('selected', true);
            } else {
              // Deselect all hosts
              this.get('availableHosts').setEach('selected', false);
            }
          }.observes('allHostsSelected'),
          toggleShowSelectedHosts: function () {
            var currentFilter = this.get('filterComponent');
            if (currentFilter != null) {
              currentFilter.set('selected', false);
            }
            this.set('filterComponent', null);
            this.set('filterText', null);
            this.set('showOnlySelectedHosts', !this.get('showOnlySelectedHosts'));
          }
        })
      });
    }
  });

  App.ServiceConfigTab = Ember.View.extend({

    tagName: 'li',

    selectService: function (event) {
      this.set('controller.selectedService', event.context);
    },

    didInsertElement: function () {
      var serviceName = this.get('controller.selectedService.serviceName');
      this.$('a[href="#' + serviceName + '"]').tab('show');
    }
  });

  /**
   * custom view for capacity scheduler category
   * @type {*}
   */
  App.ServiceConfigCapacityScheduler = App.ServiceConfigsByCategoryView.extend({
    templateName: require('templates/common/configs/capacity_scheduler'),
    category: null,
    service: null,
    serviceConfigs: null,
    customConfigs: require('data/custom_configs'),
    /**
     * configs filtered by capacity-scheduler category
     */
    categoryConfigs: function () {
      return this.get('serviceConfigs').filterProperty('category', this.get('category.name'));
    }.property('queueObserver', 'serviceConfigs.@each'),
    /**
     * rewrote method to avoid incompatibility with parent
     */
    filteredCategoryConfigs: function () {
      return this.get('categoryConfigs');
    }.property(),
    advancedConfigs: function () {
      return this.get('categoryConfigs').filterProperty('isQueue', undefined) || [];
    }.property('categoryConfigs.@each'),
    didInsertElement: function () {
      this._super();
      this.createEmptyQueue(this.get('customConfigs').filterProperty('isQueue'));
    },
    //list of fields which will be populated by default in a new queue
    fieldsToPopulate: [
      "mapred.capacity-scheduler.queue.<queue-name>.minimum-user-limit-percent",
      "mapred.capacity-scheduler.queue.<queue-name>.user-limit-factor",
      "mapred.capacity-scheduler.queue.<queue-name>.supports-priority",
      "mapred.capacity-scheduler.queue.<queue-name>.maximum-initialized-active-tasks",
      "mapred.capacity-scheduler.queue.<queue-name>.maximum-initialized-active-tasks-per-user",
      "mapred.capacity-scheduler.queue.<queue-name>.init-accept-jobs-factor"
    ],
    /**
     * create empty queue
     * take some queue then copy it and set all config values to null
     * @param customConfigs
     */
    createEmptyQueue: function (customConfigs) {
      var emptyQueue = {
        name: '<queue-name>',
        configs: []
      };
      var fieldsToPopulate = this.get('fieldsToPopulate');
      customConfigs.forEach(function (config) {
        var newConfig = $.extend({}, config);
        if (fieldsToPopulate.contains(config.name)) {
          App.config.setDefaultQueue(newConfig, emptyQueue.name);
        }
        newConfig = App.ServiceConfigProperty.create(newConfig);
        newConfig.validate();
        emptyQueue.configs.push(newConfig);
      });
      this.set('emptyQueue', emptyQueue);
    },
    queues: function () {
      var configs = this.get('categoryConfigs').filterProperty('isQueue', true);
      var queueNames = [];
      var queues = [];
      configs.mapProperty('name').forEach(function (name) {
        var queueName = /^mapred\.capacity-scheduler\.queue\.(.*?)\./.exec(name);
        if (queueName) {
          queueNames.push(queueName[1]);
        }
      });
      queueNames = queueNames.uniq();
      queueNames.forEach(function (queueName) {
        queues.push({
          name: queueName,
          color: this.generateColor(queueName),
          configs: this.filterConfigsByQueue(queueName, configs)
        })
      }, this);
      return queues;
    }.property('queueObserver'),
    /**
     * filter configs by queue
     * @param queueName
     * @param configs
     */
    filterConfigsByQueue: function (queueName, configs) {
      var customConfigs = this.get('customConfigs');
      var queue = [];
      configs.forEach(function (config) {
        var customConfig = customConfigs.findProperty('name', config.name.replace('queue.' + queueName, 'queue.<queue-name>'));
        if ((config.name.indexOf('mapred.capacity-scheduler.queue.' + queueName) !== -1) ||
          (config.name.indexOf('mapred.queue.' + queueName) !== -1)) {
          if (customConfig) {
            config.set('description', customConfig.description);
            config.set('displayName', customConfig.displayName);
            config.set('isRequired', customConfig.isRequired);
            config.set('unit', customConfig.unit);
            config.set('displayType', customConfig.displayType);
            config.set('valueRange', customConfig.valueRange);
            config.set('isVisible', customConfig.isVisible);
            config.set('index', customConfig.index);
          }
          queue.push(config);
        }
      });
      //each queue consists of 10 properties if less then add missing properties
      if (queue.length < 10) {
        this.addMissingProperties(queue, queueName);
      }
      return queue;
    },
    /**
     * add missing properties to queue
     * @param queue
     * @param queueName
     */
    addMissingProperties: function (queue, queueName) {
      var customConfigs = this.get('customConfigs');
      customConfigs.forEach(function (_config) {
        var serviceConfigProperty = $.extend({}, _config);
        serviceConfigProperty.name = serviceConfigProperty.name.replace(/<queue-name>/, queueName);
        if (!queue.someProperty('name', serviceConfigProperty.name)) {
          App.config.setDefaultQueue(serviceConfigProperty, queueName);
          serviceConfigProperty = App.ServiceConfigProperty.create(serviceConfigProperty);
          serviceConfigProperty.validate();
          queue.push(serviceConfigProperty);
        }
      }, this);
    },
    /**
     * format table content from queues
     */
    tableContent: function () {
      var result = [];
      this.get('queues').forEach(function (queue) {
        var usersAndGroups = queue.configs.findProperty('name', 'mapred.queue.' + queue.name + '.acl-submit-job').get('value');
        usersAndGroups = (usersAndGroups) ? usersAndGroups.split(' ') : [''];
        if (usersAndGroups.length == 1) {
          usersAndGroups.push('');
        }
        var queueObject = {
          name: queue.name,
          color: 'background-color:' + queue.color + ';',
          users: usersAndGroups[0],
          groups: usersAndGroups[1],
          capacity: queue.configs.findProperty('name', 'mapred.capacity-scheduler.queue.' + queue.name + '.capacity').get('value'),
          maxCapacity: queue.configs.findProperty('name', 'mapred.capacity-scheduler.queue.' + queue.name + '.maximum-capacity').get('value'),
          minUserLimit: queue.configs.findProperty('name', 'mapred.capacity-scheduler.queue.' + queue.name + '.minimum-user-limit-percent').get('value'),
          userLimitFactor: queue.configs.findProperty('name', 'mapred.capacity-scheduler.queue.' + queue.name + '.user-limit-factor').get('value'),
          supportsPriority: queue.configs.findProperty('name', 'mapred.capacity-scheduler.queue.' + queue.name + '.supports-priority').get('value')
        };
        result.push(queueObject);
      }, this);
      return result;
    }.property('queues'),
    queueObserver: null,
    /**
     * uses as template for adding new queue
     */
    emptyQueue: [],
    generateColor: function (str) {
      var hash = 0;
      for (var i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
      }
      return '#' + Number(Math.abs(hash)).toString(16).concat('00000').substr(0, 6);
    },
    /**
     * add new queue
     * add created configs to serviceConfigs with current queue name
     * @param queue
     */
    addQueue: function (queue) {
      var serviceConfigs = this.get('serviceConfigs');
      var admin = [];
      var submit = [];
      var submitConfig;
      var adminConfig;
      queue.name = queue.configs.findProperty('name', 'queueName').get('value');
      queue.configs.forEach(function (config) {
        if (config.name == 'mapred.queue.<queue-name>.acl-administer-jobs') {
          if (config.type == 'USERS') {
            admin[0] = config.value;
          }
          if (config.type == 'GROUPS') {
            admin[1] = config.value;
          }
          if (config.isQueue) {
            adminConfig = config;
          }
        }
        if (config.name == 'mapred.queue.<queue-name>.acl-submit-job') {
          if (config.type == 'USERS') {
            submit[0] = config.value;
          }
          if (config.type == 'GROUPS') {
            submit[1] = config.value;
          }
          if (config.isQueue) {
            submitConfig = config;
          }
        }
        config.set('name', config.get('name').replace('<queue-name>', queue.name));
        config.set('value', config.get('value').toString());
        if (config.isQueue) {
          serviceConfigs.push(config);
        }
      });
      adminConfig.set('value', admin.join(' '));
      submitConfig.set('value', submit.join(' '));
      this.set('queueObserver', new Date().getTime());
    },
    /**
     * delete queue
     * delete configs from serviceConfigs which have current queue name
     * @param queue
     */
    deleteQueue: function (queue) {
      var serviceConfigs = this.get('serviceConfigs');
      var configNames = queue.configs.filterProperty('isQueue').mapProperty('name');
      for (var i = 0, l = serviceConfigs.length; i < l; i++) {
        if (configNames.contains(serviceConfigs[i].name)) {
          serviceConfigs.splice(i, 1);
          l--;
          i--;
        }
      }
      this.set('queueObserver', new Date().getTime());
    },
    /**
     * save changes that was made to queue
     * edit configs from serviceConfigs which have current queue name
     * @param queue
     */
    editQueue: function (queue) {
      var serviceConfigs = this.get('serviceConfigs');
      var configNames = queue.configs.filterProperty('isQueue').mapProperty('name');
      serviceConfigs.forEach(function (_config) {
        var configName = _config.get('name');
        var admin = [];
        var submit = [];
        if (configNames.contains(_config.get('name'))) {
          if (configName == 'mapred.queue.' + queue.name + '.acl-submit-job') {
            submit = queue.configs.filterProperty('name', configName);
            submit = submit.findProperty('type', 'USERS').get('value') + ' ' + submit.findProperty('type', 'GROUPS').get('value');
            _config.set('value', submit);
          } else if (configName == 'mapred.queue.' + queue.name + '.acl-administer-jobs') {
            admin = queue.configs.filterProperty('name', configName);
            admin = admin.findProperty('type', 'USERS').get('value') + ' ' + admin.findProperty('type', 'GROUPS').get('value');
            _config.set('value', admin);
          } else {
            _config.set('value', queue.configs.findProperty('name', _config.get('name')).get('value').toString());
          }
          //comparison executes including 'queue.<queue-name>' to avoid false matches
          _config.set('name', configName.replace('queue.' + queue.name, 'queue.' + queue.configs.findProperty('name', 'queueName').get('value')));
        }
      });
      this.set('queueObserver', new Date().getTime());
    },
    pieChart: App.ChartPieView.extend({
      w: 200,
      h: 200,
      queues: null,
      didInsertElement: function () {
        this.update();
      },
      data: [
        {"label": "default", "value": 100}
      ],
      update: function () {
        var self = this;
        var data = [];
        var queues = this.get('queues');
        var capacitiesSum = 0;
        queues.forEach(function (queue) {
          data.push({
            label: queue.name,
            value: parseInt(queue.configs.findProperty('name', 'mapred.capacity-scheduler.queue.' + queue.name + '.capacity').get('value')),
            color: queue.color
          })
        });

        data.mapProperty('value').forEach(function (capacity) {
          capacitiesSum += capacity;
        });
        if (capacitiesSum < 100) {
          data.push({
            label: Em.I18n.t('common.empty'),
            value: (100 - capacitiesSum),
            color: 'transparent',
            isEmpty: true
          })
        }
        $(d3.select(this.get('selector'))[0]).children().remove();
        this.set('data', data);
        this.set('palette', new Rickshaw.Color.Palette({
          scheme: data.mapProperty('color')
        }));
        this.appendSvg();

        this.get('arcs')
          .on("click",function (d, i) {
            var event = {context: d.data.label};
            if (d.data.isEmpty !== true) self.get('parentView').queuePopup(event);
          }).on('mouseover', function (d, i) {
            var position = d3.svg.mouse(this);
            var label = $('#section_label');
            label.css('left', position[0] + 100);
            label.css('top', position[1] + 100);
            label.text(d.data.label);
            label.show();
          })
          .on('mouseout', function (d, i) {
            $('#section_label').hide();
          })

      }.observes('queues'),
      donut: d3.layout.pie().sort(null).value(function (d) {
        return d.value;
      })
    }),
    /**
     * open popup with chosen queue
     * @param event
     */
    queuePopup: function (event) {
      //if queueName was handed that means "Edit" mode, otherwise "Add" mode
      var queueName = event.context || null;
      var self = this;
      App.ModalPopup.show({
        didInsertElement: function () {
          if (queueName) {
            this.set('header', Em.I18n.t('services.mapReduce.config.editQueue'));
            this.set('secondary', Em.I18n.t('common.save'));
            if (self.get('queues').length > 1 && self.get('canEdit')) {
              this.set('delete', Em.I18n.t('common.delete'));
            }
          }
        },
        header: Em.I18n.t('services.mapReduce.config.addQueue'),
        secondary: Em.I18n.t('common.add'),
        primary: Em.I18n.t('common.cancel'),
        delete: null,
        isError: function () {
          if (!self.get('canEdit')) {
            return true;
          }
          var content = this.get('content');
          var configs = content.configs.filter(function (config) {
            if ((config.name == 'mapred.queue.' + content.name + '.acl-submit-job' ||
              config.name == 'mapred.queue.' + content.name + '.acl-administer-jobs') &&
              (config.isQueue)) {
              return false;
            }
            return true;
          });
          return configs.someProperty('isValid', false);
        }.property('content.configs.@each.isValid'),
        onDelete: function () {
          var view = this;
          App.ModalPopup.show({
            header: Em.I18n.t('popup.confirmation.commonHeader'),
            body: Em.I18n.t('hosts.delete.popup.body'),
            primary: Em.I18n.t('yes'),
            onPrimary: function () {
              self.deleteQueue(view.get('content'));
              view.hide();
              this.hide();
            }
          });
        },
        onSecondary: function () {
          if (queueName) {
            self.editQueue(this.get('content'));
          } else {
            self.addQueue(this.get('content'));
          }
          this.hide();
        },
        /**
         * Queue properties order:
         * 1. Queue Name
         * 2. Capacity
         * 3. Max Capacity
         * 4. Users
         * 5. Groups
         * 6. Admin Users
         * 7. Admin Groups
         * 8. Support Priority
         * ...
         */
        content: function () {
          var content = (queueName) ? self.get('queues').findProperty('name', queueName) : self.get('emptyQueue');
          var configs = [];
          var tableContent = self.get('tableContent');
          // copy of queue configs
          content.configs.forEach(function (config, index) {
            if (config.name == 'mapred.capacity-scheduler.queue.' + content.name + '.capacity') {
              config.reopen({
                validate: function () {
                  var value = this.get('value');
                  var isError = false;
                  var capacities = [];
                  var capacitySum = 0;
                  if (tableContent) {
                    capacities = tableContent.mapProperty('capacity');
                    for (var i = 0, l = capacities.length; i < l; i++) {
                      capacitySum += parseInt(capacities[i]);
                    }
                    if (content.name != '<queue-name>') {
                      capacitySum = capacitySum - parseInt(tableContent.findProperty('name', content.name).capacity);
                    }
                  }
                  if (value == '') {
                    if (this.get('isRequired')) {
                      this.set('errorMessage', 'This is required');
                      isError = true;
                    } else {
                      return;
                    }
                  }
                  if (!isError) {
                    if (!validator.isValidInt(value)) {
                      this.set('errorMessage', 'Must contain digits only');
                      isError = true;
                    }
                  }
                  if (!isError) {
                    if ((capacitySum + parseInt(value)) > 100) {
                      isError = true;
                      this.set('errorMessage', 'The sum of capacities more than 100');
                    }
                    if (!isError) {
                      this.set('errorMessage', '');
                    }
                  }
                }.observes('value')
              });
            }
            if (config.name == 'mapred.capacity-scheduler.queue.' + content.name + '.supports-priority') {
              if (config.get('value') == 'true' || config.get('value') === true) {
                config.set('value', true);
              } else {
                config.set('value', false);
              }
            }
            configs[index] = App.ServiceConfigProperty.create(config);
          });
          content = {
            name: content.name,
            configs: configs
          };
          content = this.insertExtraConfigs(content);
          content.configs = self.sortByIndex(content.configs);
          return content;
        }.property(),
        footerClass: Ember.View.extend({
          classNames: ['modal-footer', 'host-checks-update'],
          template: Ember.Handlebars.compile([
            '{{#if view.parentView.delete}}<div class="pull-left">',
            '<button class="btn btn-danger" {{action onDelete target="view.parentView"}}>',
            '{{view.parentView.delete}}</button></div>{{/if}}',
            '<p class="pull-right">',
            '{{#if view.parentView.primary}}<button type="button" class="btn" {{action onPrimary target="view.parentView"}}>',
            '{{view.parentView.primary}}</button>{{/if}}',
            '{{#if view.parentView.secondary}}',
            '<button type="button" {{bindAttr disabled="view.parentView.isError"}} class="btn btn-success" {{action onSecondary target="view.parentView"}}>',
            '{{view.parentView.secondary}}</button>{{/if}}',
            '</p>'
          ].join(''))
        }),
        bodyClass: Ember.View.extend({
          template: Ember.Handlebars.compile([
            '<form class="form-horizontal pre-scrollable" autocomplete="off">{{#each view.parentView.content.configs}}',
            '{{#if isVisible}}',
            '<div class="row-fluid control-group">',
            '   <div {{bindAttr class="errorMessage:error :control-label-span :span4"}}>',
            '     <label>{{displayName}}</label>',
            '   </div>',
            '   <div {{bindAttr class="errorMessage:error :control-group :span8"}}>',
            '     {{view viewClass serviceConfigBinding="this" categoryConfigsBinding="view.categoryConfigs" }}',
            '     <span class="help-inline">{{errorMessage}}</span>',
            '   </div>',
            '</div>',
            '{{/if}}',
            '{{/each}}</form>'
          ].join(''))
        }),
        /**
         * Insert extra config in popup according to queue
         *
         * the mapred.queue.default.acl-administer-jobs turns into two implicit configs:
         * "Admin Users" field and "Admin Groups" field
         * the mapred.queue.default.acl-submit-job turns into two implicit configs:
         * "Users" field and "Groups" field
         * Add implicit config that contain "Queue Name"
         * @param content
         * @return {*}
         */
        insertExtraConfigs: function (content) {
          var that = this;
          var admin = content.configs.findProperty('name', 'mapred.queue.' + content.name + '.acl-administer-jobs').get('value');
          var submit = content.configs.findProperty('name', 'mapred.queue.' + content.name + '.acl-submit-job').get('value');
          admin = (admin) ? admin.split(' ') : [''];
          submit = (submit) ? submit.split(' ') : [''];
          if (admin.length < 2) {
            admin.push('');
          }
          if (submit.length < 2) {
            submit.push('');
          }
          var newField = App.ServiceConfigProperty.create({
            name: 'queueName',
            displayName: Em.I18n.t('services.mapReduce.extraConfig.queue.name'),
            description: Em.I18n.t('services.mapReduce.description.queue.name'),
            value: (content.name == '<queue-name>') ? '' : content.name,
            validate: function () {
              var queueNames = self.get('queues').mapProperty('name');
              var value = this.get('value');
              var isError = false;
              var regExp = /^[a-z]([\_\-a-z0-9]{0,50})\$?$/i;
              if (value == '') {
                if (this.get('isRequired')) {
                  this.set('errorMessage', 'This is required');
                  isError = true;
                } else {
                  return;
                }
              }
              if (!isError) {
                if ((queueNames.indexOf(value) !== -1) && (value != content.name)) {
                  this.set('errorMessage', 'Queue name is already used');
                  isError = true;
                }
              }
              if (!isError) {
                if (!regExp.test(value)) {
                  this.set('errorMessage', 'Incorrect input');
                  isError = true;
                }
              }
              if (!isError) {
                this.set('errorMessage', '');
              }
            }.observes('value'),
            isRequired: true,
            isVisible: true,
            isEditable: self.get('canEdit'),
            index: 0
          });
          newField.validate();
          content.configs.unshift(newField);

          var submitUser = App.ServiceConfigProperty.create({
            name: 'mapred.queue.' + content.name + '.acl-submit-job',
            displayName: Em.I18n.t('common.users'),
            value: submit[0],
            description: Em.I18n.t('services.mapReduce.description.queue.submit.user'),
            isRequired: true,
            isVisible: true,
            type: 'USERS',
            displayType: "UNIXList",
            isEditable: self.get('canEdit'),
            index: 3
          });

          var submitGroup = App.ServiceConfigProperty.create({
            name: 'mapred.queue.' + content.name + '.acl-submit-job',
            displayName: Em.I18n.t('services.mapReduce.config.queue.groups'),
            description: Em.I18n.t('services.mapReduce.description.queue.submit.group'),
            value: submit[1],
            isRequired: true,
            isVisible: true,
            "displayType": "UNIXList",
            type: 'GROUPS',
            isEditable: self.get('canEdit'),
            index: 4
          });

          var adminUser = App.ServiceConfigProperty.create({
            name: 'mapred.queue.' + content.name + '.acl-administer-jobs',
            displayName: Em.I18n.t('services.mapReduce.config.queue.adminUsers'),
            description: Em.I18n.t('services.mapReduce.description.queue.admin.user'),
            value: admin[0],
            isRequired: true,
            isVisible: true,
            type: 'USERS',
            displayType: "UNIXList",
            isEditable: self.get('canEdit'),
            index: 5
          });

          var adminGroup = App.ServiceConfigProperty.create({
            name: 'mapred.queue.' + content.name + '.acl-administer-jobs',
            displayName: Em.I18n.t('services.mapReduce.config.queue.adminGroups'),
            value: admin[1],
            description: Em.I18n.t('services.mapReduce.description.queue.admin.group'),
            isRequired: true,
            isVisible: true,
            "displayType": "UNIXList",
            type: 'GROUPS',
            isEditable: self.get('canEdit'),
            index: 6
          });

          submitUser.reopen({
            validate: function () {
              that.userGroupValidation(this, submitGroup);
            }.observes('value')
          });
          submitGroup.reopen({
            validate: function () {
              that.userGroupValidation(this, submitUser);
            }.observes('value')
          });
          adminUser.reopen({
            validate: function () {
              that.userGroupValidation(this, adminGroup);
            }.observes('value')
          });
          adminGroup.reopen({
            validate: function () {
              that.userGroupValidation(this, adminUser);
            }.observes('value')
          });

          submitUser.validate();
          adminUser.validate();
          content.configs.push(submitUser);
          content.configs.push(submitGroup);
          content.configs.push(adminUser);
          content.configs.push(adminGroup);

          return content;
        },
        /**
         * Validate by follow rules:
         * Users can be blank. If this is blank, Groups must not be blank.
         * Groups can be blank. If this is blank, Users must not be blank.
         * @param context
         * @param boundConfig
         */
        userGroupValidation: function (context, boundConfig) {
          if (context.get('value') == '') {
            if (boundConfig.get('value') == '') {
              context._super();
            } else {
              boundConfig.validate();
            }
          } else {
            if (boundConfig.get('value') == '') {
              boundConfig.set('errorMessage', '');
            }
            context._super();
          }
        }
      })
    }
  });
  
});
window.require.register("views/common/filter_combobox", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');


  /**
   * Filter component with custom dropdown. Build on Twitter Bootstrap styles
   * @type {*}
   */
  App.FilterComboboxView = Ember.View.extend({
    templateName: require('templates/common/filter_combobox'),

    classNames: ['filter-combobox', 'input-append'],

    //filter: '', binding outside
    //columns: [], binding outside

    placeHolder: function(){
      return this.t('common.combobox.placeholder');
    }.property(),

    /**
     * Onclick handler for dropdown menu
     * @param event
     */
    selectFilterColumn: function(event){
      var column = event.context;
      column.set('selected', !column.get('selected'));
    }

  });
  
});
window.require.register("views/common/filter_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Wrapper View for all filter components. Layout template and common actions are located inside of it.
   * Logic specific for data component(input, select, or custom multi select, which fire any changes on interface) are
   * located in inner view - <code>filterView</code>.
   *
   * If we want to have input filter, put <code>textFieldView</code> to it.
   * All inner views implemented below this view.
   * @type {*}
   */
  var wrapperView = Ember.View.extend({
    classNames: ['view-wrapper'],
    layout: Ember.Handlebars.compile('<a href="#" {{action "clearFilter" target="view"}} class="ui-icon ui-icon-circle-close"></a> {{yield}}'),
    template: Ember.Handlebars.compile('{{#if view.fieldId}}<input type="hidden" id="{{unbound view.fieldId}}" value="" />{{/if}} {{view view.filterView}}'),

    value: null,

    /**
     * Column index
     */
    column: null,

    /**
     * If this field is exists we dynamically create hidden input element and set value there.
     * Used for some cases, where this values will be used outside of component
     */
    fieldId: null,

    clearFilter: function(){
      this.set('value', this.get('emptyValue'));
      return false;
    },

    /**
     * Use to determine whether filter is clear or not. Also when we want to set empty value
     */
    emptyValue: '',

    /**
     * Whether our <code>value</code> is empty or not
     * @return {Boolean}
     */
    isEmpty: function(){
      if(this.get('value') === null){
        return true;
      }
      return this.get('value').toString() === this.get('emptyValue').toString();
    },

    /**
     * Show/Hide <code>Clear filter</code> button.
     * Also this method updates computed field related to <code>fieldId</code> if it exists.
     * Call <code>onChangeValue</code> callback when everything is done.
     */
    showClearFilter: function(){
      if(!this.get('parentNode')){
        return;
      }

      if(this.isEmpty()){
        this.get('parentNode').addClass('notActive');
      } else {
        this.get('parentNode').removeClass('notActive');
      }

      if(this.get('fieldId')){
        this.$('> input').eq(0).val(this.get('value'));
      }

      this.onChangeValue();
    }.observes('value'),

    /**
     * Callback for value changes
     */
    onChangeValue: function(){

    },

    /**
     * Filter components is located here. Should be redefined
     */
    filterView: Em.View,

    /**
     * Update class of parentNode(hide clear filter button) on page load
     */
    didInsertElement: function(){
      var parent = this.$().parent();
      this.set('parentNode', parent);
      parent.addClass('notActive');
    }
  });

  /**
   * Simple input control for wrapperView
   */
  var textFieldView = Ember.TextField.extend({
    type:'text',
    placeholder: Em.I18n.t('any'),
    valueBinding: "parentView.value"
  });

  /**
   * Simple multiselect control for wrapperView.
   * Used to render blue button and popup, which opens on button click.
   * All content related logic should be implemented manually outside of it
   */
  var componentFieldView = Ember.View.extend({
    classNames: ['btn-group'],
    classNameBindings: ['isFilterOpen:open:'],

    /**
     * Whether popup is shown or not
     */
    isFilterOpen: false,

    /**
     * We have <code>value</code> property similar to inputs <code>value</code> property
     */
    valueBinding: 'parentView.value',

    /**
     * Clear filter to initial state
     */
    clearFilter: function(){
      this.set('value', '');
    },

    /**
     * Onclick handler for <code>cancel filter</code> button
     */
    closeFilter:function () {
      $(document).unbind('click');
      this.set('isFilterOpen', false);
    },

    /**
     * Onclick handler for <code>apply filter</code> button
     */
    applyFilter:function() {
      this.closeFilter();
    },

    /**
     * Onclick handler for <code>show component filter</code> button.
     * Also this function is used in some other places
     */
    clickFilterButton:function () {
      var self = this;
      this.set('isFilterOpen', !this.get('isFilterOpen'));
      if (this.get('isFilterOpen')) {

        var dropDown = this.$('.filter-components');
        var firstClick = true;
        $(document).bind('click', function (e) {
          if (!firstClick && $(e.target).closest(dropDown).length == 0) {
            self.set('isFilterOpen', false);
            $(document).unbind('click');
          }
          firstClick = false;
        });
      }
    }
  });

  /**
   * Simple select control for wrapperView
   */
  var selectFieldView = Ember.Select.extend({
    selectionBinding: 'parentView.value',
    contentBinding: 'parentView.content'
  });

  /**
   * Result object, which will be accessible outside
   * @type {Object}
   */
  module.exports = {
    /**
     * You can access wrapperView outside
     */
    wrapperView : wrapperView,

    /**
     * And also controls views if need it
     */
    textFieldView : textFieldView,
    selectFieldView: selectFieldView,
    componentFieldView: componentFieldView,

    /**
     * Quick create input filters
     * @param config parameters of <code>wrapperView</code>
     */
    createTextView : function(config){

      config.fieldType = config.fieldType || 'input-medium';
      config.filterView = textFieldView.extend({
        classNames : [ config.fieldType ]
      });

      return wrapperView.extend(config);
    },

    /**
     * Quick create multiSelect filters
     * @param config parameters of <code>wrapperView</code>
     */
    createComponentView : function(config){
      config.clearFilter = function(){
        this.forEachChildView(function(item){
          if(item.clearFilter){
            item.clearFilter();
          }
        });
        return false;
      };

      return wrapperView.extend(config);
    },

    /**
     * Quick create select filters
     * @param config parameters of <code>wrapperView</code>
     */
    createSelectView: function(config){

      config.fieldType = config.fieldType || 'input-medium';
      config.filterView = selectFieldView.extend({
        classNames : [ config.fieldType ]
      });
      config.emptyValue = Em.I18n.t('any');

      return wrapperView.extend(config);
    },
    /**
     * returns the filter function, which depends on the type of property
     * @param type
     * @param isGlobal check is search global
     * @return {Function}
     */
    getFilterByType: function(type, isGlobal){
      switch (type){
        case 'ambari-bandwidth':
          return function(rowValue, rangeExp){
            var compareChar = isNaN(rangeExp.charAt(0)) ? rangeExp.charAt(0) : false;
            var compareScale = rangeExp.charAt(rangeExp.length - 1);
            var compareValue = compareChar ? parseFloat(rangeExp.substr(1, rangeExp.length)) : parseFloat(rangeExp.substr(0, rangeExp.length));
            var match = false;
            if (rangeExp.length == 1 && compareChar !== false) {
              // User types only '=' or '>' or '<', so don't filter column values
              match = true;
              return match;
            }
            switch (compareScale) {
              case 'g':
                compareValue *= 1073741824;
                break;
              case 'm':
                compareValue *= 1048576;
                break;
              case 'k':
                compareValue *= 1024;
                break;
              default:
                //default value in GB
                compareValue *= 1073741824;
            }
            rowValue = (jQuery(rowValue).text()) ? jQuery(rowValue).text() : rowValue;

            var convertedRowValue;
            if (rowValue === '<1KB') {
              convertedRowValue = 1;
            } else {
              var rowValueScale = rowValue.substr(rowValue.length - 2, 2);
              switch (rowValueScale) {
                case 'KB':
                  convertedRowValue = parseFloat(rowValue)*1024;
                  break;
                case 'MB':
                  convertedRowValue = parseFloat(rowValue)*1048576;
                  break;
                case 'GB':
                  convertedRowValue = parseFloat(rowValue)*1073741824;
                  break;
              }
            }

            switch (compareChar) {
              case '<':
                if (compareValue > convertedRowValue) match = true;
                break;
              case '>':
                if (compareValue < convertedRowValue) match = true;
                break;
              case false:
              case '=':
                if (compareValue == convertedRowValue) match = true;
                break;
            }
            return match;
          }
          break;
        case 'duration':
          return function (rowValue, rangeExp) {
            var compareChar = isNaN(rangeExp.charAt(0)) ? rangeExp.charAt(0) : false;
            var compareScale = rangeExp.charAt(rangeExp.length - 1);
            var compareValue = compareChar ? parseFloat(rangeExp.substr(1, rangeExp.length)) : parseFloat(rangeExp.substr(0, rangeExp.length));
            var match = false;
            if (rangeExp.length == 1 && compareChar !== false) {
              // User types only '=' or '>' or '<', so don't filter column values
              match = true;
              return match;
            }
            switch (compareScale) {
              case 's':
                compareValue *= 1000;
                break;
              case 'm':
                compareValue *= 60000;
                break;
              case 'h':
                compareValue *= 3600000;
                break;
              default:
                compareValue *= 1000;
            }
            rowValue = (jQuery(rowValue).text()) ? jQuery(rowValue).text() : rowValue;

            switch (compareChar) {
              case '<':
                if (compareValue > rowValue) match = true;
                break;
              case '>':
                if (compareValue < rowValue) match = true;
                break;
              case false:
              case '=':
                if (compareValue == rowValue) match = true;
                break;
            }
            return match;
          }
          break;
        case 'date':
          return function (rowValue, rangeExp) {
            var match = false;
            var timePassed = new Date().getTime() - rowValue;
            switch (rangeExp) {
              case 'Past 1 Day':
                match = timePassed <= 86400000;
                break;
              case 'Past 2 Days':
                match = timePassed <= 172800000;
                break;
              case 'Past 7 Days':
                match = timePassed <= 604800000;
                break;
              case 'Past 14 Days':
                match = timePassed <= 1209600000;
                break;
              case 'Past 30 Days':
                match = timePassed <= 2592000000;
                break;
              case 'Any':
                match = true;
                break;
            }
            return match;
          }
          break;
        case 'number':
          return function(rowValue, rangeExp){
            var compareChar = rangeExp.charAt(0);
            var compareValue;
            var match = false;
            if (rangeExp.length == 1) {
              if (isNaN(parseInt(compareChar))) {
                // User types only '=' or '>' or '<', so don't filter column values
                match = true;
                return match;
              }
              else {
                compareValue = parseFloat(parseFloat(rangeExp).toFixed(2));
              }
            }
            else {
              if (isNaN(parseInt(compareChar))) {
                compareValue = parseFloat(parseFloat(rangeExp.substr(1, rangeExp.length)).toFixed(2));
              }
              else {
                compareValue = parseFloat(parseFloat(rangeExp.substr(0, rangeExp.length)).toFixed(2));
              }
            }
            rowValue = parseFloat((jQuery(rowValue).text()) ? jQuery(rowValue).text() : rowValue);
            match = false;
            switch (compareChar) {
              case '<':
                if (compareValue > rowValue) match = true;
                break;
              case '>':
                if (compareValue < rowValue) match = true;
                break;
              case '=':
                if (compareValue == rowValue) match = true;
                break;
              default:
                if (rangeExp == rowValue) match = true;
            }
            return match;
          }
          break;
        case 'multiple':
          return function(origin, compareValue){
            var options = compareValue.split(',');
            var rowValue = origin.mapProperty('componentName').join(" ");
            var str = new RegExp(compareValue, "i");
            for (var i = 0; i < options.length; i++) {
              if(!isGlobal) {
                str = new RegExp('(\\W|^)' + options[i] + '(\\W|$)');
              }
              if (rowValue.search(str) !== -1) {
                return true;
              }
            }
            return false;
          }
          break;
        case 'string':
        default:
          return function(origin, compareValue){
            var regex = new RegExp(compareValue,"i");
            return regex.test(origin);
          }
      }
    }
  };
});
window.require.register("views/common/form/field", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.FormFieldTemplate = Em.View.extend({
    templateDir: 'templates/common/form/',
    defaultTemplate: 'field',
    classNames: ["control-group"],
    init: function(){
      this._super();
      this.updateTemplate();
    },
    updateTemplate: function(){
      var field = this.get('field');
      if(field) {
        var templateName = '';
        switch(field.get('displayType')) {
          case 'checkbox':
            templateName = field.get('displayType');
            break;
          default:
            templateName = this.get('defaultTemplate');
            break;
        }

        this.set('templateName', require(this.get('templateDir') + templateName));
      }
    }.observes('field')
  });
});
window.require.register("views/common/grid", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var validator = require('utils/validator');

  App.GridFilterObject = Em.Object.extend({
    checked:false
  });

  App.GridFilter = Em.View.extend({
    tagName:"ul",
    classNames:['filter'],
    templateName:require('templates/common/grid/filter'),
    attributeBindings:['style'],
    getHeader:function () {
      return this.get('header')
    },
    filters:function () {
      return this.get('header._filters');
    }.property('header._filters')
  });

  App.GridHeader = Em.View.extend({
    templateName:require('templates/common/grid/header'),
    tagName:'th',
    filterable:true,
    showFilter:false,
    getGrid:function () {
      return this.get('grid');
    },
    _filters:[],
    doFilter:function () {
      console.log(this.get('grid'));
    },
    toggleFilter:function () {
      this.set('showFilter', 1 - this.get('showFilter'));
    },
    applyFilter:function () {
      console.warn('APPLYING FILTERS');

      var filters = this.get('_filters');
      var filterValues = [];
      $.each(filters, function(){
        if(this.get('checked')) {
          filterValues.push(this.get('value'));
        }
      });

      var grid = this.get('grid');
      grid.addFilters(this.get('name'), filterValues);
      this.set('showFilter', false);
    },
    init:function () {
      this._super();
      if (!this.get('_filters').length) {
        this.filterValues();
        var thisHeader = this;
        this.set('filter', App.GridFilter.extend({ header:thisHeader }));
      }
    },

    filterValues:function () {
      var gridFilters = this.get('grid._filters');
      if (gridFilters && gridFilters[this.get('name')]) {
        var filters = this.get('grid._filters')[this.get('name')];
        // there should be something like filter preparing
        var newFilters = [];
        $.each(filters, function (i, v) {
          newFilters.push(App.GridFilterObject.create({label:v, value:v}));
        });

        this.set('_filters', newFilters);
      }
    }.observes('grid._filters')
  });

  App.GridRow = Em.View.extend({
    tagName:'tr',
    init:function (options) {
      var object = this.get('object');
      var grid = this.get('grid');
      var fieldNames = grid.get('fieldNames');
      var template = '';

      if (fieldNames) {
        $.each(grid.get('fieldNames'), function (i, field) {
          template += "<td>" + object.get(field) + "</td>";
        });

        this.set('template', Em.Handlebars.compile(template));
      }
      return this._super();
    }
  });

  App.GridPage = Em.Object.extend({
    activeClass:function () {
      return this.get('active') ? "active" : "";
    }.property('active'),
    active:function () {
      return parseInt(this.get('number')) == parseInt(this.get('pager.grid.currentPage'));
    }.property('pager.grid.currentPage')
  });

  App.GridPager = Em.View.extend({

    pages:[],
    templateName:require('templates/common/grid/pager'),
    classNames:['pagination'],

    activatePrevPage:function () {
      var current = this.get('grid.currentPage');
      if (current > 1) this.set('grid.currentPage', current - 1);
    },
    activateNextPage:function () {
      var current = this.get('grid.currentPage');
      if (current < this.get('pages').length) this.set('grid.currentPage', current + 1);
    },

    prevPageDisabled:function () {
      return this.get('grid.currentPage') > 1 ? false : "disabled";
    }.property('grid.currentPage'),

    nextPageDisabled:function () {
      return this.get('grid.currentPage') < this.get('pages').length ? false : "disabled";
    }.property('grid.currentPage'),

    init:function () {
      this._super();
      this.clearPages()
      this.pushPages();
    },

    activatePage:function (event) {
      var page = event.context;
      this.get('grid').set('currentPage', parseInt(event.context.get('number')));
    },

    clearPages:function () {
      this.set('pages', []);
    },

    pushPages:function () {
      var thisPager = this;
      var pages = this.get('grid._pager.pages');
      $.each(pages, function () {
        var thisNumber = this;
        thisPager.get('pages').push(App.GridPage.create({
          number:thisNumber,
          pager:thisPager
        }));
      })
    }.observes('grid._pager')
  });

  App.Grid = Em.View.extend({
    _columns:{}, // not used
    _filters:{}, // prepared filters from data values
    _pager:{pages:[1, 2, 3, 4, 5]}, // observed by pager to config it

    _collection:{className:false, staticOptions:{}}, // collection config
    currentPage:1,
    fieldNames:[],
    appliedFilters:{},
    filteredArray:[],
    columns:[],
    collection:[],
    initComleted:false,
    rows:[],
    templateName:require('templates/main/admin/audit'),

    init:function () {
      console.warn("  Grid INIT  ");
      this._super();
      this.prepareColumns(); // should be the 1
      this.prepareCollection();
      this.preparePager();
    },

    preparePager:function () {
  //    this.set('pager', App.GridPager.extend({ grid:this })); ask to hide
    },

    addFilters: function(field, values){
      var filters = this.get('appliedFilters');
      filters[field] = values;

      var collection = this.get('_collection.className');
      collection = collection.find();
      arrayCollection = collection.filter(function(data) {
        var oneFilterFail = false;
        $.each(filters, function(fieldname, values){
          if(values.length && values.indexOf(data.get(fieldname)) == -1) {
            return oneFilterFail = true;
          }
        });
        return !oneFilterFail;
      });

      this.set('filteredArray', arrayCollection);
    },

    prepareCollection:function () {
      if (validator.empty(this.get('_collection.className'))) {
        throw "_collection.className field is not defined";
      }
      var collection = this.get('_collection.className');
      this.set('collection', collection.find(this.get('_collection.staticOptions')));
    },

    addColumn:function (options) {
      options.grid = this;
      if (validator.empty(options.name)) {
        throw "define column name";
      }

      if (this.get('_columns.' + options.name)) {
        throw "column with this '" + options.name + "' already exists";
      }

      var field = App.GridHeader.extend(options);
      this.columns.push(field);

      if (field.filterable || 1) { // .filterable - field not working :(
        this.fieldNames.push(options.name);
      }
    },

    clearColumns:function () {
      this.set('_columns', {});
      this.set('columns', []);
      this.set('fieldNames', []);
    },

    prepareColumns:function () {
      this.clearColumns();
    },

    prepareFilters:function () {
      var thisGrid = this;
      var collection = this.get('collection');
      var fieldNames = this.get('fieldNames');
      var options = {};

      if (collection && collection.content) {
        collection.forEach(function (object, i) {
          $.each(fieldNames, function (j, field) {
            if (!options[field]) {
              options[field] = [];
            }

            var filter = object.get(field);
            if (options[field].indexOf(filter) == -1) {
              options[field].push(filter);
            }
          });
        })

        thisGrid.set('_filters', options);
      }
    }.observes('collection.length'),


    clearRows:function () {
      this.set('rows', [])
    },

    prepareRows:function () {
      var collection = this.get('collection');
      var thisGrid = this;
      this.clearRows();
      console.warn("PREPARE ROWS LEN:", collection.get('length'));
      var i=1;

      if (collection && collection.content) {
        collection.forEach(function (object, i) {
          var row = App.GridRow.extend({grid:thisGrid, object:object});
          thisGrid.rows.push(row);
        });
      }
    }.observes('collection.length'),

    filteredRows:function () {
      var collection = this.get('filteredArray');
      var thisGrid = this;
      this.clearRows();

      collection.forEach(function (object) {
        var row = App.GridRow.extend({grid:thisGrid, object:object});
        thisGrid.rows.push(row);
      });
    }.observes('filteredArray')
  });
});
window.require.register("views/common/metric", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  /**
   * use: {{view App.MetricFilteringWidget controllerBinding="App.router.mainChartsController"}}
   * set controller.metric field with metric value
   * widget assign itself to controller like metricWidget (controller.get('metricWidget'))
   * @type {*}
   */
  App.MetricFilteringWidget = Em.View.extend({
    classNames:['metric-filtering-widget'],
    /**
     * chosen metric value
     */
    chosenMetric:null,
    chosenMoreMetric:null,
    showMore:0, // toggle more metrics indicator
    /**
     * metrics
     */
    metrics:[
      Em.Object.create({ label:Em.I18n.t('metric.default'), value:null}),
      Em.Object.create({ label:Em.I18n.t('metric.cpu'), value:'cpu'}),
      Em.Object.create({ label:Em.I18n.t('metric.memory'), value:'memory'}),
      Em.Object.create({ label:Em.I18n.t('metric.network'), value:'network'}),
      Em.Object.create({ label:Em.I18n.t('metric.io'), value:'io'})
    ],


    moreMetrics:[
      Em.Object.create({ label:Em.I18n.t('metric.more.cpu'), code:'cpu', items:[
        Em.Object.create({value:"cpu_nice"}),
        Em.Object.create({value:"cpu_wio"}),
        Em.Object.create({value:"cpu_user"}),
        Em.Object.create({value:"cpu_idle"}),
        Em.Object.create({value:"cpu_system"}),
        Em.Object.create({value:"cpu_aidle"})
      ] }),

      Em.Object.create({ label:Em.I18n.t('metric.more.disk'), code:'disk',
        items:[
          Em.Object.create({value:'disk_free'}),
          Em.Object.create({value:'disk_total'}),
          Em.Object.create({value:'part_max_used'})
        ]
      }),

      Em.Object.create({ label:Em.I18n.t('metric.more.load'), code:'load',
        items:[
          Em.Object.create({value:'load_one'}),
          Em.Object.create({value:'load_five'}),
          Em.Object.create({value:'load_fifteen'})
        ]
      }),

      Em.Object.create({ label:Em.I18n.t('metric.more.memory'), code:'memory',
        items:[
          Em.Object.create({value:'swap_free'}),
          Em.Object.create({value:'cpu'})
        ]
      }),

      Em.Object.create({ label:Em.I18n.t('metric.more.network'), code:'network',
        items:[
          Em.Object.create({value:'bytes_out'}),
          Em.Object.create({value:'bytes_in'}),
          Em.Object.create({value:'pkts_in'}),
          Em.Object.create({value:'pkts_out'})
        ]
      }),

      Em.Object.create({ label:Em.I18n.t('metric.more.process'), code:'process',
        items:[
          Em.Object.create({value:'proc_run'}),
          Em.Object.create({value:'proc_total'}),
        ]
      })

    ],

    /**
     * return array of chosen metrics
     */
    chosenMetrics:function () {
      return this.get('chosenMetric') ? [this.get('chosenMetric')] : this.get('defaultMetrics');
    }.property('chosenMetric'),

    /**
     * metric item view
     */
    itemView:Em.View.extend({
      tagName:'li',
      classNameBindings:['disabled'],
      disabled:function () {
        return this.get('isActive') ? "disabled" : false;
      }.property('isActive'),
      isActive:function () {
        return this.get('metric.value') == this.get('widget.chosenMetric');
      }.property('widget.chosenMetric'),
      label:function () {
        return this.get('metric.label');
      }.property('metric.label'),
      template:Em.Handlebars.compile('<a {{action activate view.metric.value target="view.widget" href="#" }}>{{unbound view.label}}</a>')
    }),

    moreItemView:function () {
      return this.get('itemView').extend({
        label:function () {
          return this.get('metric.value');
        }.property('metric.value')
      });
    }.property(),

    /**
     * return default selected metrics (currently - all)
     */
    defaultMetrics:function () {
      var values = [];
      $.each(this.get('metrics'), function () {
        if (this.value) {
          values.push(this.value);
        }
      });
      return values;
    }.property(),

    bindToController:function () {
      var thisW = this;
      var controller = this.get('controller');
      controller.set('metricWidget', thisW);
    },

    toggleMore:function () {
      this.set('showMore', 1 - this.get('showMore'));
    },

    /**
     * assign this widget to controller, prepare items by metricsConfig
     */
    init:function () {
      this._super();
      this.bindToController();
    },

    /**
     * write active metric to widget
     * @param event
     */
    activate:function (event) {
      this.set('chosenMetric', event.context);
    },

    templateName:require('templates/common/metric')
  })
});
window.require.register("views/common/modal_popup", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.ModalPopup = Ember.View.extend({

    viewName: 'modalPopup',

    template: Ember.Handlebars.compile([
      '<div class="modal-backdrop"></div><div class="modal" id="modal" tabindex="-1" role="dialog" aria-labelledby="modal-label" aria-hidden="true">',
      '<div class="modal-header">',
      '{{#if showCloseButton}}<a class="close" {{action onClose target="view"}}>x</a>{{/if}}',
      '<h3 id="modal-label">',
      '{{#if headerClass}}{{view headerClass}}',
      '{{else}}{{header}}{{/if}}',
      '</h3>',
      '</div>',
      '<div class="modal-body">',
      '{{#if bodyClass}}{{view bodyClass}}',
      '{{else}}{{#if encodeBody}}{{body}}{{else}}{{{body}}}{{/if}}{{/if}}',
      '</div>',
      '{{#if showFooter}}',
      '{{#if footerClass}}{{view footerClass}}',
      '{{else}}',
      '<div class="modal-footer">',
      '{{#if view.secondary}}<a class="btn" {{action onSecondary target="view"}}>{{view.secondary}}</a>{{/if}}',
      '{{#if view.primary}}<a class="btn btn-success" {{action onPrimary target="view"}}>{{view.primary}}</a>{{/if}}',
      '</div>',
      '{{/if}}',
      '{{/if}}',

      '</div>'
    ].join('\n')),

    header: '&nbsp;',
    body: '&nbsp;',
    encodeBody: true,
    // define bodyClass which extends Ember.View to use an arbitrary Handlebars template as the body
    primary: Em.I18n.t('ok'),
    secondary: Em.I18n.t('common.cancel'),
    autoHeight: true,

    onPrimary: function () {
      this.hide();
    },

    onSecondary: function () {
      this.hide();
    },

    onClose: function () {
      this.hide();
    },

    hide: function () {
      this.destroy();
    },

    showFooter: true,

    /**
     * Hide or show 'X' button for closing popup
     */
    showCloseButton: true,

    didInsertElement: function () {
      if (this.autoHeight) {
        var block = this.$().find('#modal > .modal-body').first();
        block.css('max-height', $(window).height() - block.offset().top - 300 + $(window).scrollTop()); // fix popup height
      }
    },

    fitHeight: function () {
      var popup = this.$().find('#modal');
      var block = this.$().find('#modal > .modal-body');
      var wh = $(window).height();

      var top = wh * .05;
      popup.css({
        'top': top + 'px',
        'marginTop': 0
      });

      block.css('max-height', $(window).height() - top * 2 - (popup.height() - block.height()));
    }
  });

  App.ModalPopup.reopenClass({

    show: function (options) {
      var popup = this.create(options);
      popup.appendTo('#wrapper');
      return popup;
    }

  })

  App.showReloadPopup = function () {
    return App.ModalPopup.show({
      primary: null,
      secondary: null,
      showFooter: false,
      header: this.t('app.reloadPopup.header'),
      body: "<div class='alert alert-info'><div class='spinner'>" + this.t('app.reloadPopup.text') + "</div></div><div><a href='#' onclick='location.reload();'>" + this.t('app.reloadPopup.link') + "</a></div>",
      encodeBody: false
    });
  }

  /**
   * Show confirmation popup
   *
   * @param {Function} primary - "OK" button click handler
   * @param {String} body - additional text constant. Will be placed in the popup-body
   * @return {*}
   */
  App.showConfirmationPopup = function (primary, body, secondary) {
    if (!primary) {
      return false;
    }
    return App.ModalPopup.show({
      primary: Em.I18n.t('ok'),
      secondary: Em.I18n.t('common.cancel'),
      header: Em.I18n.t('popup.confirmation.commonHeader'),
      body: body || Em.I18n.t('question.sure'),
      onPrimary: function () {
        this.hide();
        primary();
      },
      onSecondary: function () {
        this.hide();
        if (secondary) {
          secondary();
        }
      }
    });
  };

  /**
   * Show alert popup
   *
   * @param {String} header - header of the popup
   * @param {String} body - body of the popup
   * @param {Function} primary - function to call upon clicking the OK button
   * @return {*}
   */
  App.showAlertPopup = function (header, body, primary) {
    return App.ModalPopup.show({
      primary: Em.I18n.t('ok'),
      secondary: null,
      header: header,
      body: body,
      onPrimary: function () {
        this.hide();
        if (primary) {
          primary();
        }
      }
    });
  }
});
window.require.register("views/common/quick_view_link_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.QuickViewLinks = Em.View.extend({

    /**
     * Updated quick links. Here we put correct hostname to url
     */
    quickLinks: function () {
      var serviceName = this.get('content.serviceName');
      var components = this.get('content.hostComponents');
      var host;

      switch (serviceName) {
        case "HDFS":
          host = App.singleNodeInstall ? App.singleNodeAlias : components.findProperty('componentName', 'NAMENODE').get('host.publicHostName');
          break;
        case "MAPREDUCE":
        case "OOZIE":
        case "GANGLIA":
        case "NAGIOS":
        case "HUE":
          host = App.singleNodeInstall ? App.singleNodeAlias : components.findProperty('isMaster', true).get("host").get("publicHostName");
          break;
        case "HBASE":
          var component;
          if (App.supports.multipleHBaseMasters) {
            component = components.filterProperty('componentName', 'HBASE_MASTER').findProperty('haStatus', 'active');
          } else {
            component = components.findProperty('componentName', 'HBASE_MASTER');
          }
          if (component) {
            if (App.singleNodeInstall) {
              host = App.singleNodeAlias;
            } else {
              host = component.get('host.publicHostName');
            }
          }
          break;
      }
      if (!host) {
        return [
          {
            label: this.t('quick.links.error.label'),
            url: 'javascript:alert("' + this.t('contact.administrator') + '");return false;'
          }
        ];
      }
      return this.get('content.quickLinks').map(function (item) {
        if (item.get('url')) {
          item.set('url', item.get('url').fmt(host));
        }
        return item;
      });
    }.property('content.quickLinks.@each.label'),

    linkTarget: function () {
      switch (this.get('content.serviceName').toLowerCase()) {
        case "hdfs":
        case "mapreduce":
        case "hbase":
        case "oozie":
        case "ganglia":
        case "nagios":
        case "hue":
          return "_blank";
          break;
        default:
          return "";
          break;
      }
    }.property('service')

  });
  
});
window.require.register("views/common/sort_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var misc = require('utils/misc');
  var App = require('app');

  /**
   * Wrapper View for all sort components. Layout template and common actions are located inside of it.
   * Logic specific for sort fields
   * located in inner view - <code>fieldView</code>.
   *
   * @type {*}
   */
  var wrapperView = Em.View.extend({
    tagName: 'tr',

    /**
     * Load sort statuses from local storage
     * Works only after finish filtering in the parent View
     */
    loadSortStatuses: function() {
      var statuses = App.db.getSortingStatuses(this.get('controller.name'));
      if (!this.get('parentView.filteringComplete')) return;
      if (statuses) {
        var childViews = this.get('childViews');
        var self = this;
        statuses.forEach(function(st) {
          if (st.status != 'sorting') {
            var sortOrder = false;
            if(st.status == 'sorting_desc') {
              sortOrder = true;
            }
            self.sort(childViews.findProperty('name', st.name), sortOrder);

            childViews.findProperty('name', st.name).set('status', (sortOrder)?'sorting_desc':'sorting_asc');
          }
          else {
            childViews.findProperty('name', st.name).set('status', st.status);
          }
        });
        this.get('parentView').showProperPage();
      }
    }.observes('parentView.filteringComplete'),

    /**
     * Save sort statuses to local storage
     * Works only after finish filtering in the parent View
     */
    saveSortStatuses: function() {
      if (!this.get('parentView.filteringComplete')) return;
      var statuses = [];
      this.get('childViews').forEach(function(childView) {
        statuses.push({
          name: childView.get('name'),
          status: childView.get('status')
        });
      });
      App.db.setSortingStatuses(this.get('controller.name'), statuses);
    }.observes('childViews.@each.status'),

    /**
     * sort content by property
     * @param property
     * @param order: true - DESC, false - ASC
     */
    sort: function(property, order){
      var content = this.get('content').toArray();
      var sortFunc = this.getSortFunc(property, order);
      this.resetSort();
      content.sort(sortFunc);
      this.set('content', content);
    },
    /**
     * reset all sorts fields
     */
    resetSort: function(){
      this.get('childViews').setEach('status', 'sorting');
    },
    /**
     * determines sort function depending on the type of sort field
     * @param property
     * @param order
     * @return {*}
     */
    getSortFunc: function(property, order){
      var func;
      switch (property.get('type')){
        case 'ip':
          func = function (a, b) {
            var a = misc.ipToInt(a.get(property.get('name')));
            var b = misc.ipToInt(b.get(property.get('name')));
            if(order){
              return b - a;
            } else {
              return a - b;
            }
          };
          break;
        case 'number':
          func = function (a, b) {
            var a = parseFloat(a.get(property.get('name')));
            var b = parseFloat(b.get(property.get('name')));
            if(order){
              return b - a;
            } else {
              return a - b;
            }
          }
          break;
        default:
          func = function(a,b){
            if(order){
              if (a.get(property.get('name')) > b.get(property.get('name')))
                return -1;
              if (a.get(property.get('name')) < b.get(property.get('name')))
                return 1;
              return 0;
            } else {
              if (a.get(property.get('name')) < b.get(property.get('name')))
                return -1;
              if (a.get(property.get('name')) > b.get(property.get('name')))
                return 1;
              return 0;
            }
          }
      }
      return func;
    }
  });
  /**
   * particular view that contain sort field properties:
   * name - name of property in content table
   * type(optional) - specific type to sort
   * displayName - label to display
   * @type {*}
   */
  var fieldView = Em.View.extend({
    template:Em.Handlebars.compile('{{view.displayName}}'),
    classNameBindings: ['status'],
    tagName: 'th',
    name: null,
    displayName: null,
    status: 'sorting',
    type: null,
    /**
     * callback that run sorting and define order of sorting
     * @param event
     */
    click: function(event){
      if(this.get('status') === 'sorting_desc'){
        this.get('parentView').sort(this, false);
        this.set('status', 'sorting_asc');
      }
      else {
        this.get('parentView').sort(this, true);
        this.set('status', 'sorting_desc');
      }
    }
  });

  /**
   * Result object, which will be accessible outside
   * @type {Object}
   */
  module.exports = {
    wrapperView: wrapperView,
    fieldView: fieldView
  };
});
window.require.register("views/common/table_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var filters = require('views/common/filter_view');
  var sort = require('views/common/sort_view');

  App.TableView = Em.View.extend({

    /**
     * Shows if all data is loaded and filtered
     */
    filteringComplete: false,

    /**
     * Loaded from local storage startIndex value
     */
    startIndexOnLoad: null,
    /**
     * Loaded from local storage displayLength value
     */
    displayLengthOnLoad: null,

    /**
     * Do filtering, using saved in the local storage filter conditions
     */
    willInsertElement:function () {
      var self = this;
      var name = this.get('controller.name');

      this.set('startIndexOnLoad', App.db.getStartIndex(name));
      this.set('displayLengthOnLoad', App.db.getDisplayLength(name));

      var filterConditions = App.db.getFilterConditions(name);
      if (filterConditions) {
        this.set('filterConditions', filterConditions);

        var childViews = this.get('childViews');

        filterConditions.forEach(function(condition) {
          var view = childViews.findProperty('column', condition.iColumn);
          if (view) {
            view.set('value', condition.value);
            Em.run.next(function() {
              view.showClearFilter();
            });
          }
        });
      } else {
        this.clearFilters();
      }

      Em.run.next(function() {
        Em.run.next(function() {
          self.set('filteringComplete', true);
        });
      });
    },

    /**
     * Do pagination after filtering and sorting
     * Don't call this method! It's already used where it's need
     */
    showProperPage: function() {
      var self = this;
      Em.run.next(function() {
        Em.run.next(function() {
          if (self.get('displayLengthOnLoad')) {
            self.set('displayLength', self.get('displayLengthOnLoad'));
          }
          if(self.get('startIndexOnLoad')) {
            self.set('startIndex', self.get('startIndexOnLoad'));
          }
        });
      });
    },

    /**
     * return pagination information displayed on the page
     */
    paginationInfo: function () {
      return this.t('apps.filters.paginationInfo').format(this.get('startIndex'), this.get('endIndex'), this.get('filteredContent.length'));
    }.property('displayLength', 'filteredContent.length', 'startIndex', 'endIndex'),

    paginationLeft: Ember.View.extend({
      tagName: 'a',
      template: Ember.Handlebars.compile('<i class="icon-arrow-left"></i>'),
      classNameBindings: ['class'],
      class: function () {
        if (this.get("parentView.startIndex") > 1) {
          return "paginate_previous";
        }
        return "paginate_disabled_previous";
      }.property("parentView.startIndex", 'filteredContent.length'),

      click: function () {
        this.get('parentView').previousPage();
      }
    }),

    paginationRight: Ember.View.extend({
      tagName: 'a',
      template: Ember.Handlebars.compile('<i class="icon-arrow-right"></i>'),
      classNameBindings: ['class'],
      class: function () {
        if ((this.get("parentView.endIndex")) < this.get("parentView.filteredContent.length")) {
          return "paginate_next";
        }
        return "paginate_disabled_next";
      }.property("parentView.endIndex", 'filteredContent.length'),

      click: function () {
        this.get('parentView').nextPage();
      }
    }),

    rowsPerPageSelectView: Em.Select.extend({
      content: ['10', '25', '50']
    }),

    // start index for displayed content on the page
    startIndex: 1,

    // calculate end index for displayed content on the page
    endIndex: function () {
      return Math.min(this.get('filteredContent.length'), this.get('startIndex') + parseInt(this.get('displayLength')) - 1);
    }.property('startIndex', 'displayLength', 'filteredContent.length'),

    /**
     * onclick handler for previous page button on the page
     */
    previousPage: function () {
      var result = this.get('startIndex') - parseInt(this.get('displayLength'));
      if (result < 2) {
        result = 1;
      }
      this.set('startIndex', result);
    },

    /**
     * onclick handler for next page button on the page
     */
    nextPage: function () {
      var result = this.get('startIndex') + parseInt(this.get('displayLength'));
      if (result - 1 < this.get('filteredContent.length')) {
        this.set('startIndex', result);
      }
    },

    // the number of rows to show on every page
    displayLength: null,

    // calculates default value for startIndex property after applying filter or changing displayLength
    updatePaging: function () {
      this.set('startIndex', Math.min(1, this.get('filteredContent.length')));
    }.observes('displayLength', 'filteredContent.length'),

    /**
     * Apply each filter to each row
     *
     * @param iColumn number of column by which filter
     * @param value
     * @param type
     */
    updateFilter: function (iColumn, value, type) {
      var filterCondition = this.get('filterConditions').findProperty('iColumn', iColumn);
      if (filterCondition) {
        filterCondition.value = value;
      }
      else {
        filterCondition = {
          iColumn: iColumn,
          value: value,
          type: type
        };
        this.get('filterConditions').push(filterCondition);
      }
      this.saveFilterConditions();
      this.filtersUsedCalc();
      this.filter();
    },

    saveFilterConditions: function() {
      App.db.setFilterConditions(this.get('controller.name'), this.get('filterConditions'));
    },

    saveDisplayLength: function() {
      var self = this;
      Em.run.next(function() {
        App.db.setDisplayLength(self.get('controller.name'), self.get('displayLength'));
      });
    }.observes('displayLength'),

    saveStartIndex: function() {
      if (this.get('filteringComplete')) {
        App.db.setStartIndex(this.get('controller.name'), this.get('startIndex'));
      }
    }.observes('startIndex'),

    clearFilterCondition: function() {
      App.db.setFilterConditions(this.get('controller.name'), null);
    },

    clearDisplayLength: function() {
      App.db.setDisplayLength(this.get('controller.name'), null);
    },

    clearStartIndex: function() {
      App.db.setStartIndex(this.get('controller.name'), null);
    },

    /**
     * contain filter conditions for each column
     */
    filterConditions: [],

    filteredContent: [],

    // contain content to show on the current page of data page view
    pageContent: function () {
      return this.get('filteredContent').slice(this.get('startIndex') - 1, this.get('endIndex'));
    }.property('filteredContent.length', 'startIndex', 'endIndex'),

    /**
     * filter table by filterConditions
     */
    filter: function () {
      var content = this.get('content');
      var filterConditions = this.get('filterConditions').filterProperty('value');
      var result;
      var assoc = this.get('colPropAssoc');
      if (filterConditions.length) {
        result = content.filter(function (item) {
          var match = true;
          filterConditions.forEach(function (condition) {
            var filterFunc = filters.getFilterByType(condition.type, false);
            if (match) {
              match = filterFunc(item.get(assoc[condition.iColumn]), condition.value);
            }
          });
          return match;
        });
        this.set('filteredContent', result);
      } else {
        this.set('filteredContent', content.toArray());
      }
    }.observes('content'),

    filtersUsed: false,

    filtersUsedCalc: function() {
      var filterConditions = this.get('filterConditions');
      if (!filterConditions.length) {
        this.set('filtersUsed', false);
      }
      var filtersUsed = false;
      filterConditions.forEach(function(filterCondition) {
        if (filterCondition.value.toString() !== '') {
          filtersUsed = true;
        }
      });
      this.set('filtersUsed', filtersUsed);
    },

    clearFilters: function() {
      this.set('filterConditions', []);
      this.get('_childViews').forEach(function(childView) {
        if (childView['clearFilter']) {
          childView.clearFilter();
        }
      });
    }

  });
  
});
window.require.register("views/common/time_range", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  /**
   * use: {{view App.TimeRangeWidget controllerBinding="App.router.mainChartsController"}}
   * set controller.preset field with preset value
   * widget assign itself to controller like presetWidget (controller.get('presetWidget'))
   * @type {*}
   */
  App.TimeRangeWidget = Em.View.extend({
    classNames:['time-range-widget'],
    templateName:require('templates/common/time_range'),
    dateFrom: null,
    dateTo: null,

    /**
     * presets
     */
    presets:[
      Em.Object.create({ label:Em.I18n.t('timeRange.presets.1hour'), value:'1h', period: 3600000, step: 300000}),
      Em.Object.create({ label:Em.I18n.t('timeRange.presets.12hour'), value:'12h', period: 43200000, step: 3600000}),
      Em.Object.create({ label:Em.I18n.t('timeRange.presets.1day'), value:'1d', period: 86400000, step: 3600000}),
      Em.Object.create({ label:Em.I18n.t('timeRange.presets.1week'), value:'1wk', period: 604800000, step: 86400000}),
      Em.Object.create({ label:Em.I18n.t('timeRange.presets.1month'), value:'1mo', period: 2592000000, step: 86400000}),
      Em.Object.create({ label:Em.I18n.t('timeRange.presets.1year'), value:'1yr', period: 31536000000, step: 2592000000})
    ],
    /**
     * chosen preset value
     */
    chosenPreset: null,

    /**
     * return array of chosen presets
     */
    chosenPresets:function () {
      return this.get('chosenPreset') ? [this.get('chosenPreset')] : this.get('defaultPresets');
    }.property('chosenPreset'),

    /**
     * preset item view
     */
    presetView:Em.View.extend({
      tagName:'li',
      classNameBindings:['disabled'],
      disabled:function () {
        return this.get('isActive') ? "disabled" : false;
      }.property('isActive'),
      isActive:function () {
        return this.get('preset.value') == this.get('widget.chosenPreset.value');
      }.property('widget.chosenPreset'),
      template:Em.Handlebars.compile('<a {{action activate view.preset target="view.widget" href="true" }}>{{unbound view.preset.label}}</a>')
    }),

    /**
     * return default selected presets (currently - all)
     */
    defaultPresets:function () {
      var values = [];
      $.each(this.get('presets'), function () {
        if (this.value) {
          values.push(this.value);
        }
      });
      return values;
    }.property(),

    bindToController:function () {
      var thisW = this;
      var controller = this.get('controller');
      controller.set('presetWidget', thisW);
    },

    /**
     * assign this widget to controller, prepare items by presetsConfig
     */
    init:function () {
      this._super();
      this.bindToController();
    },

    /**
     * write active preset to widget
     * @param event
     */
    activate:function (event) {
      if (event.context == this.get('chosenPreset')) {
        this.set('chosenPreset', null);
      } else {
        this.set('chosenPreset', event.context);
      }
    },

    dateFromView: Ember.TextField.extend({
      elementId: 'timeRangeFrom',
      classNames: 'timeRangeFrom',
      attributeBindings:['readonly'],
      readonly: true,
      didInsertElement: function() {
        var self = this;
        this.$().datetimepicker({
          dateFormat: 'dd/mm/yy',
          timeFormat: 'hh:mm',
          maxDate: new Date(),
          onClose:function (dateText, inst) {
            var endDateTextBox = $('#timeRangeTo');
            if (endDateTextBox.val() != '') {
              var testStartDate = new Date(dateText);
              var testEndDate = new Date(endDateTextBox.val());
              if (testStartDate > testEndDate)
                endDateTextBox.val(dateText);
            } else {
              endDateTextBox.val(dateText);
            }
            self.set('dateFrom', dateText);
          },
          onSelect:function (selectedDateTime) {
            var start = $(this).datetimepicker('getDate');
            $('#timeRangeTo').datetimepicker('option', 'minDate', new Date(start.getTime()));
          }
        });
        self.set('dateFrom', this.get('value'));
      }
    }),

    dateToView: Ember.TextField.extend({
      elementId: 'timeRangeTo',
      classNames: 'timeRangeTo',
      attributeBindings:['readonly'],
      readonly: true,
      didInsertElement: function() {
        var self = this;
        this.$().datetimepicker({
          dateFormat: 'dd/mm/yy',
          timeFormat: 'hh:mm',
          maxDate: new Date(),
          onClose:function (dateText, inst) {
            var startDateTextBox = $('#timeRangeFrom');
            if (startDateTextBox.val() != '') {
              var testStartDate = new Date(startDateTextBox.val());
              var testEndDate = new Date(dateText);
              if (testStartDate > testEndDate)
                startDateTextBox.val(dateText);
            } else {
              startDateTextBox.val(dateText);
            }
            self.set('dateTo', dateText);
          },
          onSelect:function (selectedDateTime) {
            var end = $(this).datetimepicker('getDate');
            $('#timeRangeFrom').datetimepicker('option', 'maxDate', new Date(end.getTime()));
          }
        });
        self.set('dateTo', this.get('value'));
      }
    }),

    sliderOptions: Ember.Object.extend({
      end: null,
      period: null,
      start: function() {
        return this.get('end') - this.get('period');
      }.property('end', 'period')
    }),
    nowLabel: null,
    rangeLabel: null,
    buildSlider: function() {
      if (this.get('chosenPreset')) {
        var sliderOptions = this.sliderOptions.create({
          end: function() {
            var endDate = new Date();
            return endDate.getTime();
          }.property(),
          period: this.get('chosenPreset.period'),
          step: this.get('chosenPreset.step'),
          countTimeAgo: function(stepValue) {
            var msAgo = this.get('end') - stepValue;
            return msAgo.toDaysHoursMinutes();
          }
        });
        this.set('nowLabel', 'Now');
        this.set('rangeLabel', new Date(sliderOptions.get('start')));

        var self = this;
        $('#slider').slider({
          range: "max",
          min: sliderOptions.get('start'),
          max: sliderOptions.get('end'),
          value: sliderOptions.get('start'),
          step: sliderOptions.get('step'),
          stop: function(event, ui) {
            self.set('rangeLabel', new Date(ui.value));
  //          self.set('rangeLabel', sliderOptions.countTimeAgo(ui.value).h);
          },
          slide: function(event, ui){
            self.set('rangeLabel', new Date(ui.value));
  //          self.set('rangeLabel', sliderOptions.countTimeAgo(ui.value).h);
          }
        });
      } else {
        console.log(this.get('chosenPreset'));
        $("#slider").slider("destroy");
      }
    }.observes('chosenPreset')
  })
});
window.require.register("views/installer", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.InstallerView = Em.View.extend({

    templateName: require('templates/installer'),

    isStep0Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',0).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep1Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',1).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep2Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',2).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep3Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',3).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep4Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',4).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep5Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',5).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep6Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',6).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep7Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',7).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep8Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',8).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep9Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',9).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep10Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',10).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable()

  });
});
window.require.register("views/loading", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.LoadingView = Em.View.extend({
      tagName: 'h2',
      template: Ember.Handlebars.compile('{{t app.loadingPlaceholder}}')
  });
});
window.require.register("views/login", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.LoginView = Em.View.extend({

    templateName: require('templates/login'),
    loginTextField: Em.TextField.extend({
      didInsertElement: function(){
        this._super();
        this.$().focus();
      }
    }),
    passTextField : Em.TextField.extend({
      insertNewline: function(){
        this.get("controller").submit();
      }
    })

  });
});
window.require.register("views/main", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.MainView = Em.View.extend({
    templateName:require('templates/main')
  });

  App.MainBackgroundOperation = Em.View.extend({
    content: null,
    classNames: ['background-operations'],
    classNameBindings: ['isOpen'],
    isOpen: function () {
      return this.get('content.isOpen');
    }.property('content.isOpen'),
    iconClass: function(){
      return this.get('isOpen') ? 'icon-minus' : 'icon-plus';
    }.property('isOpen'),
    showOperationLog:function(){
      this.set('content.isOpen', !this.get('content.isOpen'));
      this.set('isTextArea', false);
    },
    hasProgressBar: function () {
      return this.get('content.command') == 'EXECUTE';
    }.property('content.command'),
    isInProgress: function () {
      var status = this.get('content.status');
      return status == 'IN_PROGRESS' || status == 'QUEUED' || status == 'PENDING';
    }.property('content.status'),
    barColor: function () {
      if (this.get('isInProgress')) {
        return 'progress-info';
      } else {
        if (this.get('content.status') == 'COMPLETED') return 'progress-success';
        return 'progress-danger';
      }
    }.property('isInProgress'),
    buttonLabel:function(){
      var button = $(this.get('element')).find('.textTrigger');
      if(this.get('isTextArea')){
        button.text('press CTRL+C');
      } else {
        button.text('click to highlight');
      }
    }.observes('isTextArea'),
    didInsertElement: function () {
      var self = this;
      var button = $(this.get('element')).find('.textTrigger');
      button.click(function () {
        self.set('isTextArea', !self.get('isTextArea'));
      });
      $(this.get('element')).find('.content-area').mouseenter(
        function () {
          var element = $(this);
          element.css('border', '1px solid #dcdcdc');
          button.css('visibility', 'visible');
        }).mouseleave(
        function () {
          var element = $(this);
          element.css('border', 'none');
          button.css('visibility', 'hidden');
        })
    },
    isTextArea: false,
    textArea: Em.TextArea.extend({
      didInsertElement: function(){
        var element = $(this.get('element'));
        element.width($(this.get('parentView').get('element')).width() - 10);
        element.height($(this.get('parentView').get('element')).height());
        element.select();
        element.css('resize', 'none');
      },
      readOnly: true,
      value: function(){
        var operation = this.get('content');
        var content = "";
        content += operation.command + " " + operation.role + " on " + operation.host_name + "\n";
        content += "exitcode: " + operation.exit_code + "\n";
        content += "stderr: " + operation.stderr + "\n";
        content += "stdout: " + operation.stdout + "\n";
        return content;
      }.property('content')
    })
  });
});
window.require.register("views/main/admin", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminView = Em.View.extend({
    templateName: require('templates/main/admin'),
    selectedBinding: 'controller.category',
    categories: function() {
      var items = [{
        name: 'user',
        url: 'adminUser',
        label: Em.I18n.t('common.users')
      }];
      if (App.supports.secureCluster) {
        items.push({
          name: 'security',
          url: 'adminSecurity.index',
          label: Em.I18n.t('common.security')
        });
      };
      items.push({
        name: 'cluster',
        url: 'adminCluster',
        label: Em.I18n.t('common.cluster')
      });
      items.push({
        name: 'misc',
        url: 'adminMisc',
        label: Em.I18n.t('common.misc')
      });
      return items;
    }.property(''),

    NavItemView: Ember.View.extend({
      tagName: 'li',
      classNameBindings: 'isActive:active'.w(),
      isActive: function () {
        return this.get('item') === this.get('parentView.selected');
      }.property('item', 'parentView.selected')
    })
  });

  
});
window.require.register("views/main/admin/advanced", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminAdvancedView = Em.View.extend({
    templateName: require('templates/main/admin/advanced'),
    params: {keepData: 1}
  });
});
window.require.register("views/main/admin/advanced/password", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminAdvancedPasswordView = App.Form.extend({
    fieldsOptions:[
      { name:"password", displayName:Em.I18n.t('form.password'), displayType:"password", disableRequiredOnExistent:true },
      { name:"passwordRetype", displayName:Em.I18n.t('form.passwordRetype'), displayType:"passwordRetype", disableRequiredOnExistent:true }
    ],
    fields: []
  });
});
window.require.register("views/main/admin/audit", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  require('views/common/grid');

  App.MainAdminAuditView = App.Grid.extend({
    _collection: {className: App.ServiceAudit},
    prepareColumns:function () {
      this._super();

      this.addColumn({
        name:"date",
        label:Em.I18n.t("admin.audit.grid.date")
      });
      this.addColumn({
        name:"service.label",
        label:Em.I18n.t("admin.audit.grid.service")
      });
      this.addColumn({
        name:"operationName",
        label:Em.I18n.t("admin.audit.grid.operationName")
      });
      this.addColumn({
        name:"user.userName",
        label:Em.I18n.t("admin.audit.grid.performedBy")
      });
    }
  });
});
window.require.register("views/main/admin/authentication", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminAuthenticationView = Em.View.extend({
    templateName:require('templates/main/admin/authentication'),
    form:App.AuthenticationForm.create({}),
    pushAuthenticationToForm:function () {
      var auth = App.Authentication.find(1);
      App.router.set('mainAdminAuthenticationController.content', auth);
      this.form.set('object', auth);
    },
    didInsertElement: function (){
      this._super();
      this.pushAuthenticationToForm();
    },

    ldapChecked:function () {
      return this.get('form.field.method.value');
    }.property('form.field.method.value'),

    useCredentials:function () {
      return this.get('form.field.bindMethod.value');
    }.property('form.field.bindMethod.value')
  });
});
window.require.register("views/main/admin/cluster", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var stringUtils = require('utils/string_utils');

  App.MainAdminClusterView = Em.View.extend({
    templateName: require('templates/main/admin/cluster'),

    isUpgradeAvailable: function(){
      return stringUtils.compareVersions(this.get('controller.upgradeVersion').replace(/HDP(Local)?-/, ''), App.get('currentStackVersionNumber')) === 1;
    }.property('controller.upgradeVersion', 'App.currentStackVersion')
  });
});
window.require.register("views/main/admin/menu", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  // This logic is substituted by MainAdminView for now.
  App.MainAdminMenuView = Em.CollectionView.extend({
    //contentBinding: 'controller',
    /*content: [
      {
        route:'user',
        label:'Users'
      },
      {
        route:'security',
        label:'Security'
      },
      {
        route:'cluster',
        label:'Cluster'
      }
      /*,
      {
        route:'authentication',
        label:'Authentication'
      },

  {
        route: 'user',
        label: 'Users'

      },
      {
        route: 'security',
        label: 'Security'
      }/*,
       {
       route:'authentication',
       label:'Authentication'
       },

       {
       route:'audit',
       label:'Audit'
       }*/
      /*,
       {
       route:'advanced',
       label:'Advanced'
       }

    ],
    tagName: "ul",
    classNames: ["nav", "nav-list"],

    init: function () {
      this._super();
      this.activateView(); // default selected menu
    },

    activateView: function () {
      var route = App.get('router.mainAdminController.category');
      $.each(this._childViews, function () {
        this.set('active', (this.get('content.route') == route ? "active" : ""));
      });
    }.observes('App.router.mainAdminController.category'),

    itemViewClass:Em.View.extend({
      classNameBindings:["active"],
      active:"",
      template:Ember.Handlebars.compile('<a class="text-center" {{action adminNavigate view.content.route }} href="#"> {{unbound view.content.label}}</a>')
    })
  */
  });
});
window.require.register("views/main/admin/misc_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminMiscView = Em.View.extend({
    templateName: require('templates/main/admin/misc'),
    didInsertElement: function() {
      this.get('controller').loadUsers();
    }
  });
  
});
window.require.register("views/main/admin/security", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminSecurityView = Em.View.extend({
    templateName: require('templates/main/admin/security'),
    didInsertElement: function() {
      this.get('controller').setSecurityStatus();
    }

  });
});
window.require.register("views/main/admin/security/add/menu", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminSecurityAddMenuView = Em.View.extend({

    templateName: require('templates/main/admin/security/add/menu'),

    isStep1Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',1).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep2Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',2).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep3Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',3).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep4Disabled: function () {
      return this.get('controller.isStepDisabled').findProperty('step',4).get('value');
    }.property('controller.isStepDisabled.@each.value').cacheable()

  });


  
});
window.require.register("views/main/admin/security/add/step1", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminSecurityAddStep1View = Em.View.extend({

    templateName: require('templates/main/admin/security/add/step1')

  });



  
});
window.require.register("views/main/admin/security/add/step2", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminSecurityAddStep2View = Em.View.extend({

    templateName: require('templates/main/admin/security/add/step2'),

    configProperties: function () {
      var configProperties = [];
      var stepConfigs = this.get('controller.stepConfigs');
      if (stepConfigs) {
        this.get('controller.stepConfigs').mapProperty('configs').forEach(function (_stepProperties) {
          _stepProperties.forEach(function (_stepConfigProperty) {
            configProperties.pushObject(_stepConfigProperty);
          }, this);
        }, this);
      }
      return configProperties;
    }.property('controller.stepConfigs.@each.configs'),

    realmName: function () {
      return this.get('configProperties').findProperty('name', 'kerberos_domain');
    }.property('configProperties'),

    onRealmNameChange: function () {
      this.get('configProperties').forEach(function (_globalProperty) {
        if (/principal_name?$/.test(_globalProperty.get('name'))) {
          _globalProperty.set('unit', '@' + this.get('realmName.value'));
        }
      }, this);
    }.observes('realmName.value')

  });
  
});
window.require.register("views/main/admin/security/add/step3", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminSecurityAddStep3View = Em.View.extend({
    templateName: require('templates/main/admin/security/add/step3'),
    didInsertElement: function(){
      this.get('controller').loadStep();
    }
  });

  
});
window.require.register("views/main/admin/security/add/step4", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminSecurityAddStep4View = Em.View.extend({

    templateName: require('templates/main/admin/security/add/step4'),
    didInsertElement: function () {
      this.get('controller').loadStep();
    },
    msgColor: 'alert-info',
    message: Em.I18n.t('admin.security.step4.body.header'),
    onResult: function () {
      var stage1 = this.get('controller.stages').findProperty('stage', 'stage2');
      var stage2 = this.get('controller.stages').findProperty('stage', 'stage3');
      var stage3 = this.get('controller.stages').findProperty('stage', 'stage4');
        if (stage2 && stage2.get('isSuccess') === true ) {
          this.set('message', Em.I18n.t('admin.security.step4.body.success.header'));
          this.set('msgColor','alert-success');
        } else if ((stage1 && stage1.get('isError') === true) || (stage2 && stage2.get('isError') === true)) {
          this.set('message', Em.I18n.t('admin.security.step4.body.failure.header'));
          this.set('msgColor','alert-error');
        } else {
          this.set('message', Em.I18n.t('admin.security.step4.body.header'));
          this.set('msgColor','alert-info');
        }
    }.observes('controller.stages.@each.isCompleted')

  });

  App.StageStatusView = Em.View.extend({
    tagName: 'tr',
    hasStarted: null,
    classNameBindings: ['faintText']
  });

  App.StageSuccessView = Em.View.extend({
    template: Ember.Handlebars.compile('<i class="icon-ok icon-large"></i> Done')
  });

  App.StageFailureView = Em.View.extend({
    template: Ember.Handlebars.compile('<i class="icon-remove icon-large"></i> Failed')
  });

  App.StageInProgressView = Em.View.extend({
    stage: null,
    classNames: ['progress-striped', 'active', 'progress'],
    template: Ember.Handlebars.compile([
      '<div class="bar" {{bindAttr style="stage.barWidth"}}>',
      '</div>'
    ].join('\n')),

    isStageCompleted: function () {
      return this.get('obj.progress') == 100 || this.get('controller.isStepCompleted');
    }.property('controller.isStepCompleted', 'obj.progress')

  });

  
});
window.require.register("views/main/admin/security/disable", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminSecurityDisableView = Em.View.extend({

    templateName: require('templates/main/admin/security/disable'),

    didInsertElement: function () {
      this.get('controller').loadStep();
    },
    msgColor: 'alert-info',
    message: Em.I18n.t('admin.security.disable.body.header'),
    onResult: function () {
      var stage1 = this.get('controller.stages').findProperty('stage', 'stage2');
      var stage2 = this.get('controller.stages').findProperty('stage', 'stage3');
      var stage3 = this.get('controller.stages').findProperty('stage', 'stage4');
      if (stage2 && stage2.get('isSuccess') === true ) {
        this.set('message', Em.I18n.t('admin.security.disable.body.success.header'));
        this.set('msgColor', 'alert-success');
      } else if ((stage1 && stage1.get('isError') === true) || (stage2 && stage2.get('isError') === true)) {
        this.set('message', Em.I18n.t('admin.security.disable.body.failure.header'));
        this.set('msgColor', 'alert-error');
      } else {
        this.set('message', Em.I18n.t('admin.security.disable.body.header'));
        this.set('msgColor', 'alert-info');
      }
    }.observes('controller.stages.@each.isCompleted')
  });
  
});
window.require.register("views/main/admin/stack_upgrade", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.StackUpgradeView = Em.View.extend({
    templateName: require('templates/main/admin/stack_upgrade'),

    isStep1Disabled: function () {
      return this.isStepDisabled(1);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep2Disabled: function () {
      return this.isStepDisabled(2);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep3Disabled: function () {
      return this.isStepDisabled(3);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStepDisabled: function (index) {
      return this.get('controller.isStepDisabled').findProperty('step', index).get('value');
    }
  });
  
});
window.require.register("views/main/admin/user", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminUserView = Em.View.extend({
    templateName: require('templates/main/admin/user'),
    users: App.User.find(),
    delete: function(event, context){
      console.log("EVENT:");
      console.log(event);

      console.log("CONTEXT:");
      console.log(context);
    },
    ldapUser: function(){
      var auth = App.router.get('mainAdminAuthenticationController.content');
      return auth.get('method');
    }.property('App.router.mainAdminAuthenticationController.content')


  });
});
window.require.register("views/main/admin/user/create", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminUserCreateView = Em.View.extend({
    templateName: require('templates/main/admin/user/create'),
    userId: false,
    create: function(event){
      var parent_controller=this.get("controller").controllers.mainAdminUserController;
      var form = this.get("userForm");
      if(form.isValid()) {
        form.getField("userName").set('value', form.getField("userName").get('value').toLowerCase());
        if(form.getField("admin").get('value') === "" || form.getField("admin").get('value') == true) {
          form.getField("roles").set("value","admin,user");
          form.getField("admin").set("value","true");
        } else{
          form.getField("roles").set("value","user");
        }
        parent_controller.sendCommandToServer('/users/' + form.getField("userName").get('value'), "POST" , {
          Users: {
            password: form.getField("password").get('value'),
            roles: form.getField("roles").get('value')
          }
        }, function (success) {

          if (!success) {
            App.ModalPopup.show({
              header: Em.I18n.t('admin.users.addButton'),
              body: Em.I18n.t('admin.users.createError'),
              primary: Em.I18n.t('ok'),
              secondary: null,
              onPrimary: function() {
                this.hide();
              }
            });
            return;
          }
          App.ModalPopup.show({
            header: Em.I18n.t('admin.users.addButton'),
            body: Em.I18n.t('admin.users.createSuccess'),
            primary: Em.I18n.t('ok'),
            secondary: null,
            onPrimary: function() {
              this.hide();
            }
          });
          form.save();

          App.router.transitionTo("allUsers");
        })
      }
    },

    userForm: App.CreateUserForm.create({}),

    keyPress: function(event) {
      if (event.keyCode === 13) {
        this.create();
        return false;
      }
    },

    didInsertElement: function(){
      this.get('userForm').propertyDidChange('object');
    }
  });
  
});
window.require.register("views/main/admin/user/edit", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminUserEditView = Em.View.extend({
    templateName: require('templates/main/admin/user/edit'),
    userId: false,
    edit: function(event){
      var parent_controller=this.get("controller").controllers.mainAdminUserController;
      var form = this.get("userForm");
      if(form.isValid()) {
        var Users={};
        if(form.getField("admin").get('value') === "" || form.getField("admin").get('value') == true) {
          form.getField("roles").set("value","admin,user");
          form.getField("admin").set("value", true);
        } else{
          form.getField("roles").set("value","user");
        }

        Users.roles = form.getField("roles").get('value');

        if(form.getField("new_password").get('value') != "" && form.getField("old_password").get('value') != "") {
          Users.password = form.getField("new_password").get('value');
          Users.old_password = form.getField("old_password").get('value');
        }

        parent_controller.sendCommandToServer('/users/' + form.getField("userName").get('value'), "PUT" , {
         Users:Users
        }, function (success, message) {
          if (!success) {
            App.ModalPopup.show({
              header: Em.I18n.t('admin.users.editButton'),
              body: message,
              primary: Em.I18n.t('ok'),
              secondary: null,
              onPrimary: function() {
                this.hide();
              }
            });
            return;
          }

          form.save();

          App.router.transitionTo("allUsers");
        })
      }
    },

    keyPress: function(event) {
      if (event.keyCode === 13) {
        this.edit();
        return false;
      }
    },

    userForm: App.EditUserForm.create({}),

    didInsertElement: function() {
      var form = this.get('userForm');
      if (form.getField("isLdap").get("value")) {
        form.getField("old_password").set("disabled",true);
        form.getField("new_password").set("disabled",true);
      }
      else {
        form.getField("old_password").set("disabled",false);
        form.getField("new_password").set("disabled",false);
      }
      form.propertyDidChange('object');
    }
  });
});
window.require.register("views/main/admin/user/row", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAdminUserRowView = Em.View.extend({
    templateName: require('templates/main/admin/user/row'),
    disableCheckBoxes: "disabled"
  });
});
window.require.register("views/main/apps/item/bar_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var graph = require('utils/graph');

  App.MainAppsItemBarView = Em.View.extend({
    elementId:'bars',
    templateName:require('templates/main/apps/item/bar'),
    content:function () {
      return this.get('controller.content.jobs');
    }.property('controller.content.jobs'),
    onLoad:function () {
      if (!this.get('controller.content.loadAllJobs') || this.get('activeJob')) {
        return;
      }

      var self = this;
      Ember.run.next(function(){
        self.updateTasksView();
      });
    }.observes('controller.content.loadAllJobs'),
    didInsertElement:function () {
      this.onLoad();
    },
    draw:function () {
    },

    mapNodeLocal:false,
    mapRackLocal:false,
    mapOffSwitch:false,
    reduceOffSwitch:false,
    submit:false,
    finish:false,

    updateTasksView:function () {
      var url = App.testMode ? '/data/apps/jobs/taskview.json' : App.apiPrefix + "/jobhistory/tasklocality?workflowId=" + this.get('controller.content.id');
      var mapper = App.jobTasksMapper;
      mapper.set('model', this);
      var self = this;
      App.HttpClient.get(url, mapper,{
        complete:function(jqXHR, textStatus) {
          self.set('loadJobTasks', true);
        }
      });
    },

    drawJobTasks:function () {
      if (!this.get('mapNodeLocal') || !this.get('mapRackLocal') || !this.get('mapOffSwitch') || !this.get('reduceOffSwitch')) {return;}
      graph.drawJobTasks(this.get('mapNodeLocal'), this.get('mapRackLocal'), this.get('mapOffSwitch'), this.get('reduceOffSwitch'), this.get('controller.content.startTime'), this.get('controller.content.startTime')+this.get('controller.content.elapsedTime'), this.$().width(), 300, 'job_tasks');
    }.observes('loadJobTasks')

  });
  
});
window.require.register("views/main/apps/item/dag_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var sort = require('views/common/sort_view');

  App.MainAppsItemDagView = Em.View.extend({
    templateName: require('templates/main/apps/item/dag'),
    elementId : 'jobs',
    content:function(){
      return this.get('controller.content.jobs');
    }.property('controller.content.jobs'),

    classNames:['table','dataTable'],
    /**
     * convert content to special jobs object for DagViewer
     */
    jobs: function(){
      var c = this.get('content');
      var result = [];
      c.forEach(function(item, index){
        result[index] = new Object({
          'name' : item.get('id'),
          'entityName' : item.get('workflow_entity_name'),
          'status' : item.get('status'),
          'input' : item.get('input'),
          'output' : item.get('output'),
          'submitTime' : item.get('submit_time'),
          'elapsedTime' : item.get('elapsed_time')
        })
      });
      return result;
    }.property('content'),

    loaded : false,

    hasManyJobs: function(){
      return (this.get('content') && this.get('content').length > 1);
    }.property('content'),

    onLoad:function (){
      if(!this.get('controller.content.loadAllJobs') || this.get('loaded')){
        return;
      }

      this.set('loaded', true);

      var self = this;

      Ember.run.next(function(){
        self.draw();
        self.updateTimeline();
      });

    }.observes('controller.content.loadAllJobs'),

    resizeModal: function () {
      var modal = $('.modal');
      var body = $('body');
      modal.find('.modal-body').first().css('max-height', 'none');
      var modalHeight = modal.height() + 300;
      var bodyHeight = body.height();
      if (modalHeight > bodyHeight) {
        modal.css('top', '20px');
        $('.modal-body').height(bodyHeight - 180);
      } else {
        modal.css('top', (bodyHeight - modalHeight) / 2 + 'px');
      }

      var modalWidth = modal.width();
      var bodyWidth = body.width();
      if (modalWidth > bodyWidth) {
        modal.css('left', '10px');
        modal.width(bodyWidth - 20);
      } else {
        modal.css('left', (bodyWidth - modalWidth) / 2 + 'px');
      }
    },

    didInsertElement: function(){
      this.onLoad();
    },

    loadTaskTimeline:false,
    loadJobTimeline:false,
    map:false,
    shuffle:false,
    reduce:false,
    allmap:false,
    allshuffle:false,
    allreduce:false,

    updateTimeline:function () {
      var url = App.testMode ? '/data/apps/jobs/timeline.json' : App.apiPrefix + "/jobhistory/task?workflowId=" + this.get('controller.content.id') + "&width=" + this.$().width() + "&startTime=" + this.get('controller.content.startTime') + "&endTime=" + (this.get('controller.content.startTime')+this.get('controller.content.elapsedTime'));
      var mapper = App.jobTimeLineMapper;
      mapper.set('model', this);
      var self = this;
      App.HttpClient.get(url, mapper,{
        complete:function(jqXHR, textStatus) {
          self.set('loadJobTimeline', true);
        }
      });
      url = App.testMode ? '/data/apps/jobs/timeline.json' : App.apiPrefix + "/jobhistory/task?width=" + this.$().width() + "&startTime=" + this.get('controller.content.startTime') + "&endTime=" + (this.get('controller.content.startTime')+this.get('controller.content.elapsedTime'));
      var mapper = App.taskTimeLineMapper;
      mapper.set('model', this);
      var self = this;
      App.HttpClient.get(url, mapper,{
        complete:function(jqXHR, textStatus) {
          self.set('loadTaskTimeline', true);
        }
      });
    },

    drawJobTimeline:function () {
      if (this.get('loadJobTimeline') && this.get('loadTaskTimeline')) {
        this.daggraph.addTimeSeries([{"name":"allmap","color":"green","values":this.get('allmap')},
          {"name":"map","color":"green","values":this.get('map')}], 0, "Maps");
        this.daggraph.addTimeSeries([
          {"name":"allshuffle","color":"lightblue","values":this.get('allshuffle')},
          {"name":"allreduce","color":"steelblue","values":this.get("allreduce")},
          {"name":"shuffle","color":"lightblue","values":this.get('shuffle')},
          {"name":"reduce","color":"steelblue","values":this.get("reduce")}], 1, "Reduces");
      }
    }.observes('loadJobTimeline', 'loadTaskTimeline'),

    daggraph:false,

    draw: function(){
      var dagSchema = this.get('controller.content.workflowContext');
      var jobs = this.get('jobs');
      this.resizeModal();
      this.daggraph = new DagViewer('dag_viewer')
          .setData(dagSchema, jobs)
          .drawDag(this.$().width(), 300, 20);
    },
    sortView: sort.wrapperView,
    nameSort: sort.fieldView.extend({
      name:'workflow_entity_name',
      displayName: Em.I18n.t('apps.item.dag.job')
    }),
    idSort: sort.fieldView.extend({
      name:'id',
      displayName: Em.I18n.t('apps.item.dag.jobId')
    }),
    statusSort: sort.fieldView.extend({
      name:'status',
      displayName: Em.I18n.t('apps.item.dag.status')
    }),
    mapsSort: sort.fieldView.extend({
      name:'maps',
      displayName: Em.I18n.t('apps.item.dag.maps')
    }),
    reducesSort: sort.fieldView.extend({
      name:'reduces',
      displayName: Em.I18n.t('apps.item.dag.reduces')
    }),
    inputSort: sort.fieldView.extend({
      name:'input',
      displayName: Em.I18n.t('apps.item.dag.input')
    }),
    outputSort: sort.fieldView.extend({
      name:'output',
      displayName: Em.I18n.t('apps.item.dag.output')
    }),
    durationSort: sort.fieldView.extend({
      name:'elapsed_time',
      displayName: Em.I18n.t('apps.item.dag.duration')
    })
  });
  
});
window.require.register("views/main/apps/item_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainAppsItemView = Em.View.extend({
    tagName: 'tr',
    classNames : ['containerRow'],
    templateName:require('templates/main/apps/item'),
    menuTabs:[
      Em.Object.create({
        label:Em.I18n.t('apps.dagCharts.popup.dag'),
        active:'active',
        content:'App.MainAppsItemDagView'
      }),
      Em.Object.create({
        label:Em.I18n.t('apps.dagCharts.popup.tasks'),
        active:'',
        content:'App.MainAppsItemBarView'
      })
    ],
    activeTab:null,
    switchTab:function(event){
      var tabs = this.get('menuTabs');
      for(var i = 0; i < tabs.length; i++){
        if(tabs[i] === event.context){
          tabs[i].set('active', 'active');
        }
        else {
          tabs[i].set('active', '');
        }
      }
      this.set('activeTab', event.context);
    },
    didInsertElement: function(){
      var tabs = this.get('menuTabs');
      tabs[0].set('active', 'active');
      tabs[1].set('active', '');
      this.set('activeTab', tabs[0]);
    },
    containerView: Em.ContainerView.extend({
      onchange:function(){

        if(this.get('childViews').length){
          this.get('childViews').get('firstObject').destroy();
        }

        var view = this.get('parentView.activeTab.content').split('.')[1];
        view = App[view].create({
          controllerBinding: 'App.router.mainAppsItemController'
        });
        this.get('childViews').pushObject(view);
      }.observes('parentView.activeTab')
    })
  });
  
});
window.require.register("views/main/apps_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var filters = require('views/common/filter_view');

  App.MainAppsView = Em.View.extend({
    templateName: require('templates/main/apps'),
    paginationInfo: function() {
      return this.t('apps.filters.paginationInfo').format(this.get('controller.paginationObject.startIndex'), this.get('controller.paginationObject.endIndex'), this.get('controller.paginationObject.iTotalDisplayRecords'));
    }.property('controller.paginationObject.startIndex', 'controller.paginationObject.endIndex', 'controller.paginationObject.iTotalDisplayRecords'),
    //Pagination left/right buttons css class
    paginationLeft: Ember.View.extend({
      tagName: 'a',
      template: Ember.Handlebars.compile('<i class="icon-arrow-left"></i>'),
      classNameBindings: ['class'],
      class: "",
      calculateClass: function () {
        if (parseInt(this.get("controller.paginationObject.startIndex")) > 1) {
          this.set("class", "paginate_previous");
        } else {
          this.set("class", "paginate_disabled_previous");
        }
      }.observes("controller.paginationObject"),
      click: function (event) {
        if (this.get('class') == "paginate_previous") {
          var startIndex = parseInt(this.get("controller.paginationObject.startIndex")) - 1;
          var showRows = parseInt(this.get("controller.filterObject.iDisplayLength"));
          var startDisplayValue = Math.max(0, startIndex - showRows);
          this.set("controller.filterObject.iDisplayStart", startDisplayValue);
        }
      }
    }),
    paginationRight: Ember.View.extend({
      tagName: 'a',
      template: Ember.Handlebars.compile('<i class="icon-arrow-right"></i>'),
      classNameBindings: ['class'],
      class: "",
      calculateClass: function () {
        if ((parseInt(this.get("controller.paginationObject.endIndex"))) < parseInt(this.get("controller.paginationObject.iTotalDisplayRecords"))) {
          this.set("class", "paginate_next");
        } else {
          this.set("class", "paginate_disabled_next");
        }
      }.observes("controller.paginationObject"),
      click: function (event) {
        if (this.get('class') == "paginate_next") {
          var startDisplayValue = parseInt(this.get("controller.paginationObject.endIndex"));
          this.set("controller.filterObject.iDisplayStart", startDisplayValue);
        }
      }
    }),

    /**
     * If there are table rows with runs.
     */
    emptyData:true,

    /*
     If no runs to display set emptyData to true and reset Avg table data, else to set emptyData to false.
     */
    emptyDataObserver:function(){
      if(this.get("controller.paginationObject.iTotalRecords") != null && this.get("controller.paginationObject.iTotalDisplayRecords")>0){
        this.set("emptyData",false);
      }else{
        this.set("emptyData",true);
        this.set("controller.serverData",null);
      }
    }.observes("controller.paginationObject.iTotalDisplayRecords","controller.paginationObject.iTotalRecords"),


    /**
     * View for RunPerPage select component
     */
    runPerPageSelectView: Em.Select.extend({
      selected: '10',
      content: ['10', '25', '50', '100']
    }),

    wrapSorting: Ember.View.extend({
      tagName: 'tr'
    }),

    sortingColumns: Ember.View.extend({
      tagName: 'th',
      classNameBindings: ['class', 'widthClass'],
      class: "sorting",
      widthClass: "",
      content: null,
      defaultColumn: 8,

      didInsertElement: function () {
        this.set("widthClass", "col" + this.get('content.index'));
        if (this.get('content.index') == this.get('defaultColumn')) {
          this.setControllerObj(this.content.index, "DESC");
          this.set("class", "sorting_desc");
        }
      },
      click: function (event) {
        console.log(this.get('class'));
        if (this.get('class') == "sorting") {
          this.resetSortClass();
          this.setControllerObj(this.get('content.index'), "ASC");
          this.set("class", "sorting_asc");
        } else if (this.get('class') == "sorting_asc") {
          this.setControllerObj(this.get('content.index'), "DESC");
          this.set("class", "sorting_desc");
        } else if (this.get('class') == "sorting_desc") {
          this.setControllerObj(this.get('content.index'), "ASC");
          this.set("class", "sorting_asc");
        }
      },
      resetSortClass: function () {
        this.get("parentView.childViews").map(function (a, e) {
          a.get("childViews")[0].set("class", "sorting")
        });
      },
      setControllerObj: function (col, dir) {
        this.set("controller.filterObject.iSortCol_0", col);
        this.set("controller.filterObject.sSortDir_0", dir);
      }
    }),

    /**
     * Filter-field for Search
     */
    appSearchThrough: Em.TextField.extend({
      classNames: ['input-medium'],
      type: 'text',
      placeholder: Em.I18n.t('common.search')
    }),
    /**
     * Filter-field for App ID.
     * Based on <code>filters</code> library
     */
    appIdFilterView: filters.createTextView({
      valueBinding: "controller.filterObject.sSearch_0"
    }),
    /**
     * Filter-field for name.
     * Based on <code>filters</code> library
     */
    nameFilterView: filters.createTextView({
      valueBinding: "controller.filterObject.sSearch_1",
      fieldType: 'input-small'
    }),
    /**
     * Filter-field for type.
     * Based on <code>filters</code> library
     */
    typeFilterView: filters.createSelectView({
      fieldType: 'input-small',
      valueBinding: "controller.filterObject.runType",
      content: ['Any', 'Pig', 'Hive', 'MapReduce']
    }),

    /**
     * Filter-list for User.
     * Based on <code>filters</code> library
     */
    userFilterView: filters.createComponentView({
      /**
       * Inner FilterView. Used just to render component. Value bind to <code>mainview.value</code> property
       * Base methods was implemented in <code>filters.componentFieldView</code>
       */
      filterView: filters.componentFieldView.extend({
        templateName:require('templates/main/apps/user_filter'),

        usersBinding: 'controller.users',

        allComponentsChecked:false,
        toggleAllComponents:function () {
          var checked = this.get('allComponentsChecked');
          this.get('users').setEach('checked', checked);
        }.observes('allComponentsChecked'),

        clearFilter:function() {
          this.set('allComponentsChecked', false);

          this.get('users').setEach('checked', false);

          this._super();
        },

        applyFilter:function() {
          this._super();

          var chosenUsers = this.get('users').filterProperty('checked', true).mapProperty('name');
          this.set('value', chosenUsers.toString());
        }
      }),

      valueBinding: 'controller.filterObject.sSearch_3'
    }),
    /**
     * Filter-field for jobs.
     * Based on <code>filters</code> library
     */
    jobsFilterView: filters.createTextView({
      fieldType: 'input-super-mini',
      valueBinding: "controller.filterObject.jobs"
    }),
    /**
     * Filter-field for Input.
     * Based on <code>filters</code> library
     */
    inputFilterView: filters.createTextView({
      fieldType: 'input-super-mini',
      valueBinding: "controller.filterObject.input"
    }),
    /**
     * Filter-field for Output.
     * Based on <code>filters</code> library
     */
    outputFilterView: filters.createTextView({
      fieldType: 'input-super-mini',
      valueBinding: "controller.filterObject.output"
    }),
    /**
     * Filter-field for Duration.
     * Based on <code>filters</code> library
     */
    durationFilterView: filters.createTextView({
      fieldType: 'input-super-mini',
      valueBinding: "controller.filterObject.duration"
    }),
    /**
     * Filter-field for RunDate.
     * Based on <code>filters</code> library
     */
    runDateFilterView: filters.createSelectView({
      fieldType: 'input-medium',
      valueBinding: "controller.filterObject.runDate",
      content: ['Any', 'Past 1 Day', 'Past 2 Days', 'Past 7 Days', 'Past 14 Days', 'Past 30 Days']
    }),

    /**
     * Onclick handler for Show All/Filtered buttons
     */
    clickViewType: function (event) {
      this.set("controller.filterObject.viewTypeClickEvent", true);
      if ($(event.target).hasClass("filtered") || $(event.target.parentNode).hasClass("filtered")) {
        this.set("controller.filterObject.viewType", "filtered");
      } else {
        this.set("controller.filterObject.allFilterActivated", true);
        this.set("controller.filterObject.viewType", "all");
      }
    },
    /**
     * Clears up last job ID when coming in fresh to page.
     * Not doing this will result in failure to load job
     * data, and subsequently the popup dialog.
     */
    didInsertElement: function(){
      var self = this;
      Em.run.next(function() {
        self.get('_childViews').forEach(function(childView) {
          if(childView['showClearFilter']) {
            childView.showClearFilter();
          }
        });
      });
      this.get('controller').set('lastJobId', null);
      this.onChangeViewType();
    },
    /**
     *
     */
    onChangeViewType: function () {
      var tmpViewType = this.get('controller.filterObject.viewType');
      var filterButtons = $("#filter_buttons").children();
      filterButtons.each(function (index, element) {
        $(element).removeClass('selected');
        if (tmpViewType == $(element).data('view-type')) {
          $(element).addClass('selected');
        }
      });
      this.set("controller.filterObject.viewTypeClickEvent", false);
    }.observes("controller.filterObject.viewType"),

    /**
     * This Container View is used to render static table row(appTableRow) and additional dynamic content
     */
    containerRow: Em.ContainerView.extend({

      /**
       * Unique row id
       */
      id: function () {
        return this.get('run.id');
      }.property("run.id"),

      /**
       * Show/hide additional content appropriated for this row
       */
      expandToggle: function () {
        //App.router.get('mainAppsItemController').set('jobsLoaded', false);
        App.router.get('mainAppsItemController').set('content', this.get('run'));
        App.ModalPopup.show({
          classNames: ['big-modal'],
          header: Em.I18n.t('apps.dagCharts.popup'),
          bodyClass: App.MainAppsItemView.extend({
            controllerBinding: 'App.router.mainAppsItemController'
          }),
          onPrimary: function () {
            this.hide();
          },
          secondary: null
        });
      }
    }),
    /**
     * Table-row view
     */
    appTableRow: Em.View.extend({
      templateName: require('templates/main/apps/list_row'),
      classNames: ['app-table-row'],
      tagName: "tr",
      onLoad: function() {
        var run = this.get('parentView.run');
        if (run.index) {
          var strip = (run.index % 2) ? 'odd' : 'even';
          this.$().addClass(strip);
        }
      }.observes('parentView.run'),

      didInsertElement: function() {
        this.onLoad();
      },
      mouseEnter: function (event, view) {
        $(event.currentTarget).addClass("hover")
      },
      mouseLeave: function (event, view) {
        $(event.currentTarget).removeClass("hover");
      },
      click: function (event, view) {
        this.get('parentView').expandToggle();
      }

    })

  });
});
window.require.register("views/main/charts", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainChartsView = Em.View.extend({
      templateName: require('templates/main/charts')
  });
});
window.require.register("views/main/charts/heatmap", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.MainChartsHeatmapView = Em.View.extend({
    templateName: require('templates/main/charts/heatmap'),
    spinner: null,
    didInsertElement: function () {
      this._super();
      // set default metric
      this.set('controller.selectedMetric', this.get('controller.allMetrics')[0].get('items')[0]);
      $("#heatmapDetailsBlock").hide();
    },
    showLoading: function () {
      if (this.get('controller.selectedMetric.loading')) {
        var e = document.getElementById("heatmap-metric-loading");
        if (e) {
          var spinOpts = {
            lines: 9,
            length: 4,
            width: 2,
            radius: 3,
            top: '0',
            left: '0'
          };
          this.set('spinner', new Spinner(spinOpts).spin(e));
        }
      } else {
        var spinner = this.get('spinner');
        if (spinner) {
          spinner.stop();
        }
        this.set('spinner', null);
      }
    }.observes('controller.selectedMetric.loading')
  });
});
window.require.register("views/main/charts/heatmap/heatmap_host", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var date = require('utils/date');

  var App = require('app');

  App.MainChartsHeatmapHostView = Em.View.extend({
    templateName: require('templates/main/charts/heatmap/heatmap_host'),
    /** @private */
    hostClass: 'hostBlock',

    /**
     * show Host details block and move it near the cursor
     * 
     * @param {Object}
     *          e
     * @this App.MainChartsHeatmapHostView
     */
    mouseEnter: function (e) {
      var host = this.get('content');
      var view = App.MainChartsHeatmapHostDetailView.create();
      $.each(view.get('details'), function(i){
        var val = host.get(i);
        if (i == 'diskUsage') {
          if (val == undefined || isNaN(val) || val == Infinity || val == -Infinity) {
            val = null;
          } else {
            val = val.toFixed(1);
          }
        } else if (i == 'cpuUsage') {
          if (val == undefined || isNaN(val)) {
            val = null;
          } else {
            val = val.toFixed(1);
          }
        } else if (i == 'memoryUsage') {
          if (val == undefined || isNaN(val) || val == Infinity || val == -Infinity) {
            val = null;
          } else {
            val = val.toFixed(1);
          }
        } else if (i == 'hostComponents') {
          if (val == undefined) {
            val = null;
          } else {
            val = val.filterProperty('isMaster').concat(val.filterProperty('isSlave')).mapProperty('displayName').join(', ');
          }
        }
        view.set('details.' + i, val);
      });
      var selectedMetric = this.get('controller.selectedMetric');
      if (selectedMetric) {
        var metricName = selectedMetric.get('name');
        var h2vMap = selectedMetric.get('hostToValueMap');
        if (h2vMap && metricName) {
          var value = h2vMap[host.get('hostName')];
          if (value == undefined || value == null) {
            value = this.t('charts.heatmap.unknown');
          } else {
            if (metricName == 'Garbage Collection Time') {
              value = date.timingFormat(parseInt(value));
            } else {
              if (isNaN(value)) {
                value = this.t('charts.heatmap.unknown');
              } else {
                value = value + selectedMetric.get('units');
              }
            }
          }
          view.set('details.metricName', metricName);
          view.set('details.metricValue', value);
        }
      }
      var detailsBlock = $("#heatmapDetailsBlock");
      detailsBlock.css('top', e.pageY + 10);
      detailsBlock.css('left', e.pageX + 10);
      detailsBlock.show();
    },

    /**
     * hide Host details block
     * 
     * @param {Object}
     *          e
     * @this App.MainChartsHeatmapHostView
     */
    mouseLeave: function (e) {
      $("#heatmapDetailsBlock").hide();
    },

    hostTemperatureStyle: function () {
      var controller = this.get('controller');
      var h2sMap = controller.get('hostToSlotMap');
      if (h2sMap) {
        var hostname = this.get('content.hostName');
        if (hostname) {
          var slot = h2sMap[hostname];
          if (slot > -1) {
            var slotDefs = controller.get('selectedMetric.slotDefinitions');
            if (slotDefs && slotDefs.length > slot) {
              return slotDefs[slot].get('cssStyle');
            }
          }
        }
      }
      return '';
    }.property('controller.hostToSlotMap')
  });
});
window.require.register("views/main/charts/heatmap/heatmap_host_detail", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainChartsHeatmapHostDetailView = Em.View.extend({
    templateName: require('templates/main/charts/heatmap/heatmap_host_detail'),
    /** @private */ classNames:['heatmap_host_details'],
    /** @private */ elementId:'heatmapDetailsBlock',
    /** @private */ details:{
      hostName:'test node',
      publicHostName:'test node',
      osType: 'OS',
      ip: '192.168.0.0',
      metricName: 'metric-name',
      metricValue: 'metric-value',
      diskUsage: '10',
      cpuUsage: '10',
      memoryUsage: '10',
      hostComponents: 'host components'
    }
  });
});
window.require.register("views/main/charts/heatmap/heatmap_rack", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainChartsHeatmapRackView = Em.View.extend({
    templateName: require('templates/main/charts/heatmap/heatmap_rack'),
    classNames: ['rack'],
    classNameBindings: ['visualSchema'],
    /**
     * this is the class for binding attribute to hosts block
     * @private
     */
    hostsBlockClass:"hosts clearfix",
    heatmapIsOpened: 1,

    /** rack status block class */
    statusIndicator:'statusIndicator',

    toggleRack: function(){
      var newHeatmapStatus = 1 - this.get('heatmapIsOpened');
      this.set('heatmapIsOpened', newHeatmapStatus);
    },

    /**
     * change toggler class, depends on heatmapIsOpened property
     * @this App.MainChartsHeatmapRackView
     */
    heatmapTogglerClass:function () {
      if (this.heatmapIsOpened) {
        return "isActive"
      }
      return "";
    }.property("heatmapIsOpened"),
    
    /**
     * Provides the CSS style for an individual host.
     * This can be used as the 'style' attribute of element.
     */
    hostCssStyle: function(){
      var rack = this.get('rack');
      var widthPercent = 100;
      var hostCount = rack.get('hosts.length');
      if(hostCount<11){
        widthPercent = (100/hostCount)-0.5;
      }else{
        widthPercent = 10; // max out at 10%
      }
      return "width:"+widthPercent+"%;float:left;";
    }.property('rack')
  });
});
window.require.register("views/main/charts/menu", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainChartsMenuView = Em.CollectionView.extend({
    tagName: 'ul',
    classNames: ["nav", "nav-tabs"],
    content:[
      /*{ label:'Heatmap', routing:'heatmap', active:"active"},
      { label:'Horizon Chart', routing:'horizon_chart'}*/
    ],

    init: function(){ this._super(); this.activateView(); },

    activateView:function () {
      $.each(this._childViews, function () {
        this.set('active', (this.get('content.routing') == 'heatmap' ? "active" : ""));
      });
    },

    deactivateChildViews: function() {
      $.each(this._childViews, function(){
        this.set('active', "");
      });
    },

    itemViewClass: Em.View.extend({
      classNameBindings: ["active"],
      active: "",
      template: Ember.Handlebars.compile('<a {{action showChart view.content.routing }} href="#"> {{unbound view.content.label}}</a>')
    })
  });
});
window.require.register("views/main/dashboard", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var filters = require('views/common/filter_view');

  App.MainDashboardView = Em.View.extend({
    templateName:require('templates/main/dashboard'),
    didInsertElement:function () {
      this.services();
      this.setWidgetsDataModel();
      this.setInitPrefObject();
      this.setOnLoadVisibleWidgets();
      this.set('isDataLoaded',true);
      Ember.run.next(this, 'makeSortable');
    },
    content:[],
    isDataLoaded: false,
    isClassicDashboard: false,

    makeSortable: function () {
      var self = this;
      $( "#sortable" ).sortable({
        items: "> div",
        //placeholder: "sortable-placeholder",
        cursor: "move",
        update: function (event, ui) {
          if (!App.testMode) {
            // update persist then translate to real
            var widgetsArray = $('div[viewid]'); // get all in DOM
            self.getUserPref(self.get('persistKey'));
            var oldValue = self.get('currentPrefObject');
            var newValue = Em.Object.create({
              dashboardVersion: oldValue.dashboardVersion,
              visible: [],
              hidden: oldValue.hidden,
              threshold: oldValue.threshold
            });
            var size = oldValue.visible.length;
            for(var j = 0; j <= size -1; j++){
              var viewID = widgetsArray.get(j).getAttribute('viewid');
              var id = viewID.split("-").get(1);
              newValue.visible.push(id);
            }
            self.postUserPref(self.get('persistKey'), newValue);
            //self.translateToReal(newValue);
          }
        }
      });
      $( "#sortable" ).disableSelection();
    },

    setWidgetsDataModel: function () {
      var services = App.Service.find();
      var self = this;
      services.forEach(function (item) {
        switch (item.get('serviceName')) {
          case "HDFS":
            self.set('hdfs_model',  App.HDFSService.find(item.get('id')) || item);
            break;
          case "MAPREDUCE":
            self.set('mapreduce_model', App.MapReduceService.find(item.get('id')) || item);
            break;
          case "HBASE":
            self.set('hbase_model', App.HBaseService.find(item.get('id')) || item);
            break;
        }
      }, this);
    },
    setInitPrefObject: function() {
      //in case of some service not installed
      var visibleFull = [
        '2', '4', '8', '10',
        '17', '11', '12', '13', '14',
        '18', '1', '6', '5', '9',
        '3', '7', '15', '16', '20',
        '19', '21', '23'
      ]; // all in order
      var hiddenFull = [['22','Region In Transition']];
      if (this.get('hdfs_model') == null) {
        var hdfs= ['1', '2', '3', '4', '5', '15', '17'];
        hdfs.forEach ( function (item) {
          var index = visibleFull.indexOf(item);
          visibleFull.splice(index, 1);
        }, this);
      }
      if (this.get('mapreduce_model') == null) {
        var map = ['6', '7', '8', '9', '10', '16', '18'];
        map.forEach ( function (item) {
          var index = visibleFull.indexOf(item);
          visibleFull.splice(index, 1);
        }, this);
      }
      if (this.get('hbase_model') == null) {
        var hbase = ['19', '20', '21', '23'];
        hbase.forEach ( function (item) {
          var index = visibleFull.indexOf(item);
          visibleFull.splice(index, 1);
        }, this);
        hiddenFull = [];
      }
      var obj = this.get('initPrefObject');
      obj.visible = visibleFull;
      obj.hidden = hiddenFull;
    },
    
    hdfs_model: null,
    mapreduce_model: null,
    hbase_model: null,
    visibleWidgets: [],
    hiddenWidgets: [], // widget child view will push object in this array if deleted

    plusButtonFilterView: filters.createComponentView({
      /**
       * Base methods was implemented in <code>filters.componentFieldView</code>
       */
      hiddenWidgetsBinding: 'parentView.hiddenWidgets',
      visibleWidgetsBinding: 'parentView.visibleWidgets',
      layout: null,

      filterView: filters.componentFieldView.extend({
        templateName:require('templates/main/dashboard/plus_button_filter'),
        hiddenWidgetsBinding: 'parentView.hiddenWidgets',
        visibleWidgetsBinding: 'parentView.visibleWidgets',
        valueBinding: '',
        applyFilter:function() {
          this._super();
          var parent = this.get('parentView').get('parentView');
          var hiddenWidgets = this.get('hiddenWidgets');
          var checkedWidgets = hiddenWidgets.filterProperty('checked', true);

          if (App.testMode) {
            var visibleWidgets = this.get('visibleWidgets');
            checkedWidgets.forEach(function(item){
              var newObj = parent.widgetsMapper(item.id);
              visibleWidgets.pushObject(newObj);
              hiddenWidgets.removeObject(item);
            }, this);
          } else {
            //save in persist
            parent.getUserPref(parent.get('persistKey'));
            var oldValue = parent.get('currentPrefObject');
            var newValue = Em.Object.create({
              dashboardVersion: oldValue.dashboardVersion,
              visible: oldValue.visible,
              hidden: [],
              threshold: oldValue.threshold
            });
            checkedWidgets.forEach(function(item){
              newValue.visible.push(item.id);
              hiddenWidgets.removeObject(item);
            }, this);
            hiddenWidgets.forEach(function(item){
              newValue.hidden.push([item.id, item.displayName]);
            }, this);

            parent.postUserPref(parent.get('persistKey'), newValue);
            parent.translateToReal(newValue);
          }
        }
      })
    }),

    /**
     * translate from Json value got from persist to real widgets view
     */
    translateToReal: function (value) {
      var version = value.dashboardVersion;
      var visible = value.visible;
      var hidden = value.hidden;
      var threshold = value.threshold;

      if (version == 'classic') {
        this.set('isClassicDashboard', true);
      } else if (version == 'new') {
        this.set('isClassicDashboard', false);
        var visibleWidgets = [];
        var hiddenWidgets = [];
        // re-construct visibleWidgets and hiddenWidgets
        for (var j = 0; j <= visible.length -1; j++) {
          var id = visible[j];
          var widgetClass = this.widgetsMapper(id);
          //override with new threshold
          if (threshold[id].length > 0) {
            widgetClass.reopen({
              thresh1: threshold[id][0],
              thresh2: threshold[id][1]
            });
          }
          visibleWidgets.pushObject(widgetClass);
        }
        for (var j = 0; j <= hidden.length -1; j++) {
          var id = hidden[j][0];
          var title = hidden[j][1];
          hiddenWidgets.pushObject(Em.Object.create({displayName:title , id: id, checked: false}));
        }
        this.set('visibleWidgets', visibleWidgets);
        this.set('hiddenWidgets', hiddenWidgets);
      }
    },

    setOnLoadVisibleWidgets: function () {
      if (App.testMode) {
        this.translateToReal(this.get('initPrefObject'));
      } else {
        // called when first load/refresh/jump back page
        this.getUserPref(this.get('persistKey'));
        var currentPrefObject = this.get('currentPrefObject');
        if (currentPrefObject) { // fit for no dashboard version
          if (!currentPrefObject.dashboardVersion) {
            currentPrefObject.dashboardVersion = 'new';
            this.postUserPref(this.get('persistKey'), currentPrefObject);
          }
          this.translateToReal(currentPrefObject);
        } else {
          // post persist then translate init object
          this.postUserPref(this.get('persistKey'), this.get('initPrefObject'));
          this.translateToReal(this.get('initPrefObject'));
        }
      }
    },

    widgetsMapper: function (id) {
      switch(id){
        case '1': return App.NameNodeHeapPieChartView;
        case '2': return App.NameNodeCapacityPieChartView;
        case '3': return App.NameNodeCpuPieChartView;
        case '4': return App.DataNodeUpView;
        case '5': return App.NameNodeRpcView;
        case '6': return App.JobTrackerHeapPieChartView;
        case '7': return App.JobTrackerCpuPieChartView;
        case '8': return App.TaskTrackerUpView;
        case '9': return App.JobTrackerRpcView;
        case '10': return App.MapReduceSlotsView;
        case '11': return App.ChartClusterMetricsMemoryWidgetView;
        case '12': return App.ChartClusterMetricsNetworkWidgetView;
        case '13': return App.ChartClusterMetricsCPUWidgetView;
        case '14': return App.ChartClusterMetricsLoadWidgetView;
        case '15': return App.NameNodeUptimeView;
        case '16': return App.JobTrackerUptimeView;
        case '17': return App.HDFSLinksView;
        case '18': return App.MapReduceLinksView;
        case '19': return App.HBaseLinksView;
        case '20': return App.HBaseMasterHeapPieChartView;
        case '21': return App.HBaseAverageLoadView;
        case '22': return App.HBaseRegionsInTransitionView;
        case '23': return App.HBaseMasterUptimeView;
      }
    },

    currentPrefObject: null,
    initPrefObject: Em.Object.create({
      dashboardVersion: 'new',
      visible: [],
      hidden: [],
      threshold: {1: [80, 90], 2: [85, 95], 3: [90, 95], 4: [80, 90], 5: [1000, 3000], 6: [70, 90], 7: [90, 95], 8: [50, 75], 9: [30000, 120000],
        10: [], 11: [], 12: [], 13: [], 14: [], 15: [], 16: [], 17: [], 18: [], 19: [], 20: [70, 90], 21: [10, 19.2], 22: [3, 10], 23: []} // id:[thresh1, thresh2]
    }),
    persistKey: function () {
      var loginName = App.router.get('loginName');
      return 'user-pref-' + loginName + '-dashboard';
    }.property(''),

    /**
     * get persist value from server with persistKey
     */
    getUserPref: function (key) {
      var self = this;
      var url = App.apiPrefix + '/persist/' + key;
      jQuery.ajax(
        {
          url: url,
          context: this,
          async: false,
          success: function (response) {
            if (response) {
              var value = jQuery.parseJSON(response);
              console.log('Got persist value from server with key ' + key + '. Value is: ' + response);
              self.set('currentPrefObject', value);
              return value;
             }
          },
          error: function (xhr) {
            // this user is first time login
            if (xhr.status == 404) {
              console.log('Persist did NOT find the key '+ key);
              return null;
            }
          },
          statusCode: require('data/statusCodes')
        }
      );
    },

    /**
     * post persist key/value to server, value is object
     */
    postUserPref: function (key, value) {
      var url = App.apiPrefix + '/persist/';
      var keyValuePair = {};
      keyValuePair[key] = JSON.stringify(value);

      jQuery.ajax({
        async: false,
        context: this,
        type: "POST",
        url: url,
        data: JSON.stringify(keyValuePair),
        beforeSend: function () {
          console.log('BeforeSend to persist: persistKeyValues', keyValuePair);
        }
      });
    },

    resetAllWidgets: function(){
      var self = this;
      App.showConfirmationPopup(function() {
        if(!App.testMode){
          self.postUserPref(self.get('persistKey'), self.get('initPrefObject'));
        }
        self.translateToReal(self.get('initPrefObject'));
      });
    },

    switchToClassic: function () {
      if(!App.testMode){
        this.getUserPref(this.get('persistKey'));
        var oldValue = this.get('currentPrefObject');
        oldValue.dashboardVersion = 'classic';
        this.postUserPref(this.get('persistKey'), oldValue);
      }else{
        var oldValue = this.get('initPrefObject');
        oldValue.dashboardVersion = 'classic';
      }
      this.translateToReal(oldValue);
    },
    switchToNew: function () {
      if(!App.testMode){
        this.getUserPref(this.get('persistKey'));
        var oldValue = this.get('currentPrefObject');
        oldValue.dashboardVersion = 'new';
        this.postUserPref(this.get('persistKey'), oldValue);
        this.didInsertElement();
      }else{
        var oldValue = this.get('initPrefObject');
        oldValue.dashboardVersion = 'new';
        this.translateToReal(oldValue);
      }
    },

    updateServices: function(){
      var services = App.Service.find();
      services.forEach(function (item) {
        var view;
        switch (item.get('serviceName')) {
          case "HDFS":
            view = this.get('content').filterProperty('viewName', App.MainDashboardServiceHdfsView);
            view.objectAt(0).set('model', App.HDFSService.find(item.get('id')));
            break;
          case "MAPREDUCE":
            view = this.get('content').filterProperty('viewName', App.MainDashboardServiceMapreduceView);
            view.objectAt(0).set('model', App.MapReduceService.find(item.get('id')));
            break;
          case "HBASE":
            view = this.get('content').filterProperty('viewName', App.MainDashboardServiceHbaseView);
            view.objectAt(0).set('model', App.HBaseService.find(item.get('id')));
        }
      }, this);
    }.observes('App.router.updateController.isUpdate'),
    services: function () {
      var services = App.Service.find();
      if (this.get('content').length > 0) {
        return false
      }
      services.forEach(function (item) {
        var vName;
        var item2;
        switch (item.get('serviceName')) {
          case "HDFS":
            vName = App.MainDashboardServiceHdfsView;
            item2 = App.HDFSService.find(item.get('id'));
            break;
          case "MAPREDUCE":
            vName = App.MainDashboardServiceMapreduceView;
            item2 = App.MapReduceService.find(item.get('id'));
            break;
          case "MAPREDUCE2":
            vName = App.MainDashboardServiceMapreduce2View;
            break;
          case "HBASE":
            vName = App.MainDashboardServiceHbaseView;
            item2 = App.HBaseService.find(item.get('id'));
            break;
          case "HIVE":
            vName = App.MainDashboardServiceHiveView;
            break;
          case "ZOOKEEPER":
            vName = App.MainDashboardServiceZookeperView;
            break;
          case "OOZIE":
            vName = App.MainDashboardServiceOozieView;
            break;
          default:
            vName = Em.View;
        }
        this.get('content').pushObject(Em.Object.create({
          viewName: vName,
          model: item2 || item
        }))
      }, this);
    },

    gangliaUrl: function () {
      return App.router.get('clusterController.gangliaUrl') + "/?r=hour&cs=&ce=&m=&s=by+name&c=HDPSlaves&tab=m&vn=";
    }.property('App.router.clusterController.gangliaUrl'),

    showAlertsPopup: function (event) {
      App.ModalPopup.show({
        header: this.t('services.alerts.headingOfList'),
        bodyClass: Ember.View.extend({
          service: event.context,
          warnAlerts: function () {
            var allAlerts = App.router.get('clusterController.alerts');
            var serviceId = this.get('service.serviceName');
            if (serviceId) {
              return allAlerts.filterProperty('serviceType', serviceId).filterProperty('isOk', false).filterProperty('ignoredForServices', false);
            }
            return 0;
          }.property('App.router.clusterController.alerts'),

          warnAlertsCount: function () {
            return this.get('warnAlerts').length;
          }.property('warnAlerts'),

          warnAlertsMessage: function() {
            return Em.I18n.t('services.alerts.head').format(this.get('warnAlertsCount'));
          }.property('warnAlertsCount'),

          nagiosUrl: function () {
            return App.router.get('clusterController.nagiosUrl');
          }.property('App.router.clusterController.nagiosUrl'),

          closePopup: function () {
            this.get('parentView').hide();
          },

          viewNagiosUrl: function () {
            window.open(this.get('nagiosUrl'), "_blank");
            this.closePopup();
          },

          selectService: function () {
            App.router.transitionTo('services.service.summary', event.context)
            this.closePopup();
          },
          templateName: require('templates/main/dashboard/alert_notification_popup')
        }),
        primary: 'Close',
        onPrimary: function() {
          this.hide();
        },
        secondary : null,
        didInsertElement: function () {
          this.$().find('.modal-footer').addClass('align-center');
          this.$().children('.modal').css({'margin-top': '-350px'});
        }
      });
      event.stopPropagation();
    }
  });
});
window.require.register("views/main/dashboard/cluster_metrics/cpu", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartClusterMetricsCPU = App.ChartLinearTimeView.extend({
    id: "cluster-metrics-cpu",

    ajaxIndex: 'dashboard.cluster_metrics.cpu',

    title: Em.I18n.t('dashboard.clusterMetrics.cpu'),
    yAxisFormatter: App.ChartLinearTimeView.PercentageFormatter,
    isTimePagingDisable: true,
    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.cpu) {
        var cpu_idle;
        for ( var name in jsonData.metrics.cpu) {
          var seriesData = jsonData.metrics.cpu[name];
          if (seriesData) {
            var s = this.transformData(seriesData, name);
            if (Em.I18n.t('dashboard.clusterMetrics.cpu.displayNames.idle') == s.name) {
              cpu_idle = s;
            }
            else {
              seriesArray.push(s);
            }
          }
        }
        seriesArray.push(cpu_idle);
      }
      return seriesArray;
    },
    
    colorForSeries: function (series) {
      if (Em.I18n.t('dashboard.clusterMetrics.cpu.displayNames.idle') == series.name){
        return '#CFECEC';
      }
      return null;
    }
  });
});
window.require.register("views/main/dashboard/cluster_metrics/load", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster load
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartClusterMetricsLoad = App.ChartLinearTimeView.extend({
    id: "cluster-metrics-load",

    ajaxIndex: 'dashboard.cluster_metrics.load',
    isTimePagingDisable: true,
    renderer: 'line',
    title: Em.I18n.t('dashboard.clusterMetrics.load'),
    
    transformToSeries: function(jsonData){
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.load) {
        for ( var name in jsonData.metrics.load) {
          var displayName = name;
          var seriesData = jsonData.metrics.load[name];
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/dashboard/cluster_metrics/memory", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster memory metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartClusterMetricsMemory = App.ChartLinearTimeView.extend({
    id: "cluster-metrics-memory",

    ajaxIndex: 'dashboard.cluster_metrics.memory',

    isTimePagingDisable: true,
    title: Em.I18n.t('dashboard.clusterMetrics.memory'),
    yAxisFormatter: App.ChartLinearTimeView.BytesFormatter,
    renderer: 'line',
    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.memory) {
        for ( var name in jsonData.metrics.memory) {
          var displayName = name;
          var seriesData = jsonData.metrics.memory[name];
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/dashboard/cluster_metrics/network", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster network metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartClusterMetricsNetwork = App.ChartLinearTimeView.extend({
    id: "cluster-metrics-network",

    ajaxIndex: 'dashboard.cluster_metrics.network',

    isTimePagingDisable: true,
    title: Em.I18n.t('dashboard.clusterMetrics.network'),
    yAxisFormatter: App.ChartLinearTimeView.BytesFormatter,
    renderer: 'line',

    transformToSeries : function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.network) {
        for ( var name in jsonData.metrics.network) {
          var displayName = name;
          var seriesData = jsonData.metrics.network[name];
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/dashboard/service", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var uiEffects = require('utils/ui_effects');

  require('models/alert');

  App.MainDashboardServiceHealthView = Em.View.extend({
    classNameBindings: ["healthStatus"],
    //template: Em.Handlebars.compile(""),
    blink: false,
    tagName: 'span',
    attributeBindings:['rel', 'title','data-original-title'],
    rel: 'HealthTooltip',
    'data-original-title': function(){
      var popupText = "";
      this.get("service").get("hostComponents").filterProperty('isMaster', true).forEach(function(item){
        popupText += item.get("displayName") + " " + item.get("componentTextStatus") + "<br/>";
      });
      return popupText;
    }.property('service.healthStatus'),

    /**
     * When set to true, extending classes should
     * show only tabular rows as they will be 
     * embedded into other tables.
     */
    showOnlyRows: false,

    startBlink: function () {
      this.set('blink', true);
    },

    doBlink: function () {
      var self = this;
      if (this.get('blink') && (this.get("state") == "inDOM")) {
        uiEffects.pulsate(self.$(), 1000, function(){
          self.doBlink();
        });
      }
    }.observes('blink'),

    stopBlink: function () {
      this.set('blink', false);
    },

    healthStatus: function () {
      var status = this.get('service.healthStatus');
      switch (status) {
        case 'green':
          status = App.Service.Health.live;
          this.stopBlink();
          break;
        case 'green-blinking':
          status = App.Service.Health.live;
          this.startBlink();
          break;
        case 'red-blinking':
          status = App.Service.Health.dead;
          this.startBlink();
          break;
        case 'yellow':
          status = App.Service.Health.unknown;
          break;
        default:
          status = App.Service.Health.dead;
          this.stopBlink();
          break;
      }

      return 'health-status-' + status;
    }.property('service.healthStatus'),

    didInsertElement: function () {
      $("[rel='HealthTooltip']").tooltip();
      this.doBlink(); // check for blink availability
    }
  });

  App.MainDashboardServiceView = Em.View.extend({
    classNames: ['service', 'clearfix'],

    data: function () {
      return this.get('controller.data.' + this.get('serviceName'));
    }.property('controller.data'),

    dashboardMasterComponentView : Em.View.extend({
      templateName: require('templates/main/service/info/summary/master_components'),
      mastersComp : function(){
       return this.get('parentView.service.hostComponents').filterProperty('isMaster', true);
      }.property("service")
    }),

    formatUnavailable: function(value){
      return (value || value == 0) ? value : this.t('services.service.summary.notAvailable');
    },

    criticalAlertsCount: function () {
      var alerts = App.router.get('clusterController.alerts');
      return alerts.filterProperty('serviceType', this.get('service.id')).filterProperty('isOk', false).filterProperty('ignoredForServices', false).length;
    }.property('App.router.clusterController.alerts'),

    isCollapsed: false,

    toggleInfoView: function () {
      this.$('.service-body').toggle('blind', 200);
      this.set('isCollapsed', !this.isCollapsed);
    },

    masters: function(){
      return this.get('service.hostComponents').filterProperty('isMaster', true);
    }.property('service'),

    clients: function(){
      var clients = this.get('service.hostComponents').filterProperty('isClient', true);
      var len = clients.length;
      var template = 'dashboard.services.{0}.client'.format(this.get('serviceName').toLowerCase());
      if(len > 1){
        template += 's';
      }

      return {
        title: this.t(template).format(len),
        component: clients.objectAt(0)
      };
    }.property('service')

  });
});
window.require.register("views/main/dashboard/service/flume", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');
  var date = require('utils/date');

  App.MainDashboardServiceFlumeView = App.MainDashboardServiceView.extend({
    templateName: require('templates/main/dashboard/service/flume'),
    serviceName: 'flume',
    
    summaryHeader: function () {
      var count = this.get('service.nodes.length');
      if(count==1)
        return this.t("dashboard.services.flume.summary.single").format(count);
      return this.t("dashboard.services.flume.summary.multiple").format(count);
    }.property('service.nodes'),

    flumeServerComponent: function () {
      return App.HostComponent.find().findProperty('componentName', 'FLUME_SERVER');
    }.property()

  });
  
});
window.require.register("views/main/dashboard/service/hbase", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');
  var date = require('utils/date');

  App.MainDashboardServiceHbaseView = App.MainDashboardServiceView.extend({
    templateName: require('templates/main/dashboard/service/hbase'),
    serviceName: 'hbase',
    /**
     * All master components
     */
    masters: function () {
      return this.get('service.hostComponents').filterProperty('isMaster', true);
    }.property('service.hostComponents.@each'),
    /**
     * Passive master components
     */
    passiveMasters: function () {
      if(App.supports.multipleHBaseMasters){
        return this.get('masters').filterProperty('haStatus', 'passive');
      }
      return [];
    }.property('masters'),


    liveRegionServes: function () {
      return App.HostComponent.find().filterProperty('componentName', 'HBASE_REGIONSERVER').filterProperty("workStatus","STARTED");
    }.property(),

    regionServesText: function () {
      if(this.get('service.regionServers').get("length") > 1){
        return Em.I18n.t('services.service.summary.viewHosts');
      }else{
        return Em.I18n.t('services.service.summary.viewHost');
      }
    }.property("service"),

    /**
     * Formatted output for passive master components
     */
    passiveMasterOutput: function () {
      return Em.I18n.t('service.hbase.passiveMasters').format(this.get('passiveMasters').length);
    }.property('passiveMasters'),
    /**
     * One(!) active master component
     */
    activeMaster: function () {
      if(App.supports.multipleHBaseMasters){
        return this.get('masters').findProperty('haStatus', 'active');
      } else {
        return this.get('masters')[0];
      }
    }.property('masters'),

    activeMasterTitle: function(){
      if(App.supports.multipleHBaseMasters){
        return this.t('service.hbase.activeMaster');
      } else {
        return this.get('activeMaster.host.publicHostName');
      }
    }.property('activeMaster'),

    masterServerHeapSummary: function () {
      var heapUsed = this.get('service').get('heapMemoryUsed');
      var heapMax = this.get('service').get('heapMemoryMax');
      var percent = heapMax > 0 ? 100 * heapUsed / heapMax : 0;
      var heapString = heapUsed > 0 ? heapUsed.bytesToSize(1, "parseFloat") : 0;
      var heapMaxString = heapMax > 0 ? heapMax.bytesToSize(1, "parseFloat") : 0;
      return this.t('dashboard.services.hbase.masterServerHeap.summary').format(heapString, heapMaxString, percent.toFixed(1));
    }.property('service.heapMemoryUsed', 'service.heapMemoryMax'),

    summaryHeader: function () {
      var avgLoad = this.get('service.averageLoad');
      if (avgLoad == null) {
        avgLoad = this.t("services.service.summary.unknown");
      }
      return this.t("dashboard.services.hbase.summary").format(this.get('service.regionServers.length'), avgLoad);
    }.property('service.regionServers', 'service.averageLoad'),

    hbaseMasterWebUrl: function () {
      if (this.get('activeMaster.host') && this.get('activeMaster.host').get('publicHostName')) {
        return "http://" + (App.singleNodeInstall ? App.singleNodeAlias : this.get('activeMaster.host').get('publicHostName')) + ":60010";
      }
    }.property('activeMaster'),

    averageLoad: function () {
      var avgLoad = this.get('service.averageLoad');
      if (avgLoad == null) {
        avgLoad = this.t('services.service.summary.notAvailable');
      }
      return this.t('dashboard.services.hbase.averageLoadPerServer').format(avgLoad);
    }.property("service.averageLoad"),

    masterStartedTime: function () {
      var uptime = this.get('service').get('masterStartTime');
      if (uptime && uptime > 0) {
        var diff = (new Date()).getTime() - uptime;
        if (diff < 0) {
          diff = 0;
        }
        var formatted = date.timingFormat(diff);
        return this.t('dashboard.services.uptime').format(formatted);
      }
      return this.t('services.service.summary.notRunning');
    }.property("service.masterStartTime"),

    masterActivatedTime: function () {
      var uptime = this.get('service').get('masterActiveTime');
      if (uptime && uptime > 0) {
        var diff = (new Date()).getTime() - uptime;
        if (diff < 0) {
          diff = 0;
        }
        var formatted = date.timingFormat(diff);
        return this.t('dashboard.services.uptime').format(formatted);
      }
      return this.t('services.service.summary.notRunning');
    }.property("service.masterActiveTime"),

    regionServerComponent: function () {
      return App.HostComponent.find().findProperty('componentName', 'HBASE_REGIONSERVER');
    }.property()

  });
});
window.require.register("views/main/dashboard/service/hdfs", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');
  var date = require('utils/date');

  App.MainDashboardServiceHdfsView = App.MainDashboardServiceView.extend({
    templateName: require('templates/main/dashboard/service/hdfs'),
    serviceName: 'HDFS',
    Chart: App.ChartPieView.extend({
      service: null,
      color: '#0066B3',
      stroke: '#0066B3',
      palette: new Rickshaw.Color.Palette({
        scheme: [ 'rgba(0,102,179,0)', 'rgba(0,102,179,1)'].reverse()
      }),
      data: function () {
        var total = this.get('service.capacityTotal') + 0;
        var remaining = (this.get('service.capacityRemaining') + 0);
        var used = total - remaining;
        return [ used, remaining ];
      }.property('service.capacityUsed', 'service.capacityTotal')
    }),

    dataNodesLive: function(){
      return App.HostComponent.find().filterProperty('componentName', 'DATANODE').filterProperty("workStatus","STARTED");
    }.property('service'),

    dataNodeHostText: function () {
      if(this.get("service.dataNodes") > 1){
        return Em.I18n.t('services.service.summary.viewHosts');
      }else{
        return Em.I18n.t('services.service.summary.viewHost');
      }
    }.property("service"),

    dfsTotalBlocks: function(){
      return this.formatUnavailable(this.get('service.dfsTotalBlocks'));
    }.property('service.dfsTotalBlocks'),
    dfsTotalFiles: function(){
      return this.formatUnavailable(this.get('service.dfsTotalFiles'));
    }.property('service.dfsTotalFiles'),
    dfsCorruptBlocks: function(){
      return this.formatUnavailable(this.get('service.dfsCorruptBlocks'));
    }.property('service.dfsCorruptBlocks'),
    dfsMissingBlocks: function(){
      return this.formatUnavailable(this.get('service.dfsMissingBlocks'));
    }.property('service.dfsMissingBlocks'),
    dfsUnderReplicatedBlocks: function(){
      return this.formatUnavailable(this.get('service.dfsUnderReplicatedBlocks'));
    }.property('service.dfsUnderReplicatedBlocks'),

    blockErrorsMessage: function() {
      return Em.I18n.t('dashboard.services.hdfs.blockErrors').format(this.get('dfsCorruptBlocks'), this.get('dfsMissingBlocks'), this.get('dfsUnderReplicatedBlocks'));
    }.property('dfsCorruptBlocks','dfsMissingBlocks','dfsUnderReplicatedBlocks'),

    nodeUptime: function () {
      var uptime = this.get('service').get('nameNodeStartTime');
      if (uptime && uptime > 0){
        var diff = (new Date()).getTime() - uptime;
        if (diff < 0) {
          diff = 0;
        }
        var formatted = date.timingFormat(diff);
        return this.t('dashboard.services.uptime').format(formatted);
      }
      return this.t('services.service.summary.notRunning');
    }.property("service.nameNodeStartTime"),

    nodeWebUrl: function () {
      return "http://" + (App.singleNodeInstall ? App.singleNodeAlias :  this.get('service').get('nameNode').get('publicHostName')) + ":50070";
    }.property('service.nameNode'),

    nodeHeap: function () {
      var memUsed = this.get('service').get('jvmMemoryHeapUsed') * 1000000;
      var memCommitted = this.get('service').get('jvmMemoryHeapCommitted') * 1000000;
      var percent = memCommitted > 0 ? ((100 * memUsed) / memCommitted) : 0;
      return this.t('dashboard.services.hdfs.nodes.heapUsed').format(memUsed.bytesToSize(1, 'parseFloat'), memCommitted.bytesToSize(1, 'parseFloat'), percent.toFixed(1));

    }.property('service.jvmMemoryHeapUsed', 'service.jvmMemoryHeapCommitted'),

    summaryHeader: function () {
      var text = this.t("dashboard.services.hdfs.summary");
      var svc = this.get('service');
      var liveCount = svc.get('liveDataNodes').get('length');
      var totalCount = svc.get('dataNodes').get('length');
      var total = this.get('service.capacityTotal') + 0;
      var remaining = this.get('service.capacityRemaining') + 0;
      var used = total - remaining;
      var percent = total > 0 ? ((used * 100) / total).toFixed(1) : 0;
      if (percent == "NaN" || percent < 0) {
        percent = Em.I18n.t('services.service.summary.notAvailable') + " ";
      }
      return text.format(liveCount, totalCount, percent);
    }.property('service.liveDataNodes', 'service.dataNodes', 'service.capacityUsed', 'service.capacityTotal'),

    capacity: function () {
      var text = this.t("dashboard.services.hdfs.capacityUsed");
      var total = this.get('service.capacityTotal') + 0;
      var remaining = this.get('service.capacityRemaining') + 0;
      var used = total - remaining;
      var percent = total > 0 ? ((used * 100) / total).toFixed(1) : 0;
      if (percent == "NaN" || percent < 0) {
        percent = Em.I18n.t('services.service.summary.notAvailable') + " ";
      }
      if (used < 0) {
        used = 0;
      }
      if (total < 0) {
        total = 0;
      }
      return text.format(used.bytesToSize(1, 'parseFloat'), total.bytesToSize(1, 'parseFloat'), percent);
    }.property('service.capacityUsed', 'service.capacityTotal'),

    dataNodeComponent: function () {
      return App.HostComponent.find().findProperty('componentName', 'DATANODE');
    }.property(),

    isSafeMode: function () {
      var safeMode = this.get('service.safeModeStatus');
      return safeMode != null && safeMode.length > 0;
    }.property('service.safeModeStatus')
  });
});
window.require.register("views/main/dashboard/service/hive", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainDashboardServiceHiveView = App.MainDashboardServiceView.extend({
    templateName: require('templates/main/dashboard/service/hive'),
    serviceName: 'hive',

    titleMasters: function(){
      var masters = this.get('masters');
      return [masters.findProperty('componentName', 'HIVE_SERVER'), masters.findProperty('componentName', 'HIVE_METASTORE')];
    }.property('service')
  });
});
window.require.register("views/main/dashboard/service/mapreduce", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');
  var date = require('utils/date');

  App.MainDashboardServiceMapreduceView = App.MainDashboardServiceView.extend({
    templateName: require('templates/main/dashboard/service/mapreduce'),
    serviceName: 'MAPREDUCE',
    jobTrackerWebUrl: function () {
      return "http://" + (App.singleNodeInstall ? App.singleNodeAlias : this.get('service').get('jobTracker').get('publicHostName')) + ":50030";
    }.property('service.jobTracker'),

    Chart: App.ChartLinearView.extend({
      data: function () {
        return this.get('_parentView.data.chart');
      }.property('_parentView.data.chart')
    }),

    jobTrackerUptime: function () {
      var uptime = this.get('service').get('jobTrackerStartTime');
      if (uptime && uptime > 0){
        var diff = (new Date()).getTime() - uptime;
        if (diff < 0) {
          diff = 0;
        }
        var formatted = date.timingFormat(diff);
        return this.t('dashboard.services.uptime').format(formatted);

      }
      return this.t('services.service.summary.notRunning');
    }.property("service.jobTrackerStartTime"),

    summaryHeader: function () {
      var svc = this.get('service');
      var liveCount = svc.get('aliveTrackers').get('length');
      var allCount = svc.get('taskTrackers').get('length');
      var runningCount = svc.get('mapsRunning') + svc.get('reducesRunning');
      var waitingCount = svc.get('mapsWaiting') + svc.get('reducesWaiting');
      var template = this.t('dashboard.services.mapreduce.summary');
      return template.format(liveCount, allCount, runningCount, waitingCount);
    }.property('service.aliveTrackers', 'service.taskTrackers','service.mapsRunning', 'service.mapsWaiting', 'service.reducesRunning', 'service.reducesWaiting'),

    trackersText: function () {
      if(this.get('service').get('taskTrackers').get('length') > 1){
        return Em.I18n.t('services.service.summary.viewHosts');
      }else{
        return Em.I18n.t('services.service.summary.viewHost');
      }
    }.property("service.taskTrackers.length"),

    trackersSummary: function () {
      var svc = this.get('service');
      var liveCount = App.HostComponent.find().filterProperty('componentName', 'TASKTRACKER').filterProperty("workStatus","STARTED").length;
      var totalCount = svc.get('taskTrackers').get('length');
      var template = this.t('dashboard.services.mapreduce.trackersSummary');
      return template.format(liveCount, totalCount);
    }.property('service.aliveTrackers.length', 'service.taskTrackers.length'),

    trackersHeapSummary: function () {
      var heapUsed = this.get('service').get('jobTrackerHeapUsed') || 0;
      var heapMax = this.get('service').get('jobTrackerHeapMax') || 0;
      var percent = heapMax > 0 ? 100 * heapUsed / heapMax : 0;
      return this.t('dashboard.services.mapreduce.jobTrackerHeapSummary').format(heapUsed.bytesToSize(1, "parseFloat"), heapMax.bytesToSize(1, "parseFloat"), percent.toFixed(1));
    }.property('service.jobTrackerHeapUsed', 'service.jobTrackerHeapMax'),

    jobsSummary: function () {
      var svc = this.get('service');
      var template = this.t('dashboard.services.mapreduce.jobsSummary');
      return template.format(this.formatUnavailable(svc.get('jobsSubmitted')), this.formatUnavailable(svc.get('jobsCompleted')));
    }.property('service.jobsSubmitted', 'service.jobsCompleted'),

    mapSlotsSummary: function () {
      var svc = this.get('service');
      var template = this.t('dashboard.services.mapreduce.mapSlotsSummary');
      return template.format(this.formatUnavailable(svc.get('mapSlotsOccupied')), this.formatUnavailable(svc.get('mapSlotsReserved')));
    }.property('service.mapSlotsOccupied', 'service.mapSlotsReserved'),

    reduceSlotsSummary: function () {
      var svc = this.get('service');
      var template = this.t('dashboard.services.mapreduce.reduceSlotsSummary');
      return template.format(this.formatUnavailable(svc.get('reduceSlotsOccupied')), this.formatUnavailable(svc.get('reduceSlotsReserved')));
    }.property('service.reduceSlotsOccupied', 'service.reduceSlotsReserved'),

    mapTasksSummary: function () {
      var svc = this.get('service');
      var template = this.t('dashboard.services.mapreduce.tasksSummary');
      return template.format(this.formatUnavailable(svc.get('mapsRunning')), this.formatUnavailable(svc.get('mapsWaiting')));
    }.property('service.mapsRunning', 'service.mapsWaiting'),

    reduceTasksSummary: function () {
      var svc = this.get('service');
      var template = this.t('dashboard.services.mapreduce.tasksSummary');
      return template.format(this.formatUnavailable(svc.get('reducesRunning')), this.formatUnavailable(svc.get('reducesWaiting')));
    }.property('service.reducesRunning', 'service.reducesWaiting'),

    slotsCapacitySummary: function () {
      var mapSlots = this.get('service').get('mapSlots');
      var reduceSlots = this.get('service').get('reduceSlots');
      var liveNodeCount = this.get('service').get('aliveTrackers').get('length');
      if(liveNodeCount != 0){
        var avg = (mapSlots + reduceSlots) / liveNodeCount;
      }else{
        avg = Em.I18n.t('services.service.summary.notAvailable') + " ";
      }
      return this.t('dashboard.services.mapreduce.slotCapacitySummary').format(mapSlots, reduceSlots, avg);
    }.property('service.mapSlots', 'service.reduceSlots', 'service.aliveTrackers'),

    taskTrackerComponent: function () {
      return App.HostComponent.find().findProperty('componentName', 'TASKTRACKER');
    }.property()
  });
});
window.require.register("views/main/dashboard/service/mapreduce2", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.MainDashboardServiceMapreduce2View = App.MainDashboardServiceView.extend({
      templateName: require('templates/main/dashboard/service/mapreduce2'),
      serviceName: 'MAPREDUCE2',

      titleInfo: function(){
        var hs = this.get('service.hostComponents').findProperty('componentName', 'HISTORYSERVER');
        if(hs.get('workStatus') === App.HostComponentStatus.started)
          return this.t('services.mapreduce2.history.running');
        return this.t('services.mapreduce2.history.stopped');
      }.property('service')
    });
});
window.require.register("views/main/dashboard/service/oozie", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainDashboardServiceOozieView = App.MainDashboardServiceView.extend({
    serviceName: 'oozie',
    templateName: require('templates/main/dashboard/service/oozie'),

    webUi: function () {
      var hostName = App.singleNodeInstall ? App.singleNodeAlias : this.get('service.hostComponents').findProperty('componentName', 'OOZIE_SERVER').get('host.publicHostName');
      return "http://{0}:11000/oozie".format(hostName);
    }.property('service')
  });
});
window.require.register("views/main/dashboard/service/zookeeper", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainDashboardServiceZookeperView = App.MainDashboardServiceView.extend({
    templateName: require('templates/main/dashboard/service/zookeeper'),
    serviceName: 'zookeeper',

    titleInfo: function(){
      var components = this.get('service.hostComponents').filterProperty('componentName', 'ZOOKEEPER_SERVER');
      var running = 0;
      components.forEach(function(item){
        if(item.get('workStatus') === App.HostComponentStatus.started){
          running += 1;
        }
      });

      return {
        pre: this.t('services.zookeeper.prefix').format(running),
        title: this.t('services.zookeeper.title').format(components.length),
        component: components.objectAt(0)
      };
    }.property('service')
  });
});
window.require.register("views/main/dashboard/widget", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.DashboardWidgetView = Em.View.extend({

    title: null,
    templateName: null, // each has specific template

    model : function () {
      if (this.get('model_type') == 'hdfs') {
        return this.get('parentView').get('hdfs_model');
      } else if (this.get('model_type') == 'mapreduce') {
        return this.get('parentView').get('mapreduce_model');
      } else if (this.get('model_type') == 'hbase') {
        return this.get('parentView').get('hbase_model');
      }
    }.property(''), //data bind from parent view

    id: null, // id 1-10 used to identify
    viewID: function(){ // used by re-sort
      return 'widget-' + this.id;
    }.property('id'),  //html id bind to view-class: widget-(1)
    attributeBindings: ['viewID'],

    isPieChart: false,
    isText: false,
    isProgressBar: false,
    isLinks: false,
    content: null, // widget content pieChart/ text/ progress bar/links/ metrics. etc
    hiddenInfo: null, // more info details
    hiddenInfoClass: "hidden-info",

    thresh1: null, //num not string
    thresh2: null,

    didInsertElement: function () {
      this.$("[rel='ZoomInTooltip']").tooltip({
        placement : 'left'
      });
    },

    deleteWidget: function (event) {
      var parent = this.get('parentView');
      if (App.testMode) {
        //update view on dashboard
        var objClass = parent.widgetsMapper(this.id);
        parent.get('visibleWidgets').removeObject(objClass);
        parent.get('hiddenWidgets').pushObject(Em.Object.create({displayName: this.title, id: this.id, checked: false}));
      } else {
        //reconstruct new persist value then post in persist
        parent.getUserPref(parent.get('persistKey'));
        var oldValue = parent.get('currentPrefObject');
        var deletedId = this.id;
        var newValue = Em.Object.create({
          dashboardVersion: oldValue.dashboardVersion,
          visible: [],
          hidden: oldValue.hidden,
          threshold: oldValue.threshold
        });
        for (var i = 0; i <= oldValue.visible.length - 1; i++) {
          if (oldValue.visible[i] != deletedId) {
            newValue.visible.push(oldValue.visible[i]);
          }
        }
        newValue.hidden.push([deletedId, this.title]);
        parent.postUserPref(parent.get('persistKey'), newValue);
        parent.translateToReal(newValue);
      }
    },

    editWidget: function (event) {
      var self = this;
      var max_tmp =  parseFloat(self.get('maxValue'));
      var configObj = Ember.Object.create({
        thresh1: self.get('thresh1') + '',
        thresh2: self.get('thresh2') + '',
        hintInfo: 'Edit the percentage thresholds to change the color of current pie chart. ' + ' '+
          ' Enter two numbers between 0 to ' + max_tmp,
        isThresh1Error: false,
        isThresh2Error: false,
        errorMessage1: "",
        errorMessage2: "",
        maxValue: max_tmp,
        observeNewThresholdValue: function () {
          var thresh1 = this.get('thresh1');
          var thresh2 = this.get('thresh2');
          if (thresh1.trim() != "") {
            if (isNaN(thresh1) || thresh1 > max_tmp || thresh1 < 0) {
              this.set('isThresh1Error', true);
              this.set('errorMessage1', 'Invalid! Enter a number between 0 - ' + max_tmp);
            } else if (this.get('isThresh2Error') === false && parseFloat(thresh2)<= parseFloat(thresh1)) {
              this.set('isThresh1Error', true);
              this.set('errorMessage1', 'Threshold 1 should be smaller than threshold 2 !');
            } else {
              this.set('isThresh1Error', false);
              this.set('errorMessage1', '');
            }
          } else {
            this.set('isThresh1Error', true);
            this.set('errorMessage1', 'This is required');
          }

          if (thresh2.trim() != "") {
            if (isNaN(thresh2) || thresh2 > max_tmp || thresh2 < 0) {
              this.set('isThresh2Error', true);
              this.set('errorMessage2', 'Invalid! Enter a number between 0 - ' + max_tmp);
            } else {
              this.set('isThresh2Error', false);
              this.set('errorMessage2', '');
            }
          } else {
            this.set('isThresh2Error', true);
            this.set('errorMessage2', 'This is required');
          }

          // update the slider handles and color
          if (this.get('isThresh1Error') === false && this.get('isThresh2Error') === false) {
            $("#slider-range").slider('values', 0 , parseFloat(thresh1));
            $("#slider-range").slider('values', 1 , parseFloat(thresh2));
          }
        }.observes('thresh1', 'thresh2')

      });

      var browserVerion = this.getInternetExplorerVersion();
      App.ModalPopup.show({
        header: 'Customize Widget',
        classNames: [ 'sixty-percent-width-modal-edit-widget' ],
        bodyClass: Ember.View.extend({
          templateName: require('templates/main/dashboard/edit_widget_popup'),
          configPropertyObj: configObj
        }),
        primary: Em.I18n.t('common.apply'),
        onPrimary: function() {
          configObj.observeNewThresholdValue();
          if (!configObj.isThresh1Error && !configObj.isThresh2Error) {
            self.set('thresh1', parseFloat(configObj.get('thresh1')) );
            self.set('thresh2', parseFloat(configObj.get('thresh2')) );

            if (!App.testMode) {
              // save to persist
              var parent = self.get('parentView');
              parent.getUserPref(parent.get('persistKey'));
              var oldValue = parent.get('currentPrefObject');
              oldValue.threshold[parseInt(self.id)] = [configObj.get('thresh1'), configObj.get('thresh2')];
              parent.postUserPref(parent.get('persistKey'), oldValue);
            }

            this.hide();
          }
        },
        secondary : Em.I18n.t('common.cancel'),
        onSecondary: function () {
          this.hide();
        },

        didInsertElement: function () {
          var handlers = [configObj.get('thresh1'), configObj.get('thresh2')];
          var colors = ['#95A800', '#FF8E00', '#B80000']; //color green, orange ,red

          if (browserVerion == -1 || browserVerion > 9) {
            configObj.set('isIE9', false);
            configObj.set('isGreenOrangeRed', true);
            $("#slider-range").slider({
              range: true,
              min: 0,
              max: max_tmp,
              values: handlers,
              create: function (event, ui) {
                updateColors(handlers);
              },
              slide: function (event, ui) {
                updateColors(ui.values);
                configObj.set('thresh1', ui.values[0] + '');
                configObj.set('thresh2', ui.values[1] + '');
              },
              change: function (event, ui) {
                updateColors(ui.values);
              }
            });

            function updateColors (handlers) {
              var colorstops = colors[0] + ", "; // start with the first color
              for (var i = 0; i < handlers.length; i++) {
                colorstops += colors[i] + " " + handlers[i]*100/max_tmp + "%,";
                colorstops += colors[i+1] + " " + handlers[i]*100/max_tmp + "%,";
              }
              colorstops += colors[colors.length - 1];
              var css1 = '-webkit-linear-gradient(left,' + colorstops + ')'; // chrome & safari
              $('#slider-range').css('background-image', css1);
              var css2 = '-ms-linear-gradient(left,' + colorstops + ')'; // IE 10+
              $('#slider-range').css('background-image', css2);
              //$('#slider-range').css('filter', 'progid:DXImageTransform.Microsoft.gradient( startColorStr= ' + colors[0] + ', endColorStr= ' + colors[2] +',  GradientType=1 )' ); // IE 10-
              var css3 = '-moz-linear-gradient(left,' + colorstops + ')'; // Firefox
              $('#slider-range').css('background-image', css3);

              $('#slider-range .ui-widget-header').css({'background-color': '#FF8E00', 'background-image': 'none'}); // change the  original ranger color
            }
          } else {
            configObj.set('isIE9', true);
            configObj.set('isGreenOrangeRed', true);
          }
        }
      });
    },

    getInternetExplorerVersion: function (){
      var rv = -1; //return -1 for other browsers
      if (navigator.appName == 'Microsoft Internet Explorer') {
        var ua = navigator.userAgent;
        var re  = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
        if (re.exec(ua) != null)
          rv = parseFloat( RegExp.$1 ); // IE version 1-10
      }
      var isFirefox = typeof InstallTrigger !== 'undefined';   // Firefox 1.0+
      if (isFirefox) {
        return -2;
      }else{
        return rv;
      }
    },

    /**
     * for simple-text template,
     * calculate the hover content top number
     * based on how long the hiddenInfo is
     */
    hoverContentTopClass: function () {
      var lineNum = this.get('hiddenInfo.length');
      if (lineNum == 2) {
        return "simple-text-hidden-two-line";
      } else if (lineNum == 3) {
        return "simple-text-hidden-three-line";
      } else {
        return "";
      }
    }.property('this.hiddenInfo.length')

  });


  
});
window.require.register("views/main/dashboard/widgets/datanode_live", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.DataNodeUpView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/simple_text'),
    title: Em.I18n.t('dashboard.widgets.DataNodeUp'),
    id: '4',

    isPieChart: false,
    isText: true,
    isProgressBar: false,
    model_type: 'hdfs',

    hiddenInfo: function () {
      var result = [];
      result.pushObject(this.get('model.liveDataNodes.length') + ' ' + this.t('dashboard.services.hdfs.nodes.live'));
      result.pushObject(this.get('model.deadDataNodes.length') + ' ' + this.t('dashboard.services.hdfs.nodes.dead'));
      result.pushObject(this.get('model.decommissionDataNodes.length')+ ' ' + this.t('dashboard.services.hdfs.nodes.decom'));
      return result;
    }.property('model.liveDataNodes.length','model.deadDataNodes.length','model.decommissionDataNodes.length'),
    hiddenInfoClass: "hidden-info-three-line",

    classNameBindings: ['isRed', 'isOrange', 'isGreen'],
    isRed: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return this.get('data') <= thresh1? true: false;
    }.property('data','thresh1','thresh2'),
    isOrange: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return (this.get('data') <= thresh2 && this.get('data') > thresh1 )? true: false;
    }.property('data','thresh1','thresh2'),
    isGreen: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return this.get('data') > thresh2? true: false;
    }.property('data','thresh1','thresh2'),

    thresh1: 40,
    thresh2: 70,
    maxValue: 100,

    data: function () {
      return ((this.get('model.liveDataNodes.length')/ this.get('model.dataNodes.length')).toFixed(2)) * 100;
    }.property('model.dataNodes.length', 'model.liveDataNodes.length'),

    content: function () {
      return this.get('model.liveDataNodes.length') + "/" + this.get('model.dataNodes.length');
    }.property('model.dataNodes.length', 'model.liveDataNodes.length'),

    editWidget: function (event) {
      var parent = this;
      var max_tmp =  parseFloat(parent.get('maxValue'));
      var configObj = Ember.Object.create({
        thresh1: parent.get('thresh1') + '',
        thresh2: parent.get('thresh2') + '',
        hintInfo: 'Edit the percentage of thresholds to change the color of current widget. ' +
          ' Assume all data nodes UP is 100, and all DOWN is 0. '+
          ' So enter two numbers between 0 to ' + max_tmp,
        isThresh1Error: false,
        isThresh2Error: false,
        errorMessage1: "",
        errorMessage2: "",
        maxValue: max_tmp,
        observeNewThresholdValue: function () {
          var thresh1 = this.get('thresh1');
          var thresh2 = this.get('thresh2');
          if (thresh1.trim() != "") {
            if (isNaN(thresh1) || thresh1 > max_tmp || thresh1 < 0){
              this.set('isThresh1Error', true);
              this.set('errorMessage1', 'Invalid! Enter a number between 0 - ' + max_tmp);
            } else if ( this.get('isThresh2Error') === false && parseFloat(thresh2)<= parseFloat(thresh1)) {
              this.set('isThresh1Error', true);
              this.set('errorMessage1', 'Threshold 1 should be smaller than threshold 2 !');
            } else {
              this.set('isThresh1Error', false);
              this.set('errorMessage1', '');
            }
          } else {
            this.set('isThresh1Error', true);
            this.set('errorMessage1', 'This is required');
          }

          if (thresh2.trim() != "") {
            if (isNaN(thresh2) || thresh2 > max_tmp || thresh2 < 0) {
              this.set('isThresh2Error', true);
              this.set('errorMessage2', 'Invalid! Enter a number between 0 - ' + max_tmp);
            } else {
              this.set('isThresh2Error', false);
              this.set('errorMessage2', '');
            }
          } else {
            this.set('isThresh2Error', true);
            this.set('errorMessage2', 'This is required');
          }

          // update the slider handles and color
          if (this.get('isThresh1Error') === false && this.get('isThresh2Error') === false) {
            $("#slider-range").slider('values', 0 , parseFloat(thresh1));
            $("#slider-range").slider('values', 1 , parseFloat(thresh2));
          }
        }.observes('thresh1', 'thresh2')

      });

      var browserVerion = this.getInternetExplorerVersion();
      App.ModalPopup.show({
        header: 'Customize Widget',
        classNames: [ 'sixty-percent-width-modal-edit-widget'],
        bodyClass: Ember.View.extend({
          templateName: require('templates/main/dashboard/edit_widget_popup'),
          configPropertyObj: configObj
        }),
        primary: Em.I18n.t('common.apply'),
        onPrimary: function () {
          configObj.observeNewThresholdValue();
          if (!configObj.isThresh1Error && !configObj.isThresh2Error) {
            parent.set('thresh1', parseFloat(configObj.get('thresh1')) );
            parent.set('thresh2', parseFloat(configObj.get('thresh2')) );
            if (!App.testMode) {
              var big_parent = parent.get('parentView');
              big_parent.getUserPref(big_parent.get('persistKey'));
              var oldValue = big_parent.get('currentPrefObject');
              oldValue.threshold[parseInt(parent.id)] = [configObj.get('thresh1'), configObj.get('thresh2')];
              big_parent.postUserPref(big_parent.get('persistKey'),oldValue);
            }
            this.hide();
          }
        },
        secondary : Em.I18n.t('common.cancel'),
        onSecondary: function () {
          this.hide();
        },

        didInsertElement: function () {
          var handlers = [configObj.get('thresh1'), configObj.get('thresh2')];
          var colors = ['#B80000', '#FF8E00', '#95A800']; //color red, orange, green

          if (browserVerion == -1 || browserVerion > 9) {
            configObj.set('isIE9', false);
            configObj.set('isGreenOrangeRed', false);
            $("#slider-range").slider({
              range: true,
              min: 0,
              max: max_tmp,
              values: handlers,
              create: function (event, ui) {
                updateColors(handlers);
              },
              slide: function (event, ui) {
                updateColors(ui.values);
                configObj.set('thresh1', ui.values[0] + '');
                configObj.set('thresh2', ui.values[1] + '');
              },
              change: function (event, ui) {
                updateColors(ui.values);
              }
            });

            function updateColors(handlers) {
              var colorstops = colors[0] + ", "; // start with the first color
              for (var i = 0; i < handlers.length; i++) {
                colorstops += colors[i] + " " + handlers[i] + "%,";
                colorstops += colors[i+1] + " " + handlers[i] + "%,";
              }
              // end with the last color
              colorstops += colors[colors.length - 1];
              var css1 = '-webkit-linear-gradient(left,' + colorstops + ')'; // chrome & safari
              $('#slider-range').css('background-image', css1);
              var css2 = '-ms-linear-gradient(left,' + colorstops + ')'; // IE 10+
              $('#slider-range').css('background-image', css2);
              //$('#slider-range').css('filter', 'progid:DXImageTransform.Microsoft.gradient( startColorStr= ' + colors[0] + ', endColorStr= ' + colors[2] +',  GradientType=1 )' ); // IE 10-
              var css3 = '-moz-linear-gradient(left,' + colorstops + ')'; // Firefox
              $('#slider-range').css('background-image', css3);

              $('#slider-range .ui-widget-header').css({'background-color': '#FF8E00', 'background-image': 'none'}); // change the  original ranger color
            }
          } else {
            configObj.set('isIE9', true);
            configObj.set('isGreenOrangeRed', false);
          }
        }
      });
    }

  })
  
});
window.require.register("views/main/dashboard/widgets/hbase_average_load", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.HBaseAverageLoadView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/simple_text'),
    title: Em.I18n.t('dashboard.widgets.HBaseAverageLoad'),
    id: '21',

    isPieChart: false,
    isText: true,
    isProgressBar: false,
    model_type: 'hbase',
    hiddenInfo: function () {
      var avgLoad = this.get('model.averageLoad');
      if (avgLoad == null) {
        avgLoad = this.t('services.service.summary.notAvailable');
      }
      var result = [];
      result.pushObject(this.t('dashboard.services.hbase.averageLoadPerServer').format(avgLoad));
      return result;
    }.property("model.averageLoad"),

    classNameBindings: ['isRed', 'isOrange', 'isGreen', 'isNA'],
    isGreen: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return this.get('data') <= thresh1? true: false;
    }.property('data','thresh1','thresh2'),
    isOrange: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return (this.get('data') <= thresh2 && this.get('data') > thresh1 )? true: false;
    }.property('data','thresh1','thresh2'),
    isRed: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return this.get('data') > thresh2? true: false;
    }.property('data','thresh1','thresh2'),
    isNA: function (){
      return this.get('data') === null;
    }.property('data'),

    thresh1: 0.5,
    thresh2: 2,
    maxValue: 'infinity',

    data: function () {
      return this.get('model.averageLoad');
    }.property("model.averageLoad"),

    content: function (){
      if(this.get('data') || this.get('data') == 0){
        return this.get('data') + "";
      }else{
        return this.t('services.service.summary.notAvailable');
      }
    }.property('model.averageLoad'),

    editWidget: function (event) {
      var parent = this;
      var configObj = Ember.Object.create({
        thresh1: parent.get('thresh1') + '',
        thresh2: parent.get('thresh2') + '',
        hintInfo: 'Edit the thresholds to change the color of current widget. ' +

          ' So enter two numbers larger than 0. ',
        isThresh1Error: false,
        isThresh2Error: false,
        errorMessage1: "",
        errorMessage2: "",
        maxValue: 'infinity',
        observeNewThresholdValue: function () {
          var thresh1 = this.get('thresh1');
          var thresh2 = this.get('thresh2');
          if (thresh1.trim() != "") {
            if (isNaN(thresh1) || thresh1 < 0) {
              this.set('isThresh1Error', true);
              this.set('errorMessage1', 'Invalid! Enter a number larger than 0');
            } else if ( this.get('isThresh2Error') === false && parseFloat(thresh2)<= parseFloat(thresh1)){
              this.set('isThresh1Error', true);
              this.set('errorMessage1', 'Threshold 1 should be smaller than threshold 2 !');
            } else {
              this.set('isThresh1Error', false);
              this.set('errorMessage1', '');
            }
          } else {
            this.set('isThresh1Error', true);
            this.set('errorMessage1', 'This is required');
          }

          if (thresh2.trim() != "") {
            if (isNaN(thresh2) || thresh2 < 0) {
              this.set('isThresh2Error', true);
              this.set('errorMessage2', 'Invalid! Enter a number larger than 0');
            } else {
              this.set('isThresh2Error', false);
              this.set('errorMessage2', '');
            }
          } else {
            this.set('isThresh2Error', true);
            this.set('errorMessage2', 'This is required');
          }

        }.observes('thresh1', 'thresh2')

      });

      var browserVerion = this.getInternetExplorerVersion();
      App.ModalPopup.show( {
        header: 'Customize Widget',
        classNames: [ 'sixty-percent-width-modal-edit-widget'],
        bodyClass: Ember.View.extend({
          templateName: require('templates/main/dashboard/edit_widget_popup'),
          configPropertyObj: configObj
        }),
        primary: Em.I18n.t('common.apply'),
        onPrimary: function () {
          configObj.observeNewThresholdValue();
          if (!configObj.isThresh1Error && !configObj.isThresh2Error) {
            parent.set('thresh1', parseFloat(configObj.get('thresh1')) );
            parent.set('thresh2', parseFloat(configObj.get('thresh2')) );
            if (!App.testMode) {
              //save to persist
              var big_parent = parent.get('parentView');
              big_parent.getUserPref(big_parent.get('persistKey'));
              var oldValue = big_parent.get('currentPrefObject');
              oldValue.threshold[parseInt(parent.id)] = [configObj.get('thresh1'), configObj.get('thresh2')];
              big_parent.postUserPref(big_parent.get('persistKey'),oldValue);
            }

            this.hide();
          }
        },
        secondary : Em.I18n.t('common.cancel'),
        onSecondary: function() {
          this.hide();
        },

        didInsertElement: function () {
          var colors = ['#95A800', '#FF8E00', '#B80000']; //color green, orange ,red
          var handlers = [33, 66]; //fixed value

          if (browserVerion == -1 || browserVerion > 9) {
            configObj.set('isIE9', false);
            configObj.set('isGreenOrangeRed', true);
            $("#slider-range").slider({
              range:true,
              disabled:true, //handlers cannot move
              min: 0,
              max: 100,
              values: handlers,
              create: function (event, ui) {
                updateColors(handlers);
              }
            });

            function updateColors(handlers) {
              var colorstops = colors[0] + ", "; // start with the first color
              for (var i = 0; i < handlers.length; i++) {
                colorstops += colors[i] + " " + handlers[i] + "%,";
                colorstops += colors[i+1] + " " + handlers[i] + "%,";
              }
              // end with the last color
              colorstops += colors[colors.length - 1];
              var css1 = '-webkit-linear-gradient(left,' + colorstops + ')'; // chrome & safari
              $('#slider-range').css('background-image', css1);
              var css2 = '-ms-linear-gradient(left,' + colorstops + ')'; // IE 10+
              $('#slider-range').css('background-image', css2);
              //$('#slider-range').css('filter', 'progid:DXImageTransform.Microsoft.gradient( startColorStr= ' + colors[0] + ', endColorStr= ' + colors[2] +',  GradientType=1 )' ); // IE 10-
              var css3 = '-moz-linear-gradient(left,' + colorstops + ')'; // Firefox
              $('#slider-range').css('background-image', css3);

              $('#slider-range .ui-widget-header').css({'background-color': '#FF8E00', 'background-image': 'none'}); // change the  original ranger color
            }
          } else {
            configObj.set('isIE9', true);
            configObj.set('isGreenOrangeRed', true);
          }
        }
      });
    }

  })
  
});
window.require.register("views/main/dashboard/widgets/hbase_links", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.HBaseLinksView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/hbase_links'),
    title: Em.I18n.t('dashboard.widgets.HBaseLinks'),
    id: '19',

    isPieChart: false,
    isText: false,
    isProgressBar: false,
    isLinks: true,
    model_type: 'hbase',

    /**
     * All master components
     */
    masters: function () {
      return this.get('model.hostComponents').filterProperty('isMaster', true);
    }.property('model.hostComponents.@each'),
    /**
     * Passive master components
     */
    passiveMasters: function () {
      if (App.supports.multipleHBaseMasters) {
        return this.get('masters').filterProperty('haStatus', 'passive');
      }
      return [];
    }.property('masters'),
    /**
     * Formatted output for passive master components
     */
    passiveMasterOutput: function () {
      return Em.I18n.t('service.hbase.passiveMasters').format(this.get('passiveMasters').length);
    }.property('passiveMasters'),
    /**
     * One(!) active master component
     */
    activeMaster: function () {
      if(App.supports.multipleHBaseMasters) {
        return this.get('masters').findProperty('haStatus', 'active');
      } else {
        return this.get('masters')[0];
      }
    }.property('masters'),

    activeMasterTitle: function(){
      if (App.supports.multipleHBaseMasters) {
        return this.t('service.hbase.activeMaster');
      } else {
        return this.get('activeMaster.host.publicHostName');
      }
    }.property('activeMaster'),

    regionServerComponent: function () {
      return App.HostComponent.find().findProperty('componentName', 'HBASE_REGIONSERVER');
    }.property(),

    hbaseMasterWebUrl: function () {
      if (this.get('activeMaster.host') && this.get('activeMaster.host').get('publicHostName')) {
        return "http://" + this.get('activeMaster.host').get('publicHostName') + ":60010";
      }
    }.property('activeMaster')

  })

  App.HBaseLinksView.reopenClass({
    isLinks: true
  })
  
});
window.require.register("views/main/dashboard/widgets/hbase_master_heap", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.HBaseMasterHeapPieChartView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/pie_chart'),
    title: Em.I18n.t('dashboard.widgets.HBaseMasterHeap'),
    id: '20',

    isPieChart: true,
    isText: false,
    isProgressBar: false,
    model_type: 'hbase',

    hiddenInfo: function () {
      var heapUsed = this.get('model').get('heapMemoryUsed') || 0;
      var heapMax = this.get('model').get('heapMemoryMax') || 0;
      var percent = heapMax > 0 ? 100 * heapUsed / heapMax : 0;
      var result = [];
      result.pushObject(percent.toFixed(1) + '% used');
      result.pushObject(heapUsed.bytesToSize(1, "parseFloat") + ' of ' + heapMax.bytesToSize(1, "parseFloat"));
      return result;
    }.property('model.heapMemoryUsed', 'model.heapMemoryMax'),

    thresh1: null,
    thresh2: null,
    maxValue: 100,

    isPieExist: function () {
      var total = this.get('model.heapMemoryMax') * 1000000;
      return total > 0 ;
    }.property('model.heapMemoryMax'),

    content: App.ChartPieView.extend({

      model: null,  //data bind here
      id: 'widget-hbase-heap', // html id
      stroke: '#D6DDDF', //light grey
      thresh1: null, //bind from parent
      thresh2: null,
      innerR: 25,

      existCenterText: true,
      centerTextColor: function () {
        return this.get('contentColor');
      }.property('contentColor'),

      palette: new Rickshaw.Color.Palette({
        scheme: [ '#FFFFFF', '#D6DDDF'].reverse()
      }),

      data: function () {
        var heapUsed = this.get('model').get('heapMemoryUsed');
        var heapMax = this.get('model').get('heapMemoryMax');
        var percent = heapMax > 0 ? (100 * heapUsed / heapMax).toFixed() : 0;
        return [percent, 100-percent];
      }.property('model.heapMemoryUsed', 'model.heapMemoryMax'),

      contentColor: function () {
        var used = parseFloat(this.get('data')[0]);
        var thresh1 = parseFloat(this.get('thresh1'));
        var thresh2 = parseFloat(this.get('thresh2'));
        var color_green = '#95A800';
        var color_red = '#B80000';
        var color_orange = '#FF8E00';
        if (used <= thresh1) {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_green  ].reverse()
          }))
          return color_green;
        } else if (used <= thresh2) {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_orange  ].reverse()
          }))
          return color_orange;
        } else {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_red  ].reverse()
          }))
          return color_red;
        }
      }.property('data', 'this.thresh1', 'this.thresh2'),

      // refresh text and color when data in model changed
      refreshSvg: function () {
        // remove old svg
        var old_svg =  $("#" + this.id);
        if(old_svg){
          old_svg.remove();
        }
        // draw new svg
        this.appendSvg();
      }.observes('this.data', 'this.thresh1', 'this.thresh2')

    })

  })


  
});
window.require.register("views/main/dashboard/widgets/hbase_master_uptime", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var date = require('utils/date');

  App.HBaseMasterUptimeView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/uptime'),
    title: Em.I18n.t('dashboard.widgets.HBaseMasterUptime'),
    id: '23',

    isPieChart: false,
    isText: true,
    isProgressBar: false,
    model_type: 'hbase',
    hiddenInfo: [],
    hiddenInfoClass: "hidden-info-three-line",

    classNameBindings: ['isRed', 'isOrange', 'isGreen', 'isNA'],
    isGreen: function () {
      return this.get('data') != null;
    }.property('data'),
    isOrange: function () {
      return false;
    }.property('data'),
    isRed: function () {
      return false;
    }.property('data'),
    isNA: function () {
      return this.get('data') == null;
    }.property('data'),

    thresh1: 5,
    thresh2: 10,
    maxValue: 'infinity',

    data: function () {
      var uptime = this.get('model.masterStartTime');
      if (uptime && uptime > 0) {
        var uptimeString = this.timeConverter(uptime);
        var diff = (new Date()).getTime() - uptime;
        if (diff < 0) {
          diff = 0;
        }
        var formatted = date.timingFormat(diff); //17.67 days
        var timeUnit = null;
        switch (formatted.split(" ")[1]) {
          case 'secs':
            timeUnit = '秒';
            break;
          case 'hours':
            timeUnit = '小时';
            break;
          case 'days':
            timeUnit = '天';
            break;
          case 'mins':
            timeUnit = '分';
            break;
          default:
            timeUnit = formatted.split(" ")[1];
        }
        this.set('timeUnit', timeUnit);
        this.set('hiddenInfo', []);
        this.get('hiddenInfo').pushObject(formatted);
        this.get('hiddenInfo').pushObject(uptimeString[0]);
        this.get('hiddenInfo').pushObject(uptimeString[1]);
        return parseFloat(formatted.split(" ")[0]);
      }
      this.set('hiddenInfo', []);
      this.set('hiddenInfo', ['Hbase Master','没有运行']);
      return null;
    }.property('model.masterStartTime'),

    timeUnit: null,

    content: function () {
      var data = this.get('data');
      if (data) {
        return data.toFixed(1) + ' '+ this.get('timeUnit');
      } else {
        return this.t('services.service.summary.notAvailable');
      }
    }.property('model.masterStartTime'),

    timeConverter: function (timestamp){
      var origin = new Date(timestamp);
      origin = origin.toString();
      var result = [];
      var start = origin.indexOf('GMT');
      if (start == -1) { // ie
        var arr = origin.split(" ");
        result.pushObject(arr[0] + " " + arr[1] + " " + arr[2] + " " + arr[3]);
        var second = '';
        for (var i = 4; i < arr.length; i++) {
          second = second + " " + arr[i];
        }
        result.pushObject(second);
      } else { // other browsers
        var end = origin.indexOf(" ", start);
        result.pushObject(origin.slice(0, start-10));
        result.pushObject(origin.slice(start-9));
      }
      return result;
    }

  })
  
});
window.require.register("views/main/dashboard/widgets/hbase_regions_in_transition", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.HBaseRegionsInTransitionView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/simple_text'),
    title: Em.I18n.t('dashboard.widgets.HBaseRegionsInTransition'),
    id: '22',

    isPieChart: false,
    isText: true,
    isProgressBar: false,
    model_type: 'hbase',
    hiddenInfo: function () {
      var result = [];
      result.pushObject(this.get("model.regionsInTransition") + " regions");
      result.pushObject("in transition");
      return result;
    }.property("model.regionsInTransition"),

    classNameBindings: ['isRed', 'isOrange', 'isGreen', 'isNA'],
    isGreen: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return this.get('data') <= thresh1? true: false;
    }.property('data','thresh1','thresh2'),
    isOrange: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return (this.get('data') <= thresh2 && this.get('data') > thresh1 )? true: false;
    }.property('data','thresh1','thresh2'),
    isRed: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return this.get('data') > thresh2? true: false;
    }.property('data','thresh1','thresh2'),
    isNA: function () {
      return this.get('data') === null;
    }.property('data'),

    thresh1: 0.5,
    thresh2: 2,
    maxValue: 'infinity',

    data: function () {
      return this.get('model.regionsInTransition');
    }.property("model.regionsInTransition"),

    content: function (){
      return this.get('data') + "";
    }.property('model.regionsInTransition'),

    editWidget: function (event) {
      var parent = this;
      var configObj = Ember.Object.create({
        thresh1: parent.get('thresh1') + '',
        thresh2: parent.get('thresh2') + '',
        hintInfo: 'Edit the thresholds to change the color of current widget. ' +

          ' So enter two numbers larger than 0. ',
        isThresh1Error: false,
        isThresh2Error: false,
        errorMessage1: "",
        errorMessage2: "",
        maxValue: 'infinity',
        observeNewThresholdValue: function () {
          var thresh1 = this.get('thresh1');
          var thresh2 = this.get('thresh2');
          if (thresh1.trim() != "") {
            if (isNaN(thresh1) || thresh1 < 0) {
              this.set('isThresh1Error', true);
              this.set('errorMessage1', 'Invalid! Enter a number larger than 0');
            } else if ( this.get('isThresh2Error') === false && parseFloat(thresh2)<= parseFloat(thresh1)){
              this.set('isThresh1Error', true);
              this.set('errorMessage1', 'Threshold 1 should be smaller than threshold 2 !');
            } else {
              this.set('isThresh1Error', false);
              this.set('errorMessage1', '');
            }
          } else {
            this.set('isThresh1Error', true);
            this.set('errorMessage1', 'This is required');
          }

          if (thresh2.trim() != "") {
            if (isNaN(thresh2) || thresh2 < 0) {
              this.set('isThresh2Error', true);
              this.set('errorMessage2', 'Invalid! Enter a number larger than 0');
            } else {
              this.set('isThresh2Error', false);
              this.set('errorMessage2', '');
            }
          } else {
            this.set('isThresh2Error', true);
            this.set('errorMessage2', 'This is required');
          }
        }.observes('thresh1', 'thresh2')

      });

      var browserVerion = this.getInternetExplorerVersion();
      App.ModalPopup.show({
        header: 'Customize Widget',
        classNames: [ 'sixty-percent-width-modal-edit-widget'],
        bodyClass: Ember.View.extend({
          templateName: require('templates/main/dashboard/edit_widget_popup'),
          configPropertyObj: configObj
        }),
        primary: Em.I18n.t('common.apply'),
        onPrimary: function () {
          configObj.observeNewThresholdValue();
          if (!configObj.isThresh1Error && !configObj.isThresh2Error) {
            parent.set('thresh1', parseFloat(configObj.get('thresh1')) );
            parent.set('thresh2', parseFloat(configObj.get('thresh2')) );
            if (!App.testMode) {
              //save to persist
              var big_parent = parent.get('parentView');
              big_parent.getUserPref(big_parent.get('persistKey'));
              var oldValue = big_parent.get('currentPrefObject');
              oldValue.threshold[parseInt(parent.id)] = [configObj.get('thresh1'), configObj.get('thresh2')];
              big_parent.postUserPref(big_parent.get('persistKey'),oldValue);
            }

            this.hide();
          }
        },
        secondary : Em.I18n.t('common.cancel'),
        onSecondary: function () {
          this.hide();
        },

        didInsertElement: function () {
          var colors = ['#95A800', '#FF8E00', '#B80000']; //color green, orange ,red
          var handlers = [33, 66]; //fixed value

          if (browserVerion == -1 || browserVerion > 9) {
            configObj.set('isIE9', false);
            configObj.set('isGreenOrangeRed', true);
            $("#slider-range").slider({
              range:true,
              disabled:true, //handlers cannot move
              min: 0,
              max: 100,
              values: handlers,
              create: function (event, ui) {
                updateColors(handlers);
              }
            });

            function updateColors (handlers) {
              var colorstops = colors[0] + ", "; // start with the first color
              for (var i = 0; i < handlers.length; i++) {
                colorstops += colors[i] + " " + handlers[i] + "%,";
                colorstops += colors[i+1] + " " + handlers[i] + "%,";
              }
              // end with the last color
              colorstops += colors[colors.length - 1];
              var css1 = '-webkit-linear-gradient(left,' + colorstops + ')'; // chrome & safari
              $('#slider-range').css('background-image', css1);
              var css2 = '-ms-linear-gradient(left,' + colorstops + ')'; // IE 10+
              $('#slider-range').css('background-image', css2);
              //$('#slider-range').css('filter', 'progid:DXImageTransform.Microsoft.gradient( startColorStr= ' + colors[0] + ', endColorStr= ' + colors[2] +',  GradientType=1 )' ); // IE 10-
              var css3 = '-moz-linear-gradient(left,' + colorstops + ')'; // Firefox
              $('#slider-range').css('background-image', css3);

              $('#slider-range .ui-widget-header').css({'background-color': '#FF8E00', 'background-image': 'none'}); // change the  original ranger color
            }
          } else {
            configObj.set('isIE9', true);
            configObj.set('isGreenOrangeRed', true);
          }
        }
      });
    }

  })
  
});
window.require.register("views/main/dashboard/widgets/hdfs_capacity", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.NameNodeCapacityPieChartView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/pie_chart'),
    title: Em.I18n.t('dashboard.widgets.NameNodeCapacity'),
    id: '2',

    isPieChart: true,
    isText: false,
    isProgressBar: false,
    model_type: 'hdfs',

    hiddenInfo: function () {
      var text = this.t("dashboard.services.hdfs.capacityUsed");
      var total = this.get('model.capacityTotal') + 0;
      var remaining = this.get('model.capacityRemaining') + 0;
      var used = total - remaining;
      var percent = total > 0 ? ((used * 100) / total).toFixed(1) : 0;
      if (percent == "NaN" || percent < 0) {
        percent = Em.I18n.t('services.service.summary.notAvailable') + " ";
      }
      if (used < 0) {
        used = 0;
      }
      if (total < 0) {
        total = 0;
      }
      var result = [];
      result.pushObject(percent + '% used');
      result.pushObject(used.bytesToSize(1, 'parseFloat') + ' of ' + total.bytesToSize(1, 'parseFloat'));
      return result;
    }.property('model.capacityUsed', 'model.capacityTotal'),

    thresh1: 40,// can be customized
    thresh2: 70,
    maxValue: 100,

    isPieExist: function () {
      var total = this.get('model.capacityTotal') + 0;
      return total > 0 ;
    }.property('model.capacityTotal'),

    content: App.ChartPieView.extend({

      model: null,  //data bind here
      id: 'widget-nn-capacity', // html id
      stroke: '#D6DDDF', //light grey
      thresh1: null,  // can be customized later
      thresh2: null,
      innerR: 25,

      existCenterText: true,
      centerTextColor: function () {
        return this.get('contentColor');
      }.property('contentColor'),

      palette: new Rickshaw.Color.Palette({
        scheme: [ '#FFFFFF', '#D6DDDF'].reverse()
      }),

      data: function () {
        var total = this.get('model.capacityTotal') + 0;
        var remaining = this.get('model.capacityRemaining') + 0;
        var used = total - remaining;
        var percent = total > 0 ? ((used * 100) / total).toFixed() : 0;
        if (percent == "NaN" || percent < 0) {
          percent = Em.I18n.t('services.service.summary.notAvailable') + " ";
        }
        return [ percent, 100 - percent];
      }.property('model.capacityUsed', 'model.capacityTotal'),

      contentColor: function () {
        var used = parseFloat(this.get('data')[0]);
        var thresh1 = parseFloat(this.get('thresh1'));
        var thresh2 = parseFloat(this.get('thresh2'));
        var color_green = '#95A800';
        var color_red = '#B80000';
        var color_orange = '#FF8E00';
        if (used <= thresh1) {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_green  ].reverse()
          }))
          return color_green;
        } else if (used <= thresh2) {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_orange  ].reverse()
          }))
          return color_orange;
        } else {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_red  ].reverse()
          }))
          return color_red;
        }
      }.property('data', 'this.thresh1', 'this.thresh2'),

      // refresh text and color when data in model changed
      refreshSvg: function () {
        // remove old svg
        var old_svg =  $("#" + this.id);
        old_svg.remove();

        // draw new svg
        this.appendSvg();
      }.observes('this.data', 'this.thresh1', 'this.thresh2')
    })

  })
  
});
window.require.register("views/main/dashboard/widgets/hdfs_links", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.HDFSLinksView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/hdfs_links'),
    title: Em.I18n.t('dashboard.widgets.HDFSLinks'),
    id: '17',

    isPieChart: false,
    isText: false,
    isProgressBar: false,
    isLinks: true,
    model_type: 'hdfs',

    dataNodeComponent: function () {
      return App.HostComponent.find().findProperty('componentName', 'DATANODE');
    }.property(),

    nodeWebUrl: function () {
      return "http://" + this.get('model').get('nameNode').get('publicHostName') + ":50070";
    }.property('model.nameNode')

  })

  App.HDFSLinksView. reopenClass({
    isLinks: true
  })
  
});
window.require.register("views/main/dashboard/widgets/jobtracker_cpu", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.JobTrackerCpuPieChartView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/pie_chart'),
    title: Em.I18n.t('dashboard.widgets.JobTrackerCpu'),
    id: '7',

    isPieChart: true,
    isText: false,
    isProgressBar: false,
    model_type: 'mapreduce',
    hiddenInfo: function () {
      var value = this.get('model.jobTrackerCpu');
      var obj1;
      if( value == null) {
        obj1 = Em.I18n.t('services.service.summary.notAvailable');
      }else{
        value = value >= 100 ? 100: value;
        obj1 = (value + 0).toFixed(2) + '%';
      }
      var result = [];
      result.pushObject(obj1);
      result.pushObject('CPU wait I/O');
      return result;
    }.property('model.jobTrackerCpu'),

    thresh1: 40,// can be customized
    thresh2: 70,
    maxValue: 100,

    isPieExist: function () {
      var total = this.get('model.jobTrackerCpu');
      return total !== null ;
    }.property('model.jobTrackerCpu'),

    content: App.ChartPieView.extend({

      model: null,  //data bind here
      id: 'widget-jt-cpu', // html id
      stroke: '#D6DDDF', //light grey
      thresh1: 50,  // can be customized later
      thresh2: 80,
      innerR: 25,

      existCenterText: true,
      centerTextColor: function () {
        return this.get('contentColor');
      }.property('contentColor'),

      palette: new Rickshaw.Color.Palette({
        scheme: [ '#FFFFFF', '#D6DDDF'].reverse()
      }),

      data: function () {
        var value = this.get('model.jobTrackerCpu');
        value = value >= 100 ? 100: value;
        var percent = (value + 0).toFixed(1);
        return [ percent, 100 - percent];
      }.property('model.jobTrackerCpu'),

      contentColor: function () {
        var used = parseFloat(this.get('data')[0]);
        var thresh1 = parseFloat(this.get('thresh1'));
        var thresh2 = parseFloat(this.get('thresh2'));
        var color_green = '#95A800';
        var color_red = '#B80000';
        var color_orange = '#FF8E00';
        if (used <= thresh1) {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_green  ].reverse()
          }))
          return color_green;
        } else if (used <= thresh2) {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_orange  ].reverse()
          }))
          return color_orange;
        } else {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_red  ].reverse()
          }))
          return color_red;
        }
      }.property('data', 'thresh1', 'thresh2'),

      // refresh text and color when data in model changed
      refreshSvg: function () {
        // remove old svg
        var old_svg =  $("#" + this.id);
        old_svg.remove();

        // draw new svg
        this.appendSvg();
      }.observes('model.jobTrackerCpu', 'thresh1', 'thresh2')
    })

  })
  
});
window.require.register("views/main/dashboard/widgets/jobtracker_heap", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.JobTrackerHeapPieChartView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/pie_chart'),
    title: Em.I18n.t('dashboard.widgets.JobTrackerHeap'),
    id: '6',

    isPieChart: true,
    isText: false,
    isProgressBar: false,
    model_type: 'mapreduce',

    hiddenInfo: function () {
      var heapUsed = this.get('model').get('jobTrackerHeapUsed') || 0;
      var heapMax = this.get('model').get('jobTrackerHeapMax') || 0;
      var percent = heapMax > 0 ? 100 * heapUsed / heapMax : 0;
      var result = [];
      result.pushObject(percent.toFixed(1) + '% used');
      result.pushObject(heapUsed.bytesToSize(1, "parseFloat") + ' of ' + heapMax.bytesToSize(1, "parseFloat"));
      return result;
    }.property('model.jobTrackerHeapUsed', 'model.jobTrackerHeapMax'),

    thresh1: 40,// can be customized
    thresh2: 70,
    maxValue: 100,

    isPieExist: function () {
      var total = this.get('model.jobTrackerHeapMax') * 1000000;
      return total > 0 ;
    }.property('model.jobTrackerHeapMax'),

    content: App.ChartPieView.extend({

      model: null,  //data bind here
      id: 'widget-jt-heap', // id in html
      stroke: '#D6DDDF', //light grey
      thresh1: null,
      thresh2: null,
      innerR: 25,

      existCenterText: true,
      centerTextColor: function () {
        return this.get('contentColor');
      }.property('contentColor'),

      palette: new Rickshaw.Color.Palette({
        scheme: [ '#FFFFFF', '#D6DDDF'].reverse()
      }),

      data: function () {
        var used = this.get('model.jobTrackerHeapUsed') * 1000000;
        var total = this.get('model.jobTrackerHeapMax') * 1000000;
        var percent = total > 0 ? ((used)*100 / total).toFixed() : 0;
        return [ percent, 100 - percent];
      }.property('model.jobTrackerHeapUsed', 'model.jobTrackerHeapMax'),

      contentColor: function (){
        var used = parseFloat(this.get('data')[0]);
        var thresh1 = parseFloat(this.get('thresh1'));
        var thresh2 = parseFloat(this.get('thresh2'));
        var color_green = '#95A800';
        var color_red = '#B80000';
        var color_orange = '#FF8E00';
        if (used <= thresh1) {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_green  ].reverse()
          }))
          return color_green;
        } else if (used <= thresh2) {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_orange  ].reverse()
          }))
          return color_orange;
        } else {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_red  ].reverse()
          }))
          return color_red;
        }
      }.property('data', 'this.thresh1', 'this.thresh2'),

      refreshSvg: function () {
        // remove old svg
        var old_svg =  $("#" + this.id);
        old_svg.remove();

        // draw new svg
        this.appendSvg();
      }.observes('this.data', 'this.thresh1', 'this.thresh2')
    })

  })
});
window.require.register("views/main/dashboard/widgets/jobtracker_rpc", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.JobTrackerRpcView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/simple_text'),
    title: Em.I18n.t('dashboard.widgets.JobTrackerRpc'),
    id:'9',

    isPieChart: false,
    isText: true,
    isProgressBar: false,
    model_type: 'mapreduce',
    hiddenInfo: function (){
      var result = [];
      result.pushObject(this.get('content') + ' average RPC');
      result.pushObject('队列等待时间');
      return result;
    }.property('model.jobTrackerRpc'),

    classNameBindings: ['isRed', 'isOrange', 'isGreen', 'isNA'],
    isGreen: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return this.get('data') <= thresh1? true: false;
    }.property('data','thresh1','thresh2'),
    isOrange: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return (this.get('data') <= thresh2 && this.get('data') > thresh1 )? true: false;
    }.property('data','thresh1','thresh2'),
    isRed: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return this.get('data') > thresh2? true: false;
    }.property('data','thresh1','thresh2'),
    isNA: function () {
       return this.get('data') === null;
    }.property('data'),

    thresh1: 0.5,
    thresh2: 2,
    maxValue: 'infinity',

    data: function (){
      if (this.get('model.jobTrackerRpc')) {
        return (this.get('model.jobTrackerRpc')).toFixed(2);
      } else {
        if (this.get('model.jobTrackerRpc') == 0) {
          return 0;
        } else {
          return null;
        }
      }
    }.property('model.jobTrackerRpc'),

    content: function () {
      if (this.get('data') || this.get('data') == 0) {
        return this.get('data') + " ms";
      } else {
        return this.t('services.service.summary.notAvailable');
      }
    }.property('model.jobTrackerRpc'),

    editWidget: function (event) {
      var parent = this;
      var configObj = Ember.Object.create({
        thresh1: parent.get('thresh1') + '',
        thresh2: parent.get('thresh2') + '',
        hintInfo: 'Edit the thresholds to change the color of current widget. ' +
          ' The unit is milli-second. '+
          ' So enter two numbers larger than 0. ',
        isThresh1Error: false,
        isThresh2Error: false,
        errorMessage1: "",
        errorMessage2: "",
        maxValue: 'infinity',
        observeNewThresholdValue: function () {
          var thresh1 = this.get('thresh1');
          var thresh2 = this.get('thresh2');
          if (thresh1.trim() != "") {
            if (isNaN(thresh1) || thresh1 < 0) {
              this.set('isThresh1Error', true);
              this.set('errorMessage1', 'Invalid! Enter a number larger than 0');
            } else if (this.get('isThresh2Error') === false && parseFloat(thresh2)<= parseFloat(thresh1)) {
              this.set('isThresh1Error', true);
              this.set('errorMessage1', 'Threshold 1 should be smaller than threshold 2 !');
            } else {
              this.set('isThresh1Error', false);
              this.set('errorMessage1', '');
            }
          } else {
            this.set('isThresh1Error', true);
            this.set('errorMessage1', 'This is required');
          }

          if (thresh2.trim() != "") {
            if (isNaN(thresh2) || thresh2 < 0) {
              this.set('isThresh2Error', true);
              this.set('errorMessage2', 'Invalid! Enter a number larger than 0');
            } else {
              this.set('isThresh2Error', false);
              this.set('errorMessage2', '');
            }
          } else{
            this.set('isThresh2Error', true);
            this.set('errorMessage2', 'This is required');
          }
        }.observes('thresh1', 'thresh2')
      });

      var browserVerion = this.getInternetExplorerVersion();
      App.ModalPopup.show({
        header: 'Customize Widget',
        classNames: [ 'sixty-percent-width-modal-edit-widget'],
        bodyClass: Ember.View.extend({
          templateName: require('templates/main/dashboard/edit_widget_popup'),
          configPropertyObj: configObj
        }),
        primary: Em.I18n.t('common.apply'),
        onPrimary: function () {
          configObj.observeNewThresholdValue();
          if (!configObj.isThresh1Error && !configObj.isThresh2Error) {
            parent.set('thresh1', parseFloat(configObj.get('thresh1')) );
            parent.set('thresh2', parseFloat(configObj.get('thresh2')) );
            if (!App.testMode) {
              // save to persist
              var big_parent = parent.get('parentView');
              big_parent.getUserPref(big_parent.get('persistKey'));
              var oldValue = big_parent.get('currentPrefObject');
              oldValue.threshold[parseInt(parent.id)] = [configObj.get('thresh1'), configObj.get('thresh2')];
              big_parent.postUserPref(big_parent.get('persistKey'),oldValue);
            }

            this.hide();
          }
        },
        secondary : Em.I18n.t('common.cancel'),
        onSecondary: function () {
          this.hide();
        },

        didInsertElement: function () {
          var colors = ['#95A800', '#FF8E00', '#B80000']; //color green, orange ,red
          var handlers = [33, 66]; //fixed value

          if (browserVerion == -1 || browserVerion > 9) {
            configObj.set('isIE9', false);
            configObj.set('isGreenOrangeRed', true);
            $("#slider-range").slider({
              range:true,
              disabled:true,
              min: 0,
              max: 100,
              values: handlers,
              create: function (event, ui) {
                updateColors(handlers);
              }
            });

            function updateColors (handlers) {
              var colorstops = colors[0] + ", "; // start with the first color
              for (var i = 0; i < handlers.length; i++) {
                colorstops += colors[i] + " " + handlers[i] + "%,";
                colorstops += colors[i+1] + " " + handlers[i] + "%,";
              }
              // end with the last color
              colorstops += colors[colors.length - 1];
              var css1 = '-webkit-linear-gradient(left,' + colorstops + ')'; // chrome & safari
              $('#slider-range').css('background-image', css1);
              var css2 = '-ms-linear-gradient(left,' + colorstops + ')'; // IE 10+
              $('#slider-range').css('background-image', css2);
              //$('#slider-range').css('filter', 'progid:DXImageTransform.Microsoft.gradient( startColorStr= ' + colors[0] + ', endColorStr= ' + colors[2] +',  GradientType=1 )' ); // IE 10-
              var css3 = '-moz-linear-gradient(left,' + colorstops + ')'; // Firefox
              $('#slider-range').css('background-image', css3);

              $('#slider-range .ui-widget-header').css({'background-color': '#FF8E00', 'background-image': 'none'}); // change the  original ranger color
            }
          } else {
            configObj.set('isIE9', true);
            configObj.set('isGreenOrangeRed', true);
          }
        }
      });
    }

  })
  
});
window.require.register("views/main/dashboard/widgets/jobtracker_uptime", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var date = require('utils/date');

  App.JobTrackerUptimeView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/uptime'),
    title: Em.I18n.t('dashboard.widgets.JobTrackerUptime'),
    id: '16',

    isPieChart: false,
    isText: true,
    isProgressBar: false,
    model_type: 'mapreduce',
    hiddenInfo: [],
    hiddenInfoClass: "hidden-info-three-line",

    classNameBindings: ['isRed', 'isOrange', 'isGreen', 'isNA'],
    isGreen: function () {
      return this.get('data') != null;
    }.property('data'),
    isOrange: function () {
     return false;
    }.property('data'),
    isRed: function () {
      return false;
    }.property('data'),
    isNA: function () {
      return this.get('data') == null;
    }.property('data'),

    thresh1: 5,
    thresh2: 10,
    maxValue: 'infinity',

    data: function(){
      var uptime = this.get('model.jobTrackerStartTime');
      if (uptime && uptime > 0) {
        var uptimeString = this.timeConverter(uptime);
        var diff = (new Date()).getTime() - uptime;
        if (diff < 0) {
          diff = 0;
        }
        var formatted = date.timingFormat(diff); //17.67 days
        var timeUnit = null;
        switch (formatted.split(" ")[1]){
          case 'secs':
            timeUnit = '秒';
            break;
          case 'hours':
            timeUnit = '小时';
            break;
          case 'days':
            timeUnit = '天';
            break;
          case 'mins':
            timeUnit = '分';
            break;
          default:
            timeUnit = formatted.split(" ")[1];
        }
        this.set('timeUnit', timeUnit);
        this.set('hiddenInfo', []);
        this.get('hiddenInfo').pushObject(formatted);
        this.get('hiddenInfo').pushObject(uptimeString[0]);
        this.get('hiddenInfo').pushObject(uptimeString[1]);
        return parseFloat(formatted.split(" ")[0]);
      }
      this.set('hiddenInfo', ['JobTracker','Not Running']);
      return null;
    }.property('model.jobTrackerStartTime'),

    timeUnit: null,

    content: function () {
      var data = this.get('data');
      if (data) {
        return data.toFixed(1) + ' '+ this.get('timeUnit');
      } else {
        return this.t('services.service.summary.notAvailable');
      }
    }.property('model.jobTrackerStartTime'),

    timeConverter: function (timestamp) {
      var origin = new Date(timestamp);
      origin = origin.toString();
      var result = [];
      var start = origin.indexOf('GMT');
      if(start == -1){ // ie
        var arr = origin.split(" ");
        result.pushObject(arr[0] + " " + arr[1] + " " + arr[2] + " " + arr[3]);
        var second = '';
        for(var i = 4; i < arr.length; i++){
          second = second + " " + arr[i];
        }
        result.pushObject(second);
      }else{ // other browsers
        var end = origin.indexOf(" ", start);
        result.pushObject(origin.slice(0, start-10));
        result.pushObject(origin.slice(start-9));
      }
      return result;
    }

  })
  
});
window.require.register("views/main/dashboard/widgets/mapreduce_links", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MapReduceLinksView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/mapreduce_links'),
    title: Em.I18n.t('dashboard.widgets.MapReduceLinks'),
    id: '18',

    isPieChart: false,
    isText: false,
    isProgressBar: false,
    isLinks: true,
    model_type: 'mapreduce',

    taskTrackerComponent: function () {
      return App.HostComponent.find().findProperty('componentName', 'TASKTRACKER');
    }.property(),

    jobTrackerWebUrl: function () {
      return "http://" + this.get('model').get('jobTracker').get('publicHostName') + ":50030";
    }.property('model.jobTracker')

  })

  App.MapReduceLinksView. reopenClass({
    isLinks: true
  })
  
});
window.require.register("views/main/dashboard/widgets/mapreduce_slots", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MapReduceSlotsView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/mapreduce_slots'),
    title: Em.I18n.t('dashboard.widgets.MapReduceSlots'),
    id:'10',

    isPieChart: false,
    isText: false,
    isProgressBar: true,
    model_type: 'mapreduce',
    hiddenInfo: function (){
      var result = [];
      if(this.get('isViewExist')){
        var line1 = "Map: " + this.get('model.mapSlotsOccupied') + " Occupied / " + this.get('model.mapSlotsReserved') + " Reserved / " + this.get('model.mapSlots') + " Total";
        result.pushObject(line1);
        var line2 = "Reduce: " + this.get('model.reduceSlotsOccupied') + " Occupied / " + this.get('model.reduceSlotsReserved') + " Reserved / " + this.get('model.reduceSlots') + " Total";
        result.pushObject(line2);
      }else{
        result.pushObject('MapReduce 没有启动');
      }
      return result;
    }.property('isViewExist', 'map_display_text', 'reduce_display_text'),
    isViewExist: function () {
      return this.get('model.mapSlotsOccupied') != null && this.get('model.mapSlotsReserved') != null && this.get('model.reduceSlotsOccupied') != null && this.get('model.reduceSlotsReserved') != null;
    }.property('model.mapSlotsReserved', 'model.mapSlotsOccupied', 'model.reduceSlotsReserved', 'model.reduceSlotsOccupied'),

    map_occupied: function () {
      if (this.get('model.mapSlotsOccupied')) {
        return "width: " + ((this.get('model.mapSlotsOccupied'))*100/(this.get('model.mapSlots'))).toString() + "%";
      } else {
        return "width: 0%";
      }
    }.property('model.mapSlotsOccupied','model.mapSlots'),
    map_reserved: function () {
      if (this.get('model.mapSlotsReserved')) {
        return "width: " + ((this.get('model.mapSlotsReserved'))*100/(this.get('model.mapSlots'))).toString() + "%";
      } else {
        return "width: 0%";
      }
    }.property('model.mapSlotsReserved','model.mapSlots'),
    map_display_text: function () {
      return this.get('model.mapSlotsOccupied') + "/" + this.get('model.mapSlotsReserved') + "/" + this.get('model.mapSlots');
    }.property('model.mapSlotsReserved','model.mapSlotsOccupied','model.mapSlots'),


    reduce_occupied: function () {
      if (this.get('model.reduceSlotsOccupied')) {
        return "width: " + ((this.get('model.reduceSlotsOccupied'))*100/(this.get('model.reduceSlots'))).toString() + "%";
      } else {
        return "width: 0%";
      }
    }.property('model.reduceSlotsOccupied','model.reduceSlots'),
    reduce_reserved: function () {
      if (this.get('model.reduceSlotsReserved')) {
        return "width: " + ((this.get('model.reduceSlotsReserved'))*100/(this.get('model.reduceSlots'))).toString() + "%";
      } else {
        return "width: 0%";
      }
    }.property('model.reduceSlotsReserved','model.reduceSlots'),
    reduce_display_text: function () {
      return this.get('model.reduceSlotsOccupied') + "/" + this.get('model.reduceSlotsReserved') + "/" + this.get('model.reduceSlots');
    }.property('model.reduceSlotsReserved','model.reduceSlotsOccupied','model.reduceSlots')

  })

  App.MapReduceSlotsView.reopenClass({
    isProgressBar: true
  })
});
window.require.register("views/main/dashboard/widgets/metrics_cpu", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.ChartClusterMetricsCPUWidgetView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/cluster_metrics'),
    title: Em.I18n.t('dashboard.clusterMetrics.cpu'),
    id: '13',

    isClusterMetrics: true,
    isPieChart: false,
    isText: false,
    isProgressBar: false,

    content: App.ChartClusterMetricsCPU.extend({
      noTitleUnderGraph: true,
      inWidget: true
    })
  })
  
});
window.require.register("views/main/dashboard/widgets/metrics_load", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.ChartClusterMetricsLoadWidgetView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/cluster_metrics'),
    title: Em.I18n.t('dashboard.clusterMetrics.load'),
    id: '14',

    isClusterMetrics: true,
    isPieChart: false,
    isText: false,
    isProgressBar: false,

    content: App.ChartClusterMetricsLoad.extend({
      noTitleUnderGraph: true,
      inWidget: true
    })
  })
  
});
window.require.register("views/main/dashboard/widgets/metrics_memory", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.ChartClusterMetricsMemoryWidgetView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/cluster_metrics'),
    title: Em.I18n.t('dashboard.clusterMetrics.memory'),
    id: '11',

    isClusterMetrics: true,
    isPieChart: false,
    isText: false,
    isProgressBar: false,

    content: App.ChartClusterMetricsMemory.extend({
      noTitleUnderGraph: true,
      inWidget: true
    })
  })
  
});
window.require.register("views/main/dashboard/widgets/metrics_network", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.ChartClusterMetricsNetworkWidgetView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/cluster_metrics'),
    title: Em.I18n.t('dashboard.clusterMetrics.network'),
    id: '12',

    isClusterMetrics: true,
    isPieChart: false,
    isText:false,
    isProgressBar:false,

    content: App.ChartClusterMetricsNetwork.extend({
      noTitleUnderGraph: true,
      inWidget: true
    })
  })
  
});
window.require.register("views/main/dashboard/widgets/namenode_cpu", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.NameNodeCpuPieChartView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/pie_chart'),
    title: Em.I18n.t('dashboard.widgets.NameNodeCpu'),
    id: '3',

    isPieChart: true,
    isText: false,
    isProgressBar: false,
    model_type: 'hdfs',
    hiddenInfo: function () {
      var value = this.get('model.nameNodeCpu');
      var obj1;
      if( value == null) {
        obj1 = Em.I18n.t('services.service.summary.notAvailable');
      }else{
        value = value >= 100 ? 100: value;
        obj1 = (value + 0).toFixed(2) + '%';
      }
      var result = [];
      result.pushObject(obj1);
      result.pushObject('CPU wait I/O');
      return result;
    }.property('model.nameNodeCpu'),

    thresh1: 40,// can be customized
    thresh2: 70,
    maxValue: 100,

    isPieExist: function () {
      var total = this.get('model.nameNodeCpu');
      return total !== null ;
    }.property('model.nameNodeCpu'),

    content: App.ChartPieView.extend({

      model: null,  //data bind here
      id: 'widget-nn-cpu', // html id
      stroke: '#D6DDDF', //light grey
      thresh1: null,  // can be customized later
      thresh2: null,
      innerR: 25,

      existCenterText: true,
      centerTextColor: function () {
        return this.get('contentColor');
      }.property('contentColor'),

      palette: new Rickshaw.Color.Palette ({
        scheme: [ '#FFFFFF', '#D6DDDF'].reverse()
      }),

      data: function () {
        var value = this.get('model.nameNodeCpu');
        value = value >= 100 ? 100: value;
        var percent = (value + 0).toFixed(1);
        return [ percent, 100 - percent];
      }.property('model.nameNodeCpu'),

      contentColor: function () {
        var used = parseFloat(this.get('data')[0]);
        var thresh1 = parseFloat(this.get('thresh1'));
        var thresh2 = parseFloat(this.get('thresh2'));
        var color_green = '#95A800';
        var color_red = '#B80000';
        var color_orange = '#FF8E00';
        if (used <= thresh1) {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_green  ].reverse()
          }))
          return color_green;
        } else if (used <= thresh2) {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_orange  ].reverse()
          }))
          return color_orange;
        } else {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_red  ].reverse()
          }))
          return color_red;
        }
      }.property('data', 'thresh1', 'thresh2'),

      // refresh text and color when data in model changed
      refreshSvg: function () {
        // remove old svg
        var old_svg =  $("#" + this.id);
        old_svg.remove();

        // draw new svg
        this.appendSvg();
      }.observes('model.nameNodeCpu', 'thresh1', 'thresh2')
    })

  })
  
});
window.require.register("views/main/dashboard/widgets/namenode_heap", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.NameNodeHeapPieChartView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/pie_chart'),
    title: Em.I18n.t('dashboard.widgets.NameNodeHeap'),
    id: '1',

    isPieChart: true,
    isText: false,
    isProgressBar: false,
    model_type: 'hdfs',

    hiddenInfo: function () {
    var memUsed = this.get('model').get('jvmMemoryHeapUsed') * 1000000;
    var memCommitted = this.get('model').get('jvmMemoryHeapCommitted') * 1000000;
    var percent = memCommitted > 0 ? ((100 * memUsed) / memCommitted) : 0;
    var result = [];
    result.pushObject(percent.toFixed(1) + '% used');
    result.pushObject(memUsed.bytesToSize(1, 'parseFloat') + ' of ' + memCommitted.bytesToSize(1, 'parseFloat'));
    return result;
    }.property('model.jvmMemoryHeapUsed', 'model.jvmMemoryHeapCommitted'),

    thresh1: null,
    thresh2: null,
    maxValue: 100,

    isPieExist: function () {
      var total = this.get('model.jvmMemoryHeapCommitted') * 1000000;
      return total > 0 ;
    }.property('model.jvmMemoryHeapCommitted'),

    content: App.ChartPieView.extend({

      model: null,  //data bind here
      id: 'widget-nn-heap', // html id
      stroke: '#D6DDDF', //light grey
      thresh1: null, //bind from parent
      thresh2: null,
      innerR: 25,

      existCenterText: true,
      centerTextColor: function () {
        return this.get('contentColor');
      }.property('contentColor'),

      palette: new Rickshaw.Color.Palette({
        scheme: [ '#FFFFFF', '#D6DDDF'].reverse()
      }),

      data: function () {
        var used = this.get('model.jvmMemoryHeapUsed') * 1000000;
        var total = this.get('model.jvmMemoryHeapCommitted') * 1000000;
        var percent = total > 0 ? ((used)*100 / total).toFixed() : 0;
        return [ percent, 100 - percent];
      }.property('model.jvmMemoryHeapUsed', 'model.jvmMemoryHeapCommitted'),

      contentColor: function () {
        var used = parseFloat(this.get('data')[0]);
        var thresh1 = parseFloat(this.get('thresh1'));
        var thresh2 = parseFloat(this.get('thresh2'));
        var color_green = '#95A800';
        var color_red = '#B80000';
        var color_orange = '#FF8E00';
        if (used <= thresh1) {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_green  ].reverse()
          }))
          return color_green;
        } else if (used <= thresh2) {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_orange  ].reverse()
          }))
          return color_orange;
        } else {
          this.set('palette', new Rickshaw.Color.Palette({
            scheme: [ '#FFFFFF', color_red  ].reverse()
          }))
          return color_red;
        }
      }.property('data', 'this.thresh1', 'this.thresh2'),

      // refresh text and color when data in model changed
      refreshSvg: function () {
        // remove old svg
        var old_svg =  $("#" + this.id);
        if(old_svg){
          old_svg.remove();
        }
        // draw new svg
        this.appendSvg();
      }.observes('this.data', 'this.thresh1', 'this.thresh2')
    })

  })


  
});
window.require.register("views/main/dashboard/widgets/namenode_rpc", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.NameNodeRpcView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/simple_text'),
    title: Em.I18n.t('dashboard.widgets.NameNodeRpc'),
    id: '5',

    isPieChart: false,
    isText: true,
    isProgressBar: false,
    model_type: 'hdfs',
    hiddenInfo: function () {
      var result = [];
      result.pushObject(this.get('content') + ' average RPC');
      result.pushObject('队列等待时间');
      return result;
    }.property('model.nameNodeRpc'),

    classNameBindings: ['isRed', 'isOrange', 'isGreen', 'isNA'],
    isGreen: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return this.get('data') <= thresh1? true: false;
    }.property('data','thresh1','thresh2'),
    isOrange: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return (this.get('data') <= thresh2 && this.get('data') > thresh1 )? true: false;
    }.property('data','thresh1','thresh2'),
    isRed: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return this.get('data') > thresh2? true: false;
    }.property('data','thresh1','thresh2'),
    isNA: function () {
      return this.get('data') === null;
    }.property('data'),

    thresh1: 0.5,
    thresh2: 2,
    maxValue: 'infinity',

    data: function () {
      if (this.get('model.nameNodeRpc')) {
        return (this.get('model.nameNodeRpc')).toFixed(2);
      } else {
        if (this.get('model.nameNodeRpc') == 0) {
          return 0;
        } else {
          return null;
        }
      }
    }.property('model.nameNodeRpc'),

    content: function () {
      if (this.get('data') || this.get('data') == 0) {
        return this.get('data') + " ms";
      } else {
        return this.t('services.service.summary.notAvailable');
      }
    }.property('model.nameNodeRpc'),

    editWidget: function (event) {
      var parent = this;
      var configObj = Ember.Object.create({
        thresh1: parent.get('thresh1') + '',
        thresh2: parent.get('thresh2') + '',
        hintInfo: 'Edit the thresholds to change the color of current widget. ' +
          ' The unit is milli-second. '+
          ' So enter two numbers larger than 0. ',
        isThresh1Error: false,
        isThresh2Error: false,
        errorMessage1: "",
        errorMessage2: "",
        maxValue: 'infinity',
        observeNewThresholdValue: function () {
          var thresh1 = this.get('thresh1');
          var thresh2 = this.get('thresh2');
          if (thresh1.trim() != "") {
            if (isNaN(thresh1) || thresh1 < 0) {
              this.set('isThresh1Error', true);
              this.set('errorMessage1', 'Invalid! Enter a number larger than 0');
            } else if ( this.get('isThresh2Error') === false && parseFloat(thresh2)<= parseFloat(thresh1)){
              this.set('isThresh1Error', true);
              this.set('errorMessage1', 'Threshold 1 should be smaller than threshold 2 !');
            } else {
              this.set('isThresh1Error', false);
              this.set('errorMessage1', '');
            }
          } else {
            this.set('isThresh1Error', true);
            this.set('errorMessage1', 'This is required');
          }

          if (thresh2.trim() != "") {
            if (isNaN(thresh2) || thresh2 < 0) {
              this.set('isThresh2Error', true);
              this.set('errorMessage2', 'Invalid! Enter a number larger than 0');
            } else {
              this.set('isThresh2Error', false);
              this.set('errorMessage2', '');
            }
          } else {
            this.set('isThresh2Error', true);
            this.set('errorMessage2', 'This is required');
          }
        }.observes('thresh1', 'thresh2')

      });

      var browserVerion = this.getInternetExplorerVersion();
      App.ModalPopup.show({
        header: 'Customize Widget',
        classNames: ['sixty-percent-width-modal-edit-widget'],
        bodyClass: Ember.View.extend({
          templateName: require('templates/main/dashboard/edit_widget_popup'),
          configPropertyObj: configObj
        }),
        primary: Em.I18n.t('common.apply'),
        onPrimary: function () {
          configObj.observeNewThresholdValue();
          if (!configObj.isThresh1Error && !configObj.isThresh2Error) {
            parent.set('thresh1', parseFloat(configObj.get('thresh1')) );
            parent.set('thresh2', parseFloat(configObj.get('thresh2')) );
            if (!App.testMode) {
              //save to persist
              var big_parent = parent.get('parentView');
              big_parent.getUserPref(big_parent.get('persistKey'));
              var oldValue = big_parent.get('currentPrefObject');
              oldValue.threshold[parseInt(parent.id)] = [configObj.get('thresh1'), configObj.get('thresh2')];
              big_parent.postUserPref(big_parent.get('persistKey'),oldValue);
            }

            this.hide();
          }
        },
        secondary : Em.I18n.t('common.cancel'),
        onSecondary: function () {
          this.hide();
        },

        didInsertElement: function () {
          var colors = ['#95A800', '#FF8E00', '#B80000']; //color green, orange ,red
          var handlers = [33, 66]; //fixed value

          if (browserVerion == -1 || browserVerion > 9) {
            configObj.set('isIE9', false);
            configObj.set('isGreenOrangeRed', true);
            $("#slider-range").slider({
              range:true,
              disabled:true, //handlers cannot move
              min: 0,
              max: 100,
              values: handlers,
              create: function (event, ui) {
                updateColors(handlers);
              }
            });

            function updateColors (handlers) {
              var colorstops = colors[0] + ", "; // start with the first color
              for (var i = 0; i < handlers.length; i++) {
                colorstops += colors[i] + " " + handlers[i] + "%,";
                colorstops += colors[i+1] + " " + handlers[i] + "%,";
              }
              // end with the last color
              colorstops += colors[colors.length - 1];
              var css1 = '-webkit-linear-gradient(left,' + colorstops + ')'; // chrome & safari
              $('#slider-range').css('background-image', css1);
              var css2 = '-ms-linear-gradient(left,' + colorstops + ')'; // IE 10+
              $('#slider-range').css('background-image', css2);
              //$('#slider-range').css('filter', 'progid:DXImageTransform.Microsoft.gradient( startColorStr= ' + colors[0] + ', endColorStr= ' + colors[2] +',  GradientType=1 )' ); // IE 10-
              var css3 = '-moz-linear-gradient(left,' + colorstops + ')'; // Firefox
              $('#slider-range').css('background-image', css3);

              $('#slider-range .ui-widget-header').css({'background-color': '#FF8E00', 'background-image': 'none'}); // change the  original ranger color
            }
          } else {
            configObj.set('isIE9', true);
            configObj.set('isGreenOrangeRed', true);
          }
        }
      });
    }

  })
  
});
window.require.register("views/main/dashboard/widgets/namenode_uptime", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var date = require('utils/date');

  App.NameNodeUptimeView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/uptime'),
    title: Em.I18n.t('dashboard.widgets.NameNodeUptime'),
    id: '15',

    isPieChart: false,
    isText: true,
    isProgressBar: false,
    model_type: 'hdfs',
    hiddenInfo: [],
    hiddenInfoClass: "hidden-info-three-line",

    classNameBindings: ['isRed', 'isOrange', 'isGreen', 'isNA'],
    isGreen: function () {
      return this.get('data') != null;
    }.property('data'),
    isOrange: function () {
      return false;
    }.property('data'),
    isRed: function () {
      return false;
    }.property('data'),
    isNA: function () {
      return this.get('data') == null;
    }.property('data'),

    thresh1: 5,
    thresh2: 10,
    maxValue: 'infinity',

    data: function () {
      var uptime = this.get('model.nameNodeStartTime');
      if (uptime && uptime > 0) {
        var uptimeString = this.timeConverter(uptime);
        var diff = (new Date()).getTime() - uptime;
        if (diff < 0) {
          diff = 0;
        }
        var formatted = date.timingFormat(diff); //17.67 days
        var timeUnit = null;
        switch (formatted.split(" ")[1]) {
          case 'secs':
            timeUnit = '秒';
            break;
          case 'hours':
            timeUnit = '小时';
            break;
          case 'days':
            timeUnit = '天';
            break;
          case 'mins':
            timeUnit = '分';
            break;
          default:
            timeUnit = formatted.split(" ")[1];
        }
        this.set('timeUnit', timeUnit);
        this.set('hiddenInfo', []);
        this.get('hiddenInfo').pushObject(formatted);
        this.get('hiddenInfo').pushObject(uptimeString[0]);
        this.get('hiddenInfo').pushObject(uptimeString[1]);
        return parseFloat(formatted.split(" ")[0]);
      }
      this.set('hiddenInfo', []);
      this.set('hiddenInfo', ['NameNode','Not Running']);
      return null;
    }.property('model.nameNodeStartTime'),

    timeUnit: null,

    content: function () {
      var data = this.get('data');
      if (data) {
        return data.toFixed(1) + ' '+ this.get('timeUnit');
      } else {
        return this.t('services.service.summary.notAvailable');
      }
    }.property('model.nameNodeStartTime'),

    timeConverter: function (timestamp){
      var origin = new Date(timestamp);
      origin = origin.toString();
      var result = [];
      var start = origin.indexOf('GMT');
      if (start == -1) { // ie
        var arr = origin.split(" ");
        result.pushObject(arr[0] + " " + arr[1] + " " + arr[2] + " " + arr[3]);
        var second = '';
        for (var i = 4; i < arr.length; i++) {
          second = second + " " + arr[i];
        }
        result.pushObject(second);
      } else { // other browsers
        var end = origin.indexOf(" ", start);
        result.pushObject(origin.slice(0, start-10));
        result.pushObject(origin.slice(start-9));
      }
      return result;
    }

  })
  
});
window.require.register("views/main/dashboard/widgets/tasktracker_live", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.TaskTrackerUpView = App.DashboardWidgetView.extend({

    templateName: require('templates/main/dashboard/widgets/simple_text'),
    title: Em.I18n.t('dashboard.widgets.TaskTrackerUp'),
    id: '8',

    isPieChart: false,
    isText: true,
    isProgressBar: false,
    model_type: 'mapreduce',

    hiddenInfo: function () {
      var svc = this.get('model');
      var liveCount = svc.get('aliveTrackers').get('length');
      var totalCount = svc.get('taskTrackers').get('length');
      var result = [];
      result.pushObject(liveCount + " live");
      result.pushObject(totalCount + " total");
      return result;
    }.property('model.aliveTrackers.length', 'model.taskTrackers.length'),

    classNameBindings: ['isRed', 'isOrange', 'isGreen'],
    isRed: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return this.get('data') <= thresh1? true: false;
    }.property('data','thresh1','thresh2'),
    isOrange: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return (this.get('data') <= thresh2 && this.get('data') > thresh1 )? true: false;
    }.property('data','thresh1','thresh2'),
    isGreen: function () {
      var thresh1 = this.get('thresh1');
      var thresh2 = this.get('thresh2');
      return this.get('data') > thresh2? true: false;
    }.property('data','thresh1','thresh2'),

    thresh1: 40,
    thresh2: 70,
    maxValue: 100,

    data: function () {
      return ((this.get('model.aliveTrackers.length')/ this.get('model.taskTrackers.length')).toFixed(2)) * 100;
    }.property('model.taskTrackers.length', 'model.aliveTrackers.length'),

    content: function () {
      return this.get('model.aliveTrackers.length') + "/" + this.get('model.taskTrackers.length');
    }.property('model.taskTrackers.length', 'model.aliveTrackers.length'),

    editWidget: function (event) {
      var parent = this;
      var max_tmp =  parseFloat(parent.get('maxValue'));
      var configObj = Ember.Object.create({
        thresh1: parent.get('thresh1') + '',
        thresh2: parent.get('thresh2') + '',
        hintInfo: 'Edit the percentage of thresholds to change the color of current widget. ' +
          ' Assume all task trackers UP is 100, and all DOWN is 0. '+
          ' So enter two numbers between 0 to ' + max_tmp,
        isThresh1Error: false,
        isThresh2Error: false,
        errorMessage1: "",
        errorMessage2: "",
        maxValue: max_tmp,
        observeNewThresholdValue: function () {
          var thresh1 = this.get('thresh1');
          var thresh2 = this.get('thresh2');
          if (thresh1.trim() != "") {
            if (isNaN(thresh1) || thresh1 > max_tmp || thresh1 < 0) {
              this.set('isThresh1Error', true);
              this.set('errorMessage1', 'Invalid! Enter a number between 0 - ' + max_tmp);
            } else if (this.get('isThresh2Error') === false && parseFloat(thresh2)<= parseFloat(thresh1)){
              this.set('isThresh1Error', true);
              this.set('errorMessage1', 'Threshold 1 should be smaller than threshold 2 !');
            } else {
              this.set('isThresh1Error', false);
              this.set('errorMessage1', '');
            }
          } else {
            this.set('isThresh1Error', true);
            this.set('errorMessage1', 'This is required');
          }

          if (thresh2.trim() != "") {
            if (isNaN(thresh2) || thresh2 > max_tmp || thresh2 < 0) {
              this.set('isThresh2Error', true);
              this.set('errorMessage2', 'Invalid! Enter a number between 0 - ' + max_tmp);
            } else {
              this.set('isThresh2Error', false);
              this.set('errorMessage2', '');
            }
          } else {
            this.set('isThresh2Error', true);
            this.set('errorMessage2', 'This is required');
          }

          // update the slider handles and color
          if (this.get('isThresh1Error') === false && this.get('isThresh2Error') === false) {
            $("#slider-range").slider('values', 0 , parseFloat(thresh1));
            $("#slider-range").slider('values', 1 , parseFloat(thresh2));
          }
        }.observes('thresh1', 'thresh2')
      });

      var browserVerion = this.getInternetExplorerVersion();
      App.ModalPopup.show({
        header: 'Customize Widget',
        classNames: [ 'sixty-percent-width-modal-edit-widget'],
        bodyClass: Ember.View.extend({
          templateName: require('templates/main/dashboard/edit_widget_popup'),
          configPropertyObj: configObj
        }),
        primary: Em.I18n.t('common.apply'),
        onPrimary: function() {
          configObj.observeNewThresholdValue();
          if (!configObj.isThresh1Error && !configObj.isThresh2Error) {
            parent.set('thresh1', parseFloat(configObj.get('thresh1')) );
            parent.set('thresh2', parseFloat(configObj.get('thresh2')) );
            if (!App.testMode) {
              //save to persit
              var big_parent = parent.get('parentView');
              big_parent.getUserPref(big_parent.get('persistKey'));
              var oldValue = big_parent.get('currentPrefObject');
              oldValue.threshold[parseInt(parent.id)] = [configObj.get('thresh1'), configObj.get('thresh2')];
              big_parent.postUserPref(big_parent.get('persistKey'),oldValue);
            }
            this.hide();
          }
        },
        secondary : Em.I18n.t('common.cancel'),
        onSecondary: function () {
          this.hide();
        },

        didInsertElement: function () {
          var handlers = [configObj.get('thresh1'), configObj.get('thresh2')];
          var colors = ['#B80000', '#FF8E00', '#95A800']; //color red, orange, green

          if (browserVerion == -1 || browserVerion > 9) {
            configObj.set('isIE9', false);
            configObj.set('isGreenOrangeRed', false);
            $("#slider-range").slider({
              range: true,
              min: 0,
              max: max_tmp,
              values: handlers,
              create: function (event, ui) {
                updateColors(handlers);
              },
              slide: function (event, ui) {
                updateColors(ui.values);
                configObj.set('thresh1', ui.values[0] + '');
                configObj.set('thresh2', ui.values[1] + '');
              },
              change: function (event, ui) {
                updateColors(ui.values);
              }
            });

            function updateColors(handlers) {
              var colorstops = colors[0] + ", "; // start with the first color
              for (var i = 0; i < handlers.length; i++) {
                colorstops += colors[i] + " " + handlers[i] + "%,";
                colorstops += colors[i+1] + " " + handlers[i] + "%,";
              }
              // end with the last color
              colorstops += colors[colors.length - 1];
              var css1 = '-webkit-linear-gradient(left,' + colorstops + ')'; // chrome & safari
              $('#slider-range').css('background-image', css1);
              var css2 = '-ms-linear-gradient(left,' + colorstops + ')'; // IE 10+
              $('#slider-range').css('background-image', css2);
              //$('#slider-range').css('filter', 'progid:DXImageTransform.Microsoft.gradient( startColorStr= ' + colors[0] + ', endColorStr= ' + colors[2] +',  GradientType=1 )' ); // IE 10-
              var css3 = '-moz-linear-gradient(left,' + colorstops + ')'; // Firefox
              $('#slider-range').css('background-image', css3);

              $('#slider-range .ui-widget-header').css({'background-color': '#FF8E00', 'background-image': 'none'}); // change the  original ranger color
            }
          } else {
            configObj.set('isIE9', true);
            configObj.set('isGreenOrangeRed', false);
          }
        }
      });
    }

  })
  
});
window.require.register("views/main/host", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var filters = require('views/common/filter_view');
  var sort = require('views/common/sort_view');
  var date = require('utils/date');

  App.MainHostView = App.TableView.extend({
    templateName:require('templates/main/host'),
    content:function () {
      return this.get('controller.content');
    }.property('controller.content.length'),

    willInsertElement: function() {
      this._super();
    },

    sortView: sort.wrapperView,
    nameSort: sort.fieldView.extend({
      name:'publicHostName',
      displayName: Em.I18n.t('common.name')
    }),
    ipSort: sort.fieldView.extend({
      name:'ip',
      displayName: Em.I18n.t('common.ipAddress'),
      type: 'ip'
    }),
    cpuSort: sort.fieldView.extend({
      name:'cpu',
      displayName: Em.I18n.t('common.cpu'),
      type: 'number'
    }),
    memorySort: sort.fieldView.extend({
      name:'memory',
      displayName: Em.I18n.t('common.ram'),
      type: 'number'
    }),
    diskUsageSort: sort.fieldView.extend({
      name:'diskUsage',
      displayName: Em.I18n.t('common.diskUsage')
    }),
    loadAvgSort: sort.fieldView.extend({
      name:'loadAvg',
      displayName: Em.I18n.t('common.loadAvg'),
      type: 'number'
    }),

    HostView:Em.View.extend({
      content:null,
      tagName: 'tr',
      didInsertElement: function(){
        this.$("[rel='HealthTooltip'], [rel='UsageTooltip']").tooltip();
      },
      shortLabels: function() {
        var labels = this.get('content.hostComponents').getEach('displayName');
        var shortLabels = '';
        var c = 0;
        labels.forEach(function(label) {
          if (label) {
            if (c < 2) {
              shortLabels += label.replace(/[^A-Z]/g, '') + ', ';
              c++;
            }
          }
        });
        shortLabels = shortLabels.substr(0, shortLabels.length - 2);
        if (labels.length > 2) {
          shortLabels += ' ' + Em.I18n.t('and') + ' ' + (labels.length - 2) + ' ' + Em.I18n.t('more');
        }
        return shortLabels;
      }.property('labels'),

      labels: function(){
        return this.get('content.hostComponents').getEach('displayName').join('\n');
      }.property('content.hostComponents.@each'),

      usageStyle:function () {
        return "width:" + this.get('content.diskUsage') + "%";
        //return "width:" + (25+Math.random()*50) + "%"; // Just for tests purposes
      }.property('content.diskUsage')

    }),

    /**
     * Category view for all hosts
     */
    categoryObject: Em.Object.extend({

      hostsCount: function () {
        var statusString = this.get('healthStatusValue');
        var alerts = this.get('alerts');
        if(alerts){
          return this.get('view.content').filterProperty('criticalAlertsCount').get('length');
        } else if (statusString == "") {
          return this.get('view.content').get('length');
        } else {
          return this.get('view.content').filterProperty('healthClass', statusString ).get('length');
        }
      }.property('view.content.@each.healthClass', 'view.content.@each.criticalAlertsCount'),

      label: function () {
        return "%@ (%@)".fmt(this.get('value'), this.get('hostsCount'));
      }.property('value', 'hostsCount')
    }),

    categories: function () {
      var self = this;
      self.categoryObject.reopen({
        view: self,
        isActive: false,
        itemClass: function() {
          return this.get('isActive') ? 'active' : '';
        }.property('isActive')
      });

      var categories = [
        self.categoryObject.create({value: Em.I18n.t('common.all'), healthStatusValue: '', isActive: true, isVisible: false}),
        self.categoryObject.create({value: Em.I18n.t('hosts.host.healthStatusCategory.green'), healthStatusValue: 'health-status-LIVE', isVisible: true}),
        self.categoryObject.create({value: Em.I18n.t('hosts.host.healthStatusCategory.red'), healthStatusValue: 'health-status-DEAD-RED', isVisible: true}),
        self.categoryObject.create({value: Em.I18n.t('hosts.host.healthStatusCategory.orange'), healthStatusValue: 'health-status-DEAD-ORANGE', isVisible: true}),
        self.categoryObject.create({value: Em.I18n.t('hosts.host.healthStatusCategory.yellow'), healthStatusValue: 'health-status-DEAD-YELLOW', isVisible: true}),
        self.categoryObject.create({value: Em.I18n.t('hosts.host.alerts.label'), healthStatusValue: 'health-status-WITH-ALERTS', last: true, alerts: true, isVisible: true })
      ];

      return categories;
    }.property(),


    statusFilter: Em.View.extend({
      column: 0,
      categories: [],
      value: null,
      /**
       * switch active category label
       */
      onCategoryChange: function(){
        this.get('categories').setEach('isActive', false);
        this.get('categories').findProperty('healthStatusValue', this.get('value')).set('isActive', true);
      }.observes('value'),
      showClearFilter: function(){
        var mockEvent = {
          context: this.get('categories').findProperty('healthStatusValue', this.get('value'))
        };
        this.selectCategory(mockEvent);
      },
      selectCategory: function(event){
        var category = event.context;
        this.set('value', category.get('healthStatusValue'));
        if(category.get('alerts')){
          this.get('parentView').updateFilter(0, '', 'string');
          this.get('parentView').updateFilter(7, '>0', 'number');
        } else {
          this.get('parentView').updateFilter(7, '', 'number');
          this.get('parentView').updateFilter(0, category.get('healthStatusValue'), 'string');
        }
      },
      clearFilter: function() {
        this.get('categories').setEach('isActive', false);
        this.set('value', '');
        this.showClearFilter();
      }
    }),

    /**
     * view of the alert filter implemented as a category of host statuses
     */
    alertFilter: Em.View.extend({
      column: 7,
      value: null,
      classNames: ['noDisplay'],
      showClearFilter: function(){
        var mockEvent = {
          context: this.get('parentView.categories').findProperty('healthStatusValue', 'health-status-WITH-ALERTS')
        };
        if(this.get('value')) {
          this.get('parentView.childViews').findProperty('column', 0).selectCategory(mockEvent);
        }
      }
    }),


    /**
     * Count of the hosts with alerts
     */
    hostsWithAlertsCount: function() {
      return this.get('content.length') - this.get('content').filterProperty('criticalAlertsCount', 0).length;
    }.property('content.@each.criticalAlertsCount'),


    /**
     * Filter view for name column
     * Based on <code>filters</code> library
     */
    nameFilterView: filters.createTextView({
      column: 1,
      onChangeValue: function(){
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'string');
      }
    }),

    /**
     * Filter view for ip column
     * Based on <code>filters</code> library
     */
    ipFilterView: filters.createTextView({
      column: 2,
      onChangeValue: function(){
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'string');
      }
    }),

    /**
     * Filter view for Cpu column
     * Based on <code>filters</code> library
     */
    cpuFilterView: filters.createTextView({
      fieldType: 'input-mini',
      fieldId: 'cpu_filter',
      column: 3,
      onChangeValue: function(){
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'number');
      }
    }),

    /**
     * Filter view for LoadAverage column
     * Based on <code>filters</code> library
     */
    loadAvgFilterView: filters.createTextView({
      fieldType: 'input-mini',
      fieldId: 'load_avg_filter',
      column: 5,
      onChangeValue: function(){
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'number');
      }
    }),

    /**
     * Filter view for Ram column
     * Based on <code>filters</code> library
     */
    ramFilterView: filters.createTextView({
      fieldType: 'input-mini',
      fieldId: 'ram_filter',
      column: 4,
      onChangeValue: function(){
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'ambari-bandwidth');
      }
    }),

    /**
     * Filter view for HostComponents column
     * Based on <code>filters</code> library
     */
    componentsFilterView: filters.createComponentView({

      column: 6,

      /**
       * Inner FilterView. Used just to render component. Value bind to <code>mainview.value</code> property
       * Base methods was implemented in <code>filters.componentFieldView</code>
       */
      filterView: filters.componentFieldView.extend({
        templateName: require('templates/main/host/component_filter'),

        /**
         * Next three lines bind data to this view
         */
        masterComponentsBinding: 'controller.masterComponents',
        slaveComponentsBinding: 'controller.slaveComponents',
        clientComponentsBinding: 'controller.clientComponents',

        /**
         * Checkbox for quick selecting/deselecting of master components
         */
        masterComponentsChecked:false,
        toggleMasterComponents:function () {
          this.get('masterComponents').setEach('checkedForHostFilter', this.get('masterComponentsChecked'));
        }.observes('masterComponentsChecked'),

        /**
         * Checkbox for quick selecting/deselecting of slave components
         */
        slaveComponentsChecked:false,
        toggleSlaveComponents:function () {
          this.get('slaveComponents').setEach('checkedForHostFilter', this.get('slaveComponentsChecked'));
        }.observes('slaveComponentsChecked'),

        /**
         * Checkbox for quick selecting/deselecting of client components
         */
        clientComponentsChecked: false,
        toggleClientComponents: function() {
          this.get('clientComponents').setEach('checkedForHostFilter', this.get('clientComponentsChecked'));
        }.observes('clientComponentsChecked'),

        /**
         * Clear filter.
         * Called by parent view, when user clicks on <code>x</code> button(clear button)
         */
        clearFilter:function() {
          this.set('masterComponentsChecked', false);
          this.set('slaveComponentsChecked', false);
          this.set('clientComponentsChecked', false);

          this.get('masterComponents').setEach('checkedForHostFilter', false);
          this.get('slaveComponents').setEach('checkedForHostFilter', false);
          this.get('clientComponents').setEach('checkedForHostFilter', false);

          this._super();
        },

        /**
         * Onclick handler for <code>Apply filter</code> button
         */
        applyFilter:function() {
          this._super();
          var self = this;
          var chosenComponents = [];

          this.get('masterComponents').filterProperty('checkedForHostFilter', true).forEach(function(item){
            chosenComponents.push(item.get('id'));
          });
          this.get('slaveComponents').filterProperty('checkedForHostFilter', true).forEach(function(item){
            chosenComponents.push(item.get('id'));
          });
          this.get('clientComponents').filterProperty('checkedForHostFilter', true).forEach(function(item){
            chosenComponents.push(item.get('id'));
          });
          Em.run.next(function() {
            self.set('value', chosenComponents.toString());
          });
        },

        /**
         * Verify that checked checkboxes are equal to value stored in hidden field (components ids list)
         */
        checkComponents: function() {
          var components = this.get('value').split(',');
          var self = this;
          if (components) {
            components.forEach(function(componentId) {
              if(!self.tryCheckComponent(self, 'masterComponents', componentId)) {
                if(!self.tryCheckComponent(self, 'slaveComponents', componentId)) {
                  self.tryCheckComponent(self, 'clientComponents', componentId);
                }
              }
            });
          }
        }.observes('value'),

        tryCheckComponent: function(self, category, componentId) {
          var c = self.get(category).findProperty('id', componentId);
          if (c) {
            if (!c.get('checkedForHostFilter')) {
              c.set('checkedForHostFilter', true);
              return true;
            }
          }
          return false;
        }

      }),
      onChangeValue: function(){
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'multiple');
      }
    }),

    /**
     * associations between host property and column index
     */
    colPropAssoc: function(){
      var associations = [];
      associations[0] = 'healthClass';
      associations[1] = 'publicHostName';
      associations[2] = 'ip';
      associations[3] = 'cpu';
      associations[4] = 'memoryFormatted';
      associations[5] = 'loadAvg';
      associations[6] = 'hostComponents';
      associations[7] = 'criticalAlertsCount';
      return associations;
    }.property()
  });
  
});
window.require.register("views/main/host/add_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.AddHostView = Em.View.extend({

    templateName: require('templates/main/host/add'),

    isStep1Disabled: function () {
      return this.isStepDisabled(1);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep2Disabled: function () {
      return this.isStepDisabled(2);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep3Disabled: function () {
      return this.isStepDisabled(3);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep4Disabled: function () {
      return this.isStepDisabled(4);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep5Disabled: function () {
      return this.isStepDisabled(5);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep6Disabled: function () {
      return this.isStepDisabled(6);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep7Disabled: function () {
      return this.isStepDisabled(7);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep8Disabled: function () {
      return this.isStepDisabled(8);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep9Disabled: function () {
      return this.isStepDisabled(9);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep10Disabled: function () {
      return this.isStepDisabled(10);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStepDisabled: function (index) {
      return this.get('controller.isStepDisabled').findProperty('step', index).get('value');
    }

  });
  
});
window.require.register("views/main/host/configs", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var date = require('utils/date');

  App.MainHostConfigsView = Em.View.extend({
    templateName: require('templates/main/host/configs'),

    content: function(){
      return App.router.get('mainHostDetailsController.content');
    }.property('App.router.mainHostDetailsController.content')

  });
  
});
window.require.register("views/main/host/configs_service", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.MainHostServiceConfigsView = Em.View.extend({
    templateName: require('templates/main/host/configs_service'),
    didInsertElement: function () {
      var controller = this.get('controller');
      controller.loadStep();
    },
    isConfigsEditable: false,
    content: function () {
      return App.router.get('mainHostDetailsController.content');
    }.property('App.router.mainHostDetailsController.content')
  });
  
});
window.require.register("views/main/host/configs_service_menu", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainHostServiceMenuView = Em.CollectionView.extend({
    content:function () {
      var host = this.get('host');
      var hostComponents = host.get('hostComponents');
      var services = Em.A([]);
      if (hostComponents) {
        hostComponents.forEach(function (hc) {
          var service = hc.get('service');
          var serviceName = service.get('serviceName');
          if(!['PIG', 'SQOOP', 'HCATALOG', 'GANGLIA'].contains(serviceName)){
            if (!services.findProperty('serviceName', serviceName)) {
              services.push(service);
            }
          }
        });
      }
      return services;
    }.property('host'),
    
    host: function(){
      return App.router.get('mainHostDetailsController.content');
    }.property('App.router.mainHostDetailsController.content'),
    
    selectedService: null,
    
    showHostService: function(event){
      var service = event.contexts[0];
      if(service!=null){
        this.set('selectedService', service);
        var context = service;
        context.host = this.get('host');
        this.get('controller').connectOutlet('service_config_outlet', 'mainHostServiceConfigs', context);
      }else{
        this.get('controller').connectOutlet('service_config_outlet', Em.View.extend({
          template: Ember.Handlebars.compile('<i class="message">Service not available on this host</i>')
        }))
      }
    },

    didInsertElement:function () {
      var event = {
          contexts: [this.get('content').objectAt(0)]
      }
      this.showHostService(event);
    },

    activeServiceId:null,

    tagName:'ul',
    classNames:["nav", "nav-list", "nav-services"],

    itemViewClass:Em.View.extend({
      classNameBindings:["active", "clients"],
      active:function () {
        return this.get('content.serviceName') == this.get('parentView.selectedService.serviceName') ? 'active' : '';
      }.property('parentView.selectedService.serviceName'),
      template: Ember.Handlebars.compile('<a href="#" {{action showHostService view.content target="view.parentView"}} >{{view.content.displayName}}</a>')
    })
  });
});
window.require.register("views/main/host/details", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var date = require('utils/date');

  App.MainHostDetailsView = Em.View.extend({
    templateName: require('templates/main/host/details'),

    content: function(){
      return App.router.get('mainHostDetailsController.content');
    }.property('App.router.mainHostDetailsController.content'),

    maintenance: function(){
      var options = [{action: 'deleteHost', 'label': this.t('hosts.host.details.deleteHost')}];
      return options;
    }.property('controller.content'),
    didInsertElement: function() {
      $("[rel='HealthTooltip']").tooltip();
    }
  });
  
});
window.require.register("views/main/host/menu", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainHostMenuView = Em.CollectionView.extend({
    tagName: 'ul',
    classNames: ["nav", "nav-tabs"],
    content: function () {
      var array = [ {
        label: 'Summary',
        routing: 'summary'
      }
      /* { label:'Audit', routing:'audit'} */
      ];
      if (App.supports.hostOverrides) {
        array.push({
          label: 'Configs',
          routing: 'configs'
        });
      }
      return array;
    }.property(''),

    init: function(){ this._super(); this.activateView(); },

    activateView:function () {
      $.each(this._childViews, function () {
        this.set('active', (this.get('content.routing') == 'summary' ? "active" : ""));
      });
    },

    deactivateChildViews: function() {
      $.each(this._childViews, function(){
        this.set('active', "");
      });
    },

    itemViewClass: Em.View.extend({
      classNameBindings: ["active"],
      active: "",
      template: Ember.Handlebars.compile('<a {{action hostNavigate view.content.routing }} href="#"> {{unbound view.content.label}}</a>')
    })
  });
});
window.require.register("views/main/host/metrics", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainHostMetricsView = Em.View.extend({
    templateName: require('templates/main/host/metrics'),
    content:function(){
      return App.router.get('mainHostDetailsController.content');
    }.property('App.router.mainHostDetailsController.content')
  });
});
window.require.register("views/main/host/metrics/cpu", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing Host CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartHostMetricsCPU = App.ChartLinearTimeView.extend({
    id: "host-metrics-cpu",
    title: Em.I18n.t('hosts.host.metrics.cpu'),
    yAxisFormatter: App.ChartLinearTimeView.PercentageFormatter,

    ajaxIndex: 'host.metrics.cpu',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.cpu) {
        var cpu_idle;
        for ( var name in jsonData.metrics.cpu) {
          var displayName;
          var seriesData = jsonData.metrics.cpu[name];
          switch (name) {
            case "cpu_wio":
              displayName = Em.I18n.t('hosts.host.metrics.cpu.displayNames.cpu_wio');
              break;
            case "cpu_idle":
              displayName = Em.I18n.t('hosts.host.metrics.cpu.displayNames.cpu_idle');
              break;
            case "cpu_nice":
              displayName = Em.I18n.t('hosts.host.metrics.cpu.displayNames.cpu_nice');
              break;
            case "cpu_aidle":
              displayName = Em.I18n.t('hosts.host.metrics.cpu.displayNames.cpu_aidle');
              break;
            case "cpu_system":
              displayName = Em.I18n.t('hosts.host.metrics.cpu.displayNames.cpu_system');
              break;
            case "cpu_user":
              displayName = Em.I18n.t('hosts.host.metrics.cpu.displayNames.cpu_user');
              break;
            default:
              break;
          }
          if (seriesData) {
            var s = this.transformData(seriesData, displayName);
            if (Em.I18n.t('hosts.host.metrics.cpu.displayNames.cpu_idle') == s.name) {
              cpu_idle = s;
            }
            else {
              seriesArray.push(s);
            }
          }
        }
        seriesArray.push(cpu_idle);
      }
      return seriesArray;
    },

    colorForSeries: function (series) {
      if (Em.I18n.t('hosts.host.metrics.cpu.displayNames.cpu_idle') == series.name) {
        return '#CFECEC';
      }
      return null;
    }
  });
});
window.require.register("views/main/host/metrics/disk", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing host disk usage
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartHostMetricsDisk = App.ChartLinearTimeView.extend({
    id: "host-metrics-disk",
    title: Em.I18n.t('hosts.host.metrics.disk'),
    yAxisFormatter: App.ChartLinearTimeView.BytesFormatter,
    renderer: 'line',

    ajaxIndex: 'host.metrics.disk',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      var GB = Math.pow(2, 30);
      if (jsonData && jsonData.metrics && jsonData.metrics.disk) {
        if(jsonData.metrics.part_max_used){
          jsonData.metrics.disk.part_max_used = jsonData.metrics.part_max_used;
        }
        for ( var name in jsonData.metrics.disk) {
          var displayName;
          var seriesData = jsonData.metrics.disk[name];
          switch (name) {
            case "disk_total":
              displayName = Em.I18n.t('hosts.host.metrics.disk.displayNames.disk_total');
              break;
            case "disk_free":
              displayName = Em.I18n.t('hosts.host.metrics.disk.displayNames.disk_free');
              break;
            default:
              break;
          }
          if (seriesData) {
            var s = this.transformData(seriesData, displayName);
            for (var i = 0; i < s.data.length; i++) {
              s.data[i].y *= GB;
            }
            seriesArray.push(s);
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/host/metrics/load", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing host load
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartHostMetricsLoad = App.ChartLinearTimeView.extend({
    id: "host-metrics-load",
    title: Em.I18n.t('hosts.host.metrics.load'),
    renderer: 'line',

    ajaxIndex: 'host.metrics.load',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.load) {
        for ( var name in jsonData.metrics.load) {
          var displayName;
          var seriesData = jsonData.metrics.load[name];
          switch (name) {
            case "load_fifteen":
              displayName = Em.I18n.t('hosts.host.metrics.load.displayNames.load_fifteen');
              break;
            case "load_one":
              displayName = Em.I18n.t('hosts.host.metrics.load.displayNames.load_one');
              break;
            case "load_five":
              displayName = Em.I18n.t('hosts.host.metrics.load.displayNames.load_five');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/host/metrics/memory", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing host memory metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartHostMetricsMemory = App.ChartLinearTimeView.extend({
    id: "host-metrics-memory",
    title: Em.I18n.t('hosts.host.metrics.memory'),
    yAxisFormatter: App.ChartLinearTimeView.BytesFormatter,
    renderer: 'line',

    ajaxIndex: 'host.metrics.memory',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      var KB = Math.pow(2, 10);
      if (jsonData && jsonData.metrics && jsonData.metrics.memory) {
        for ( var name in jsonData.metrics.memory) {
          var displayName;
          var seriesData = jsonData.metrics.memory[name];
          switch (name) {
            case "mem_shared":
              displayName = Em.I18n.t('hosts.host.metrics.memory.displayNames.mem_shared');
              break;
            case "swap_free":
              displayName = Em.I18n.t('hosts.host.metrics.memory.displayNames.swap_free');
              break;
            case "mem_buffers":
              displayName = Em.I18n.t('hosts.host.metrics.memory.displayNames.mem_buffers');
              break;
            case "mem_free":
              displayName = Em.I18n.t('hosts.host.metrics.memory.displayNames.mem_free');
              break;
            case "mem_cached":
              displayName = Em.I18n.t('hosts.host.metrics.memory.displayNames.mem_cached');
              break;
            default:
              break;
          }
          if (seriesData) {
            var s = this.transformData(seriesData, displayName);
            for (var i = 0; i < s.data.length; i++) {
              s.data[i].y *= KB;
            }
            seriesArray.push(s);
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/host/metrics/network", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing host network metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartHostMetricsNetwork = App.ChartLinearTimeView.extend({
    id: "host-metrics-network",
    title: Em.I18n.t('hosts.host.metrics.network'),
    yAxisFormatter: App.ChartLinearTimeView.BytesFormatter,
    renderer: 'line',

    ajaxIndex: 'host.metrics.network',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.network) {
        for ( var name in jsonData.metrics.network) {
          var displayName;
          var seriesData = jsonData.metrics.network[name];
          switch (name) {
            case "pkts_out":
              displayName = Em.I18n.t('hosts.host.metrics.network.displayNames.pkts_out');
              break;
            case "bytes_in":
              displayName = Em.I18n.t('hosts.host.metrics.network.displayNames.bytes_in');
              break;
            case "bytes_out":
              displayName = Em.I18n.t('hosts.host.metrics.network.displayNames.bytes_out');
              break;
            case "pkts_in":
              displayName = Em.I18n.t('hosts.host.metrics.network.displayNames.pkts_in');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/host/metrics/processes", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing host process counts
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartHostMetricsProcesses = App.ChartLinearTimeView.extend({
    id: "host-metrics-processes",
    title: Em.I18n.t('hosts.host.metrics.processes'),
    renderer: 'line',

    ajaxIndex: 'host.metrics.processes',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.process) {
        for ( var name in jsonData.metrics.process) {
          var displayName;
          var seriesData = jsonData.metrics.process[name];
          switch (name) {
            case "proc_total":
              displayName = Em.I18n.t('hosts.host.metrics.processes.displayNames.proc_total');
              break;
            case "proc_run":
              displayName = Em.I18n.t('hosts.host.metrics.processes.displayNames.proc_run');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/host/summary", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var uiEffects = require('utils/ui_effects');

  App.MainHostSummaryView = Em.View.extend({
    templateName: require('templates/main/host/summary'),

    content: function () {
      return App.router.get('mainHostDetailsController.content');
    }.property('App.router.mainHostDetailsController.content'),

    showGangliaCharts: function () {
      var name = this.get('content.hostName');
      var gangliaMobileUrl = App.router.get('clusterController.gangliaUrl') + "/mobile_helper.php?show_host_metrics=1&h=" + name + "&c=HDPNameNode&r=hour&cs=&ce=";
      window.open(gangliaMobileUrl);
    },

    /**
     * @type: [{String}]
     */
    decommissionDataNodeHostNames: null,

    loadDecommissionNodesList: function () {
      var self = this;
      var clusterName = App.router.get('clusterController.clusterName');
      var persistUrl = App.apiPrefix + '/persist';
      var clusterUrl = App.apiPrefix + '/clusters/' + clusterName;
      var getConfigAjax = {
        type: 'GET',
        url: persistUrl,
        dataType: 'json',
        timeout: App.timeout,
        success: function (data) {
          if (data && data.decommissionDataNodesTag) {
            // We know the tag which contains the decommisioned nodes.
            var configsUrl = clusterUrl + '/configurations?type=hdfs-exclude-file&tag=' + data.decommissionDataNodesTag;
            var decomNodesAjax = {
              type: 'GET',
              url: configsUrl,
              dataType: 'json',
              timeout: App.timeout,
              success: function (data) {
                if (data && data.items) {
                  var csv = data.items[0].properties.datanodes;
                  self.set('decommissionDataNodeHostNames', csv.split(','));
                }
              },
              error: function (xhr, textStatus, errorThrown) {
                console.log(textStatus);
                console.log(errorThrown);
              }
            };
            jQuery.ajax(decomNodesAjax);
          }
        },
        error: function (xhr, textStatus, errorThrown) {
          // No tag pointer in persist. Rely on service's decomNodes.
          var hdfsSvcs = App.HDFSService.find();
          if (hdfsSvcs && hdfsSvcs.get('length') > 0) {
            var hdfsSvc = hdfsSvcs.objectAt(0);
            if (hdfsSvc) {
              var hostNames = [];
              var decomNodes = hdfsSvc.get('decommissionDataNodes');
              decomNodes.forEach(function (decomNode) {
                hostNames.push(decomNode.get('hostName'));
              });
              self.set('decommissionDataNodeHostNames', hostNames);
            }
          }
        }
      }
      jQuery.ajax(getConfigAjax);
    },
    didInsertElement: function () {
      this.loadDecommissionNodesList();
    },
    sortedComponents: function () {
      var slaveComponents = [];
      var masterComponents = [];
      this.get('content.hostComponents').forEach(function (component) {
        if (component.get('workStatus') != 'INSTALLING') {
          if (component.get('isMaster')) {
            masterComponents.push(component);
          } else if (component.get('isSlave')) {
            slaveComponents.push(component);
          }
        }

      }, this);
      return masterComponents.concat(slaveComponents);
    }.property('content', 'content.hostComponents.length'),
    clients: function () {
      var clients = [];
      this.get('content.hostComponents').forEach(function (component) {
        if (!component.get('componentName')) {
          //temporary fix because of different data in hostComponents and serviceComponents
          return;
        }
        if (!component.get('isSlave') && !component.get('isMaster')) {
          if (clients.length) {
            clients[clients.length - 1].set('isLast', false);
          }
          component.set('isLast', true);
          clients.push(component);
        }
      }, this);
      return clients;
    }.property('content'),

    addableComponentObject: Em.Object.extend({
      componentName: '',
      displayName: function () {
        return App.format.role(this.get('componentName'));
      }.property('componentName')
    }),
    isAddComponent: function () {
      return this.get('content.healthClass') !== 'health-status-DEAD-YELLOW';
    }.property('content.healthClass'),
    addableComponents: function () {
      var components = [];
      var services = App.Service.find();
      var dataNodeExists = false;
      var taskTrackerExists = false;
      var regionServerExists = false;

      this.get('content.hostComponents').forEach(function (component) {
        switch (component.get('componentName')) {
          case 'DATANODE':
            dataNodeExists = true;
            break;
          case 'TASKTRACKER':
            taskTrackerExists = true;
            break;
          case 'HBASE_REGIONSERVER':
            regionServerExists = true;
            break;
        }
      }, this);

      if (!dataNodeExists) {
        components.pushObject(this.addableComponentObject.create({ 'componentName': 'DATANODE' }));
      }
      if (!taskTrackerExists && services.findProperty('serviceName', 'MAPREDUCE')) {
        components.pushObject(this.addableComponentObject.create({ 'componentName': 'TASKTRACKER' }));
      }
      if (!regionServerExists && services.findProperty('serviceName', 'HBASE')) {
        components.pushObject(this.addableComponentObject.create({ 'componentName': 'HBASE_REGIONSERVER' }));
      }
      return components;
    }.property('content', 'content.hostComponents.length'),

    ComponentView: Em.View.extend({
      content: null,
      didInsertElement: function () {
        if (this.get('isInProgress')) {
          this.doBlinking();
        }
      },
      hostComponent: function () {
        var hostComponent = null;
        var serviceComponent = this.get('content');
        var host = App.router.get('mainHostDetailsController.content');
        if (host) {
          hostComponent = host.get('hostComponents').findProperty('componentName', serviceComponent.get('componentName'));
        }
        return hostComponent;
      }.property('content', 'App.router.mainHostDetailsController.content'),
      workStatus: function () {
        var workStatus = this.get('content.workStatus');
        var hostComponent = this.get('hostComponent');
        if (hostComponent) {
          workStatus = hostComponent.get('workStatus');
        }
        return workStatus;
      }.property('content.workStatus', 'hostComponent.workStatus'),

      /**
       * Return host component text status
       */
      componentTextStatus: function () {
        var workStatus = this.get("workStatus");
        var componentTextStatus = this.get('content.componentTextStatus');
        var hostComponent = this.get('hostComponent');
        if (hostComponent) {
          componentTextStatus = hostComponent.get('componentTextStatus');
          if(this.get("isDataNode"))
            if(this.get('isDataNodeRecommissionAvailable')){
              if(App.HostComponentStatus.started == workStatus){
                componentTextStatus = "Decommissioning...";
              }else if(App.HostComponentStatus.stopped == workStatus){
                componentTextStatus = "Decommissioned";
              }
            }
        }
        return componentTextStatus;
      }.property('workStatus','isDataNodeRecommissionAvailable'),

      statusClass: function () {
        var statusClass = null;

        //If the component is DataNode
        if (this.get('isDataNode')) {
          if (this.get('isDataNodeRecommissionAvailable') && (this.get('isStart') || this.get('workStatus') == 'INSTALLED')) {
            return 'health-status-DEAD-ORANGE';
          }
        }

        //Class when install failed
        if (this.get('workStatus') === App.HostComponentStatus.install_failed) {
          return 'health-status-color-red icon-cog';
        }

        //Class when installing
        if (this.get('workStatus') === App.HostComponentStatus.installing) {
          return 'health-status-color-blue icon-cog';
        }

        //For all other cases
        return 'health-status-' + App.HostComponentStatus.getKeyName(this.get('workStatus'));
      }.property('workStatus', 'isDataNodeRecommissionAvailable', 'this.content.isDecommissioning'),
      /**
       * For Upgrade failed state
       */
      isUpgradeFailed: function () {
        return App.HostComponentStatus.getKeyName(this.get('workStatus')) === "upgrade_failed";
      }.property("workStatus"),
      /**
       * For Install failed state
       */
      isInstallFailed: function () {
        return App.HostComponentStatus.getKeyName(this.get('workStatus')) === "install_failed";
      }.property("workStatus"),
      /**
       * Do blinking for 1 minute
       */
      doBlinking: function () {
        var workStatus = this.get('workStatus');
        var self = this;
        var pulsate = [ App.HostComponentStatus.starting, App.HostComponentStatus.stopping ].contains(workStatus);
        if (!pulsate && this.get('isDataNode')) {
          var dataNodeComponent = this.get('content');
          if (dataNodeComponent && workStatus != "INSTALLED") {
            pulsate = this.get('isDataNodeRecommissionAvailable');
          }
        }
        if (pulsate && !self.get('isBlinking')) {
          self.set('isBlinking', true);
          uiEffects.pulsate(self.$('.components-health'), 1000, function () {
            !self.get('isDestroyed') && self.set('isBlinking', false);
            self.doBlinking();
          });
        }
      },
      /**
       * Start blinking when host component is starting/stopping
       */
      startBlinking: function () {
        this.$('.components-health').stop(true, true);
        this.$('.components-health').css({opacity: 1.0});
        this.doBlinking();
      }.observes('workStatus','isDataNodeRecommissionAvailable'),

      isStart: function () {
        return (this.get('workStatus') == App.HostComponentStatus.started || this.get('workStatus') == App.HostComponentStatus.starting);
      }.property('workStatus'),

      /**
       * No action available while component is starting/stopping/unknown
       */
      noActionAvailable: function () {
        var workStatus = this.get('workStatus');
        if ([App.HostComponentStatus.starting, App.HostComponentStatus.stopping, App.HostComponentStatus.unknown].contains(workStatus)) {
          return "hidden";
        }else{
          return "";
        }
      }.property('workStatus'),

      isInProgress: function () {
        return (this.get('workStatus') === App.HostComponentStatus.stopping || this.get('workStatus') === App.HostComponentStatus.starting) || this.get('isDataNodeRecommissionAvailable');
      }.property('workStatus', 'isDataNodeRecommissionAvailable'),
      /**
       * Shows whether we need to show Decommision/Recomission buttons
       */
      isDataNode: function () {
        return this.get('content.componentName') === 'DATANODE';
      }.property('content'),

      isDecommissioning: function () {
        return this.get('isDataNode') &&  this.get("isDataNodeRecommissionAvailable");
      }.property("workStatus", "isDataNodeRecommissionAvailable"),

      /**
       * Set in template via binding from parent view
       */
      decommissionDataNodeHostNames: null,
      /**
       * Decommission is available whenever the service is started.
       */
      isDataNodeDecommissionAvailable: function () {
        return this.get('isStart') && !this.get('isDataNodeRecommissionAvailable');
      }.property('isStart', 'isDataNodeRecommissionAvailable'),

      /**
       * Recommission is available only when this hostname shows up in the
       * 'decommissionDataNodeHostNames'
       */
      isDataNodeRecommissionAvailable: function () {
        var decommissionHostNames = this.get('decommissionDataNodeHostNames');
        var hostName = App.router.get('mainHostDetailsController.content.hostName');
        return decommissionHostNames != null && decommissionHostNames.contains(hostName);
      }.property('App.router.mainHostDetailsController.content', 'decommissionDataNodeHostNames')

    }),
    timeSinceHeartBeat: function () {
      var d = this.get('content.lastHeartBeatTime');
      if (d) {
        return $.timeago(d);
      }
      return "";
    }.property('content.lastHeartBeatTime')
  });
});
window.require.register("views/main/menu", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var stringUtils = require('utils/string_utils');

  /**
   * this menu extended by other with modifying content and itemViewClass.template
   * @type {*}
   */
  App.MainMenuView = Em.CollectionView.extend({
    tagName:'ul',
    classNames:['nav'],
    content:function(){
      var result = [
        { label:Em.I18n.t('menu.item.dashboard'), routing:'dashboard', active:'active'},
        { label:Em.I18n.t('menu.item.heatmaps'), routing:'charts'},
        { label:Em.I18n.t('menu.item.services'), routing:'services'},
        { label:Em.I18n.t('menu.item.hosts'), routing:'hosts'}
      ];

      if (App.supports.mirroring) {
        result.push({ label:Em.I18n.t('menu.item.mirroring'), routing:'mirroring'});
      }

      if (stringUtils.compareVersions(App.get('currentStackVersionNumber'), "2.0") === -1) {
        result.push({ label:Em.I18n.t('menu.item.jobs'), routing:'apps'});
      }

      if (App.get('isAdmin')) {
        result.push({ label:Em.I18n.t('menu.item.admin'), routing:'admin'});
      }
      return result;
    }.property(),
      /**
       *    Adds observer on lastSetURL and calls navigation sync procedure
       */
    didInsertElement:function () {
      App.router.location.addObserver('lastSetURL', this, 'renderOnRoute');
      this.renderOnRoute();
    },

    /**
     *    Syncs navigation menu with requested URL
     */
    renderOnRoute:function () {
      var last_url = App.router.location.lastSetURL || location.href.replace(/^[^#]*#/, '');
      if (last_url.substr(1, 4) !== 'main' || !this._childViews) {
        return;
      }
      var reg = /^\/main\/([a-z]+)/g;
      var sub_url = reg.exec(last_url);
      var chunk = (null != sub_url) ? sub_url[1] : 'dashboard';
      $.each(this._childViews, function () {
        this.set('active', this.get('content.routing') == chunk ? "active" : "");
      });
    },

    itemViewClass:Em.View.extend({

      classNameBindings:['active', ':span2'],
      active:'',

      alertsCount:function () {
        if (this.get('content').routing == 'hosts') {
          return App.router.get('mainHostController.alerts').length;
        }
      }.property('App.router.mainHostController.alerts.length'),

      templateName: require('templates/main/menu_item')
    })
  });
});
window.require.register("views/main/mirroring/dataset_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var filters = require('views/common/filter_view');
  var sort = require('views/common/sort_view');
  var date = require('utils/date');

  App.MainMirroringDataSetView = Em.View.extend({
    name: 'mainMirroringDataSetView',
    templateName: require('templates/main/mirroring/dataset'),
    repeatNumberSelected: null,
    repeatOptions: Ember.Object.create({
      repeatOptionSelected: function (key, value) {
        if (value) {
          // setter
          var content = this.get('content');
          for (var i = 0; i < content.length; i++) {
            if (content.objectAt(i).get('value').toLowerCase() === value.get('value').toLowerCase())
              return content.objectAt(i);
          }
        }
        return this.get('content').objectAt(0);
      }.property(),
      content: function () {
        return [
          Ember.Object.create({ value: "Days"}),
          Ember.Object.create({ value: "Weeks"}),
          Ember.Object.create({ value: "Hours"}),
          Ember.Object.create({ value: "Minutes"})
        ];
      }.property('controller.model.newDataSet')
    }),
    rawDataset: null,

    targetClusterSelect: App.MainMirroringDropdownView.extend({

      selected: function (key, manuallySelectedElement) {
        // getter
        if (arguments.length == 1) {
          var targetClusterSelected = this.get('controller.model.newDataSet.targetCluster.clusterName');

          if (targetClusterSelected && targetClusterSelected.trim() !== '') {
            var newClusterOption = Ember.Object.create({title: targetClusterSelected, value: ''});
            return newClusterOption;
          }
          else {
            var defaultSelect = Ember.Object.create({title: Em.I18n.t('mirroring.dataset.selectTargetClusters'), value: ''});
            return defaultSelect;
          }
        } else {
          //setter ( if we manually change the dropdown option )
          return manuallySelectedElement;

        }
      }.property('controller.model.newDataSet.targetCluster'),

      controller: App.get('router.mainMirroringDataSetController'),

      listOfOptions: function () {
        var listOfTargetClusterNames = this.get('controller.model.listOfTargetClusterNames');
        var returnValue = [];
        if (listOfTargetClusterNames) {
          listOfTargetClusterNames.forEach(
            function (targetClusterName) {
              returnValue.push({
                title: targetClusterName,
                value: ''
              });

            }, this);

          returnValue.push({
            title: Em.I18n.t('mirroring.dataset.addTargetCluster'),
            value: ''
          });

        }
        return returnValue;
      }.property('controller.model.listOfTargetClusterNames'),

      select: function (event) {
        if (event.currentTarget.innerText === Em.I18n.t('mirroring.dataset.addTargetCluster')) {
          this.get('controller').createTargetCluster();
        }
        else {
          var selected = event.context;
          this.set('selected', selected);
          // var targetClusterRecord = App.TargetCluster.find({clusterName : selected.title});  NOT WORKING. Not sure. Why.
          var targetClusterRecord = App.TargetCluster.find().findProperty("clusterName", selected.title); // WORKING
          this.set('controller.model.newDataSet.targetCluster', targetClusterRecord);
        }
      }

    }),

    dayOrNightOptions: function (key, value) {
      var obj = Ember.Object.create({
        content: [
          Ember.Object.create({name: "AM", value: 'AM'}),
          Ember.Object.create({name: "PM", value: 'PM'})
        ]
      });

      if (value) {
        // setter
        obj.set('selectedForStart', Ember.Object.create({name: value.selectedForStart, value: value.selectedForStart}));
        obj.set('selectedForEnd', Ember.Object.create({name: value.selectedForEnd, value: value.selectedForEnd}));
      } else {
        obj.set('selectedForStart', obj.content.objectAt(0));
        obj.set('selectedForEnd', obj.content.objectAt(0));
      }

      return obj;

    }.property('controller.model.newDataSet'),

    hourOptions: Ember.Object.create({
      selectedForStart: function (key, value) {
        console.debug('selectedForStart value : ' + value);
        if (value) {
          var content = this.get('content');
          for (var i = 0; i < content.length; i++) {
            if (parseInt(content.objectAt(i).get('value')) === parseInt(value.get('value')))
              return content.objectAt(i);
          }
        }
        return this.get('content').objectAt(0);
      }.property('controller.model.newDataSet'),

      selectedForEnd: function (key, value) {
        if (value) {
          var content = this.get('content');
          for (var i = 0; i < content.length; i++) {
            if (parseInt(content.objectAt(i).get('value')) === parseInt(value.get('value')))
              return content.objectAt(i);
          }
        }
        return this.get('content').objectAt(0);
      }.property('controller.model.newDataSet'),

      content: function () {
        var values = [];
        for (var i = 0; i < 12; i++) {
          if (i == 0)
            values.push(Ember.Object.create({value: '12'}));
          else
            values.push(Ember.Object.create({value: (i < 10 ? '0' + i : '' + i)}));
        }
        return values;
      }.property()
    }),

    minuteOptions: Ember.Object.create({
      selectedForStart: function (key, value) {
        if (value) {
          var content = this.get('content');
          for (var i = 0; i < content.length; i++) {
            if (parseInt(content.objectAt(i).get('value')) === parseInt(value.get('value')))
              return content.objectAt(i);
          }
        }
        return this.get('content').objectAt(0);
      }.property('controller.model.newDataSet'),

      selectedForEnd: function (key, value) {
        if (value) {
          var content = this.get('content');
          for (var i = 0; i < content.length; i++) {
            if (parseInt(content.objectAt(i).get('value')) === parseInt(value.get('value')))
              return content.objectAt(i);
          }
        }
        return this.get('content').objectAt(0);
      }.property('controller.model.newDataSet'),

      content: function () {
        var values = [];
        for (var i = 0; i < 60; i += 5) {
          values.push(Ember.Object.create({value: (i < 10 ? '0' + i : '' + i)}));
        }
        return values;
      }.property()
    }),

    /*
     // May be used in future
     timeOptions: Ember.Object.create({

     selectedForStart: 1,
     selectedForEnd: 1,
     content: function () {
     var values = [];
     for (var i = 0; i < 24; i++) {
     var j = i;
     if (j == 0) {
     j = 12;
     }
     else if (j > 12) {
     j = j % 12;
     }

     values.push((j < 10 ? '0' + j : '' + j) + (i < 12 ? ':00am' : ':00pm'));
     values.push((j < 10 ? '0' + j : '' + j) + (i < 12 ? ':30am' : ':30pm'));

     }
     return values;
     }.property()
     }),

     */

    /*
     idChanged: function() {
     var newDataSet = this.get('newDataSet');
     if( newDataSet && newDataSet.name ){
     var re = new RegExp(" ", "g");
     newDataSet.id = newDataSet.name.replace(re, "_");
     var schedule = newDataSet.getSchedule();
     schedule.set('id',newDataSet.id);
     }

     }.observes('newDataSet.name'),
     */
    scheduleChangedOnUI: function () {

      var isPleaseIgnoreListener = this.get('isPleaseIgnoreListener');
      if (isPleaseIgnoreListener) {
        return;
      }

      var isPleaseIgnoreListener = this.get('isPleaseIgnoreListener');


      var newDataSet = this.get('controller.model.newDataSet');

      var schedule = newDataSet.get('schedule');

      var startTime = this.get('hourOptions.selectedForStart.value') + ':' + this.get('minuteOptions.selectedForStart.value') + ':' + this.get('dayOrNightOptions.selectedForStart.value');
      var endTime = this.get('hourOptions.selectedForEnd.value') + ':' + this.get('minuteOptions.selectedForEnd.value') + ':' + this.get('dayOrNightOptions.selectedForEnd.value');
      var timezone = 'UTC'; // TODO : Need to set this correctly
      var frequency = this.get('repeatOptions.repeatOptionSelected.value') + '(' + this.get('repeatNumberSelected') + ')';

      schedule.set('startTime', startTime);
      schedule.set('endTime', endTime);
      schedule.set('timezone', timezone);
      schedule.set('frequency', frequency);
      schedule.set('dataset', newDataSet);

      //1. We need to find start time, end time
      //2. We need to
    }.observes('hourOptions.selectedForStart.value', 'hourOptions.selectedForEnd.value', 'minuteOptions.selectedForStart.value', 'minuteOptions.selectedForEnd.value', 'dayOrNightOptions.selectedForStart.value', 'dayOrNightOptions.selectedForEnd.value', 'repeatOptions.repeatOptionSelected.value', 'repeatNumberSelected'),


    isPleaseIgnoreListener: false,

    updateScheduleOnUI: function () {
      this.set('isPleaseIgnoreListener', true);
      var newDataSet = this.get('controller.model.newDataSet');

      var schedule = newDataSet.get('schedule');

      // this.notifyPropertyChange("hourOptions.selectedForStart.value");
      var startTime = schedule.get('startTime');
      var endTime = schedule.get('endTime');
      var timezone = schedule.get('timezone'); // TODO : Need to handle this correctly
      var frequency = schedule.get('frequency');
      var repeatNumberSelected = frequency.substring(frequency.indexOf('(') + 1, frequency.indexOf(')'));
      var repeatOptionSelected = frequency.substring(0, frequency.indexOf('('));

      this.set('repeatNumberSelected', repeatNumberSelected);
      this.set('repeatOptions.repeatOptionSelected', Ember.Object.create({value: repeatOptionSelected}));

      var startTimeOptions = startTime.split(':');
      var endTimeOptions = endTime.split(':');

      var startHour = startTimeOptions[0];
      var startMinute = startTimeOptions[1];
      var startAMPM = startTimeOptions[2];

      var endHour = endTimeOptions[0];
      var endMinute = endTimeOptions[1];
      var endAMPM = endTimeOptions[2];

      this.set('dayOrNightOptions',
        {
          selectedForStart: startAMPM,
          selectedForEnd: endAMPM
        });

      this.set('hourOptions.selectedForStart', Ember.Object.create({value: startHour}));
      this.set('hourOptions.selectedForEnd', Ember.Object.create({value: endHour}));
      this.set('minuteOptions.selectedForStart', Ember.Object.create({value: startMinute}));
      this.set('minuteOptions.selectedForEnd', Ember.Object.create({value: endMinute}));
      this.set('isPleaseIgnoreListener', false);
    },

    /**
     * When View is displayed, it asks the controller "Give me the Model".
     */
    didInsertElement: function () {
      console.debug('In didInsertElement');
      var controller = this.get('controller');

      // Load model and expose to view
      var ds = controller.get('model.newDataSet');

      if (this.get('controller.isPopupForEdit'))
        this.updateScheduleOnUI();


      // copy dataset for "undo" ability
      var props = Em.Object.create();
      for (var prop in ds) {
        if (ds.hasOwnProperty(prop)
          && prop.indexOf('__ember') < 0
          && prop.indexOf('_super') < 0
          && Em.typeOf(ds.get(prop)) !== 'function'
          ) {
          props.set(prop, ds.get(prop));
        }
      }
      this.set('controller.rawDataSet', props);

      $('.datepicker').datepicker({
        format: 'mm/dd/yyyy'
      });
    }



  });
  
});
window.require.register("views/main/mirroring/datasets_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var filters = require('views/common/filter_view');
  var sort = require('views/common/sort_view');

  App.MainDatasetsView = App.TableView.extend({
    name: 'mainDatasetsView',
    templateName: require('templates/main/mirroring/datasets'),
    content: function () {
      return this.get('controller.datasets');
    }.property('controller.datasets'),

    jobs: function () {
      return App.DataSetJob.find().slice(0, 2);
    }.property(),

    targetClusters: function () {
      return this.get('controller.targetClusters');
    }.property('controller.targetClusters'),

    showClusterPopup: function (event) {
      return App.ModalPopup.show({
        header: Em.I18n.t('mirroring.sidebar.popup.clusters.header'),
        bodyClass: Em.View.extend({
          template: Em.Handlebars.compile("{{t mirroring.sidebar.popup.clusters.body}}")
        }),
        onPrimary: function () {
          this.hide();
        }
      });
    },

    sortView: sort.wrapperView,
    nameSort: sort.fieldView.extend({
      name: 'name',
      displayName: Em.I18n.t('common.name')
    }),
    dataSetSourceSort: sort.fieldView.extend({
      name: 'sourceDir',
      displayName: Em.I18n.t('mirroring.table.datasetSource')
    }),
    lastSuccessSort: sort.fieldView.extend({
      name: 'lastSucceededDate',
      displayName: Em.I18n.t('mirroring.table.lastSuccess'),
      type: 'number'
    }),
    lastFailSort: sort.fieldView.extend({
      name: 'lastFailedDate',
      displayName: Em.I18n.t('mirroring.table.lastFail'),
      type: 'number'
    }),
    lastDurationSort: sort.fieldView.extend({
      name: 'lastDuration',
      displayName: Em.I18n.t('mirroring.table.lastDuration'),
      type: 'number'
    }),
    avgDataSort: sort.fieldView.extend({
      name: 'avgData',
      displayName: Em.I18n.t('mirroring.table.avgData'),
      type: 'number'
    }),

    /**
     * Filter view for name column
     * Based on <code>filters</code> library
     */
    nameFilterView: filters.createTextView({
      fieldType: 'input-small',
      column: 1,
      onChangeValue: function () {
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'string');
      }
    }),

    datasetSourceFilterView: filters.createTextView({
      fieldType: 'input-small',
      column: 2,
      onChangeValue: function () {
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'string');
      }
    }),

    lastSuccessFilterView: filters.createSelectView({
      fieldType: 'input-medium',
      column: 3,
      content: ['Any', 'Past 1 Day', 'Past 2 Days', 'Past 7 Days', 'Past 14 Days', 'Past 30 Days'],
      onChangeValue: function () {
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'date');
      }
    }),

    lastFailFilterView: filters.createSelectView({
      fieldType: 'input-medium',
      column: 4,
      content: ['Any', 'Past 1 Day', 'Past 2 Days', 'Past 7 Days', 'Past 14 Days', 'Past 30 Days'],
      onChangeValue: function () {
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'date');
      }
    }),

    lastDurationFilterView: filters.createTextView({
      fieldType: 'input-small',
      column: 5,
      onChangeValue: function () {
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'duration');
      }
    }),

    avgDataFilterView: filters.createTextView({
      fieldType: 'input-small',
      column: 6,
      onChangeValue: function () {
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'ambari-bandwidth');
      }
    }),

    DatasetView: Em.View.extend({
      content: null,
      tagName: 'tr',

      lastDurationFormatted: function () {
        var milliseconds = this.get('content.lastDuration');
        var h = Math.floor(milliseconds / 3600000);
        var m = Math.floor((milliseconds % 3600000) / 60000);
        var s = Math.floor(((milliseconds % 360000) % 60000) / 1000);
        return (h == 0 ? '' : h + 'hr ') + (m == 0 ? '' : m + 'mins ') + (s == 0 ? '' : s + 'secs ');
      }.property('content.lastDuration'),

      lastSucceededDateFormatted: function () {
        if (this.get('content.lastSucceededDate')) {
          return $.timeago(this.get('content.lastSucceededDate'));
        }
      }.property('content.lastSucceededDate'),

      lastFailedDateFormatted: function () {
        if (this.get('content.lastFailedDate')) {
          return $.timeago(this.get('content.lastFailedDate'));
        }
      }.property('content.lastFailedDate')
    }),

    /**
     * associations between dataset property and column index
     */
    colPropAssoc: function () {
      var associations = [];
      associations[1] = 'name';
      associations[2] = 'sourceDir';
      associations[3] = 'lastSucceededDate';
      associations[4] = 'lastFailedDate';
      associations[5] = 'lastDuration';
      associations[6] = 'avgData';
      return associations;
    }.property()

  });
  
});
window.require.register("views/main/mirroring/dropdown_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var filters = require('views/common/filter_view');
  var sort = require('views/common/sort_view');
  var date = require('utils/date');

  App.MainMirroringDropdownView = Em.View.extend({

    name : 'mainMirroringDropdownSelect',

    templateName:require('templates/main/mirroring/dropdown'),

    selected: Ember.Object.create({title: 'Select', value: ''}),

    listOfOptions : null,

    select: function(event){
      var selected = event.context;
      this.set('selected', selected);
    },

    didInsertElement:function () {
      console.debug('In didInsertElement');
      var controller = this.get('controller');
    }
  })
});
window.require.register("views/main/mirroring/jobs_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var filters = require('views/common/filter_view');
  var sort = require('views/common/sort_view');

  App.MainJobsView = App.TableView.extend({
    templateName: require('templates/main/mirroring/jobs'),
    content: function () {
      return this.get('controller.jobs');
    }.property('controller.jobs'),

    didInsertElement: function () {
      this.set('content', this.get('controller.jobs'));
    },

    dataset: function () {
      return this.get('controller.content');
    }.property('controller.content'),

    sortView: sort.wrapperView,
    idSort: sort.fieldView.extend({
      name: 'id',
      displayName: Em.I18n.t('mirroring.table.jobId'),
      type: 'number'
    }),
    startSort: sort.fieldView.extend({
      name: 'startDate',
      displayName: Em.I18n.t('mirroring.table.start'),
      type: 'number'
    }),
    endSort: sort.fieldView.extend({
      name: 'endDate',
      displayName: Em.I18n.t('mirroring.table.end'),
      type: 'number'
    }),
    durationSort: sort.fieldView.extend({
      name: 'duration',
      displayName: Em.I18n.t('mirroring.table.duration'),
      type: 'number'
    }),
    dataSort: sort.fieldView.extend({
      name: 'data',
      displayName: Em.I18n.t('mirroring.table.data'),
      type: 'number'
    }),

    /**
     * Filter view for name column
     * Based on <code>filters</code> library
     */
    idFilterView: filters.createTextView({
      fieldType: 'input-small',
      column: 1,
      onChangeValue: function () {
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'number');
      }
    }),

    startFilterView: filters.createSelectView({
      fieldType: 'input-small',
      column: 2,
      content: ['Any', 'Past 1 Day', 'Past 2 Days', 'Past 7 Days', 'Past 14 Days', 'Past 30 Days'],
      onChangeValue: function () {
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'date');
      }
    }),

    endFilterView: filters.createSelectView({
      fieldType: 'input-medium',
      column: 3,
      content: ['Any', 'Past 1 Day', 'Past 2 Days', 'Past 7 Days', 'Past 14 Days', 'Past 30 Days'],
      onChangeValue: function () {
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'date');
      }
    }),

    durationFilterView: filters.createTextView({
      fieldType: 'input-medium',
      column: 4,
      onChangeValue: function () {
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'duration');
      }
    }),

    dataFilterView: filters.createTextView({
      fieldType: 'input-small',
      column: 5,
      onChangeValue: function () {
        this.get('parentView').updateFilter(this.get('column'), this.get('value'), 'ambari-bandwidth');
      }
    }),

    JobView: Em.View.extend({
      content: null,
      tagName: 'tr',
      canActionBeTaken: function () {
        var job_status = this.get('content.status');

        if (job_status == "RUNNING" || job_status == "SUSPENDED") {
          return true;
        }

        return false;

      }.property('content.status'),

      isKilled: function () {
        var job_status = this.get('content.status');
        return job_status == 'KILLED';
      }.property(),

      statusClass: function () {
        var job_status = this.get('content.status');
        switch (job_status) {
          case 'RUNNING' :
            return "btn btn-success dropdown-toggle";
            break;
          case 'SUSPENDED' :
            return "btn btn-warning dropdown-toggle";
            break;
          case 'SUCCEEDED' :
            return "label label-success";
            break;
          case 'KILLED' :
            return "label label-important";
            break;
          case 'WAITING' :
            return "label";
            break;
          case 'KILLED' :
          case 'FAILED' :
          case 'ERROR' :
            return "label label-important";
            break;
          default :
            return "label";
            break;
        }
      }.property('content.status'),

      listOfOptions: function () {
        var listOfActions = [];
        var status = this.get('content.status');
        switch (status) {
          case 'RUNNING' :
            listOfActions.push({title: 'Suspend', value: 'Suspend'});
            listOfActions.push({title: 'Abort', value: 'Abort'});
            break;
          case 'SUSPENDED' :
            listOfActions.push({title: 'Resume', value: 'Resume'});
            listOfActions.push({title: 'Abort', value: 'Abort'});
            break;
        }
        return listOfActions;
      }.property('content.status'),

      changeStatus: function (event) {
        var selected = event.context;
        var self = this;
        App.showConfirmationPopup(function () {
          switch (selected.title) {
            case 'Suspend' :
              self.set('content.status', 'SUSPENDED');
              break;
            case 'Resume' :
              self.set('content.status', 'RUNNING');
              break;
            case 'Abort' :
              self.set('content.status', 'KILLED');
              break;
          }
        });
      },

      durationFormatted: function () {
        var milliseconds = this.get('content.duration');
        var h = Math.floor(milliseconds / 3600000);
        var m = Math.floor((milliseconds % 3600000) / 60000);
        var s = Math.floor(((milliseconds % 360000) % 60000) / 1000);
        return (h == 0 ? '' : h + 'hr ') + (m == 0 ? '' : m + 'mins ') + (s == 0 ? '' : s + 'secs ');
      }.property('content.duration'),

      startFormatted: function () {
        if (this.get('content.startDate')) {
          return $.timeago(this.get('content.startDate'));
        }
      }.property('content.startDate'),

      endFormatted: function () {
        if (this.get('content.endDate')) {
          return $.timeago(this.get('content.endDate'));
        }
      }.property('content.endDate')
    }),

    /**
     * associations between dataset property and column index
     */
    colPropAssoc: function () {
      var associations = [];
      associations[1] = 'id';
      associations[2] = 'startDate';
      associations[3] = 'endDate';
      associations[4] = 'duration';
      associations[5] = 'data';
      return associations;
    }.property()



  });
  
});
window.require.register("views/main/mirroring/targetClusterView", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var filters = require('views/common/filter_view');
  var sort = require('views/common/sort_view');
  var date = require('utils/date');

  App.MainMirroringAddTargetClusterView = Em.View.extend({
    name : 'mainMirroringAddTargetClusterView',
    templateName:require('templates/main/mirroring/addTargetCluster')

  });
  
});
window.require.register("views/main/mirroring/testConnectionResults_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var filters = require('views/common/filter_view');
  var sort = require('views/common/sort_view');
  var date = require('utils/date');

  App.TestConnectionResultsView = Em.View.extend({
    templateName: require('templates/main/mirroring/testConnectionResults'),

    name: 'testConnectionResultsView',

    didInsertElement: function () {
      console.debug('In didInsertElement');
      var controller = this.get('controller');
      controller.tryConnecting();
    }
  });
  
});
window.require.register("views/main/mirroring/testConnection_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');
  var filters = require('views/common/filter_view');
  var sort = require('views/common/sort_view');
  var date = require('utils/date');

  App.TestConnectionView = Em.View.extend({
    name : 'testConnectionView',
    templateName:require('templates/main/mirroring/testConnection')
  });
  
});
window.require.register("views/main/mirroring_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainMirroringView = Em.View.extend({

    templateName: require('templates/main/mirroring')
  });
  
});
window.require.register("views/main/service", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainServiceView = Em.View.extend({
    templateName:require('templates/main/service')
  });
});
window.require.register("views/main/service/add_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.AddServiceView = Em.View.extend({

    templateName: require('templates/main/service/add'),

    isStep1Disabled: function () {
      return this.isStepDisabled(1);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep2Disabled: function () {
      return this.isStepDisabled(2);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep3Disabled: function () {
      return this.isStepDisabled(3);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep4Disabled: function () {
      return this.isStepDisabled(4);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep5Disabled: function () {
      return this.isStepDisabled(5);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep6Disabled: function () {
      return this.isStepDisabled(6);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep7Disabled: function () {
      return this.isStepDisabled(7);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStepDisabled: function (index) {
      return this.get('controller.isStepDisabled').findProperty('step', index).get('value');
    }

  });
  
});
window.require.register("views/main/service/info/configs", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainServiceInfoConfigsView = Em.View.extend({
    templateName: require('templates/main/service/info/configs'),
    didInsertElement: function () {
      var controller = this.get('controller');
      controller.loadStep();
    }
  });
  
});
window.require.register("views/main/service/info/menu", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainServiceInfoMenuView = Em.CollectionView.extend({
    tagName: 'ul',
    classNames: ["nav", "nav-tabs"],
    content:function(){
      var menuItems = [
        { label: Em.I18n.t('services.service.info.menu.summary'), routing:'summary', active:"active"}
        //{ label:'Audit', routing:'audit'}
      ];
      if(this.get('configTab')) menuItems.push({ label: Em.I18n.t('services.service.info.menu.configs'), routing:'configs'});
      return menuItems;
    }.property(),

    init: function(){ this._super(); this.activateView(); },

    activateView:function () {
      $.each(this._childViews, function () {
        this.set('active', (document.URL.endsWith(this.get('content.routing')) ? "active" : ""));
      });
    },

    deactivateChildViews: function() {
      $.each(this._childViews, function(){
        this.set('active', "");
      });
    },

    itemViewClass: Em.View.extend({
      classNameBindings: ["active"],
      active: "",
      template: Ember.Handlebars.compile('<a {{action showInfo view.content.routing }} href="#"> {{unbound view.content.label}}</a>')
    })
  });
});
window.require.register("views/main/service/info/metrics/flume/channel_fill_pct", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsFlume_ChannelFillPercent = App.ChartLinearTimeView.extend({
    id: "service-metrics-flume-channel-fill-percent",
    title: Em.I18n.t('services.service.info.metrics.flume.channelFillPercent'),
    yAxisFormatter: App.ChartLinearTimeView.PercentageFormatter,

    ajaxIndex: 'service.metrics.flume.channel_fill_percent',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      var self = this;
      if (jsonData && jsonData.host_components) {
        jsonData.host_components.forEach(function (hc) {
          var hostName = hc.HostRoles.host_name;
          var host = App.Host.find(hostName);
          if (host && host.get('publicHostName')) {
            hostName = host.get('publicHostName');
          }
          if (hc.metrics && hc.metrics.flume && hc.metrics.flume.flume && hc.metrics.flume.flume.CHANNEL) {
            for ( var cname in hc.metrics.flume.flume.CHANNEL) {
              var seriesName = Em.I18n.t('services.service.info.metrics.flume.channelName').format(cname + " (" + hostName + ")");
              var seriesData = hc.metrics.flume.flume.CHANNEL[cname]['ChannelFillPercentage'];
              if (seriesData) {
                seriesArray.push(self.transformData(seriesData, seriesName));
              }
            }
          }
        });
      }
      return seriesArray;
    }
  });
  
});
window.require.register("views/main/service/info/metrics/flume/channel_size", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsFlume_ChannelSize = App.ChartLinearTimeView.extend({
    id: "service-metrics-flume-channel-size",
    title: Em.I18n.t('services.service.info.metrics.flume.channelSize'),

    ajaxIndex: 'service.metrics.flume.channel_size',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      var self = this;
      if (jsonData && jsonData.host_components) {
        jsonData.host_components.forEach(function (hc) {
          var hostName = hc.HostRoles.host_name;
          var host = App.Host.find(hostName);
          if (host && host.get('publicHostName')) {
            hostName = host.get('publicHostName');
          }
          if (hc.metrics && hc.metrics.flume && hc.metrics.flume.flume && hc.metrics.flume.flume.CHANNEL) {
            for ( var cname in hc.metrics.flume.flume.CHANNEL) {
              var seriesName = Em.I18n.t('services.service.info.metrics.flume.channelName').format(cname + " (" + hostName + ")");
              var seriesData = hc.metrics.flume.flume.CHANNEL[cname]['ChannelSize'];
              if (seriesData) {
                seriesArray.push(self.transformData(seriesData, seriesName));
              }
            }
          }
        });
      }
      return seriesArray;
    }
  });
  
});
window.require.register("views/main/service/info/metrics/flume/cpu_user", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsFlume_CPUUser = App.ChartLinearTimeView.extend({
    id: "service-metrics-flume-cpu-user",
    title: Em.I18n.t('services.service.info.metrics.flume.cpu.user'),
    yAxisFormatter: App.ChartLinearTimeView.PercentageFormatter,
    renderer: 'line',
    
    ajaxIndex: 'service.metrics.flume.cpu_user',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      var self = this;
      if (jsonData && jsonData.host_components) {
        jsonData.host_components.forEach(function (hc) {
          var hostName = hc.HostRoles.host_name;
          var host = App.Host.find(hostName);
          if (host && host.get('publicHostName')) {
            hostName = host.get('publicHostName');
          }
          if (hc.metrics && hc.metrics.cpu && hc.metrics.cpu.cpu_user) {
            var seriesName = Em.I18n.t('services.service.info.metrics.flume.hostName').format(hostName);
            var seriesData = hc.metrics.cpu.cpu_user;
            if (seriesData) {
              seriesArray.push(self.transformData(seriesData, seriesName));
            }
          }
        });
      }
      return seriesArray;
    }
  });
  
});
window.require.register("views/main/service/info/metrics/flume/gc", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsFlume_GarbageCollection = App.ChartLinearTimeView.extend({
    id: "service-metrics-flume-jvm-gc",
    title: Em.I18n.t('services.service.info.metrics.flume.gc'),
    yAxisFormatter: App.ChartLinearTimeView.TimeElapsedFormatter,

    ajaxIndex: 'service.metrics.flume.gc',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      var self = this;
      if (jsonData && jsonData.host_components) {
        jsonData.host_components.forEach(function (hc) {
          var hostName = hc.HostRoles.host_name;
          var host = App.Host.find(hostName);
          if (host && host.get('publicHostName')) {
            hostName = host.get('publicHostName');
          }
          if (hc.metrics && hc.metrics.jvm && hc.metrics.jvm.gcTimeMillis) {
            var seriesName = Em.I18n.t('services.service.info.metrics.flume.hostName').format(hostName);
            var seriesData = hc.metrics.jvm.gcTimeMillis;
            if (seriesData) {
              seriesArray.push(self.transformData(seriesData, seriesName));
            }
          }
        });
      }
      return seriesArray;
    }
  });
  
});
window.require.register("views/main/service/info/metrics/flume/jvm_heap", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsFlume_JVMHeapUsed = App.ChartLinearTimeView.extend({
    id: "service-metrics-flume-jvm-heap-used",
    title: Em.I18n.t('services.service.info.metrics.flume.jvmHeapUsed'),
    yAxisFormatter: App.ChartLinearTimeView.BytesFormatter,
    renderer: 'line',

    ajaxIndex: 'service.metrics.flume.jvm_heap_used',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      var self = this;
      var MB = Math.pow(2, 20);
      if (jsonData && jsonData.host_components) {
        jsonData.host_components.forEach(function (hc) {
          var hostName = hc.HostRoles.host_name;
          var host = App.Host.find(hostName);
          if (host && host.get('publicHostName')) {
            hostName = host.get('publicHostName');
          }
          if (hc.metrics && hc.metrics.jvm && hc.metrics.jvm.memHeapUsedM) {
            var seriesName = Em.I18n.t('services.service.info.metrics.flume.hostName').format(hostName);
            var seriesData = hc.metrics.jvm.memHeapUsedM;
            if (seriesData) {
              var s = self.transformData(seriesData, seriesName);
              for (var i = 0; i < s.data.length; i++) {
                s.data[i].y *= MB;
              }
              seriesArray.push(s);
            }
          }
        });
      }
      return seriesArray;
    }
  });
  
});
window.require.register("views/main/service/info/metrics/flume/jvm_threads_runnable", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsFlume_JVMThreadsRunnable = App.ChartLinearTimeView.extend({
    id: "service-metrics-flume-jvm-threads-runnable",
    title: Em.I18n.t('services.service.info.metrics.flume.jvmThreadsRunnable'),
    renderer: 'line',

    ajaxIndex: 'service.metrics.flume.jvm_threads_runnable',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      var self = this;
      var MB = Math.pow(2, 20);
      if (jsonData && jsonData.host_components) {
        jsonData.host_components.forEach(function (hc) {
          var hostName = hc.HostRoles.host_name;
          var host = App.Host.find(hostName);
          if (host && host.get('publicHostName')) {
            hostName = host.get('publicHostName');
          }
          if (hc.metrics && hc.metrics.jvm && hc.metrics.jvm.threadsRunnable) {
            var seriesName = Em.I18n.t('services.service.info.metrics.flume.hostName').format(hostName);
            var seriesData = hc.metrics.jvm.threadsRunnable;
            if (seriesData) {
              var s = self.transformData(seriesData, seriesName);
              seriesArray.push(s);
            }
          }
        });
      }
      return seriesArray;
    }
  });
  
});
window.require.register("views/main/service/info/metrics/flume/sink_connection_failed", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsFlume_SinkConnectionFailedCount = App.ChartLinearTimeView.extend({
    id: "service-metrics-flume-sink-connection-failed",
    title: Em.I18n.t('services.service.info.metrics.flume.sinkConnectionFailed'),

    ajaxIndex: 'service.metrics.flume.sink_connection_failed',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      var self = this;
      if (jsonData && jsonData.host_components) {
        jsonData.host_components.forEach(function (hc) {
          var hostName = hc.HostRoles.host_name;
          var host = App.Host.find(hostName);
          if (host && host.get('publicHostName')) {
            hostName = host.get('publicHostName');
          }
          if (hc.metrics && hc.metrics.flume && hc.metrics.flume.flume && hc.metrics.flume.flume.SINK) {
            for ( var cname in hc.metrics.flume.flume.SINK) {
              var seriesName = Em.I18n.t('services.service.info.metrics.flume.sinkName').format(cname + " (" + hostName + ")");
              var seriesData = hc.metrics.flume.flume.SINK[cname]['ConnectionFailedCount'];
              if (seriesData) {
                seriesArray.push(self.transformData(seriesData, seriesName));
              }
            }
          }
        });
      }
      return seriesArray;
    }
  });
  
});
window.require.register("views/main/service/info/metrics/flume/sink_drain_success", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsFlume_SinkDrainSuccessCount = App.ChartLinearTimeView.extend({
    id: "service-metrics-flume-sink-drain-success",
    title: Em.I18n.t('services.service.info.metrics.flume.sinkDrainSuccess'),

    ajaxIndex: 'service.metrics.flume.sink_drain_success',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      var self = this;
      if (jsonData && jsonData.host_components) {
        jsonData.host_components.forEach(function (hc) {
          var hostName = hc.HostRoles.host_name;
          var host = App.Host.find(hostName);
          if (host && host.get('publicHostName')) {
            hostName = host.get('publicHostName');
          }
          if (hc.metrics && hc.metrics.flume && hc.metrics.flume.flume && hc.metrics.flume.flume.SINK) {
            for ( var cname in hc.metrics.flume.flume.SINK) {
              var seriesName = Em.I18n.t('services.service.info.metrics.flume.sinkName').format(cname + " (" + hostName + ")");
              var seriesData = hc.metrics.flume.flume.SINK[cname]['EventDrainSuccessCount'];
              if (seriesData) {
                seriesArray.push(self.transformData(seriesData, seriesName));
              }
            }
          }
        });
      }
      return seriesArray;
    }
  });
  
});
window.require.register("views/main/service/info/metrics/flume/source_accepted", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsFlume_SourceAcceptedCount = App.ChartLinearTimeView.extend({
    id: "service-metrics-flume-source-accepted",
    title: Em.I18n.t('services.service.info.metrics.flume.sourceAccepted'),

    ajaxIndex: 'service.metrics.flume.source_accepted',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      var self = this;
      if (jsonData && jsonData.host_components) {
        jsonData.host_components.forEach(function (hc) {
          var hostName = hc.HostRoles.host_name;
          var host = App.Host.find(hostName);
          if (host && host.get('publicHostName')) {
            hostName = host.get('publicHostName');
          }
          if (hc.metrics && hc.metrics.flume && hc.metrics.flume.flume && hc.metrics.flume.flume.SOURCE) {
            for ( var cname in hc.metrics.flume.flume.SOURCE) {
              var seriesName = Em.I18n.t('services.service.info.metrics.flume.sourceName').format(cname + " (" + hostName + ")");
              var seriesData = hc.metrics.flume.flume.SOURCE[cname]['EventAcceptedCount'];
              if (seriesData) {
                seriesArray.push(self.transformData(seriesData, seriesName));
              }
            }
          }
        });
      }
      return seriesArray;
    }
  });
  
});
window.require.register("views/main/service/info/metrics/hbase/cluster_requests", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsHBASE_ClusterRequests = App.ChartLinearTimeView.extend({
    id: "service-metrics-hbase-cluster-requests",
    title: Em.I18n.t('services.service.info.metrics.hbase.clusterRequests'),

    ajaxIndex: 'service.metrics.hbase.cluster_requests',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.hbase && jsonData.metrics.hbase.master) {
        for ( var name in jsonData.metrics.hbase.master) {
          var displayName;
          var seriesData = jsonData.metrics.hbase.master[name];
          switch (name) {
            case "cluster_requests":
              displayName = Em.I18n.t('services.service.info.metrics.hbase.clusterRequests.displayNames.requestCount');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/hbase/hlog_split_size", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsHBASE_HlogSplitSize = App.ChartLinearTimeView.extend({
    id: "service-metrics-hbase-hlog-split-size",
    title: Em.I18n.t('services.service.info.metrics.hbase.hlogSplitSize'),
    yAxisFormatter: App.ChartLinearTimeView.BytesFormatter,

    ajaxIndex: 'service.metrics.hbase.hlog_split_size',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.hbase && jsonData.metrics.hbase.master) {
        for ( var name in jsonData.metrics.hbase.master) {
          var displayName;
          var seriesData = jsonData.metrics.hbase.master[name];
          switch (name) {
            case "splitSize_avg_time":
              displayName = Em.I18n.t('services.service.info.metrics.hbase.hlogSplitSize.displayNames.splitSize');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/hbase/hlog_split_time", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsHBASE_HlogSplitTime = App.ChartLinearTimeView.extend({
    id: "service-metrics-hbase-hlog-split-time",
    title: Em.I18n.t('services.service.info.metrics.hbase.hlogSplitTime'),
    yAxisFormatter: App.ChartLinearTimeView.TimeElapsedFormatter,

    ajaxIndex: 'service.metrics.hbase.hlog_split_time',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.hbase && jsonData.metrics.hbase.master) {
        for ( var name in jsonData.metrics.hbase.master) {
          var displayName;
          var seriesData = jsonData.metrics.hbase.master[name];
          switch (name) {
            case "splitTime_avg_time":
              displayName = Em.I18n.t('services.service.info.metrics.hbase.hlogSplitTime.displayNames.splitTime');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/hbase/regionserver_queuesize", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsHBASE_RegionServerQueueSize = App.ChartLinearTimeView.extend({
    id: "service-metrics-hbase-regionserver-queuesize",
    title: Em.I18n.t('services.service.info.metrics.hbase.regionServerQueueSize'),
    renderer: 'line',
    ajaxIndex: 'service.metrics.hbase.regionserver_queuesize',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.hbase && jsonData.metrics.hbase.regionserver) {
        for ( var name in jsonData.metrics.hbase.regionserver) {
          var displayName;
          var seriesData = jsonData.metrics.hbase.regionserver[name];
          switch (name) {
            case "compactionQueueSize":
              displayName = Em.I18n.t('services.service.info.metrics.hbase.regionServerQueueSize.displayNames.compactionQueueSize');
              break;
            case "flushQueueSize":
              displayName = Em.I18n.t('services.service.info.metrics.hbase.regionServerQueueSize.displayNames.flushQueueSize');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/hbase/regionserver_regions", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsHBASE_RegionServerRegions = App.ChartLinearTimeView.extend({
    id: "service-metrics-hbase-regionserver-regions",
    title: Em.I18n.t('services.service.info.metrics.hbase.regionServerRegions'),

    ajaxIndex: 'service.metrics.hbase.regionserver_regions',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.hbase && jsonData.metrics.hbase.regionserver) {
        for ( var name in jsonData.metrics.hbase.regionserver) {
          var displayName;
          var seriesData = jsonData.metrics.hbase.regionserver[name];
          switch (name) {
            case "regions":
              displayName = Em.I18n.t('services.service.info.metrics.hbase.regionServerRegions.displayNames.regions');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/hbase/regionserver_rw_requests", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing HBase Cluster Requests
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsHBASE_RegionServerReadWriteRequests = App.ChartLinearTimeView.extend({
    id: "service-metrics-hbase-regionserver-rw-requests",
    title: Em.I18n.t('services.service.info.metrics.hbase.regionServerRequests'),
    renderer: 'line',

    ajaxIndex: 'service.metrics.hbase.regionserver_rw_requests',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.hbase && jsonData.metrics.hbase.regionserver) {
        for ( var name in jsonData.metrics.hbase.regionserver) {
          var displayName;
          var seriesData = jsonData.metrics.hbase.regionserver[name];
          switch (name) {
            case "writeRequestsCount":
              displayName = Em.I18n.t('services.service.info.metrics.hbase.regionServerRequests.displayNames.writeRequests');
              break;
            case "readRequestsCount":
              displayName = Em.I18n.t('services.service.info.metrics.hbase.regionServerRequests.displayNames.readRequests');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/hdfs/block_status", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsHDFS_BlockStatus = App.ChartLinearTimeView.extend({
    id: "service-metrics-hdfs-block-status",
    title: Em.I18n.t('services.service.info.metrics.hdfs.blockStatus'),
    renderer: 'line',

    ajaxIndex: 'service.metrics.hdfs.block_status',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.dfs && jsonData.metrics.dfs.FSNamesystem) {
        for ( var name in jsonData.metrics.dfs.FSNamesystem) {
          var displayName;
          var seriesData = jsonData.metrics.dfs.FSNamesystem[name];
          switch (name) {
            case "PendingReplicationBlocks":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.blockStatus.displayNames.pendingReplicationBlocks');
              break;
            case "UnderReplicatedBlocks":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.blockStatus.displayNames.underReplicatedBlocks');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/hdfs/file_operations", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsHDFS_FileOperations = App.ChartLinearTimeView.extend({
    id: "service-metrics-hdfs-file-operations",
    title: Em.I18n.t('services.service.info.metrics.hdfs.fileOperations'),
    renderer: 'line',

    ajaxIndex: 'service.metrics.hdfs.file_operations',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.dfs && jsonData.metrics.dfs.namenode) {
        for ( var name in jsonData.metrics.dfs.namenode) {
          var displayName;
          var seriesData = jsonData.metrics.dfs.namenode[name];
          switch (name) {
            case "FileInfoOps":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.fileOperations.displayNames.fileInformationOperations');
              break;
            case "DeleteFileOps":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.fileOperations.displayNames.deleteFileOperations');
              break;
            case "CreateFileOps":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.fileOperations.displayNames.createFileOperations');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/hdfs/gc", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsHDFS_GC = App.ChartLinearTimeView.extend({
    id: "service-metrics-hdfs-gc",
    title: Em.I18n.t('services.service.info.metrics.hdfs.gc'),
    yAxisFormatter: App.ChartLinearTimeView.TimeElapsedFormatter,

    ajaxIndex: 'service.metrics.hdfs.gc',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.jvm) {
        for ( var name in jsonData.metrics.jvm) {
          var displayName;
          var seriesData = jsonData.metrics.jvm[name];
          switch (name) {
            case "gcTimeMillis":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.gc.displayNames.gcTimeMillis');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/hdfs/io", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsHDFS_IO = App.ChartLinearTimeView.extend({
    id: "service-metrics-hdfs-io",
    title: Em.I18n.t('services.service.info.metrics.hdfs.io'),
    yAxisFormatter: App.ChartLinearTimeView.BytesFormatter,
    renderer: 'line',

    ajaxIndex: 'service.metrics.hdfs.io',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.dfs && jsonData.metrics.dfs.datanode) {
        for ( var name in jsonData.metrics.dfs.datanode) {
          var displayName;
          var seriesData = jsonData.metrics.dfs.datanode[name];
          switch (name) {
            case "bytes_written":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.io.displayNames.bytesWritten');
              break;
            case "bytes_read":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.io.displayNames.bytesRead');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/hdfs/jvm_heap", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsHDFS_JVMHeap = App.ChartLinearTimeView.extend({
    id: "service-metrics-hdfs-jvm-heap",
    title: Em.I18n.t('services.service.info.metrics.hdfs.jvmHeap'),
    yAxisFormatter: App.ChartLinearTimeView.BytesFormatter,
    renderer: 'line',

    ajaxIndex: 'service.metrics.hdfs.jvm_heap',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      var MB = Math.pow(2, 20);
      if (jsonData && jsonData.metrics && jsonData.metrics.jvm) {
        for ( var name in jsonData.metrics.jvm) {
          var displayName;
          var seriesData = jsonData.metrics.jvm[name];
          switch (name) {
            case "memHeapCommittedM":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.jvmHeap.displayNames.memHeapCommittedM');
              break;
            case "memNonHeapUsedM":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.jvmHeap.displayNames.memNonHeapUsedM');
              break;
            case "memHeapUsedM":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.jvmHeap.displayNames.memHeapUsedM');
              break;
            case "memNonHeapCommittedM":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.jvmHeap.displayNames.memNonHeapCommittedM');
              break;
            default:
              break;
          }
          if (seriesData) {
            var s = this.transformData(seriesData, displayName);
            for (var i = 0; i < s.data.length; i++) {
              s.data[i].y *= MB;
            }
            seriesArray.push(s);
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/hdfs/jvm_threads", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsHDFS_JVMThreads = App.ChartLinearTimeView.extend({
    id: "service-metrics-hdfs-jvm-threads",
    title: Em.I18n.t('services.service.info.metrics.hdfs.jvmThreads'),
    renderer: 'line',

    ajaxIndex: 'service.metrics.hdfs.jvm_threads',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.jvm) {
        for ( var name in jsonData.metrics.jvm) {
          var displayName;
          var seriesData = jsonData.metrics.jvm[name];
          switch (name) {
            case "threadsBlocked":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.jvmThreads.displayNames.threadsBlocked');
              break;
            case "threadsWaiting":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.jvmThreads.displayNames.threadsWaiting');
              break;
            case "threadsTimedWaiting":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.jvmThreads.displayNames.threadsTimedWaiting');
              break;
            case "threadsRunnable":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.jvmThreads.displayNames.threadsRunnable');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/hdfs/rpc", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsHDFS_RPC = App.ChartLinearTimeView.extend({
    id: "service-metrics-hdfs-rpc",
    title: Em.I18n.t('services.service.info.metrics.hdfs.rpc'),
    yAxisFormatter: App.ChartLinearTimeView.TimeElapsedFormatter,

    ajaxIndex: 'service.metrics.hdfs.rpc',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.rpc) {
        for ( var name in jsonData.metrics.rpc) {
          var displayName;
          var seriesData = jsonData.metrics.rpc[name];
          switch (name) {
            case "RpcQueueTime_avg_time":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.rpc.displayNames.rpcQueueTimeAvgTime');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/hdfs/space_utilization", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsHDFS_SpaceUtilization = App.ChartLinearTimeView.extend({
    id: "service-metrics-hdfs-space-utilization",
    title: Em.I18n.t('services.service.info.metrics.hdfs.spaceUtilization'),
    yAxisFormatter: App.ChartLinearTimeView.BytesFormatter,
    renderer: 'line',
    ajaxIndex: 'service.metrics.hdfs.space_utilization',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      var GB = Math.pow(2, 30);
      if (jsonData && jsonData.metrics && jsonData.metrics.dfs && jsonData.metrics.dfs.FSNamesystem) {
        for ( var name in jsonData.metrics.dfs.FSNamesystem) {
          var displayName;
          var seriesData = jsonData.metrics.dfs.FSNamesystem[name];
          switch (name) {
            case "CapacityRemainingGB":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.spaceUtilization.displayNames.capacityRemainingGB');
              break;
            case "CapacityUsedGB":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.spaceUtilization.displayNames.capacityUsedGB');
              break;
            case "CapacityTotalGB":
              displayName = Em.I18n.t('services.service.info.metrics.hdfs.spaceUtilization.displayNames.capacityTotalGB');
              break;
            default:
              break;
          }
          if (seriesData) {
            var s = this.transformData(seriesData, displayName);
            for (var i = 0; i < s.data.length; i++) {
              s.data[i].y *= GB;
            }
            seriesArray.push(s);
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/mapreduce/gc", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsMapReduce_GC = App.ChartLinearTimeView.extend({
    id: "service-metrics-mapreduce-gc",
    title: Em.I18n.t('services.service.info.metrics.mapreduce.gc'),
    yAxisFormatter: App.ChartLinearTimeView.TimeElapsedFormatter,

    ajaxIndex: 'service.metrics.mapreduce.gc',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.jvm) {
        for ( var name in jsonData.metrics.jvm) {
          var displayName;
          var seriesData = jsonData.metrics.jvm[name];
          switch (name) {
            case "gcTimeMillis":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.gc.displayNames.gcTimeMillis');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/mapreduce/jobs_status", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsMapReduce_JobsStatus = App.ChartLinearTimeView.extend({
    id: "service-metrics-mapreduce-jobs-status",
    title: Em.I18n.t('services.service.info.metrics.mapreduce.jobsStatus'),
    renderer: 'line',

    ajaxIndex: 'service.metrics.mapreduce.jobs_status',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.mapred && jsonData.metrics.mapred.jobtracker) {
        for ( var name in jsonData.metrics.mapred.jobtracker) {
          var displayName;
          var seriesData = jsonData.metrics.mapred.jobtracker[name];
          switch (name) {
            case "jobs_running":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.jobsStatus.displayNames.jobsRunning');
              break;
            case "jobs_failed":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.jobsStatus.displayNames.jobsFailed');
              break;
            case "jobs_completed":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.jobsStatus.displayNames.jobsCompleted');
              break;
            case "jobs_preparing":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.jobsStatus.displayNames.jobsPreparing');
              break;
            case "jobs_submitted":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.jobsStatus.displayNames.jobsSubmitted');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/mapreduce/jvm_heap", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsMapReduce_JVMHeap = App.ChartLinearTimeView.extend({
    id: "service-metrics-mapreduce-jvm-heap",
    title: Em.I18n.t('services.service.info.metrics.mapreduce.jvmHeap'),
    yAxisFormatter: App.ChartLinearTimeView.BytesFormatter,
    renderer: 'line',

    ajaxIndex: 'service.metrics.mapreduce.jobs_heap',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      var MB = Math.pow(2, 20);
      if (jsonData && jsonData.metrics && jsonData.metrics.jvm) {
        for ( var name in jsonData.metrics.jvm) {
          var displayName;
          var seriesData = jsonData.metrics.jvm[name];
          switch (name) {
            case "memHeapCommittedM":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.jvmHeap.displayNames.memHeapCommittedM');
              break;
            case "memNonHeapUsedM":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.jvmHeap.displayNames.memNonHeapUsedM');
              break;
            case "memHeapUsedM":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.jvmHeap.displayNames.memHeapUsedM');
              break;
            case "memNonHeapCommittedM":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.jvmHeap.displayNames.memNonHeapCommittedM');
              break;
            default:
              break;
          }
          if (seriesData) {
            var s = this.transformData(seriesData, displayName);
            for (var i = 0; i < s.data.length; i++) {
              s.data[i].y *= MB;
            }
            seriesArray.push(s);
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/mapreduce/jvm_threads", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsMapReduce_JVMThreads = App.ChartLinearTimeView.extend({
    id: "service-metrics-mapreduce-jvm-threads",
    title: Em.I18n.t('services.service.info.metrics.mapreduce.jvmThreads'),
    renderer: 'line',

    ajaxIndex: 'service.metrics.mapreduce.jobs_threads',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.jvm) {
        for ( var name in jsonData.metrics.jvm) {
          var displayName;
          var seriesData = jsonData.metrics.jvm[name];
          switch (name) {
            case "threadsBlocked":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.jvmThreads.displayNames.threadsBlocked');
              break;
            case "threadsWaiting":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.jvmThreads.displayNames.threadsWaiting');
              break;
            case "threadsTimedWaiting":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.jvmThreads.displayNames.threadsTimedWaiting');
              break;
            case "threadsRunnable":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.jvmThreads.displayNames.threadsRunnable');
              break;
            default:
              break;
          }

          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/mapreduce/map_slots", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsMapReduce_MapSlots = App.ChartLinearTimeView.extend({
    id: "service-metrics-mapreduce-map-slots",
    title: Em.I18n.t('services.service.info.metrics.mapreduce.mapSlots'),
    renderer: 'line',

    ajaxIndex: 'service.metrics.mapreduce.map_slots',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.mapred && jsonData.metrics.mapred.jobtracker) {
        for ( var name in jsonData.metrics.mapred.jobtracker) {
          var displayName;
          var seriesData = jsonData.metrics.mapred.jobtracker[name];
          switch (name) {
            case "reserved_map_slots":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.mapSlots.displayNames.reservedMapSlots');
              break;
            case "occupied_map_slots":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.mapSlots.displayNames.occupiedMapSlots');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/mapreduce/reduce_slots", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsMapReduce_ReduceSlots = App.ChartLinearTimeView.extend({
    id: "service-metrics-mapreduce-reduce-slots",
    title: Em.I18n.t('services.service.info.metrics.mapreduce.reduceSlots'),
    renderer: 'line',

    ajaxIndex: 'service.metrics.mapreduce.reduce_slots',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.mapred && jsonData.metrics.mapred.jobtracker) {
        for ( var name in jsonData.metrics.mapred.jobtracker) {
          var displayName;
          var seriesData = jsonData.metrics.mapred.jobtracker[name];
          switch (name) {
            case "reserved_reduce_slots":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.reduceSlots.displayNames.reservedReduceSlots');
              break;
            case "occupied_reduce_slots":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.reduceSlots.displayNames.occupiedReduceSlots');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/mapreduce/rpc", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsMapReduce_RPC = App.ChartLinearTimeView.extend({
    id: "service-metrics-mapreduce-rpc",
    title: Em.I18n.t('services.service.info.metrics.mapreduce.rpc'),
    yAxisFormatter: App.ChartLinearTimeView.TimeElapsedFormatter,

    ajaxIndex: 'service.metrics.mapreduce.rpc',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.rpc) {
        for ( var name in jsonData.metrics.rpc) {
          var displayName;
          var seriesData = jsonData.metrics.rpc[name];
          switch (name) {
            case "RpcQueueTime_avg_time":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.rpc.displayNames.RpcQueueTimeAvgTime');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/metrics/mapreduce/tasks_running_waiting", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  /**
   * @class
   * 
   * This is a view for showing cluster CPU metrics
   * 
   * @extends App.ChartLinearTimeView
   * @extends Ember.Object
   * @extends Ember.View
   */
  App.ChartServiceMetricsMapReduce_TasksRunningWaiting = App.ChartLinearTimeView.extend({
    id: "service-metrics-mapreduce-tasks-running-waiting",
    title: Em.I18n.t('services.service.info.metrics.mapreduce.tasksRunningWaiting'),
    renderer: 'line',

    ajaxIndex: 'service.metrics.mapreduce.tasks_running_waiting',

    transformToSeries: function (jsonData) {
      var seriesArray = [];
      if (jsonData && jsonData.metrics && jsonData.metrics.mapred && jsonData.metrics.mapred.jobtracker) {
        for ( var name in jsonData.metrics.mapred.jobtracker) {
          var displayName;
          var seriesData = jsonData.metrics.mapred.jobtracker[name];
          switch (name) {
            case "running_maps":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.tasksRunningWaiting.displayNames.runningMaps');
              break;
            case "running_reduces":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.tasksRunningWaiting.displayNames.runningReduces');
              break;
            case "waiting_maps":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.tasksRunningWaiting.displayNames.waitingMaps');
              break;
            case "waiting_reduces":
              displayName = Em.I18n.t('services.service.info.metrics.mapreduce.tasksRunningWaiting.displayNames.waitingReduces');
              break;
            default:
              break;
          }
          if (seriesData) {
            seriesArray.push(this.transformData(seriesData, displayName));
          }
        }
      }
      return seriesArray;
    }
  });
});
window.require.register("views/main/service/info/summary", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.AlertItemView = Em.View.extend({
    tagName:"li",
    templateName: require('templates/main/service/info/summary_alert'),
    classNameBindings: ["status"],
    status: function () {
      return "status-" + this.get("content.status");
    }.property('content'),
    didInsertElement: function () {
      // Tooltips for alerts need to be enabled.
      $("div[rel=tooltip]").tooltip();
      $(".tooltip").remove();
    }
  })

  App.MainServiceInfoSummaryView = Em.View.extend({
    templateName: require('templates/main/service/info/summary'),
    attributes:null,
    serviceStatus:{
      hdfs:false,
      mapreduce:false,
      mapreduce2:false,
      hbase:false,
      zookeeper:false,
      oozie:false,
      hive:false,
      ganglia:false,
      nagios:false,
      hue: false,
      flume: false
    },

    sumMasterComponentView : Em.View.extend({
      templateName: require('templates/main/service/info/summary/master_components'),
      mastersComp : function(){
        return this.get('parentView.service.hostComponents').filterProperty('isMaster', true);
      }.property("service")
    }),

    noTemplateService: function () {
      var serviceName = this.get("service.serviceName");
      if(serviceName == "WEBHCAT" || serviceName == "NAGIOS"){
        return true;
      }else{
        return false;
      }
    }.property('controller.content'),

    clients: function () {
      var service = this.get('controller.content');
      if (["OOZIE", "ZOOKEEPER", "HIVE", "MAPREDUCE2"].contains(service.get("id"))) {
        return service.get('hostComponents').filterProperty('isClient');
      }
      return [];
    }.property('controller.content'),

    hasManyServers: function () {
      if (this.get('servers').length > 1) {
        return true;
      }
      return false;
    }.property('servers'),

    clientsHostText: function () {
      if(this.get("hasManyClients")){
        return Em.I18n.t('services.service.summary.viewHosts');
      }else{
        return Em.I18n.t('services.service.summary.viewHost');
      }
    }.property("hasManyClients"),

    hasManyClients: function () {
      if (this.get('clients').length > 1) {
        return true;
      }
      return false;
    }.property('clients'),

    servers: function () {
      var result = [];
      var service = this.get('controller.content');
      if (service.get("id") == "ZOOKEEPER" || service.get("id") == "FLUME") {
        var servers = service.get('hostComponents').filterProperty('isMaster');
        if (servers.length > 0) {
          result = [{
            'host': servers[0].get('displayName'),
            'isComma': false,
            'isAnd': false
          }];
        }
        if (servers.length > 1) {
          result[0].isComma = true;
          result.push({
            'host': servers[1].get('displayName'),
            'isComma': false,
            'isAnd': false
          });
        }
        if (servers.length > 2) {
          result[1].isAnd = true;
          result.push({
            'host': Em.I18n.t('services.service.info.summary.serversHostCount').format(servers.length - 2),
            'isComma': false,
            'isAnd': false
          });
        }
      }
      return result;
    }.property('controller.content'),

    monitors: function () {
      var result = '';
      var service = this.get('controller.content');
      if (service.get("id") == "GANGLIA") {
        var monitors = service.get('hostComponents').filterProperty('isMaster', false);
        var liveMonitors = monitors.filterProperty("workStatus","STARTED").length;
        if (monitors.length) {
          result = Em.I18n.t('services.service.info.summary.hostsRunningMonitor').format(liveMonitors, monitors.length);
        }
      }
      return result;
    }.property('controller.content'),

    hasManyMonitors: function () {
      var service = this.get('controller.content');
      if (service.get("id") == "GANGLIA") {
        var monitors = service.get('hostComponents').filterProperty('isMaster', false);
        if (monitors.length > 1){
          return Em.I18n.t('services.service.summary.viewHosts');
        }else{
          return Em.I18n.t('services.service.summary.viewHost');
        }
      }
      return result;
    }.property('controller.content'),

    /**
     * Property related to GANGLIA service, is unused for other services
     * @return {Object}
     */
    monitorsObj: function(){
      var service = this.get('controller.content');
      if (service.get("id") == "GANGLIA") {
        var monitors = service.get('hostComponents').filterProperty('isMaster', false);
        if (monitors.length) {
          return monitors[0];
        }
      }
      return {};
    }.property('controller.content'),

    /**
     * Property related to ZOOKEEPER service, is unused for other services
     * @return {Object}
     */
    serversHost: function() {
      var service = this.get('controller.content');
      if (service.get("id") == "ZOOKEEPER" || service.get("id") == "FLUME") {
        var servers = service.get('hostComponents').filterProperty('isMaster');
        if (servers.length > 0) {
          return servers[0];
        }
      }
      return {};
    }.property('controller.content'),

    /**
     * Property related to OOZIE and ZOOKEEPER services, is unused for other services
     * HIVE is supported too
     * @return {Object}
     */
    clientObj: function() {
      var service = this.get('controller.content');
      if (["OOZIE", "ZOOKEEPER", "HIVE", "MAPREDUCE2"].contains(service.get("id"))) {
        var clients = service.get('hostComponents').filterProperty('isClient', true);
        if (clients.length > 0) {
          return clients[0];
        }
      }
      return {};
    }.property('controller.content'),

    data:{
      hive:{
        "database":"PostgreSQL",
        "databaseName":"hive",
        "user":"hive"
      }
    },

    /**
     * Array of the hostComponents for service
     */
    components: [],

    /**
     * Copy hostComponents from controller to view to avoid flickering Summary block while data is updating in the controller
     * rand - just marker in the Service model for determining that Service was updated (value changes in the service_mapper)
     */
    hostComponentsUpd: function() {
        var components = [];
        this.get('controller.content.hostComponents').forEach(function(component) {
          var obj = {};
          for(var prop in component){
            if( component.hasOwnProperty(prop)
              && prop.indexOf('__ember') < 0
              && prop.indexOf('_super') < 0
              && Ember.typeOf(component.get(prop)) !== 'function'
              ) {
              obj[prop] = component.get(prop);
            }
          }
          obj.displayName = component.get('displayName'); // this is computed property and wasn't copied in the top block of code
          // suppressing MySQL server from being displayed, because Ambari always installs MySQL server no matter what
          // database type is selected, and shows an incorrect link in the summary to point to the host that's hosting
          // the MySQL server
          if (component.get('componentName') !== 'MYSQL_SERVER') {
            components.push(obj);
          }
        });
        if(!this.get('isDestroyed') && !this.get('isDestroying')){
          this.set('components', components);
        }
    },
    
    _hostComponentsUpd: function() {
      Ember.run.once(this, 'hostComponentsUpd');
    }.observes('controller.content.rand', 'controller.content.hostComponents.@each.isMaster', 'controller.content.hostComponents.@each.host'),
    
    /**
     * Wrapper for displayName. used to render correct display name for mysql_server
     */
    componentNameView: Ember.View.extend({
      template: Ember.Handlebars.compile('{{view.displayName}}'),
      comp : null,
      displayName: function(){
        if(this.get('comp.componentName') == 'MYSQL_SERVER'){
          return this.t('services.hive.databaseComponent');
        }
        return this.get('comp.displayName');
      }.property('comp')
    }),

    service:function () {
      var svc = this.get('controller.content');
      var svcName = svc.get('serviceName');
      if (svcName) {
        switch (svcName.toLowerCase()) {
          case 'hdfs':
            svc = App.HDFSService.find().objectAt(0);
            break;
          case 'mapreduce':
            svc = App.MapReduceService.find().objectAt(0);
            break;
          case 'hbase':
            svc = App.HBaseService.find().objectAt(0);
            break;
          case 'flume':
            svc = App.FlumeService.find().objectAt(0);
            break;
          default:
            break;
        }
      }
      return svc;
    }.property('controller.content.serviceName').volatile(),

    isHide:true,
    moreStatsView:Em.View.extend({
      tagName:"a",
      template:Ember.Handlebars.compile('{{t services.service.summary.moreStats}}'),
      attributeBindings:[ 'href' ],
      classNames:[ 'more-stats' ],
      click:function (event) {
        this._parentView._parentView.set('isHide', false);
        this.remove();
      },
      href:'javascript:void(null)'
    }),

    serviceName:function () {
      return this.get('service.serviceName');
    }.property('service'),

    oldServiceName:'',

    /**
     * Contains graphs for this particular service
     */
    serviceMetricGraphs:function () {
      var svcName = this.get('service.serviceName');
      var graphs = [];
      if (svcName) {
        switch (svcName.toLowerCase()) {
          case 'hdfs':
            graphs = [ [App.ChartServiceMetricsHDFS_SpaceUtilization.extend(),
              App.ChartServiceMetricsHDFS_FileOperations.extend(),
              App.ChartServiceMetricsHDFS_BlockStatus.extend(),
              App.ChartServiceMetricsHDFS_IO.extend()],
              [App.ChartServiceMetricsHDFS_RPC.extend(),
              App.ChartServiceMetricsHDFS_GC.extend(),
              App.ChartServiceMetricsHDFS_JVMHeap.extend(),
              App.ChartServiceMetricsHDFS_JVMThreads.extend()]];
            break;
          case 'mapreduce':
            graphs = [ [App.ChartServiceMetricsMapReduce_JobsStatus.extend(),
              App.ChartServiceMetricsMapReduce_TasksRunningWaiting.extend(),
              App.ChartServiceMetricsMapReduce_MapSlots.extend(),
              App.ChartServiceMetricsMapReduce_ReduceSlots.extend()],
              [App.ChartServiceMetricsMapReduce_GC.extend(),
              App.ChartServiceMetricsMapReduce_RPC.extend(),
              App.ChartServiceMetricsMapReduce_JVMHeap.extend(),
              App.ChartServiceMetricsMapReduce_JVMThreads.extend()]];
            break;
          case 'hbase':
            graphs = [  [App.ChartServiceMetricsHBASE_ClusterRequests.extend(),
              App.ChartServiceMetricsHBASE_RegionServerReadWriteRequests.extend(),
              App.ChartServiceMetricsHBASE_RegionServerRegions.extend(),
              App.ChartServiceMetricsHBASE_RegionServerQueueSize.extend()],
              [App.ChartServiceMetricsHBASE_HlogSplitTime.extend(),
              App.ChartServiceMetricsHBASE_HlogSplitSize.extend()]];
            break;
          case 'flume':
            graphs = [[App.ChartServiceMetricsFlume_ChannelFillPercent.extend(),
               App.ChartServiceMetricsFlume_ChannelSize.extend(),
               App.ChartServiceMetricsFlume_SourceAcceptedCount.extend(),
               App.ChartServiceMetricsFlume_SinkDrainSuccessCount.extend()],
               [App.ChartServiceMetricsFlume_SinkConnectionFailedCount.extend(),
                //App.ChartServiceMetricsFlume_GarbageCollection.extend(),
                //App.ChartServiceMetricsFlume_JVMHeapUsed.extend(),
                //App.ChartServiceMetricsFlume_JVMThreadsRunnable.extend(),
                App.ChartServiceMetricsFlume_CPUUser.extend()]];
            break;
          default:
            break;
        }
      }
      return graphs;
    }.property(''),

    loadServiceSummary:function (serviceName) {

      var serviceName = this.get('serviceName');
      if (!serviceName) {
        return;
      }

      if (this.get('oldServiceName')) {
        // do not delete it!
        return;
      }

      var summaryView = this;
      var serviceStatus = summaryView.get('serviceStatus');
      $.each(serviceStatus, function (key, value) {
        if (key.toUpperCase() == serviceName) {
          summaryView.set('serviceStatus.' + key, true);
        } else {
          summaryView.set('serviceStatus.' + key, false);
        }
      });

      console.log('load ', serviceName, ' info');
      this.set('oldServiceName', serviceName);
      serviceName = serviceName.toLowerCase();
    }.observes('serviceName'),

    gangliaUrl:function () {
      var gangliaUrl = App.router.get('clusterController.gangliaUrl');
      var svcName = this.get('service.serviceName');
      if (svcName) {
        switch (svcName.toLowerCase()) {
          case 'hdfs':
            gangliaUrl += "/?r=hour&cs=&ce=&m=&s=by+name&c=HDPNameNode&tab=m&vn=";
            break;
          case 'mapreduce':
            gangliaUrl += "/?r=hour&cs=&ce=&m=&s=by+name&c=HDPJobTracker&tab=m&vn=";
            break;
          case 'hbase':
            gangliaUrl += "?r=hour&cs=&ce=&m=&s=by+name&c=HDPHBaseMaster&tab=m&vn=";
            break;
          default:
            break;
        }
      }
      return gangliaUrl;
    }.property('App.router.clusterController.gangliaUrl', 'service.serviceName'),

    didInsertElement:function () {
      // We have to make the height of the Alerts section
      // match the height of the Summary section.
      var summaryTable = document.getElementById('summary-info');
      var alertsList = document.getElementById('summary-alerts-list');
      if (summaryTable && alertsList) {
        var rows = $(summaryTable).find('tr');
        if (rows != null && rows.length > 0) {
          var minimumHeightSum = 20;
          var minimumHeightAlert = 50;
          var calculatedHeight = summaryTable.clientHeight;
          if (calculatedHeight < minimumHeightAlert) {
            $(alertsList).attr('style', "height:" + minimumHeightAlert + "px;");
            $(summaryTable).attr('style', "height:" + minimumHeightSum + "px;");
          } else {
            $(alertsList).attr('style', "height:" + calculatedHeight + "px;");
          }
        } else if (alertsList.clientHeight > 0) {
          $(summaryTable).append('<tr><td></td></tr>');
          $(summaryTable).attr('style', "height:" + alertsList.clientHeight + "px;");
        }
      }
    },

    clientHosts:App.Host.find(),

    clientHostsLength:function () {
      var text = this.t('services.service.summary.clientCount');
      var self = this;
      return text.format(self.get('clientHosts.length'));
    }.property('clientHosts'),

    clientComponents:function () {
      return App.HostComponent.find().filterProperty('isClient', true);
    }.property(),

    clientComponentsString:function () {
      var components = this.get('clientComponents');
      var names = [];
      components.forEach(function (component) {
        if (names.indexOf(component.get('displayName')) == -1) {
          names.push(component.get('displayName'));
        }
      });

      return names.length ? names.join(', ') : false;
    }.property('clientComponents')
  });
  
});
window.require.register("views/main/service/item", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainServiceItemView = Em.View.extend({
    templateName: require('templates/main/service/item'),
    maintenance: function(){
      var options = [];
      var service = this.get('controller.content');
      switch(service.get('serviceName')) {
  //      case 'HDFS':
  //        options.push({action: 'runRebalancer', 'label': Em.I18n.t('services.service.actions.run.rebalancer')});
  //        break;
  //      case 'HBASE':
  //        options.push({action: 'runCompaction', 'label': Em.I18n.t('services.service.actions.run.compaction')});
  //        break;
        case 'GANGLIA':
        case 'NAGIOS':
          if (App.supports.reassignMaster) {
            this.get('controller.content.hostComponents').filterProperty('isMaster').forEach (function (hostComponent){
              options.push({action: 'reassignMaster', context: hostComponent, 'label': Em.I18n.t('services.service.actions.reassign.master').format(hostComponent.get('displayName'))});
            })
          }
          break;
        case 'HIVE':
          options.push({action: 'runSmokeTest', 'label': Em.I18n.t('services.service.actions.run.smoke')});
          if (App.supports.reassignMaster) {
            options.push({action: 'reassignMaster', context: App.HostComponent.find().findProperty('componentName', 'HIVE_METASTORE'), 'label': Em.I18n.t('services.service.actions.reassign.master').format(App.HostComponent.find().findProperty('componentName', 'HIVE_METASTORE').get('displayName'))});
            options.push({action: 'reassignMaster', context: App.HostComponent.find().findProperty('componentName', 'HIVE_SERVER'), 'label': Em.I18n.t('services.service.actions.reassign.master.hive')});
          }
          break;
        case 'WEBHCAT':
          options.push({action: 'runSmokeTest', 'label': Em.I18n.t('services.service.actions.run.smoke')});
          if (App.supports.reassignMaster) {
            options.push({action: 'reassignMaster', context: App.HostComponent.find().findProperty('componentName', 'HIVE_SERVER'), 'label': Em.I18n.t('services.service.actions.reassign.master.hive')});
          }
          break;
        case 'HUE':
          options.push({action: 'runSmokeTest', 'label': Em.I18n.t('services.service.actions.run.smoke')});
          break;
        case 'FLUME':
          break;
        default:
          var components = this.get('controller.content.hostComponents');
          options.push({action: 'runSmokeTest', 'label': Em.I18n.t('services.service.actions.run.smoke')});
          if (App.supports.reassignMaster) {
            components.filterProperty('isMaster').mapProperty('displayName').uniq().forEach (function (hostComponent){
              options.push({action: 'reassignMaster', context: components.findProperty('displayName', hostComponent), 'label': Em.I18n.t('services.service.actions.reassign.master').format(hostComponent)});
            })
          }
      }
      return options;
    }.property('controller.content'),
    isMaintenanceActive: function() {
      return this.get('maintenance').length !== 0;
    }.property('maintenance'),
    hasConfigTab: function(){
      return this.get("controller.content.isConfigurable");
    }.property('controller.content.isConfigurable'),

    didInsertElement: function () {
      this.get('controller').setStartStopState();
    }
  });
  
});
window.require.register("views/main/service/menu", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.MainServiceMenuView = Em.CollectionView.extend({
    content:function () {
      var items = App.router.get('mainServiceController.content').filter(function(item){
        if(['PIG', 'SQOOP', 'HCATALOG'].contains(item.get('id'))){
          return false;
        }
        return true;
      });
      return items;
    }.property('App.router.mainServiceController.content'),


    didInsertElement:function () {
      App.router.location.addObserver('lastSetURL', this, 'renderOnRoute');
      this.renderOnRoute();
      $(".restart-required-service").tooltip({html:true, placement:"right"});
    },

    activeServiceId:null,

    /**
     *    Syncs navigation menu with requested URL
     */
    renderOnRoute:function () {
      var last_url = App.router.location.lastSetURL || location.href.replace(/^[^#]*#/, '');
      if (last_url.substr(1, 4) !== 'main' || !this._childViews) {
        return;
      }
      var reg = /^\/main\/services\/(\S+)\//g;
      var sub_url = reg.exec(last_url);
      var service_id = (null != sub_url) ? sub_url[1] : 1;
      this.set('activeServiceId', service_id);

    },

    tagName:'ul',
    classNames:["nav", "nav-list", "nav-services"],

    itemViewClass:Em.View.extend({
      classNameBindings:["active", "clients"],
      active:function () {
        return this.get('content.id') == this.get('parentView.activeServiceId') ? 'active' : '';
      }.property('parentView.activeServiceId'),
      alertsCount: function () {
        var allAlerts = App.router.get('clusterController.alerts');
        var serviceId = this.get('content.serviceName');
        if (serviceId) {
          return allAlerts.filterProperty('serviceType', serviceId).filterProperty('isOk', false).filterProperty('ignoredForServices', false).length;
        }
        return 0;
      }.property('App.router.clusterController.alerts'),

      templateName:require('templates/main/service/menu_item')
    })
  });
});
window.require.register("views/main/service/reassign_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.ReassignMasterView = Em.View.extend({

    templateName: require('templates/main/service/reassign'),

    isStep1Disabled: function () {
      return this.isStepDisabled(1);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep2Disabled: function () {
      return this.isStepDisabled(2);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep3Disabled: function () {
      return this.isStepDisabled(3);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep4Disabled: function () {
      return this.isStepDisabled(4);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep5Disabled: function () {
      return this.isStepDisabled(5);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStep6Disabled: function () {
      return this.isStepDisabled(6);
    }.property('controller.isStepDisabled.@each.value').cacheable(),

    isStepDisabled: function (index) {
      return this.get('controller.isStepDisabled').findProperty('step', index).get('value');
    }

  });
  
});
window.require.register("views/main/service/reconfigure", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var App = require('app');

  App.MainServiceReconfigureView = Em.View.extend({

    templateName: require('templates/main/service/reconfigure')

  });

  App.StageLabelView = Em.View.extend({
    tagName: 'a',
    classNameBindings: ['removeLink'],
    attributeBindings: ['href'],
    href: '#',
    removeLink: null,
    didInsertElement: function() {
     this.onLink();
    },
    onLink: function() {
     if (this.get('showLink') === true) {
       this.set('removeLink',null);
     } else {
       this.set('removeLink','remove-link');
     }
    }.observes('showLink'),
    stage: null,
    click: function () {
      if (this.get('stage') && this.get('showLink')) {
        this.showHostPopup(this.get('stage.label'));
      }
    },

    showHostPopup: function (label) {
      var serviceName = label;
      var controller = this.get("controller");
      App.HostPopup.initPopup(serviceName, controller);
    },

    isStarted: function () {
      return  (this.get('stage') && this.get('stage.isStarted'));
    }.property('stage.isStarted'),

    showLink: function () {
      return (this.get('stage') && this.get('stage.showLink'));
    }.property('stage.showLink')
  });

  App.StageSuccessView = Em.View.extend({
    layout: Ember.Handlebars.compile('<i class="icon-ok icon-large"></i> Done')
  });

  App.StageFailureView = Em.View.extend({
    layout: Ember.Handlebars.compile('<i class="icon-remove icon-large"></i> Failed')
  });

  App.StageInProgressView = Em.View.extend({
    stage: null,
    classNames: ['progress-striped', 'active', 'progress'],
    template: Ember.Handlebars.compile([
      '<div class="bar" {{bindAttr style="stage.barWidth"}}>',
      '</div>'
    ].join('\n')),

    isStageCompleted: function () {
      return this.get('obj.progress') == 100 || this.get('controller.isStepCompleted');
    }.property('controller.isStepCompleted', 'obj.progress')

  });



  
});
window.require.register("views/wizard/controls_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  /**
   * Abstract view for config fields.
   * Add popover support to control
   */
  App.ServiceConfigPopoverSupport = Ember.Mixin.create({

    /**
     * Config object. It will instance of App.ServiceConfigProperty
     */
    serviceConfig: null,
    placeholderBinding: 'serviceConfig.defaultValue',
    isPopoverEnabled: true,

    didInsertElement: function () {
      if (this.get('isPopoverEnabled') !== 'false') {
        this.$().popover({
          title: Em.I18n.t('installer.controls.serviceConfigPopover.title').format(this.get('serviceConfig.displayName'), this.get('serviceConfig.name')),
          content: this.get('serviceConfig.description'),
          placement: 'right',
          trigger: 'hover'
        });
      }
    }
  });

  /**
   * Default input control
   * @type {*}
   */
  App.ServiceConfigTextField = Ember.TextField.extend(App.ServiceConfigPopoverSupport, {

    valueBinding: 'serviceConfig.value',
    classNameBindings: 'textFieldClassName',
    placeholderBinding: 'serviceConfig.defaultValue',

    keyPress: function (event) {
      if (event.keyCode == 13) {
        return false;
      }
    },
    //Set editDone true for last edited config text field parameter
    focusOut: function(event){
      this.get('serviceConfig').set("editDone", true);
    },
    //Set editDone false for all current category config text field parameter
    focusIn: function(event){
      this.get("parentView.categoryConfigsAll").setEach("editDone", false);
    },

    textFieldClassName: function () {
      // sets the width of the field depending on display type
      if (['directory', 'url', 'email', 'user', 'host','advanced'].contains(this.get('serviceConfig.displayType'))) {
        return ['span6'];
      } else if (this.get('serviceConfig.displayType') === 'principal'){
        return ['span12'];
      } else {
        return ['input-small'];
      }
    }.property('serviceConfig.displayType'),

    disabled: function () {
      return !this.get('serviceConfig.isEditable');
    }.property('serviceConfig.isEditable')

  });

  /**
   * Customized input control with Utits type specified
   * @type {*}
   */
  App.ServiceConfigTextFieldWithUnit = Ember.View.extend(App.ServiceConfigPopoverSupport, {
    valueBinding: 'serviceConfig.value',
    classNames: ['input-append','with-unit'],
    placeholderBinding: 'serviceConfig.defaultValue',

    template: Ember.Handlebars.compile('{{view App.ServiceConfigTextField serviceConfigBinding="view.serviceConfig" isPopoverEnabled="false"}}<span class="add-on">{{view.serviceConfig.unit}}</span>'),

    disabled: function () {
      return !this.get('serviceConfig.isEditable');
    }.property('serviceConfig.isEditable')

  });

  /**
   * Password control
   * @type {*}
   */
  App.ServiceConfigPasswordField = Ember.TextField.extend({

    serviceConfig: null,
    type: 'password',
    valueBinding: 'serviceConfig.value',
    classNames: [ 'span3' ],
    placeholder: Em.I18n.t('form.item.placeholders.typePassword'),

    template: Ember.Handlebars.compile('{{view view.retypePasswordView}}'),

    keyPress: function (event) {
      if (event.keyCode == 13) {
        return false;
      }
    },

    retypePasswordView: Ember.TextField.extend({
      placeholder: Em.I18n.t('form.passwordRetype'),
      type: 'password',
      classNames: [ 'span3', 'retyped-password' ],
      keyPress: function (event) {
        if (event.keyCode == 13) {
          return false;
        }
      },
      valueBinding: 'parentView.serviceConfig.retypedPassword',
      disabled: function () {
        return !this.get('parentView.serviceConfig.isEditable');
      }.property('parentView.serviceConfig.isEditable')
    }),

    disabled: function () {
      return !this.get('serviceConfig.isEditable');
    }.property('serviceConfig.isEditable')

  });

  /**
   * Textarea control
   * @type {*}
   */
  App.ServiceConfigTextArea = Ember.TextArea.extend(App.ServiceConfigPopoverSupport, {

    valueBinding: 'serviceConfig.value',
    rows: 4,
    classNames: ['span6', 'directories'],
    placeholderBinding: 'serviceConfig.defaultValue',

    disabled: function () {
      return !this.get('serviceConfig.isEditable');
    }.property('serviceConfig.isEditable')

  });

  /**
   * Textarea control with bigger height
   * @type {*}
   */
  App.ServiceConfigBigTextArea = App.ServiceConfigTextArea.extend({
    rows: 10
  });

  /**
   * Checkbox control
   * @type {*}
   */
  App.ServiceConfigCheckbox = Ember.Checkbox.extend(App.ServiceConfigPopoverSupport, {

    checkedBinding: 'serviceConfig.value',

    disabled: function () {
      return !this.get('serviceConfig.isEditable');
    }.property('serviceConfig.isEditable')

  });

  App.ServiceConfigRadioButtons = Ember.View.extend({
    template: Ember.Handlebars.compile([
      '{{#each option in view.options}}',
      '{{#unless option.hidden}}',
      '<label class="radio">',
      '{{#view App.ServiceConfigRadioButton nameBinding = "view.name" valueBinding = "option.displayName"}}',
      '{{/view}}',
      '{{option.displayName}} &nbsp;',
      '</label>',
      '{{/unless}}',
      '{{/each}}'
    ].join('\n')),

    didInsertElement: function () {
      // on page render, automatically populate JDBC URLs only for default database settings
      // so as to not lose the user's customizations on these fields
      if (App.clusterStatus.clusterState == 'CLUSTER_NOT_CREATED_1' && ['New MySQL Database', 'New Derby Database'].contains(this.get('serviceConfig.value'))) {
        this.onOptionsChange();
      }
    },

    configs: function () {
      return this.get('categoryConfigsAll').filterProperty('isObserved', true);
    }.property('categoryConfigsAll'),

    serviceConfig: null,
    categoryConfigsAll: null,

    onOptionsChange: function () {
      var connectionUrl = this.get('connectionUrl');
      if (this.get('serviceConfig.serviceName') === 'HIVE') {
        if (this.get('hostName') && this.get('databaseName') && connectionUrl) {
          switch (this.get('serviceConfig.value')) {
            case 'New MySQL Database':
            case 'Existing MySQL Database':
              connectionUrl.set('value', "jdbc:mysql://" + this.get('hostName') + "/" + this.get('databaseName') + "?createDatabaseIfNotExist=true");
              break;
            case 'Existing Oracle Database':
              connectionUrl.set('value', "jdbc:oracle:thin:@//" + this.get('hostName') + ":1521/" + this.get('databaseName'));
              break;
          }
        }
      } else if (this.get('serviceConfig.serviceName') === 'OOZIE') {
        if (this.get('hostName') && this.get('databaseName') && connectionUrl) {
          switch (this.get('serviceConfig.value')) {
            case 'New Derby Database':
              connectionUrl.set('value', "jdbc:derby:${oozie.data.dir}/${oozie.db.schema.name}-db;create=true");
              break;
            case 'Existing MySQL Database':
              connectionUrl.set('value', "jdbc:mysql://" + this.get('hostName') + "/" + this.get('databaseName'));
              break;
            case 'Existing Oracle Database':
              connectionUrl.set('value', "jdbc:oracle:thin:@//" + this.get('hostName') + ":1521/" + this.get('databaseName'));
              break;
          }
        }
      }
    }.observes('databaseName', 'hostName', 'connectionUrl'),

    nameBinding: 'serviceConfig.radioName',

    databaseName: function () {
      switch (this.get('serviceConfig.serviceName')) {
        case 'HIVE':
          return this.get('categoryConfigsAll').findProperty('name', 'hive_database_name').get('value');
        case 'OOZIE':
          return this.get('categoryConfigsAll').findProperty('name', 'oozie_database_name').get('value');
        default:
          return null;
      }
    }.property('configs.@each.value', 'serviceConfig.serviceName'),


    hostName: function () {
      var value = this.get('serviceConfig.value');

      if (this.get('serviceConfig.serviceName') === 'HIVE') {
        switch (value) {
          case 'New MySQL Database':
            return this.get('categoryConfigsAll').findProperty('name', 'hive_ambari_host').get('value');
          case 'Existing MySQL Database':
            return this.get('categoryConfigsAll').findProperty('name', 'hive_existing_mysql_host').get('value');
          case 'Existing Oracle Database':
            return this.get('categoryConfigsAll').findProperty('name', 'hive_existing_oracle_host').get('value');
        }
      } else if (this.get('serviceConfig.serviceName') === 'OOZIE') {
        switch (value) {
          case 'New Derby Database':
            return this.get('categoryConfigsAll').findProperty('name', 'oozie_ambari_host').get('value');
          case 'Existing MySQL Database':
            return this.get('categoryConfigsAll').findProperty('name', 'oozie_existing_mysql_host').get('value');
          case 'Existing Oracle Database':
            return this.get('categoryConfigsAll').findProperty('name', 'oozie_existing_oracle_host').get('value');
        }
      }
    }.property('serviceConfig.serviceName', 'serviceConfig.value', 'configs.@each.value'),

    connectionUrl: function () {
      if (this.get('serviceConfig.serviceName') === 'HIVE') {
        return this.get('categoryConfigsAll').findProperty('name', 'hive_jdbc_connection_url');
      } else {
        return this.get('categoryConfigsAll').findProperty('name', 'oozie_jdbc_connection_url');
      }
    }.property('serviceConfig.serviceName'),

    optionsBinding: 'serviceConfig.options',
    disabled: function () {
      return !this.get('serviceConfig.isEditable');
    }.property('serviceConfig.isEditable')
  });

  App.ServiceConfigRadioButton = Ember.Checkbox.extend({
    tagName: 'input',
    attributeBindings: ['type', 'name', 'value', 'checked'],
    checked: false,
    type: 'radio',
    name: null,
    value: null,

    didInsertElement: function () {
      if (this.get('parentView.serviceConfig.value') === this.get('value')) {
        this.set('checked', true);
      }
    },

    click: function () {
      this.set('checked', true);
      this.onChecked();
    },

    onChecked: function () {
      this.set('parentView.serviceConfig.value', this.get('value'));
      var components = this.get('parentView.serviceConfig.options');
      components
        .forEach(function (_component) {
          if (_component.foreignKeys) {
            _component.foreignKeys.forEach(function (_componentName) {
              if (this.get('parentView.categoryConfigsAll').someProperty('name', _componentName)) {
                var component = this.get('parentView.categoryConfigsAll').findProperty('name', _componentName);
                if (_component.displayName === this.get('value')) {
                  component.set('isVisible', true);
                } else {
                  component.set('isVisible', false);
                }
              }
            }, this);
          }
        }, this);
    }.observes('checked'),

    disabled: function () {
      return !this.get('parentView.serviceConfig.isEditable');
    }.property('parentView.serviceConfig.isEditable')
  });

  App.ServiceConfigComboBox = Ember.Select.extend(App.ServiceConfigPopoverSupport, {
    contentBinding: 'serviceConfig.options',
    selectionBinding: 'serviceConfig.value',
    classNames: [ 'span3' ],
    disabled: function () {
      return !this.get('serviceConfig.isEditable');
    }.property('serviceConfig.isEditable')
  });


  /**
   * Base component for host config with popover support
   */
  App.ServiceConfigHostPopoverSupport = Ember.Mixin.create({

    /**
     * Config object. It will instance of App.ServiceConfigProperty
     */
    serviceConfig: null,

    didInsertElement: function () {
      this.$().popover({
        title: this.get('serviceConfig.displayName'),
        content: this.get('serviceConfig.description'),
        placement: 'right',
        trigger: 'hover'
      });
    }
  });

  /**
   * Master host component.
   * Show hostname without ability to edit it
   * @type {*}
   */
  App.ServiceConfigMasterHostView = Ember.View.extend(App.ServiceConfigHostPopoverSupport, {

    classNames: ['master-host', 'span6'],
    valueBinding: 'serviceConfig.value',

    template: Ember.Handlebars.compile('{{value}}')

  });

  /**
   * Base component to display Multiple hosts
   * @type {*}
   */
  App.ServiceConfigMultipleHostsDisplay = Ember.Mixin.create(App.ServiceConfigHostPopoverSupport, {

    hasNoHosts: function () {
      console.log('view', this.get('viewName')); //to know which View cause errors
      console.log('controller', this.get('controller').name); //should be slaveComponentGroupsController
      if (!this.get('value')) {
        return true;
      }
      return this.get('value').length === 0;
    }.property('value'),

    hasOneHost: function () {
      return this.get('value').length === 1;
    }.property('value'),

    hasMultipleHosts: function () {
      return this.get('value').length > 1;
    }.property('value'),

    otherLength: function () {
      var len = this.get('value').length;
      if (len > 2) {
        return Em.I18n.t('installer.controls.serviceConfigMultipleHosts.others').format(len - 1);
      } else {
        return Em.I18n.t('installer.controls.serviceConfigMultipleHosts.other');
      }
    }.property('value')

  })


  /**
   * Multiple master host component.
   * Show hostnames without ability to edit it
   * @type {*}
   */
  App.ServiceConfigMasterHostsView = Ember.View.extend(App.ServiceConfigMultipleHostsDisplay, {

    viewName: "serviceConfigMasterHostsView",
    valueBinding: 'serviceConfig.value',

    classNames: ['master-hosts', 'span6'],
    templateName: require('templates/wizard/master_hosts'),

    /**
     * Onclick handler for link
     */
    showHosts: function () {
      var serviceConfig = this.get('serviceConfig');
      App.ModalPopup.show({
        header: Em.I18n.t('installer.controls.serviceConfigMasterHosts.header').format(serviceConfig.category),
        bodyClass: Ember.View.extend({
          serviceConfig: serviceConfig,
          templateName: require('templates/wizard/master_hosts_popup')
        }),
        onPrimary: function () {
          this.hide();
        },
        secondary: null
      });
    }

  });

  /**
   * Show tabs list for slave hosts
   * @type {*}
   */
  App.SlaveComponentGroupsMenu = Em.CollectionView.extend({

    content: function () {
      return this.get('controller.componentGroups');
    }.property('controller.componentGroups'),

    tagName: 'ul',
    classNames: ["nav", "nav-tabs"],

    itemViewClass: Em.View.extend({
      classNameBindings: ["active"],

      active: function () {
        return this.get('content.active');
      }.property('content.active'),

      errorCount: function () {
        return this.get('content.properties').filterProperty('isValid', false).filterProperty('isVisible', true).get('length');
      }.property('content.properties.@each.isValid', 'content.properties.@each.isVisible'),

      template: Ember.Handlebars.compile('<a {{action showSlaveComponentGroup view.content target="controller"}} href="#"> {{view.content.name}}{{#if view.errorCount}}<span class="badge badge-important">{{view.errorCount}}</span>{{/if}}</a><i {{action removeSlaveComponentGroup view.content target="controller"}} class="icon-remove"></i>')
    })
  });

  /**
   * <code>Add group</code> button
   * @type {*}
   */
  App.AddSlaveComponentGroupButton = Ember.View.extend({

    tagName: 'span',
    slaveComponentName: null,

    didInsertElement: function () {
      this.$().popover({
        title: Em.I18n.t('installer.controls.addSlaveComponentGroupButton.title').format(this.get('slaveComponentName')),
        content: Em.I18n.t('installer.controls.addSlaveComponentGroupButton.content').format(this.get('slaveComponentName'), this.get('slaveComponentName'), this.get('slaveComponentName')),
        placement: 'right',
        trigger: 'hover'
      });
    }

  });

  /**
   * Multiple Slave Hosts component
   * @type {*}
   */
  App.ServiceConfigSlaveHostsView = Ember.View.extend(App.ServiceConfigMultipleHostsDisplay, {

    viewName: 'serviceConfigSlaveHostsView',

    classNames: ['slave-hosts', 'span6'],

    valueBinding: 'serviceConfig.value',

    templateName: require('templates/wizard/slave_hosts'),

    /**
     * Onclick handler for link
     */
    showHosts: function () {
      var serviceConfig = this.get('serviceConfig');
      App.ModalPopup.show({
        header: Em.I18n.t('installer.controls.serviceConfigMasterHosts.header').format(serviceConfig.category),
        bodyClass: Ember.View.extend({
          serviceConfig: serviceConfig,
          templateName: require('templates/wizard/master_hosts_popup')
        }),
        onPrimary: function () {
          this.hide();
        },
        secondary: null
      });
    }

  });

  /**
   * properties for present active slave group
   * @type {*}
   */
  App.SlaveGroupPropertiesView = Ember.View.extend({

    viewName: 'serviceConfigSlaveHostsView',

    group: function () {
      return this.get('controller.activeGroup');
    }.property('controller.activeGroup'),

    groupConfigs: function () {
      console.log("************************************************************************");
      console.log("The value of group is: " + this.get('group'));
      console.log("************************************************************************");
      return this.get('group.properties');
    }.property('group.properties.@each').cacheable(),

    errorCount: function () {
      return this.get('group.properties').filterProperty('isValid', false).filterProperty('isVisible', true).get('length');
    }.property('configs.@each.isValid', 'configs.@each.isVisible')
  });

  /**
   * DropDown component for <code>select hosts for groups</code> popup
   * @type {*}
   */
  App.SlaveComponentDropDownGroupView = Ember.View.extend({

    viewName: "slaveComponentDropDownGroupView",

    /**
     * On change handler for <code>select hosts for groups</code> popup
     * @param event
     */
    changeGroup: function (event) {
      var host = this.get('content');
      var groupName = $('#' + this.get('elementId') + ' select').val();
      this.get('controller').changeHostGroup(host, groupName);
    },

    optionTag: Ember.View.extend({

      /**
       * Whether current value(OptionTag value) equals to host value(assigned to SlaveComponentDropDownGroupView.content)
       */
      selected: function () {
        return this.get('parentView.content.group') === this.get('content');
      }.property('content')
    })
  });

  /**
   * Show info about current group
   * @type {*}
   */
  App.SlaveComponentChangeGroupNameView = Ember.View.extend({

    contentBinding: 'controller.activeGroup',
    classNames: ['control-group'],
    classNameBindings: 'error',
    error: false,
    setError: function () {
      this.set('error', false);
    }.observes('controller.activeGroup'),
    errorMessage: function () {
      return this.get('error') ? Em.I18n.t('installer.controls.slaveComponentChangeGroupName.error') : '';
    }.property('error'),

    /**
     * Onclick handler for saving updated group name
     * @param event
     */
    changeGroupName: function (event) {
      var inputVal = $('#' + this.get('elementId') + ' input[type="text"]').val();
      if (inputVal !== this.get('content.name')) {
        var result = this.get('controller').changeSlaveGroupName(this.get('content'), inputVal);
        this.set('error', result);
      }
    }
  });

  
});
window.require.register("views/wizard/stack_upgrade/step1_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.StackUpgradeStep1View = Em.View.extend({
    templateName: require('templates/wizard/stack_upgrade/step1')
  });
  
});
window.require.register("views/wizard/stack_upgrade/step2_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.StackUpgradeStep2View = Em.View.extend({
    templateName: require('templates/wizard/stack_upgrade/step2'),
    didInsertElement: function(){
      $("[rel=popover]").popover({'placement': 'right', 'trigger': 'hover'});
    }
  });
  
});
window.require.register("views/wizard/stack_upgrade/step3_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.StackUpgradeStep3View = Em.View.extend({
    templateName: require('templates/wizard/stack_upgrade/step3'),
    overallStatus: Em.I18n.t('installer.stackUpgrade.step3.status.info'),
    statusClass: 'alert-info',
    didInsertElement: function(){
      this.get('controller').resumeStep();
      this.onStatus();
    },
    onStatus: function(){
      var currentProcess = this.get('controller.processes').findProperty('isRunning', true);
      if(currentProcess && (currentProcess.get('name') == 'UPGRADE_SERVICES')){
        switch (currentProcess.get('status')){
          case 'SUCCESS':
            this.set('overallStatus', Em.I18n.t('installer.stackUpgrade.step3.status.success').format(this.get('controller.content.upgradeVersion')));
            this.set('statusClass', 'alert-success');
            break;
          case 'FAILED':
            this.set('overallStatus', Em.I18n.t('installer.stackUpgrade.step3.status.failed'));
            this.set('statusClass', 'alert-error');
            break;
          case 'WARNING':
            this.set('overallStatus', Em.I18n.t('installer.stackUpgrade.step3.status.warning').format(this.get('controller.content.upgradeVersion')));
            this.set('statusClass', 'alert-block');
            break;
          case 'IN_PROGRESS':
          default:
            this.set('overallStatus', Em.I18n.t('installer.stackUpgrade.step3.status.info'));
            this.set('statusClass', 'alert-info');
        }
      } else {
        this.set('overallStatus', Em.I18n.t('installer.stackUpgrade.step3.status.info'));
        this.set('statusClass', 'alert-info');
      }
    }.observes('controller.processes.@each.status'),
    processView: Em.View.extend({
      barColor: '',
      icon:'',
      iconColor:'',
      status: function(){
        var process = this.get('content');
        if(process.get('name') == 'STOP_SERVICES'){
          switch(process.get('status')){
            case 'IN_PROGRESS':
              return Em.I18n.t('installer.stackUpgrade.step3.service.stopping');
            case 'FAILED':
              return Em.I18n.t('installer.stackUpgrade.step3.service.stopFail');
            case 'SUCCESS':
              return Em.I18n.t('installer.stackUpgrade.step3.service.stopped');
            default:
              return Em.I18n.t('installer.stackUpgrade.step3.service.stopPending');
          }
        } else {
          switch(process.get('status')){
            case 'IN_PROGRESS':
              return Em.I18n.t('installer.stackUpgrade.step3.service.upgrading');
            case 'WARNING':
              return Em.I18n.t('installer.stackUpgrade.step3.service.upgraded');
            case 'FAILED':
              return Em.I18n.t('installer.stackUpgrade.step3.service.failedUpgrade');
            case 'SUCCESS':
              return Em.I18n.t('installer.stackUpgrade.step3.service.upgraded');
            default:
              return Em.I18n.t('installer.stackUpgrade.step3.service.pending');
          }
        }
      }.property('content.status'),
      didInsertElement: function(){
        this.onStatus();
      },
      retryMessage: function(){
        if(this.get('content.name') == 'STOP_SERVICES'){
          return Em.I18n.t('installer.stackUpgrade.step3.retry.services');
        }
        return Em.I18n.t('installer.stackUpgrade.step3.retry.upgrade');
      }.property('content.name'),
      isProcessCompleted: function(){
        return this.get('content.status') == 'SUCCESS' || this.get('content.status') === 'WARNING';
      }.property('content.status'),
      barWidth: function(){
        return 'width: ' + this.get('content.progress') + '%;';
      }.property('content.progress'),
      /**
       * change service appearance(icon, progress-bar color,) depending on the service status
       */
      onStatus:function () {
        if (this.get('content.status') === 'IN_PROGRESS') {
          this.set('barColor', 'progress-info');
          this.set('icon', 'icon-cog');
          this.set('iconColor', 'text-info');
        } else if (this.get('content.status') === 'WARNING') {
          this.set('barColor', 'progress-warning');
          this.set('icon', 'icon-warning-sign');
          this.set('iconColor', 'text-warning');
        } else if (this.get('content.status') === 'FAILED') {
          this.set('barColor', 'progress-danger');
          this.set('icon', 'icon-exclamation-sign');
          this.set('iconColor', 'text-error');
        } else if (this.get('content.status') === 'SUCCESS') {
          this.set('barColor', 'progress-success');
          this.set('icon', 'icon-ok');
          this.set('iconColor', 'text-success');
        } else {
          this.set('barColor', 'progress-info');
          this.set('icon', 'icon-cog');
          this.set('iconColor', '');
        }
      }.observes('content.status'),
      inProgress: function(){
        return this.get('content.isRunning') && !this.get('content.isRetry');
      }.property('content.status'),
      /**
       * open popup with list of hosts, that associated to service
       * @param event
       */
      hostsLogPopup: function(event){
        var serviceName = event.contexts[0];
        var controller = this.get("controller");
        App.HostPopup.initPopup(serviceName, controller);
      }
    })
  });
});
window.require.register("views/wizard/step0_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.WizardStep0View = Em.View.extend({

    tagName: "form", //todo: why form?
    attributeBindings: ['autocomplete'],
    autocomplete: 'off',
    templateName: require('templates/wizard/step0'),

    //todo: create property for placeholder(go to template)

    didInsertElement: function () {
      $("[rel=popover]").popover({'placement': 'right', 'trigger': 'hover'});
      this.get('controller').loadStep();
    },

    //todo: rename it to class or write comments
    onError: function () {
      return this.get('controller.clusterNameError') !== '';
    }.property('controller.clusterNameError')

  });

  App.WizardStep0ViewClusterNameInput = Em.TextField.extend({
    keyPress: function(event) {
      if (event.keyCode == 13) {
        this.get('parentView.controller').submit();
        return false;
      }
    }
  });
  
});
window.require.register("views/wizard/step10_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.WizardStep10View = Em.View.extend({

    templateName: require('templates/wizard/step10'),

    didInsertElement: function () {
      var controller = this.get('controller');
      controller.loadStep();
    }

  });
});
window.require.register("views/wizard/step11_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.WizardStep11View = Em.View.extend({

    templateName: require('templates/wizard/step11')

  });
  
});
window.require.register("views/wizard/step12_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.WizardStep12View = Em.View.extend({

    templateName: require('templates/wizard/step12'),
    didInsertElement: function () {
      this.get('controller').loadStep();
    }

  });
  
});
window.require.register("views/wizard/step13_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.WizardStep13View = Em.View.extend({

    templateName: require('templates/wizard/step13'),

    changes: function () {
      return this.get('controller.content.modifiedConfigs');
    }.property('controller.content.modifiedConfigs'),
    sourceHost: function () {
      return this.get('controller.content.reassign.host_id')
    }.property('controller.content.reassign.host_id'),
    targetHost: function () {
      return this.get('controller.content.masterComponentHosts').findProperty('component', this.get('controller.content.reassign.component_name')).hostName;
    }.property('controller.content.masterComponentHosts'),

    printReview: function() {
      $("#step8-info").jqprint();
    }
  });
  
});
window.require.register("views/wizard/step14_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.WizardStep14View = Em.View.extend({

    templateName: require('templates/wizard/step14'),

    statusMessage: null,
    statusClass: 'alert-info',

    didInsertElement: function () {
      this.get('controller').loadStep();
    },

    tasks: function () {
      var tasks = this.get('controller.tasks');
      if (this.get('controller.service.serviceName') == 'GANGLIA') {
        tasks = tasks.slice(0,2).concat(tasks.slice(4));
      }
      return tasks;
    }.property('controller.tasks', 'controller.service'),

    onStatus: function () {
      var master = (this.get('controller.isCohosted')) ? Em.I18n.t('installer.step5.hiveGroup') : this.get('controller.content.reassign.display_name');
      switch (this.get('controller.status')) {
        case 'COMPLETED':
          this.set('statusMessage', Em.I18n.t('installer.step14.status.success').format(master));
          this.set('statusClass', 'alert-success');
          break;
        case 'FAILED':
          this.set('statusMessage', Em.I18n.t('installer.step14.status.failed').format(master));
          this.set('statusClass', 'alert-error');
          break;
        case 'IN_PROGRESS':
        default:
          this.set('statusMessage', Em.I18n.t('installer.step14.status.info').format(master));
          this.set('statusClass', 'alert-info');
      }
    }.observes('controller.status'),

    taskView: Em.View.extend({
      icon: '',
      iconColor: '',

      didInsertElement: function () {
        this.onStatus();
      },

      barWidth: function () {
        return 'width: ' + this.get('content.progress') + '%;';
      }.property('content.progress'),

      onStatus: function () {
        if (this.get('content.status') === 'IN_PROGRESS') {
          this.set('icon', 'icon-cog');
          this.set('iconColor', 'text-info');
        } else if (this.get('content.status') === 'WARNING') {
          this.set('icon', 'icon-warning-sign');
          this.set('iconColor', 'text-warning');
        } else if (this.get('content.status') === 'FAILED') {
          this.set('icon', 'icon-exclamation-sign');
          this.set('iconColor', 'text-error');
        } else if (this.get('content.status') === 'COMPLETED') {
          this.set('icon', 'icon-ok');
          this.set('iconColor', 'text-success');
        } else {
          this.set('icon', 'icon-cog');
          this.set('iconColor', '');
        }
      }.observes('content.status'),

      inProgress: function () {
        return this.get('content.status') === "IN_PROGRESS";
      }.property('content.status')

    })
  });
  
});
window.require.register("views/wizard/step1_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements. See the NOTICE file distributed with this
   * work for additional information regarding copyright ownership. The ASF
   * licenses this file to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   * 
   * http://www.apache.org/licenses/LICENSE-2.0
   * 
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */

  var App = require('app');

  App.WizardStep1View = Em.View.extend({
    templateName: require('templates/wizard/step1'),

    stacks: function () {
      var stacks = [];
      this.get('controller.content.stacks').forEach(function (stack) {
        stacks.pushObject(Em.Object.create({
          name: stack.get('name').replace('-', ' '),
          isSelected: stack.get('isSelected')
        }));
      });
      return stacks;
    }.property('controller.content.stacks.@each.isSelected'),

    isAddOSDisabled: true,
    localRepositories: [],
    defaultRepositories: [],
    refreshRepositoryInfo: function () {
      var selectedStack = this.get('controller.content.stacks').findProperty('isSelected', true);
      var localRepos = [];
      var defaultRepos = [];
      if (selectedStack && selectedStack.operatingSystems) {
        selectedStack.operatingSystems.forEach(function (os) {
          if (os.baseUrl !== os.defaultBaseUrl) {
            localRepos.push($.extend({}, os));
          } else {
            defaultRepos.push($.extend({}, os));
          }
        });
      }
      this.set('localRepositories', localRepos);
      this.set('defaultRepositories', defaultRepos);
      this.set('isAddOSDisabled', defaultRepos.get('length') < 1);
    }.observes('controller.content.stacks.@each.isSelected', 'controller.content.stacks.@each.operatingSystems.@each.baseUrl'),

    stackRadioButton: Ember.Checkbox.extend({
      tagName: 'input',
      attributeBindings: [ 'type', 'checked' ],
      checked: function () {
        return this.get('content.isSelected');
      }.property('content.isSelected'),
      type: 'radio',

      click: function () {
        this.get('controller.content.stacks').setEach('isSelected', false);
        this.get('controller.content.stacks').findProperty('name', this.get('content.name').replace(' ', '-')).set('isSelected', true);
      }
    }),

    removeLocalRepository: function (event) {
      var localRepo = event.context;

      var selectedStack = this.get('controller.content.stacks').findProperty('isSelected', true);
      var cos = selectedStack.operatingSystems.findProperty('osType', localRepo.osType);
      cos.baseUrl = cos.defaultBaseUrl;

      this.refreshRepositoryInfo();
    },

    addLocalRepository: function () {
      var self = this;
      var defaultRepos = self.get('defaultRepositories');
      var selectedStack = this.get('controller.content.stacks').findProperty('isSelected', true);

      App.ModalPopup.show({
        // classNames: ['big-modal'],
        classNames: [ 'sixty-percent-width-modal' ],
        header: "Add Local Repository",
        primary: 'Add',
        secondary: 'Cancel',
        onPrimary: function () {
          var error = null;
          var childViews = this.get('childViews');
          if (childViews && childViews.get('length') > 0) {
            var childView = childViews.objectAt(0);
            if (childView) {
              if (childView.get('enteredUrl')) {
                if (childView.get('selectedOS').baseUrl !== childView.get('enteredUrl') && childView.get('selectedOS').defaultBaseUrl !== childView.get('enteredUrl')) {
                  var selectedStack = self.get('controller.content.stacks').findProperty('isSelected', true);
                  var cos = selectedStack.operatingSystems.findProperty('osType', childView.get('selectedOS').osType);
                  cos.baseUrl = childView.get('enteredUrl');
                  self.refreshRepositoryInfo();
                  this.hide();
                } else {
                  error = Em.I18n.t('installer.step1.advancedRepo.localRepo.error.modifyUrl');
                }
              } else {
                error = Em.I18n.t('installer.step1.advancedRepo.localRepo.error.noUrl')
              }
              if (!childView.get('isDestroyed') && !childView.get('isDestroying') && childView.get('isVisible'))
                childView.set('errorMessage', error);
            }
          }
        },
        onSecondary: function () {
          this.hide();
        },
        bodyClass: Ember.View.extend({
          templateName: require('templates/wizard/step1_addLocalRepository'),
          controller: self.get('controller'),
          stackName: selectedStack.get('name'),
          selectedOS: defaultRepos.objectAt(0),
          enteredUrl: defaultRepos.objectAt(0).baseUrl,
          oses: defaultRepos,
          errorMessage: null,
          selectOS: function (event) {
            var os = event.context;
            this.set('selectedOS', os);
            this.set('enteredUrl', os.baseUrl);
          }
        })
      });
    }
  });
  
});
window.require.register("views/wizard/step2_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * 'License'); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an 'AS IS' BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.SshKeyFileUploader = Ember.View.extend({
    //TODO: rewrite it using tagName and attribute binding
    //TODO: rewrite it as independent component and place it somewhere in utils
    // alternative is to move it to App.WizardStep2View
    template:Ember.Handlebars.compile('<input type="file" {{bindAttr disabled="view.disabled"}} />'),
    classNames: ['ssh-key-input-indentation'],

    change: function (e) {
      var self=this;
      if (e.target.files && e.target.files.length == 1) {
        var file = e.target.files[0];
        var reader = new FileReader();

        reader.onload = (function(theFile) {
          return function(e) {
            $('#sshKey').html(e.target.result);
            self.get("controller").setSshKey(e.target.result);
          };
        })(file);
        reader.readAsText(file);
      }
    }
  });

  App.WizardStep2View = Em.View.extend({

    templateName: require('templates/wizard/step2'),

    didInsertElement: function () {
      //TODO: move it to separate function in Ember.View using reopenClass
      $("[rel=popover]").popover({'placement': 'right', 'trigger': 'hover'});

      //todo: move them to conroller
      this.set('controller.hostsError',null);
      this.set('controller.sshKeyError',null);
    },

    sshKeyState: function(){
      return this.get("controller.content.installOptions.manualInstall");
    }.property("controller.content.installOptions.manualInstall"),

    //TODO: incupsulate it inside of App.SshKeyFileUploader
    isFileApi: function () {
      return (window.File && window.FileReader && window.FileList) ? true : false ;
    }.property(),

    manualInstallPopup: function(){
      if(!this.get('controller.content.installOptions.useSsh')){
        App.ModalPopup.show({
          header: Em.I18n.t('common.warning'),
          body: Em.I18n.t('installer.step2.manualInstall.info'),
          encodeBody: false,
          onPrimary: function () {
            this.hide();
          },
          secondary: null
        });
      }
      this.set('controller.content.installOptions.manualInstall', !this.get('controller.content.installOptions.useSsh'));
    }.observes('controller.content.installOptions.useSsh'),

    //TODO: replace next 2 properties with new one used in both places
    providingSSHKeyRadioButton: Ember.Checkbox.extend({
      tagName: 'input',
      attributeBindings: ['type', 'checked'],
      checked: function () {
        return this.get('controller.content.installOptions.useSsh');
      }.property('controller.content.installOptions.useSsh'),
      type: 'radio',

      click: function () {
        this.set('controller.content.installOptions.useSsh', true);
        this.set('controller.content.installOptions.manualInstall', false);
      }
    }),

    manualRegistrationRadioButton: Ember.Checkbox.extend({
      tagName: 'input',
      attributeBindings: ['type', 'checked'],
      checked: function () {
        return this.get('controller.content.installOptions.manualInstall');
      }.property('controller.content.installOptions.manualInstall'),
      type: 'radio',

      click: function () {
        this.set('controller.content.installOptions.manualInstall', true);
        this.set('controller.content.installOptions.useSsh', false);
      }
    }),

    textFieldView: Ember.TextField.extend({
      disabled: function(){
        return !this.get('isEnabled');
      }.property('isEnabled')
    })
  });


  
});
window.require.register("views/wizard/step3_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.WizardStep3View = Em.View.extend({

    templateName: require('templates/wizard/step3'),
    category: '',

    didInsertElement: function () {
      this.get('controller').navigateStep();
    },

    message:'',
    linkText: '',
    status: '',

    monitorStatuses: function() {
      var failedHosts = 0;
      var hosts = this.get('controller.bootHosts');
      hosts.forEach(function(host) {
        if (host.get('bootStatus') == 'FAILED') {
          failedHosts++;
        }
      });
      if (this.get('controller.isHostHaveWarnings')) {
        this.set('status', 'alert-warn');
        this.set('linkText', Em.I18n.t('installer.step3.warnings.linkText'));
        this.set('message', Em.I18n.t('installer.step3.warnings.fails').format(hosts.length, failedHosts));
      }
      else {
        this.set('status', 'alert-success');
        this.set('linkText', Em.I18n.t('installer.step3.noWarnings.linkText'));
        if (failedHosts == 0) {
          // all are ok
          this.set('message', Em.I18n.t('installer.step3.warnings.noWarnings').format(hosts.length));
        } else if (failedHosts == hosts.length) {
          // all failed
          this.set('status', 'alert-warn');
          this.set('linkText', '');
          this.set('message', Em.I18n.t('installer.step3.warnings.allFailed').format(failedHosts));
        } else {
          // some failed
          this.set('message', Em.I18n.t('installer.step3.warnings.someWarnings').format((hosts.length-failedHosts), failedHosts));
        }
      }
    }.observes('controller.isHostHaveWarnings', 'controller.bootHosts.@each.bootStatus')
  });

  //todo: move it inside WizardStep3View
  App.WizardHostView = Em.View.extend({

    tagName: 'tr',
    classNameBindings: ['hostInfo.bootStatus'],
    hostInfo: null,

    remove: function () {
      this.get('controller').removeHost(this.get('hostInfo'));
    },

    retry: function() {
      this.get('controller').retryHost(this.get('hostInfo'));
    },

    isRemovable: function () {
      return true;
    }.property(),

    isRetryable: function() {
      // return ['FAILED'].contains(this.get('hostInfo.bootStatus'));
      return false;
    }.property('hostInfo.bootStatus')

  });


  
});
window.require.register("views/wizard/step4_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.WizardStep4View = Em.View.extend({

    templateName: require('templates/wizard/step4')

  });
});
window.require.register("views/wizard/step5_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.WizardStep5View = Em.View.extend({

    templateName:require('templates/wizard/step5'),

    didInsertElement:function () {
      this.get('controller').loadStep();
    }

  });

  App.SelectHostView = Em.Select.extend({
    content:[],
    zId:null,
    selectedHost:null,
    componentName:null,
    attributeBindings:['disabled'],

    change:function () {
      this.get('controller').assignHostToMaster(this.get("componentName"), this.get("value"), this.get("zId"));
    },

    didInsertElement:function () {
      this.set("value", this.get("selectedHost"));
    }
  });

  App.AddControlView = Em.View.extend({
    componentName:null,
    tagName:"span",
    classNames:["badge", "badge-important"],
    template:Ember.Handlebars.compile('+'),

    click:function () {
      this.get('controller').addComponent(this.get('componentName'));
    }
  });

  App.RemoveControlView = Em.View.extend({
    zId:null,
    componentName:null,
    tagName:"span",
    classNames:["badge", "badge-important"],
    template:Ember.Handlebars.compile('-'),

    click:function () {
      this.get('controller').removeComponent(this.get('componentName'), this.get("zId"));
    }
  });
  
});
window.require.register("views/wizard/step6_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.WizardStep6View = Em.View.extend({

    templateName: require('templates/wizard/step6'),

    title: '',

    didInsertElement: function () {
      var controller = this.get('controller');
      if (controller.get('isMasters')) {
        this.set('label', Em.I18n.t('installer.step6.addHostWizard.body'));
        this.set('title', Em.I18n.t('installer.step5.header'));
      }
      else {
        this.set('title', Em.I18n.t('installer.step6.header'));
        this.setLabel();
      }
      $('body').tooltip({
        selector: '[rel=tooltip]'
      });
      controller.loadStep();
    },

    setLabel: function () {
      var label = Em.I18n.t('installer.step6.body');
      var clients = this.get('controller.content.clients');
      clients.forEach(function (_client) {
        if (clients.length === 1) {
          label = label + ' ' + _client.display_name;
        }
        else
          if (_client !== clients[clients.length - 1]) {           // [clients.length - 1]
            label = label + ' ' + _client.display_name;
            if(_client !== clients[clients.length - 2]) {
              label = label + ',';
            }
          }
          else {
            label = label + ' ' + Em.I18n.t('and') + ' ' + _client.display_name + '.';
          }
      }, this);
      this.set('label', label);
    }
  });

  App.WizardStep6HostView = Em.View.extend({

    host: null,
    tagName: 'td',

    didInsertElement: function () {
      if (!this.get('controller.isMasters')) {
        var components = this.get('controller').getMasterComponentsForHost(this.get('host.hostName'));
        if (components && components.length > 0) {
          components = components.map(function(_component) {
            return App.format.role(_component);
          });
          components = components.join(" /\n");
          this.$().popover({
            title: Em.I18n.t('installer.step6.wizardStep6Host.title').format(this.get('host.hostName')),
            content: components,
            placement: 'right',
            trigger: 'hover'
          });
        }
      }
    }
  });

  /**
   * Binding host property with dynamic name
   * @type {*}
   */
  App.WizardStep6CheckboxView = Em.Checkbox.extend({
    /**
     * Header object with host property name
     */
    checkbox: null,

    checkedBinding: 'checkbox.checked',

    disabledBinding: 'checkbox.isInstalled',

    checkCallback: function() {
      var self = this;
      Ember.run.next(function(){
        self.get('controller').checkCallback(self.get('checkbox.title'));
      });

    }.observes('checked'),

    template: Ember.Handlebars.compile('{{checkbox.title}}')

  });
  
});
window.require.register("views/wizard/step7_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.WizardStep7View = Em.View.extend({

    templateName: require('templates/wizard/step7')

  });
  
});
window.require.register("views/wizard/step8_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */


  var App = require('app');

  App.WizardStep8View = Em.View.extend({

    templateName: require('templates/wizard/step8'),

    didInsertElement: function () {
      var controller = this.get('controller');
      controller.loadStep();
    },

    spinner : null,

    printReview: function() {
      var o = $("#step8-info");
      o.jqprint();
    },

    ajaxQueueLength: function() {
      return this.get('controller.ajaxQueueLength');
    }.property('controller.ajaxQueueLength'),

    ajaxQueueLeft: function() {
      return this.get('controller.ajaxQueueLeft');
    }.property('controller.ajaxQueueLeft'),

    // reference to modalPopup to make sure only one instance is created
    modalPopup: null,

    showLoadingIndicator: function() {
      if (!this.get('controller.isSubmitDisabled') || App.testMode) {
        if (this.get('modalPopup')) {
          this.get('modalPopup').hide();
          this.set('modalPopup', null);
        }
        return;
      }
      // don't create popup if it already exists
      if (this.get('modalPopup')) {
        return;
      }
      this.set('modalPopup', App.ModalPopup.show({
        header: '',

        showFooter: false,

        showCloseButton: false,

        bodyClass: Ember.View.extend({
          templateName: require('templates/wizard/step8_log_popup'),

          message: function() {
            return Em.I18n.t('installer.step8.deployPopup.message').format(this.get('ajaxQueueComplete'), this.get('ajaxQueueLength'));
          }.property('ajaxQueueComplete', 'ajaxQueueLength'),

          controllerBinding: 'App.router.wizardStep8Controller',

          ajaxQueueLength: function() {
            return this.get('controller.ajaxQueueLength');
          }.property(),

          ajaxQueueComplete: function() {
            return this.get('ajaxQueueLength') - this.get('controller.ajaxQueueLeft');
          }.property('controller.ajaxQueueLeft', 'ajaxQueueLength'),

          barWidth: function () {
            return 'width: ' + (this.get('ajaxQueueComplete') / this.get('ajaxQueueLength') * 100) + '%;';
          }.property('ajaxQueueComplete', 'ajaxQueueLength'),

          autoHide: function() {
            if (this.get('controller.servicesInstalled')) {
              this.get('parentView').hide();
            }
          }.observes('controller.servicesInstalled')
        })
      }));
    }.observes('controller.isSubmitDisabled')
  });

  
});
window.require.register("views/wizard/step9_view", function(exports, require, module) {
  /**
   * Licensed to the Apache Software Foundation (ASF) under one
   * or more contributor license agreements.  See the NOTICE file
   * distributed with this work for additional information
   * regarding copyright ownership.  The ASF licenses this file
   * to you under the Apache License, Version 2.0 (the
   * "License"); you may not use this file except in compliance
   * with the License.  You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var App = require('app');

  App.WizardStep9View = Em.View.extend({

    templateName:require('templates/wizard/step9'),
    barColor:'',
    resultMsg:'',
    resultMsgColor:'',

    didInsertElement:function () {
      var controller = this.get('controller');
      this.get('controller.hosts').setEach('status', 'info');
      this.onStatus();
      controller.navigateStep();
    },

    barWidth:function () {
      var controller = this.get('controller');
      var barWidth = 'width: ' + controller.get('progress') + '%;';
      return barWidth;
    }.property('controller.progress'),

    progressMessage: function() {
      return Em.I18n.t('installer.step9.overallProgress').format(this.get('controller.progress'));
    }.property('controller.progress'),

    onStatus:function () {
      if (this.get('controller.status') === 'info') {
        this.set('resultMsg', '');
        this.set('barColor', 'progress-info');
      } else if (this.get('controller.status') === 'warning') {
        this.set('barColor', 'progress-warning');
        this.set('resultMsg', Em.I18n.t('installer.step9.status.warning'));
        this.set('resultMsgColor', 'alert-warning');
      } else if (this.get('controller.status') === 'failed') {
        this.set('barColor', 'progress-danger');
        console.log('TRACE: Inside error view step9');
        this.set('resultMsg', Em.I18n.t('installer.step9.status.failed'));
        this.set('resultMsgColor', 'alert-error');
      } else if (this.get('controller.status') === 'success') {
        console.log('TRACE: Inside success view step9');
        this.set('barColor', 'progress-success');
        this.set('resultMsg', Em.I18n.t('installer.step9.status.success'));
        this.set('resultMsgColor', 'alert-success');
      }
    }.observes('controller.status')
  });

  App.HostStatusView = Em.View.extend({
    tagName:'tr',
    obj:'null',
    barColor:'',

    didInsertElement:function () {
      var controller = this.get('controller');
      this.onStatus();
    },

    barWidth:function () {
      var barWidth = 'width: ' + this.get('obj.progress') + '%;';
      return barWidth;
    }.property('obj.progress'),

    onStatus:function () {
      if (this.get('obj.status') === 'info') {
        this.set('barColor', 'progress-info');
      } else if (this.get('obj.status') === 'warning') {
        this.set('barColor', 'progress-warning');
        if (this.get('obj.progress') === '100') {
          this.set('obj.message', Em.I18n.t('installer.step9.host.status.warning'));
        }
      } else if (this.get('obj.status') === 'failed') {
        this.set('barColor', 'progress-danger');
        if (this.get('obj.progress') === '100') {
          this.set('obj.message', Em.I18n.t('installer.step9.host.status.failed'));
        }
      } else if (this.get('obj.status') === 'success') {
        this.set('barColor', 'progress-success');
        if (this.get('obj.progress') === '100') {
          this.set('obj.message', Em.I18n.t('installer.step9.host.status.success'));
        }
      }
    }.observes('obj.status', 'obj.progress'),

    isFailed:function () {
      if (this.get('controller.isStepCompleted') === true && this.get('obj.status') === 'failed') {
        return true;
      } else {
        return false;
      }
    }.property('controller.isStepCompleted', 'controller.status'),

    isSuccess:function () {
      if (this.get('controller.isStepCompleted') === true && this.get('obj.status') === 'success') {
        return true;
      } else {
        return false;
      }
    }.property('controller.isStepCompleted', 'controller.status'),

    isWarning:function () {
      if (this.get('controller.isStepCompleted') === true && this.get('obj.status') === 'warning') {
        return true;
      } else {
        return false;
      }
    }.property('controller.isStepCompleted', 'controller.status'),

    isHostCompleted:function () {
      return this.get('obj.progress') == 100 || this.get('controller.isStepCompleted');
    }.property('controller.isStepCompleted', 'obj.progress'),

    hostLogPopup:function (event, context) {
      var self = this;
      var host = event.context;
      App.ModalPopup.show({
        header: event.context.get('name'),
        classNames: ['sixty-percent-width-modal'],
        autoHeight: false,
        onPrimary:function () {
          this.hide();
        },
        secondary:null,

        bodyClass:Ember.View.extend({
          templateName:require('templates/wizard/step9HostTasksLogPopup'),
          isLogWrapHidden: true,
          showTextArea: false,
          isEmptyList:true,
          controllerBinding:context,
          hostObj:function () {
            return this.get('parentView.obj');
          }.property('parentView.obj'),

          task: null, // set in showTaskLog; contains task info including stdout and stderr
          /**
           * sort task array by Id
           * @param tasks
           * @return {Array}
           */

          sortTasksById: function(tasks){
            var result = [];
            var id = 1;
            for(var i = 0; i < tasks.length; i++){
              id = (tasks[i].Tasks.id > id) ? tasks[i].Tasks.id : id;
            }
            while(id >= 1){
              for(var j = 0; j < tasks.length; j++){
                if(id == tasks[j].Tasks.id){
                  result.push(tasks[j]);
                }
              }
              id--;
            }
            result.reverse();
            return result;
          },

          groupTasksByRole: function (tasks) {
            var sortedTasks = [];
            var taskRoles = tasks.mapProperty('Tasks.role').uniq();
            for (var i = 0; i < taskRoles.length; i++) {
              sortedTasks = sortedTasks.concat(tasks.filterProperty('Tasks.role', taskRoles[i]))
            }
            return sortedTasks;
          },

          visibleTasks: function () {
            var self = this;
            self.set("isEmptyList", true);
            if (this.get('category.value')) {
              var filter = this.get('category.value');
              var tasks = this.get('tasks');
              tasks.setEach("isVisible", false);

              if (filter == "all") {
                tasks.setEach("isVisible", true);
              }
              else if (filter == "pending") {
                tasks.filterProperty("status", "pending").setEach("isVisible", true);
                tasks.filterProperty("status", "queued").setEach("isVisible", true);
              }
              else if (filter == "in_progress") {
                tasks.filterProperty("status", "in_progress").setEach("isVisible", true);
              }
              else if (filter == "failed") {
                tasks.filterProperty("status", "failed").setEach("isVisible", true);
              }
              else if (filter == "completed") {
                tasks.filterProperty("status", "completed").setEach("isVisible", true);
              }
              else if (filter == "aborted") {
                tasks.filterProperty("status", "aborted").setEach("isVisible", true);
              }
              else if (filter == "timedout") {
                tasks.filterProperty("status", "timedout").setEach("isVisible", true);
              }

              if (tasks.filterProperty("isVisible", true).length > 0) {
                self.set("isEmptyList", false);
              }
            }
          }.observes('category', 'tasks'),

          categories: [
              Ember.Object.create({value: 'all', label: Em.I18n.t('installer.step9.hostLog.popup.categories.all') }),
              Ember.Object.create({value: 'pending', label: Em.I18n.t('installer.step9.hostLog.popup.categories.pending')}),
              Ember.Object.create({value: 'in_progress', label: Em.I18n.t('installer.step9.hostLog.popup.categories.in_progress')}),
              Ember.Object.create({value: 'failed', label: Em.I18n.t('installer.step9.hostLog.popup.categories.failed') }),
              Ember.Object.create({value: 'completed', label: Em.I18n.t('installer.step9.hostLog.popup.categories.completed') }),
              Ember.Object.create({value: 'aborted', label: Em.I18n.t('installer.step9.hostLog.popup.categories.aborted') }),
              Ember.Object.create({value: 'timedout', label: Em.I18n.t('installer.step9.hostLog.popup.categories.timedout') })
          ],

          category: null,

          tasks: function () {
            var tasksArr = [];
            var tasks = this.getStartedTasks(host);
            //tasks = this.sortTasksById(tasks);
            tasks = tasks.sort(function(a,b){
              return a.Tasks.id - b.Tasks.id;
            });
            //tasks = this.groupTasksByRole(tasks);
            if (tasks.length) {
              tasks.forEach(function (_task) {
                var taskInfo = Ember.Object.create({});
                taskInfo.set('id', _task.Tasks.id);
                taskInfo.set('command', _task.Tasks.command.toLowerCase());
                taskInfo.set('status', App.format.taskStatus(_task.Tasks.status));
                taskInfo.set('role', App.format.role(_task.Tasks.role));
                taskInfo.set('stderr', _task.Tasks.stderr);
                taskInfo.set('stdout', _task.Tasks.stdout);
                taskInfo.set('isVisible', true);
                taskInfo.set('icon', '');
                if (taskInfo.get('status') == 'pending' || taskInfo.get('status') == 'queued') {
                  taskInfo.set('icon', 'icon-cog');
                } else if (taskInfo.get('status') == 'in_progress') {
                  taskInfo.set('icon', 'icon-cogs');
                } else if (taskInfo.get('status') == 'completed') {
                  taskInfo.set('icon', ' icon-ok');
                } else if (taskInfo.get('status') == 'failed') {
                  taskInfo.set('icon', 'icon-exclamation-sign');
                } else if (taskInfo.get('status') == 'aborted') {
                  taskInfo.set('icon', 'icon-minus');
                } else if (taskInfo.get('status') == 'timedout') {
                  taskInfo.set('icon', 'icon-time');
                }
                tasksArr.push(taskInfo);
              }, this);
            }
            return tasksArr;
          }.property('App.router.wizardStep9Controller.logTasksChangesCounter'),

          backToTaskList: function(event, context) {
            this.destroyClipBoard();
            this.set("isLogWrapHidden",true);
          },

          getStartedTasks:function (host) {
            var startedTasks = host.logTasks.filter(function (task) {
              return task.Tasks.status;
              //return task.Tasks.status != 'PENDING' && task.Tasks.status != 'QUEUED';
            });
            return startedTasks;
          },

          openTaskLogInDialog: function(){
            newwindow=window.open();
            newdocument=newwindow.document;
            newdocument.write($(".task-detail-log-info").html());
            newdocument.close();
          },

          openedTaskId: 0,

          openedTask: function () {
            if (!this.get('openedTaskId')) {
              return Ember.Object.create();
            }
            return this.get('tasks').findProperty('id', this.get('openedTaskId'));
          }.property('tasks', 'openedTaskId'),

          toggleTaskLog: function (event, context) {
            if (this.isLogWrapHidden) {
              var taskInfo = event.context;
              this.set("isLogWrapHidden", false);
              this.set('openedTaskId', taskInfo.id);
              $(".modal").scrollTop(0);
              $(".modal-body").scrollTop(0);
            } else {
              this.set("isLogWrapHidden", true);
              this.set('openedTaskId', 0);
            }
          },

          textTrigger:function (event) {
            if($(".task-detail-log-clipboard").length > 0)
            {
              this.destroyClipBoard();
            }else
            {
              this.createClipBoard();
            };
          },
          createClipBoard:function(){
            $(".task-detail-log-clipboard-wrap").html('<textarea class="task-detail-log-clipboard"></textarea>');
            $(".task-detail-log-clipboard")
                .html("stderr: \n"+$(".stderr").html()+"\n stdout:\n"+$(".stdout").html())
                .css("display","block")
                .width($(".task-detail-log-maintext").width())
                .height($(".task-detail-log-maintext").height())
                .select();
            $(".task-detail-log-maintext").css("display","none")
          },
          destroyClipBoard:function(){
            $(".task-detail-log-clipboard").remove();
            $(".task-detail-log-maintext").css("display","block");
          }
        })
      });
    }

  });
});
